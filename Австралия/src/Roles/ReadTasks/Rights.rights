<?xml version="1.0" encoding="UTF-8"?>
<Rights xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://v8.1c.ru/8.2/roles" xsi:type="Rights">
	<setForNewObjects>false</setForNewObjects>
	<setForAttributesByDefault>true</setForAttributesByDefault>
	<independentRightsOfChildObjects>false</independentRightsOfChildObjects>
	<object>
		<name>Catalog.InventoryOwnership.Attribute.Contract</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Task.PerformerTask.Command.Completed</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Report.ExpiringTasksOnDate</name>
		<right>
			<name>Use</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Task.PerformerTask</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#If &amp;RecordLevelAccessRestrictionIsUniversal #Then
#ForObject("")
#Else
#ByValuesAndSetsAdvanced( "Task.PerformerTask", "", "",
"",
"",
"Object","T.BusinessProcess","OR",
"Users","T.Author","OR",
"Users","T.Performer","OR",
"Users","T.TaskPerformersGroup","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")
#EndIf</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.TaskPerformers</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.PerformerRoles</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Task.PerformerTask.Command.AllTasks</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>CommonCommand.TasksBySubject</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.TaskAddressingObjects</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.InventoryOwnership.Attribute.Counterparty</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Task.PerformerTask.Command.MyTasks</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Task.PerformerTask.Command.Forward</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Report.Tasks</name>
		<right>
			<name>Use</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Configuration.Drive</name>
		<right>
			<name>MainWindowModeNormal</name>
			<value>true</value>
		</right>
		<right>
			<name>MainWindowModeWorkplace</name>
			<value>true</value>
		</right>
		<right>
			<name>MainWindowModeEmbeddedWorkplace</name>
			<value>true</value>
		</right>
		<right>
			<name>MainWindowModeFullscreenWorkplace</name>
			<value>true</value>
		</right>
		<right>
			<name>MainWindowModeKiosk</name>
			<value>true</value>
		</right>
		<right>
			<name>AnalyticsSystemClient</name>
			<value>true</value>
		</right>
	</object>
	<restrictionTemplate>
		<name>ByValuesAndSetsAdvanced</name>
		<condition>// ByValuesAndSetsAdvanced(Table, -, Modifier, JoinedTables, B, A1,F1,B1, A2,F2,B2,..., A(n), F(n), B(n)).
// Parameter No.:                         1, 2,           3,                     4, 5,  6, 7, 8,  9,10,11,...,3+n*3,4+n*3,5+n*3.
// Read as: "access restriction by values and sets advanced".
// Parameters:
//     Table - a name of the current table, for example, Document.GoodsAndServicesReceipt.
//     Modifier - changes the template.
//                 1st modifier - string DontLimitAccessToGroups specifies
//                  unconditional selection of hierarchical catalog groups.
//                 2nd modifier - the "AdvancedOR" string 
//                  enables advanced check for restrictions, for example, "ByCompanies or ByAccounts"
//                  where access kind setting option in access groups
//                  "All allowed, none denied" is considered as "Access kind is not used".
//                  If there is no such modifier, then the check result is True, which leads to
//                  the situation where the final result is also True provided that "All allowed, none denied" is set 
//                  for at least one access kind (either ByCompanies or ByAccounts.)
//                  Modifier is intended for use only when checking access value sets.
//                  You can use such modifier combinations as: "DontLimitAccessToGroups",
//                  AdvancedOR, DontLimitAccessToGroups,AdvancedOR.
//                 No other modifiers are available in this template version.
//     JoinedTables - a query text for joining additional tables, for example
//                 INNER JOIN Document.ExpenseReport.PaysToVendors AS T1
//                  BY T.Ref = T1.Ref.
//                 Joining allows to specify fields of the PaysToVendors table as fields of the main table
//                  for checking whether the values of those fields are the same as the main table field values.
//                 Note that for multiplication of rows in the query result, it is enough if
//                  at least one row meets the condition, that is the row check results are joined using OR.
//     O         - Open parenthesis "(".
//     B(n) - Access kind - an access kind name, for example, Companies. For composite fields, to improve
//                  performance, it is better to specify several names, for example, Companies, IndividualGroups,
//                  than to use several parameter blocks with the same field name.
//                  Special access kinds Object, Condition, RightsSettings, ReadRight, EditRight,
//                  RightToReadByID, and RightToEditByID can be used only separately.
//                 When B(n) = "Condition" (or ""), then P(n) contains condition string in the query language, for example
//                   "T.Author = &amp;AuthorizedUser",
//                   "VALUETYPE(T.Owner) = TYPE(Catalog.Companies)", where T is an alias of the current table.
//                 When B(n) = "ReadRight" or "EditRight",
//                  rights to the T.P(n) value table are checked.
//                 When B(n) = RightToReadByID" or "RightToEditByID",
//                  rights to the table are checked by ID with value T.P(n).
//                 When B(n) = "Object" (or " "), then
//                   if a record of a right dependency is available in the AccessRightDependencies information register,
//                     a check of the right to read T.P(n) and the access value sets is performed
//                     in the AccessValuesSets information register and read by T.P(n) reference for a read right,
//                   otherwise the standard rule is used:
//                     when Right = "Read", then a check of the right to read T.P(n) and the access value sets is performed
//                       in the AccessValuesSets information register and read by T.P(n) reference for a read right,
//                     When Right = "Change", then a check of the right to change T.P(n)
//                       and the access value sets read by T.P(n) reference for a change right is performed.
//     P(n)      - a field of the value with an alias being checked, for example "T.Company",
//                except when A(n) = "Condition" (or"").
//     O(n)      - logical operations AND, OR used with parentheses "(", ")".
//  Note: you can increase the maximum number of field values checked at the same time by changing the template, but
// you will need to specify all template parameters, i.e. specify blank rows when the number of fields is less than the maximum one.
//  The template has the following structure:
//     &lt;Join by table1&gt;  &lt;Join by table2&gt;  ... &lt;Join by table(m)&gt;
//     &lt;Common part of conditions&gt; &lt;Condition for parameter group 1&gt; AND/OR &lt;Condition for parameter group 1&gt; AND/OR ... &lt;Condition for parameter group(n)&gt;
//  Example:
//      ByValuesAndSetsAdvanced("DocumentJournal.WarehouseDocuments", "", "",
//      "",
//      "",
//      "Object","T.Ref","AND",
//      "Object","T.MainDocument","", "","","", ...)

#If &amp;AccessRestrictionAtRecordLevelEnabled = "" #Then // Infobase is locked for update.
    WHERE FALSE
#Else

// Validating the Right parameter.
#If Not ("#Parameter(2)" = "Read"    Or "#Parameter(2)" = "Insert" Or
          "#Parameter(2)" = "Update" Or "#Parameter(2)" = "Delete"   Or "#Parameter(2)" = "")
      Or #CurrentAccessRightName &lt;&gt; "Read" AND "#Parameter(2)"  = "Read"
      Or #CurrentAccessRightName  = "Read" AND "#Parameter(2)" &lt;&gt; "Read" AND "#Parameter(2)" &lt;&gt; "" #Then
    // When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
    InvalidRight: #Parameter(2)
#EndIf

// Validating the TableName parameter.
#If "#Parameter(1)" &lt;&gt; #CurrentTableName #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Validating the Modifier parameter.
#If Not (    "#Parameter(3)" = "DoNotLimitAccessToGroups"
          Or "#Parameter(3)" = "AdvancedOR"
          Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR"
          Or "#Parameter(3)" = "") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	InvalidModifier: #Parameter(3)
#EndIf

// The overall checking if access restriction at record level is used and
// checking if at least one restriction of the specified access kind is used.
#If Not
     (  True
      AND ("#Parameter(6)" = "" AND "#Parameter(7)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(6),"))
      AND ("#Parameter(9)" = "" AND "#Parameter(10)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(9),"))
      AND ("#Parameter(12)" = "" AND "#Parameter(13)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(12),"))
      AND ("#Parameter(15)" = "" AND "#Parameter(16)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(15),"))
      AND ("#Parameter(18)" = "" AND "#Parameter(19)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(18),"))
      AND ("#Parameter(21)" = "" AND "#Parameter(22)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(21),"))
      AND ("#Parameter(24)" = "" AND "#Parameter(25)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(24),"))
      AND ("#Parameter(27)" = "" AND "#Parameter(28)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(27),"))
      AND ("#Parameter(30)" = "" AND "#Parameter(31)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(30),"))
      AND ("#Parameter(33)" = "" AND "#Parameter(34)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(33),"))
      AND ("#Parameter(36)" = "" AND "#Parameter(37)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(36),"))
      AND ("#Parameter(39)" = "" AND "#Parameter(40)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(39),"))
      AND ("#Parameter(42)" = "" AND "#Parameter(43)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(42),"))
      AND ("#Parameter(45)" = "" AND "#Parameter(46)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(45),"))
      AND ("#Parameter(48)" = "" AND "#Parameter(49)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(48),"))
      AND ("#Parameter(51)" = "" AND "#Parameter(52)" = ""
         Or Not &amp;AccessRestrictionAtRecordLevelEnabled
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(51),"))
     ) #Then

T FROM T // T - an alias of the current table (it is short to reduce the number of characters in condition parameter text in the query language).

// Tables joined to the current table T row that is being checked.
#Parameter(4)

WHERE

TRUE IN
(	// Checking user rights to the entire current table.
	// Rights to tables are generated according to the set of roles of the access group profile.
	SELECT TOP 1 TRUE
	FROM
		Catalog.MetadataObjectIDs AS CurrentTableProperties
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			  CurrentTableProperties.FullName = "#Parameter(1)"
			AND TRUE IN
			  (
				SELECT TOP 1 TRUE
				FROM
					InformationRegister.AccessGroupsTables AS AccessGroupsTables
					WHERE
						  AccessGroupsTables.Table       = CurrentTableProperties.Ref
						AND AccessGroupsTables.AccessGroup = AccessGroups.Ref
					#If #CurrentAccessRightName = "Update" #Then
						AND AccessGroupsTables.Update
					#ElseIf #CurrentAccessRightName = "Insert" #Then
						AND AccessGroupsTables.Insert
					#EndIf
			  )
			AND AccessGroups.Ref IN
			  (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
					ON
						  UserGroupCompositions.User = &amp;AuthorizedUser
						AND UserGroupCompositions.UsersGroup = AccessGroupsUsers.User
			  )
	WHERE

// Unconditional group selection in hierarchical metadata object (if required).
#If "#Parameter(3)" = "DoNotLimitAccessToGroups" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
	T.IsFolder OR
#EndIf

  ( // Searching for values of the specified fields in allowed values of access groups or users.

	#Parameter(5)  // [([(][(]...] 0-n of open parentheses.

//// Checking the field value of parameter group 1.
#If &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(6)" = "Condition" Or "#Parameter(6)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	( #Parameter(7) )
#ElseIf "#Parameter(6)" = "ReadRight" Or "#Parameter(6)" = "EditRight" #Then
	  #Parameter(7) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(7))
		#If Not "#Parameter(6)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(6)" = "ReadByIDRight" Or "#Parameter(6)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(7)
		#If Not "#Parameter(6)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(6)" = "Object" Or "#Parameter(6)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(7))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(7))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(7))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(7)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(7)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(7)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(7))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(7)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(7)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(7))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(7)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(7)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(6)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(7)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(7)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(6),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(6)", ",") #Then
		IncorrectAccessKind: "#Parameter(6)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(6)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(6),") #Then
	
	 (
			ISNULL(#Parameter(7), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(6),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(6),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(7)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(7)
		#ElseIf "#Parameter(7)" = "T.Ref"
		         AND "#Parameter(6)" &lt;&gt; "Users"
		         AND "#Parameter(6)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(6)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(6)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(7)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(7)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(7))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(7), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(8)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 2.
#If "#Parameter(9)" = "" AND "#Parameter(10)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(9)" = "Condition" Or "#Parameter(9)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(10) )
#ElseIf "#Parameter(9)" = "ReadRight" Or "#Parameter(9)" = "EditRight" #Then
	 #Parameter(10) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(10))
		#If Not "#Parameter(9)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(9)" = "ReadByIDRight" Or "#Parameter(9)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(10)
		#If Not "#Parameter(9)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(9)" = "Object" Or "#Parameter(9)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(10))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(10))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(10))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(10)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(10)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(10)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(10))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(10)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(10)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(10))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(10)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(10)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(9)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(10)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(10)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(9),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(9)", ",") #Then
		IncorrectAccessKind: "#Parameter(9)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(9)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(9),") #Then
	
	 (
			ISNULL(#Parameter(10), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(9),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(9),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(10)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(9),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(10)
		#ElseIf "#Parameter(10)" = "T.Ref"
		         AND "#Parameter(9)" &lt;&gt; "Users"
		         AND "#Parameter(9)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(9)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(9)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(9),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(10)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(10)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(10))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(10), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(11)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 3.
#If "#Parameter(12)" = "" AND "#Parameter(13)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(12)" = "Condition" Or "#Parameter(12)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(13) )
#ElseIf "#Parameter(12)" = "ReadRight" Or "#Parameter(12)" = "EditRight" #Then
	 #Parameter(13) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(13))
		#If Not "#Parameter(12)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(12)" = "ReadByIDRight" Or "#Parameter(12)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(13)
		#If Not "#Parameter(12)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(12)" = "Object" Or "#Parameter(12)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(13))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(13))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(13))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(13)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(13)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(13)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(13))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(13)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(13)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(13))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(13)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(13)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(12)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(13)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(13)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(12),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(12)", ",") #Then
		IncorrectAccessKind: "#Parameter(12)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(12)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(12),") #Then
	
	 (
			ISNULL(#Parameter(13), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(12),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(12),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(13)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(13)
		#ElseIf "#Parameter(13)" = "T.Ref"
		         AND "#Parameter(12)" &lt;&gt; "Users"
		         AND "#Parameter(12)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(12)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(12)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(13)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(13)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(13))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(13), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(14)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 4.
#If "#Parameter(15)" = "" AND "#Parameter(16)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(15)" = "Condition" Or "#Parameter(15)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(16) )
#ElseIf "#Parameter(15)" = "ReadRight" Or "#Parameter(15)" = "EditRight" #Then
	 #Parameter(16) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(16))
		#If Not "#Parameter(15)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(15)" = "ReadByIDRight" Or "#Parameter(15)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(16)
		#If Not "#Parameter(15)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(15)" = "Object" Or "#Parameter(15)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(16))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(16))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(16))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(16)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(16)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(16)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(16))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(16)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(16)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(16))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(16)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(16)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(15)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(16)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(16)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(15),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(15)", ",") #Then
		IncorrectAccessKind: "#Parameter(15)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(15)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(15),") #Then
	
	 (
			ISNULL(#Parameter(16), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(15),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(15),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(16)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(15),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(16)
		#ElseIf "#Parameter(16)" = "T.Ref"
		         AND "#Parameter(15)" &lt;&gt; "Users"
		         AND "#Parameter(15)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(15)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(15)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(15),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(16)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(16)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(16))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(16), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(17)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 5.
#If "#Parameter(18)" = "" AND "#Parameter(19)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(18)" = "Condition" Or "#Parameter(18)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(19) )
#ElseIf "#Parameter(18)" = "ReadRight" Or "#Parameter(18)" = "EditRight" #Then
	 #Parameter(19) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(19))
		#If Not "#Parameter(18)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(18)" = "ReadByIDRight" Or "#Parameter(18)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(19)
		#If Not "#Parameter(18)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(18)" = "Object" Or "#Parameter(18)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(19))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(19))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(19))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(19)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(19)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(19)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(19))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(19)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(19)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(19))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(19)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(19)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(18)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(19)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(19)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(18),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(18)", ",") #Then
		IncorrectAccessKind: "#Parameter(18)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(18)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(18),") #Then
	
	 (
			ISNULL(#Parameter(19), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(18),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(18),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(19)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(19)
		#ElseIf "#Parameter(19)" = "T.Ref"
		         AND "#Parameter(18)" &lt;&gt; "Users"
		         AND "#Parameter(18)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(18)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(18)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(19)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(19)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(19))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(19), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(20)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 6.
#If "#Parameter(21)" = "" AND "#Parameter(22)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(21)" = "Condition" Or "#Parameter(21)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(22) )
#ElseIf "#Parameter(21)" = "ReadRight" Or "#Parameter(21)" = "EditRight" #Then
	 #Parameter(22) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(22))
		#If Not "#Parameter(21)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(21)" = "ReadByIDRight" Or "#Parameter(21)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(22)
		#If Not "#Parameter(21)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(21)" = "Object" Or "#Parameter(21)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(22))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(22))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(22))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(22)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(22)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(22)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(22))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(22)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(22)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(22))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(22)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(22)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(21)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(22)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(22)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(21),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(21)", ",") #Then
		IncorrectAccessKind: "#Parameter(21)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(21)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(21),") #Then
	
	 (
			ISNULL(#Parameter(22), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(21),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(21),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(22)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(21),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(22)
		#ElseIf "#Parameter(22)" = "T.Ref"
		         AND "#Parameter(21)" &lt;&gt; "Users"
		         AND "#Parameter(21)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(21)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(21)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(21),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(22)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(22)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(22))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(22), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(23)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 7.
#If "#Parameter(24)" = "" AND "#Parameter(25)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(24)" = "Condition" Or "#Parameter(24)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(25) )
#ElseIf "#Parameter(24)" = "ReadRight" Or "#Parameter(24)" = "EditRight" #Then
	 #Parameter(25) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(25))
		#If Not "#Parameter(24)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(24)" = "ReadByIDRight" Or "#Parameter(24)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(25)
		#If Not "#Parameter(24)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(24)" = "Object" Or "#Parameter(24)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(25))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(25))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(25))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(25)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(25)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(25)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(25))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(25)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(25)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(25))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(25)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(25)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(24)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(25)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(25)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(24),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(24)", ",") #Then
		IncorrectAccessKind: "#Parameter(24)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(24)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(24),") #Then
	
	 (
			ISNULL(#Parameter(25), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(24),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(24),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(25)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(25)
		#ElseIf "#Parameter(25)" = "T.Ref"
		         AND "#Parameter(24)" &lt;&gt; "Users"
		         AND "#Parameter(24)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(24)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(24)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(25)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(25)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(25))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(25), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(26)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 8.
#If "#Parameter(27)" = "" AND "#Parameter(28)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(27)" = "Condition" Or "#Parameter(27)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(28) )
#ElseIf "#Parameter(27)" = "ReadRight" Or "#Parameter(27)" = "EditRight" #Then
	 #Parameter(28) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(28))
		#If Not "#Parameter(27)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(27)" = "ReadByIDRight" Or "#Parameter(27)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(28)
		#If Not "#Parameter(27)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(27)" = "Object" Or "#Parameter(27)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(28))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(28))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(28))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(28)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(28)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(28)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(28))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(28)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(28)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(28))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(28)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(28)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(27)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(28)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(28)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(27),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(27)", ",") #Then
		IncorrectAccessKind: "#Parameter(27)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(27)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(27),") #Then
	
	 (
			ISNULL(#Parameter(28), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(27),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(27),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(28)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(27),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(28)
		#ElseIf "#Parameter(28)" = "T.Ref"
		         AND "#Parameter(27)" &lt;&gt; "Users"
		         AND "#Parameter(27)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(27)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(27)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(27),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(28)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(28)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(28))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(28), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(29)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 9.
#If "#Parameter(30)" = "" AND "#Parameter(31)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(30)" = "Condition" Or "#Parameter(30)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(31) )
#ElseIf "#Parameter(30)" = "ReadRight" Or "#Parameter(30)" = "EditRight" #Then
	 #Parameter(31) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(31))
		#If Not "#Parameter(30)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(30)" = "ReadByIDRight" Or "#Parameter(30)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(31)
		#If Not "#Parameter(30)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(30)" = "Object" Or "#Parameter(30)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(31))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(31))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(31))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(31)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(31)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(31)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(31))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(31)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(31)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(31))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(31)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(31)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(30)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(31)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(31)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(30),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(30)", ",") #Then
		IncorrectAccessKind: "#Parameter(30)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(30)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(30),") #Then
	
	 (
			ISNULL(#Parameter(31), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(30),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(30),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(31)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(31)
		#ElseIf "#Parameter(31)" = "T.Ref"
		         AND "#Parameter(30)" &lt;&gt; "Users"
		         AND "#Parameter(30)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(30)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(30)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(31)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(31)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(31))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(31), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(32)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 10.
#If "#Parameter(33)" = "" AND "#Parameter(34)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(33)" = "Condition" Or "#Parameter(33)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(34) )
#ElseIf "#Parameter(33)" = "ReadRight" Or "#Parameter(33)" = "EditRight" #Then
	 #Parameter(34) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(34))
		#If Not "#Parameter(33)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(33)" = "ReadByIDRight" Or "#Parameter(33)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(34)
		#If Not "#Parameter(33)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(33)" = "Object" Or "#Parameter(33)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(34))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(34))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(34))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(34)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(34)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(34)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(34))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(34)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(34)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(34))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(34)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(34)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(33)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(34)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(34)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(33),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(33)", ",") #Then
		IncorrectAccessKind: "#Parameter(33)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(33)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(33),") #Then
	
	 (
			ISNULL(#Parameter(34), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(33),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(33),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(34)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(33),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(34)
		#ElseIf "#Parameter(34)" = "T.Ref"
		         AND "#Parameter(33)" &lt;&gt; "Users"
		         AND "#Parameter(33)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(33)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(33)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(33),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(34)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(34)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(34))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(34), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(35)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 11.
#If "#Parameter(36)" = "" AND "#Parameter(37)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(36)" = "Condition" Or "#Parameter(36)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(37) )
#ElseIf "#Parameter(36)" = "ReadRight" Or "#Parameter(36)" = "EditRight" #Then
	 #Parameter(37) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(37))
		#If Not "#Parameter(36)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(36)" = "ReadByIDRight" Or "#Parameter(36)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(37)
		#If Not "#Parameter(36)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(36)" = "Object" Or "#Parameter(36)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(37))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(37))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(37))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(37)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(37)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(37)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(37))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(37)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(37)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(37))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(37)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(37)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(36)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(37)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(37)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(36),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(36)", ",") #Then
		IncorrectAccessKind: "#Parameter(36)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(36)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(36),") #Then
	
	 (
			ISNULL(#Parameter(37), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(36),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(36),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(37)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(36),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(37)
		#ElseIf "#Parameter(37)" = "T.Ref"
		         AND "#Parameter(36)" &lt;&gt; "Users"
		         AND "#Parameter(36)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(36)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(36)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(36),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(37)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(37)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(37))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(37), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(38)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 12.
#If "#Parameter(39)" = "" AND "#Parameter(40)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(39)" = "Condition" Or "#Parameter(39)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(40) )
#ElseIf "#Parameter(39)" = "ReadRight" Or "#Parameter(39)" = "EditRight" #Then
	 #Parameter(40) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(40))
		#If Not "#Parameter(39)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(39)" = "ReadByIDRight" Or "#Parameter(39)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(40)
		#If Not "#Parameter(39)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(39)" = "Object" Or "#Parameter(39)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(40))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(40))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(40))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(40)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(40)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(40)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(40))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(40)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(40)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(40))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(40)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(40)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(39)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(40)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(40)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(39),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(39)", ",") #Then
		IncorrectAccessKind: "#Parameter(39)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(39)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(39),") #Then
	
	 (
			ISNULL(#Parameter(40), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(39),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(39),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(40)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(39),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(40)
		#ElseIf "#Parameter(40)" = "T.Ref"
		         AND "#Parameter(39)" &lt;&gt; "Users"
		         AND "#Parameter(39)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(39)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(39)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(39),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(40)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(40)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(40))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(40), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(41)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 13.
#If "#Parameter(42)" = "" AND "#Parameter(43)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(42)" = "Condition" Or "#Parameter(42)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(43) )
#ElseIf "#Parameter(42)" = "ReadRight" Or "#Parameter(42)" = "EditRight" #Then
	 #Parameter(43) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(43))
		#If Not "#Parameter(42)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(42)" = "ReadByIDRight" Or "#Parameter(42)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(43)
		#If Not "#Parameter(42)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(42)" = "Object" Or "#Parameter(42)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(43))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(43))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(43))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(43)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(43)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(43)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(43))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(43)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(43)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(43))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(43)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(43)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(42)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(43)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(43)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(42),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(42)", ",") #Then
		IncorrectAccessKind: "#Parameter(42)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(42)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(42),") #Then
	
	 (
			ISNULL(#Parameter(43), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(42),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(42),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(43)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(42),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(43)
		#ElseIf "#Parameter(43)" = "T.Ref"
		         AND "#Parameter(42)" &lt;&gt; "Users"
		         AND "#Parameter(42)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(42)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(42)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(42),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(43)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(43)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(43))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(43), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(44)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 14.
#If "#Parameter(45)" = "" AND "#Parameter(46)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(45)" = "Condition" Or "#Parameter(45)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(46) )
#ElseIf "#Parameter(45)" = "ReadRight" Or "#Parameter(45)" = "EditRight" #Then
	 #Parameter(46) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(46))
		#If Not "#Parameter(45)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(45)" = "ReadByIDRight" Or "#Parameter(45)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(46)
		#If Not "#Parameter(45)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(45)" = "Object" Or "#Parameter(45)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(46))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(46))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(46))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(46)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(46)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(46)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(46))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(46)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(46)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(46))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(46)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(46)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(45)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(46)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(46)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(45),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(45)", ",") #Then
		IncorrectAccessKind: "#Parameter(45)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(45)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(45),") #Then
	
	 (
			ISNULL(#Parameter(46), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(45),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(45),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(46)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(45),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(46)
		#ElseIf "#Parameter(46)" = "T.Ref"
		         AND "#Parameter(45)" &lt;&gt; "Users"
		         AND "#Parameter(45)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(45)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(45)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(45),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(46)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(46)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(46))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(46), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(47)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 15.
#If "#Parameter(48)" = "" AND "#Parameter(49)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(48)" = "Condition" Or "#Parameter(48)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(49) )
#ElseIf "#Parameter(48)" = "ReadRight" Or "#Parameter(48)" = "EditRight" #Then
	 #Parameter(49) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(49))
		#If Not "#Parameter(48)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(48)" = "ReadByIDRight" Or "#Parameter(48)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(49)
		#If Not "#Parameter(48)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(48)" = "Object" Or "#Parameter(48)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(49))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(49))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(49))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(49)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(49)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(49)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(49))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(49)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(49)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(49))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(49)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(49)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(48)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(49)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(49)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(48),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(48)", ",") #Then
		IncorrectAccessKind: "#Parameter(48)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(48)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(48),") #Then
	
	 (
			ISNULL(#Parameter(49), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(48),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(48),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(49)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(48),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(49)
		#ElseIf "#Parameter(49)" = "T.Ref"
		         AND "#Parameter(48)" &lt;&gt; "Users"
		         AND "#Parameter(48)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(48)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(48)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(48),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(49)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(49)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(49))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(49), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(50)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

//// Checking the field value of parameter group 16.
#If "#Parameter(51)" = "" AND "#Parameter(52)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;AccessRestrictionAtRecordLevelEnabled AND ("#Parameter(51)" = "Condition" Or "#Parameter(51)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(52) )
#ElseIf "#Parameter(51)" = "ReadRight" Or "#Parameter(51)" = "EditRight" #Then
	 #Parameter(52) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(52))
		#If Not "#Parameter(51)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(51)" = "ReadByIDRight" Or "#Parameter(51)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(52)
		#If Not "#Parameter(51)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(51)" = "Object" Or "#Parameter(51)" = " " #Then
	(
		// Checking the leading table object right (right dependency).
		(
			TRUE IN
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
			WHERE
				  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
				AND VALUETYPE(AccessGroupsTablesObjectRightCheck.TableType) = VALUETYPE(#Parameter(52))
			#If #CurrentAccessRightName = "Read" #Then
				// Checking the head right for the Read right.
				// Read right can depend only on the Read right.
			#Else
				// Checking the leading right for the Change right.
				// The Edit right can depend on leading rights Read or Edit.
				AND NOT
				(	  AccessGroupsTablesObjectRightCheck.Update = FALSE
					AND NOT TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
					WHERE
						  AccessRightsDependencies.SubordinateTable = CurrentTableProperties.Ref
						AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(52))
					)
				)
			#EndIf
			)
		)
  #If &amp;AccessRestrictionAtRecordLevelEnabled #Then
		// Checking the leading table object right restriction.
		AND 
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		CASE WHEN TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM Catalog.MetadataObjectIDs AS IDs
					WHERE
						  VALUETYPE(IDs.EmptyRefValue) = VALUETYPE(#Parameter(52))
						AND IDs.EmptyRefValue IN (&amp;RightsSettingsOwnersTypes)
				)
		THEN
			(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(52)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = #Parameter(52)
							AND RightsSettings.Object  = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
						  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
							AND RightsSettings.Table = CurrentTableProperties.Ref
						  #Else
							AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
						  #EndIf
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
			)
		ELSE
	#EndIf
	#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
		NOT
		 (
		  TRUE IN // Not all checks are disabled.
		  (
				SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
				FROM InformationRegister.AccessValuesSets AS SetsNumbers
				WHERE
					  SetsNumbers.Object = #Parameter(52)
				#If #CurrentAccessRightName = "Read" #Then
					// Read right can depend only on the Read right.
					AND SetsNumbers.Read = TRUE
				#Else
					// The Edit right can depend on leading rights Read or Edit.
					AND CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
							WHERE
								  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
								AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(52))
							)
						THEN SetsNumbers.Read
						ELSE SetsNumbers.Update
					  END
				#EndIf
					AND
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(52)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
		  ) AND NOT
	#Else
		 (
	#EndIf
		  TRUE IN
		  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Object = #Parameter(52)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				AND SetsNumbers.Read = TRUE
			#Else
				// The Edit right can depend on leading rights Read or Edit.
				AND CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessRightsDependencies AS AccessRightsDependencies
						WHERE
							  AccessRightsDependencies.SubordinateTable             = CurrentTableProperties.Ref
							AND VALUETYPE(AccessRightsDependencies.LeadingTableType) = VALUETYPE(#Parameter(52))
						)
					THEN SetsNumbers.Read
					ELSE SetsNumbers.Update
				  END
			#EndIf
				AND
			  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
				TRUE IN // Not all checks for the current set are disabled.
				(
					SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
					FROM InformationRegister.AccessValuesSets AS ValueSets
					WHERE
						  ValueSets.Object      = #Parameter(52)
						AND ValueSets.SetNumber = SetsNumbers.SetNumber
						AND NOT TRUE IN
							(
								SELECT TOP 1 TRUE // Searching for access restriction settings.
								FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
								WHERE
									  DefaultValues.AccessGroup = AccessGroups.Ref
									AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
									AND DefaultValues.NoSettings = TRUE
							)
				)
				AND
			  #EndIf
				  NOT FALSE IN // All checks are successful.
				(
				SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
				FROM InformationRegister.AccessValuesSets AS ValueSets
				WHERE
					  ValueSets.Object      = #Parameter(52)
					AND ValueSets.SetNumber = SetsNumbers.SetNumber
					AND NOT
				CASE
			#If #CurrentAccessRightName = "Read" #Then
			  #If NOT &amp;DisabledAccessKinds = "All" #Then
				WHEN ValueSets.ValueWithoutGroups
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			  #EndIf
				WHEN ValueSets.StandardValue
			#Else
				WHEN
					TRUE IN
					(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
							VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					)
			#EndIf
			#If &amp;DisabledAccessKinds = "All" #Then
				THEN
					TRUE
			#Else
				THEN
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					CASE
				#EndIf
				#If Not #CurrentAccessRightName = "Read" #Then
					WHEN
						NOT TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM Catalog.MetadataObjectIDs AS RefsTypes
							WHERE
								  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
								AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
							)
					THEN
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
							WHERE
								  Values.AccessGroup   = AccessGroups.Ref
								AND Values.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#EndIf
				#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					WHEN
						TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
							WHERE
								  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
								AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
							)
					THEN
						TRUE
				#EndIf
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					ELSE
				#EndIf
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.AccessGroupsValues AS Values
								INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
							ON
								  Values.AccessGroup         = AccessGroups.Ref
								AND Values.AccessValue       = ValueGroups.AccessValuesGroup
								AND ValueGroups.AccessValue = ValueSets.AccessValue
							)
						THEN TRUE
						ELSE FALSE
						END
						=
						CASE
						WHEN TRUE IN
							(
							SELECT TOP 1 TRUE
							FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
							WHERE
							      DefaultValues.AccessGroup = AccessGroups.Ref
							    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
							    AND DefaultValues.AllAllowed = FALSE
							)
						THEN TRUE
						ELSE FALSE
						END
				#If Not #CurrentAccessRightName = "Read"
				  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
				  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
					END
				#EndIf
			#EndIf
				// Checking a definitely false or true one-line set of values.
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
				THEN TRUE
				WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
				THEN FALSE
				// Checking user access rights to the AccessValues table.
				WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			#If #CurrentAccessRightName = "Read" #Then
				// Read right can depend only on the Read right.
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
					)
			#Else
				THEN TRUE IN
					(	SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
						WHERE
							  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
							AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
							AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
									AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
					)
			#EndIf
			#If Not &amp;RightsSettingsOwnersTypes = "" #Then
				ELSE
					(
					TRUE IN // Checking if the right is granted to the user or any group that includes the user.
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
						(
						SELECT TOP 1 FALSE
						FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
							INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
							ON
								  SettingsInheritance.Object = ValueSets.AccessValue
								AND RightsSettings.Object        = SettingsInheritance.Parent
							#If #CurrentAccessRightName = "Read" #Then
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
							#Else
								AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
								AND RightsSettings.Table = CASE
									WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
									THEN ValueSets.Clarification
									ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
							#EndIf
							INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
							ON
								  UserGroupCompositions.User        = &amp;AuthorizedUser
								AND UserGroupCompositions.UsersGroup = RightsSettings.User
						)
					)
			#Else
				ELSE
					FALSE
			#EndIf
				END
				) // NOT FALSE IN
		  )
		 )
	#If Not &amp;RightsSettingsOwnersTypes = "" #Then
		END
	#EndIf
  #EndIf
	)

#ElseIf Not &amp;AccessRestrictionAtRecordLevelEnabled #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(51)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(52)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(52)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(51),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(51)", ",") #Then
		IncorrectAccessKind: "#Parameter(51)" - "The list of access kinds names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(51)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(51),") #Then
	
	 (
			ISNULL(#Parameter(52), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(51),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(51),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(52)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(51),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(52)
		#ElseIf "#Parameter(52)" = "T.Ref"
		         AND "#Parameter(51)" &lt;&gt; "Users"
		         AND "#Parameter(51)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(51)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(51)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(51),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(52)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(52)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(52))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )

#Else
	ISNULL(#Parameter(52), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(53)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with/without parentheses.

  )
)
#EndIf

#EndIf // Infobase is locked for update.
</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ForObject(ObjectField)</name>
		<condition>// ForObject(ObjectField = "")
// The template is used to restrict reference items, documents, and
// other object lists by the Reference field. Also, it is used to restrict items of dependent lists
// of objects and register records by the owner object field.

// Parameters:
//  ObjectField - name of the field that stores reference to the object the list item depends on.
//                Value "" (by default) is the same as the name of the Reference field.


#If &amp;ListsWithReadRestrictionDisabled = "Undefined" #Then
  // Infobase is locked for update.
  WHERE FALSE

#ElseIf Not StrContains(&amp;AccessRestrictionTemplatesVersions, ",ForRegister6,") #Then
  Error: Template update to version supplied in the EditAccessGroupsMembers role required. Reason: Version 6 of the ForRegister access restriction template is obsolete. Object: #CurrentTableName. Right: #CurrentAccessRightName.

#ElseIf &amp;ListsWithReadRestrictionDisabled = "All" #Then
  // All access kinds are disabled for the user or
  // restriction at the record level is not used.
  WHERE TRUE

#ElseIf StrContains(&amp;ListsWithReadRestrictionDisabled, #CurrentTableName) #Then
  // Restriction for the current table is disabled for the user.
  WHERE TRUE

#ElseIf StrContains(&amp;AccessRestrictionTemplatesVersions, ",SessionRestartRequired,") #Then
  Error. Application version is updated, restart the session. Object: #CurrentTableName, Right: #CurrentAccessRightName.

#ElseIf #CurrentAccessRightName &lt;&gt; "Read" #Then
  // Checking rights Insert, Update, and Delete BeforeWrite / OnWrite.
  WHERE TRUE

#ElseIf Not StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction,  #CurrentTableName + ":#ObjectField;")
         AND Not StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":#ObjectField;") #Then

  Error: Access restriction update required. Reason: Cannot get the access restriction option for ForObject template from the session parameters. Object: #CurrentTableName. Right: #CurrentAccessRightName.
#Else

CurrentTable WHERE TRUE IN
 (
  SELECT TOP 1 TRUE
  FROM InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
  #If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, #CurrentTableName + ":#ObjectField;") #Then
      LEFT JOIN InformationRegister.AccessGroupSetsAccessKeys AS AccessGroupSetsAccessKeys
      ON
      #If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
          AccessGroupSetsAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey
      #Else
          AccessGroupSetsAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
      #EndIf
        AND AccessGroupSetsAccessKeys.AccessGroupsSet = &amp;AllowedAccessGroupsSet
  #EndIf
  #If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, #CurrentTableName + ":#ObjectField;*") #Then
      
      LEFT JOIN InformationRegister.AccessGroupSetsAccessKeys AS AccessKeysOfAllowedAccessGroupSet
      ON
      #If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
          AccessKeysOfAllowedAccessGroupSet.AccessKey = AccessKeysForObjects.UsersAccessKey
      #Else
          AccessKeysOfAllowedAccessGroupSet.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
      #EndIf
        AND AccessKeysOfAllowedAccessGroupSet.AccessGroupsSet = &amp;AllowedBlankAccessGroupsSet
  #EndIf
  #If StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":#ObjectField;") #Then
      
    #If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
      LEFT JOIN InformationRegister.UsersAccessKeys AS UsersAccessKeys
      ON
          UsersAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey
        AND UsersAccessKeys.User = &amp;AllowedUser
    #Else
      LEFT JOIN InformationRegister.ExternalUsersAccessKeys AS UsersAccessKeys
      ON
          UsersAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
        AND UsersAccessKeys.ExternalUser = &amp;AllowedUser
    #EndIf
  #EndIf
  #If StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":#ObjectField;+") #Then
      
    #If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
      LEFT JOIN InformationRegister.UsersAccessKeys AS AccessKeysOfUserGroupSets
      ON
          AccessKeysOfUserGroupSets.AccessKey = AccessKeysForObjects.UsersAccessKey
        AND AccessKeysOfUserGroupSets.User = &amp;AllowedUserGroupsSet
    #Else
      LEFT JOIN InformationRegister.ExternalUsersAccessKeys AS AccessKeysOfUserGroupSets
      ON
          AccessKeysOfUserGroupSets.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
        AND AccessKeysOfUserGroupSets.ExternalUser = &amp;AllowedUserGroupsSet
    #EndIf
  #EndIf
  WHERE
  #If "#ObjectField"  = "" #Then
      AccessKeysForObjects.Object = CurrentTable.Ref
  #Else
      AccessKeysForObjects.Object = CurrentTable.#ObjectField
  #EndIf
    AND (
  #If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, #CurrentTableName + ":#ObjectField;") #Then
          Not AccessGroupSetsAccessKeys.AccessKey Is NULL
  #Else
          False
  #EndIf
  #If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, #CurrentTableName + ":#ObjectField;*") #Then
      Or Not AccessKeysOfAllowedAccessGroupSet.AccessKey Is NULL
  #EndIf
  #If StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":#ObjectField;") #Then
      Or Not UsersAccessKeys.AccessKey Is NULL
  #EndIf
  #If StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":#ObjectField;+") #Then
      Or Not AccessKeysOfUserGroupSets.AccessKey Is NULL
  #EndIf
      )
 )
#EndIf

#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";ConsiderRightsSettingsOnBuildQueryExecutionPlan;") #Then
  #If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction,  #CurrentTableName + ":[#Register]:#Field1:#Field2:#Field3:#Field4:#Field5;") #Then
  AND TRUE IN (TRUE
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";31;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";30;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";29;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";28;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";27;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";26;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";25;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";24;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";23;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";22;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";21;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";20;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";19;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";18;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";17;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";16;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";15;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";14;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";13;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";12;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";11;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";10;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";09;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";08;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";07;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";06;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";05;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";04;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";03;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";02;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";01;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";00;") #Then ,TRUE #Else ,FALSE #EndIf
	)
  #Else
  AND TRUE IN (TRUE
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";31^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";30^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";29^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";28^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";27^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";26^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";25^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";24^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";23^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";22^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";21^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";20^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";19^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";18^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";17^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";16^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";15^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";14^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";13^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";12^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";11^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";10^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";09^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";08^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";07^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";06^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";05^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";04^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";03^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";02^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";01^;") #Then ,TRUE #Else ,FALSE #EndIf
	#If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, ";00^;") #Then ,TRUE #Else ,FALSE #EndIf
	)
  #EndIf
#EndIf
</condition>
	</restrictionTemplate>
</Rights>
