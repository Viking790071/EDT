#Region Internal

////////////////////////////////////////////////////////////////////////////////
// Main procedures and functions.

// Adds a user to an access group of the supplied profile.
// The access group is determined by ID of the reference of a supplied profile.
// If an access group is not found, it will be created.
//
// Parameters:
//  User - CatalogRef.Users,
//                        CatalogRef.ExternalUsers,
//                        CatalogRef.UserGroups,
//                        CatalogRef.ExternalUserGroups
//                        - a member to be included in the access group.
// 
//  SuppliedProfile - String - an ID string of a supplied profile.
//                      - CatalogRef.AccessGroupsProfiles - a reference to the profile created by 
//                        description in the AccessControlOverridable module in 
//                        FillAccessGroupsSuppliedProfiles procedure.
//                        Profiles with a non-blank list of access kinds are not supported.
//                        Administrator access group profile is not supported.
// 
Procedure AddUserToAccessGroup(User, SuppliedProfile) Export
	
	ProcessUserLinkToAccessGroup(User, SuppliedProfile, True);
	
EndProcedure

// Updates the users of the assignee groups.
// 
// This procedure must be called when users are changed in assignee groups, for example, in task 
// assignee groups.
//
// Assignee groups whose memebers are changed, are passed as parameter values.
//
// Parameters:
//  PerformerGroups - For example, CatalogRef.TaskAssigneesGroups.
//                     - Array of values of the types specified above.
//                     - Undefined - without filter.
//
Procedure UpdatePerformersGroupsUsers(PerformersGroups = Undefined) Export
	
	If TypeOf(PerformersGroups) = Type("Array") AND PerformersGroups.Count() = 0 Then
		Return;
	EndIf;
	
	Parameters = New Structure;
	Parameters.Insert("PerformersGroups", PerformersGroups);
	
	InformationRegisters.AccessValuesGroups.UpdateUsersGroupings(Parameters);
	
EndProcedure

// Checks whether an access kind of the specified name exists.
// It is used for automation of conditional subsystem embedding.
// 
Function AccessKindExists(AccessKindName) Export
	
	Return AccessKindProperties(AccessKindName) <> Undefined;
	
EndFunction

// Returns the user interface type for access setup.
Function SimplifiedAccessRightsSetupInterface() Export
	
	SimplifiedInterface = False;
	AccessManagementOverridable.OnDefineAccessSettingInterface(SimplifiedInterface);
	
	Return SimplifiedInterface = True;
	
EndFunction

// Returns an array of allowed values of the specified types within all access groups.
// Used in the SetDynamicListFilters procedure to speed up the opening of dynamic lists.
// 
// Parameters:
//  Table - String - a full name of the metadata object, for example, Document.PurchaseInvoice.
//  ValueType - Type - a type of access values whose allowed values are to be returned.
//               - Array - an array of above listed types.
//
//  Values - Undefined - do not consider.
//               - Array - an array of type values specified in the ValuesType parameter.
//
// Returns:
//  Undefined - if the number of allowed values exceeds 100 (when the Values parameter is not defined).
//  Array - references of allowed values of the specified types.
//
Function AllowedDynamicListValues(Table, ValuesType, Values = Undefined) Export
	
	If TypeOf(ValuesType) <> Type("Array") Then
		ValueTypes = New Array;
		ValueTypes.Add(ValuesType);
		
	ElsIf ValuesType.Count() = 0 Then
		Return Undefined;
	Else
		ValueTypes = ValuesType;
	EndIf;
	
	SetPrivilegedMode(True);
	
	ValuesQueryTextWithoutGroups =
	"SELECT TOP 101
	|	ValuesWithoutGroups.Ref AS Ref
	|FROM
	|	(SELECT
	|		&EmptyRefValue AS Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		ValuesWithoutEmptyRef.Ref
	|	FROM
	|		&AccessValuesTable AS ValuesWithoutEmptyRef) AS ValuesWithoutGroups
	|WHERE
	|	TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				UserAccessGroups AS AccessGroups
	|			WHERE
	|				CASE
	|					WHEN TRUE IN
	|							(SELECT TOP 1
	|								TRUE
	|							FROM
	|								InformationRegister.AccessGroupsValues AS Values
	|							WHERE
	|								Values.AccessGroup = AccessGroups.Ref
	|								AND Values.AccessValue = ValuesWithoutGroups.Ref)
	|						THEN TRUE
	|					ELSE FALSE
	|				END = CASE
	|					WHEN TRUE IN
	|							(SELECT TOP 1
	|								TRUE
	|							FROM
	|								InformationRegister.DefaultAccessGroupsValues AS DefaultValues
	|							WHERE
	|								DefaultValues.AccessGroup = AccessGroups.Ref
	|								AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValuesWithoutGroups.Ref)
	|								AND DefaultValues.AllAllowed = FALSE)
	|						THEN TRUE
	|					ELSE FALSE
	|				END)
	|	AND ValuesWithoutGroups.Ref IN(&Values)";
	
	If TypeOf(Values) = Type("Array") Then
		ValuesQueryTextWithoutGroups = StrReplace(ValuesQueryTextWithoutGroups, "TOP 101", "");
	Else
		ValuesQueryTextWithoutGroups = StrReplace(ValuesQueryTextWithoutGroups, "ValuesWithoutGroups.Ref IN(&Values)", "True");
	EndIf;
	
	ValuesQueryTextWithGroups =
	"SELECT TOP 101
	|	ValuesWithGroups.Ref AS Ref
	|FROM
	|	(SELECT
	|		&EmptyRefValue AS Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		ValuesWithoutEmptyRef.Ref
	|	FROM
	|		&AccessValuesTable AS ValuesWithoutEmptyRef) AS ValuesWithGroups
	|WHERE
	|	TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				UserAccessGroups AS AccessGroups
	|			WHERE
	|				CASE
	|					WHEN TRUE IN
	|							(SELECT TOP 1
	|								TRUE
	|							FROM
	|								InformationRegister.AccessGroupsValues AS Values
	|									INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
	|									ON
	|										Values.AccessGroup = AccessGroups.Ref
	|											AND Values.AccessValue = ValueGroups.AccessValuesGroup
	|											AND ValueGroups.AccessValue = ValuesWithGroups.Ref)
	|						THEN TRUE
	|					ELSE FALSE
	|				END = CASE
	|					WHEN TRUE IN
	|							(SELECT TOP 1
	|								TRUE
	|							FROM
	|								InformationRegister.DefaultAccessGroupsValues AS DefaultValues
	|							WHERE
	|								DefaultValues.AccessGroup = AccessGroups.Ref
	|								AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValuesWithGroups.Ref)
	|								AND DefaultValues.AllAllowed = FALSE)
	|						THEN TRUE
	|					ELSE FALSE
	|				END)
	|	AND ValuesWithGroups.Ref IN(&Values)";
	
	If TypeOf(Values) = Type("Array") Then
		ValuesQueryTextWithGroups = StrReplace(ValuesQueryTextWithGroups, "TOP 101", "");
	Else
		ValuesQueryTextWithGroups = StrReplace(ValuesQueryTextWithGroups, "ValuesWithGroups.Ref IN(&Values)", "True");
	EndIf;
	
	QueryTextAllValues =
	"SELECT TOP 101
	|	AllValues.Ref AS Ref
	|FROM
	|	(SELECT
	|		&EmptyRefValue AS Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		ValuesWithoutEmptyRef.Ref
	|	FROM
	|		&AccessValuesTable AS ValuesWithoutEmptyRef) AS AllValues
	|WHERE
	|	AllValues.Ref IN(&Values)";
	
	If TypeOf(Values) = Type("Array") Then
		QueryTextAllValues = StrReplace(QueryTextAllValues, "TOP 101", "");
	Else
		QueryTextAllValues = StrReplace(QueryTextAllValues, "AllValues.Ref IN(&Values)", "True");
	EndIf;
	
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	QueryText = "";
	AuthorizedUser = Users.AuthorizedUser();
	AddCurrentUser = False;
	HasUsedAccessKinds = False;
	
	For Each CurrentType In ValueTypes Do
		Properties = AccessKindsProperties.ByValuesTypes.Get(CurrentType);
		If Properties = Undefined Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Тип ""%1"" не является типом значений доступа'; en = 'Type ""%1"" is not an access value type'; pl = 'Typ ""%1"" nie jest typem wartości dostępu';es_ES = 'Tipo ""%1"" no es tipo de valores de acceso';es_CO = 'Tipo ""%1"" no es tipo de valores de acceso';tr = 'Tür ""%1"" erişim değerlerin türü değil';it = 'Il tipo ""%1"" non è un tipo di valore di accesso';de = 'Typ ""%1"" ist kein Typ von Zugriffswert'"), String(CurrentType));
			Raise ErrorText;
		EndIf;
		If Not AccessKindUsed(Properties.Name) Then
			CurrentQueryText = QueryTextAllValues;
		Else
			If AccessKindsProperties.AccessValuesTypesWithGroups.Get(CurrentType) = Undefined Then
				CurrentQueryText = ValuesQueryTextWithoutGroups;
			Else
				CurrentQueryText = ValuesQueryTextWithGroups;
			EndIf;
			HasUsedAccessKinds = True;
		EndIf;
		AccessValuesTable = Metadata.FindByType(CurrentType).FullName();
		CurrentQueryText = StrReplace(CurrentQueryText, "&AccessValuesTable", AccessValuesTable);
		CurrentQueryText = StrReplace(CurrentQueryText, "&EmptyRefValue",
			"VALUE(" + AccessValuesTable + ".EmptyRef)");
		If ValueIsFilled(QueryText) Then
			UnionQueryWithQuery(QueryText, CurrentQueryText);
		Else
			QueryText = CurrentQueryText;
		EndIf;
		If CurrentType = TypeOf(AuthorizedUser) Then
			AddCurrentUser = True;
		EndIf;
	EndDo;
	
	If Not HasUsedAccessKinds Then
		Return Undefined;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("MainListTableName", Table);
	Query.SetParameter("AuthorizedUser", AuthorizedUser);
	Query.Text = AccessGroupsRequestText();
	If TypeOf(Values) = Type("Array") Then
		Query.SetParameter("Values", Values);
	EndIf;
	
	AddQueryToPackage(Query.Text, QueryText);
	
	DataExported = Query.Execute().Unload();
	
	If TypeOf(Values) <> Type("Array")
	   AND DataExported.Count() > 100 Then
		
		Return Undefined;
	EndIf;
	
	AllowedValues = DataExported.UnloadColumn("Ref");
	
	If AddCurrentUser Then
		AllowedValues.Add(AuthorizedUser);
	EndIf;
	
	Return AllowedValues;
	
EndFunction

// Adds system administrators to the access group connected with the predefined 
// OpenExternalReportsAndDataProcessors profile.
//
Procedure SetExternalReportsAndDataProcessorsOpenRight(OpenAllowed) Export
	
	ProfileProperties = OpenExternalReportsAndDataProcessorsProfileDetails();
	ProfileProperties.Insert("Ref", Catalogs.AccessGroupProfiles.SuppliedProfileByID(
		ProfileProperties.Name, True));
	
	RoleID = Common.MetadataObjectID(
		Metadata.Roles.InteractiveOpenExtReportsAndDataProcessors);
	
	// It is not required to create an access group in the simplified interface (only profile).
	SimplifiedInterface = SimplifiedAccessRightsSetupInterface();
	If Not SimplifiedInterface Then
		ProfileGroup = OpenExternalReportsAndDataProcessorsAccessGroup(ProfileProperties);
	EndIf;
	
	If OpenAllowed Then
		// Adding administrators to access groups with this profile.
		If Not SimplifiedInterface Then
			AccessGroupObject = ProfileGroup.GetObject();
		EndIf;
		AdministratorRole = Metadata.Roles.SystemAdministrator;
		IBUsers = InfoBaseUsers.GetUsers();
		For Each InfobaseUser In IBUsers Do
			If InfobaseUser.Roles.Contains(AdministratorRole) Then
				User = Catalogs.Users.FindByAttribute(
					"IBUserID",
					InfobaseUser.UUID);
				If User = Undefined Then
					Continue;
				EndIf;
				If SimplifiedInterface Then
					// In the simplified interface, each administrator is added to a separate group.
					AccessManagement.EnableProfileForUser(User, ProfileProperties.Ref);
				Else
					// In the extended interface, administrators are added to one group connected to the predefined profile.
					If AccessGroupObject.Users.Find(User, "User") = Undefined Then
						AccessGroupObject.Users.Add().User = User;
					EndIf;
				EndIf;
			EndIf;
		EndDo;
		If Not SimplifiedInterface AND AccessGroupObject.Modified() Then
			AccessGroupObject.Write();
		EndIf;
	Else
		// Deleting a role from all profiles, except for the predefined one.
		Query = New Query;
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupProfilesRoles.Ref
		|FROM
		|	Catalog.AccessGroupProfiles.Roles AS AccessGroupProfilesRoles
		|WHERE
		|	AccessGroupProfilesRoles.Role = &Role
		|	AND AccessGroupProfilesRoles.Ref <> &ProfileToExclude";
		Query.SetParameter("Role", RoleID);
		Query.SetParameter("ProfileToExclude", ProfileProperties.Ref);
		ProfilesArray = Query.Execute().Unload().UnloadColumn("Ref");
		For Each Profile In ProfilesArray Do
			ProfileObject = Profile.GetObject();
			FoundItems = ProfileObject.Roles.FindRows(New Structure("Role", RoleID));
			For Each TableRow In FoundItems Do
				ProfileObject.Roles.Delete(TableRow);
			EndDo;
			ProfileObject.Write();
		EndDo;
		
		// Clearing access group members connected to the predefined profile.
		Query = New Query;
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroups.Ref
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile = &Profile";
		Query.SetParameter("Profile", ProfileProperties.Ref);
		GroupsArray = Query.Execute().Unload().UnloadColumn("Ref");
		For Each AccessGroup In GroupsArray Do
			AccessGroupObject = AccessGroup.GetObject();
			AccessGroupObject.Users.Clear();
			AccessGroupObject.Write();
		EndDo;
	EndIf;
	
EndProcedure

#Region UniversalRestriction

Function LimitAccessAtRecordLevelUniversally(WithConstantAccessRestrictionAtRecordLevel = False) Export
	
	If WithConstantAccessRestrictionAtRecordLevel Then
		Return Constants.LimitAccessAtRecordLevelUniversally.Get();
	EndIf;
	
	Return SessionParameters.RecordLevelAccessRestrictionIsUniversal;
	
EndFunction

// Sets the use of the AccessUpdate scheduled job.
//
// Parameters:
// Use - Boolean - True if the job must be enabled, otherwise, False.
//
Procedure SetAccessUpdate(Usage, WithoutCheckingIBUpdateExecution = False) Export
	
	If Not WithoutCheckingIBUpdateExecution
	   AND InfobaseUpdate.InfobaseUpdateInProgress() Then
		
		Return; // After infobase update, the job is activated unconditionally.
	EndIf;
	
	EnableJob = ?(LimitAccessAtRecordLevelUniversally(), Usage, False);
	
	Filter = New Structure("Metadata", Metadata.ScheduledJobs.AccessUpdateAtRecordLevel);
	Jobs = ScheduledJobsServer.FindJobs(Filter);
	
	JobEnabled = False;
	For Each Job In Jobs Do
		If Not EnableJob AND    Job.Use
		 Or    EnableJob AND Not Job.Use Then 
		
			JobEnabled = EnableJob;
			ScheduledJobsServer.ChangeJob(Job.UUID,
				New Structure("Use", EnableJob));
		EndIf;
	EndDo;
	
	If Not EnableJob
	 Or Not JobEnabled
	 Or Common.DataSeparationEnabled()Then
		Return;
	EndIf;
	
	// Running the scheduled job immediately.
	CurrentSchedule = ScheduledJobsServer.JobSchedule(
		Metadata.ScheduledJobs.AccessUpdateAtRecordLevel);
	
	ScheduledJobsServer.SetJobSchedule(
		Metadata.ScheduledJobs.AccessUpdateAtRecordLevel, CurrentSchedule);
	
EndProcedure

// Returns text errors of object access restrictions without dependencies between objects.
// Texts are checked in the mode of maximum restrictions (as if all restriction kinds are enabled).
// The function must be called before the ImplementationSettings function to collect the entire error package.
//
// Returns:
//  Array - with the following values:
//   * Structure - with the following properties:
//      * FullName - String - a full name of a metadata object.
//      * ErrorText - String - an error text in access restriction.
//
Function AccessRestrictionErrors() Export
	
	Errors = New Array;
	ErrorObject = "CommonModule.AccessManagementOverridable";
	
	CommonContext = CommonContextOfRestrictionParametersCalculation(True, False);
	
	Try
		ListsWithRestriction = AccessManagementInternalCached.ListsWithRestriction();
	Except
		ErrorInformation = ErrorInfo();
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Списки с ограничением доступа некорректно указаны
			           |в процедуре OnFillListsWithAccessRestriction
			           |общего модуля AccessManagementOverridable по причине:
			           |
			           |%1'; 
			           |en = 'Lists with access restriction are incorrectly specified
			           |in the OnFillListsWithAccessRestriction procedure
			           |of the AccessManagementOverridable common module due to:
			           |
			           |%1'; 
			           |pl = 'Ograniczone listy dostępu są niepoprawnie określone
			           |w procedurze OnFillListsWithAccessRestriction
			           | wspólnego modułu AccessManagementOverridable z powodu:
			           |
			           |%1';
			           |es_ES = 'Las listas con restricción de acceso están indicadas incorrectamente
			           |en el procedimiento OnFillListsWithAccessRestriction
			           |del módulo común AccessManagementOverridable a causa de:
			           |
			           |%1';
			           |es_CO = 'Las listas con restricción de acceso están indicadas incorrectamente
			           |en el procedimiento OnFillListsWithAccessRestriction
			           |del módulo común AccessManagementOverridable a causa de:
			           |
			           |%1';
			           |tr = 'AccessManagementOverridable ortak modülünün 
			           |OnFillListsWithAccessRestriction prosedüründe
			           |erişim kısıtlamalı listeler yanlış belirtildi. Sebebi:
			           |
			           |%1';
			           |it = 'Gli elenchi con restrizione all''accesso sono indicati in modo errato
			           |nella procedura OnFillListsWithAccessRestriction
			           |del modulo comune AccessManagementOverridable a causa di:
			           |
			           |%1';
			           |de = 'Listen mit Zugriffsbeschränkung sind
			           |in der Prozedur OnFillListsWithAccessRestriction
			           |des allgemeinen Moduls AccessManagementOverridable falsch angegeben, weil:
			           |
			           |%1'"), DetailErrorDescription(ErrorInformation));
		Errors.Add(New Structure("FullName, ErrorText", ErrorObject, ErrorText));
		Return Errors;
	EndTry;
	
	ErrorsTexts = New Map;
	CommonContext.Insert("ListsWithRestriction", ListsWithRestriction);
	CommonContext.Insert("RestrictionsDetails", New Map);
	
	For Each ListDetails In CommonContext.ListsWithRestriction Do
		FullName = ListDetails.Key;
		Try
			ErrorText = AccessRestrictionError(CommonContext, FullName);
		Except
			ErrorInformation = ErrorInfo();
			ErrorText = DetailErrorDescription(ErrorInformation);
		EndTry;
		If ValueIsFilled(ErrorText) AND ErrorsTexts.Get(ErrorText) = Undefined Then
			ErrorsTexts.Insert(ErrorText, True);
			Errors.Add(New Structure("FullName, ErrorText", FullName, ErrorText));
		EndIf;
	EndDo;
	
	Return Errors;
	
EndFunction

// Returns implementation settings for developer tools.
//
// Parameters:
//  ActiveParameters - Undefined - a default value.
//                       - Structure - only to call from the CheckAccessRestrictionResult function.
//
// Returns:
//  Structure - with the following properties:
//    * RestrictionsInRoles - Structure - with the following properties:
//       * ForUsers - Map - with properties like for external users (below).
//       * ForExternalUsers - Map - with the following properties:
//           * Key - String - a full name of the metadata object (list). Collection name in English.
//                                 Object form must have the OnReadAtServer inserted.
//           * Value - Structure - with the following properties:
//               * TemplateForObject - Boolean - if True, the #ForObject template is used, if False, 
//                                             the #ForRegister template is used.
//               * Parameters - Array - array parameters (1 for the object, 6 for the register).
//                   * Value - String - for example, the Owner field name, or a name of basic field 
//                                      of the Company register.
//
//    * PredefinedIDs - Map - with the following properties:
//        * Key - String - a name of the required predefined catalog item.
//                              MetadataObjectIDs or ExtensionObjectIDs in the "<CatalogName>.
//                              <PredefinedItemName>" format.
//        * Value - String - a full name of the relevant metadata object.
//
//    * AccessKeysValuesOwners - Structure - for the group of defined types:
//        * Refs - Array - full names of the reference types (collection name in English).
//        * Documents - Array - full names of the object types (collection name in English).
//        * Objects - Array - the same as in the previous paragraph.
//        * RecordSets - Array - the same as in the previous paragraph.
//        * CalculationRegisterRecordSets - Array - the same as in the previous paragraph.
//
//    * AccessValues - Array - full names of reference types (collection name in English).
//                                 To supplement the defined AccessValue type.
//
//    * KeysRegistersDimensionsTypes - Map - for changes with the Field* name
//        of the AccessKeysToRegisters register and AccessKeysToRegister* registers: 
//           * Key - String - a register name.
//           * Value - Structure - with the following properties:
//               * TypesNames - Array - with the following values:
//                   * Value - String - a full name of a reference type (collection name in English).
//               * RegistersFields - Map - with the following properties:
//                   * Key - a full name of the register being restricted.
//                   * Value - Array - an order of fields that match the service fields (Field1, Field2, ...):
//                       * Value - Structure - with the following properties:
//                           * Field - String - a register field name.
//                           * Type - TypesDetails - register field types.
//               * RegistersFieldsByTypes - Map - with the following properties:
//                   * Key - String - a full name of the reference type (collection name in English).
//                   * Value - Array - an array with the following values:
//                       * Value - a full field name, for example,
//                                      "InformationRegister.AdditionalInfo.Property".
//
Function ImplementationSettings(ActiveParameters = Undefined) Export
	
	RestrictionsInRoles = New Structure;
	RestrictionsInRoles.Insert("ForUsers",        New Map);
	RestrictionsInRoles.Insert("ForExternalUsers", New Map);
	
	AccessKeysValuesOwners = New Structure;
	AccessKeysValuesOwners.Insert("References",        New Array);
	AccessKeysValuesOwners.Insert("Documents",     New Array);
	AccessKeysValuesOwners.Insert("Objects",       New Array);
	AccessKeysValuesOwners.Insert("RecordSets", New Array);
	AccessKeysValuesOwners.Insert("CalculationRegisterRecordSets", New Array);
	
	PredefinedIDs = New Map;
	AccessValues = New Array;
	KeysRegistersDimensionsTypes = New Map;
	KeysRegisterDimensionsTypes(KeysRegistersDimensionsTypes, "AccessKeysForRegisters");
	
	TablesTypesByNames = AccessManagementInternalCached.LanguageSyntax().TablesTypes.ByNames;
	AccessValues.Add(XMLRefTypeName(Metadata.Catalogs.AccessKeys.FullName(), TablesTypesByNames));
	
	AvailableRights = AccessManagementInternalCached.RightsForObjectsRightsSettingsAvailable();
	For Each AvailableRightsDetails In AvailableRights.ByFullNames Do
		AccessValues.Add(XMLRefTypeName(AvailableRightsDetails.Key, TablesTypesByNames));
	EndDo;
	
	TransactionID = New UUID;
	
	If ActiveParameters = Undefined Then
		CommonContext = CommonContextOfRestrictionParametersCalculation(True);
		NewStoredParameters = StoredAccessRestrictionParameters(CommonContext);
		ActiveParameters = New Structure(NewStoredParameters.ForWritingObjectsAndCheckingRights.Get());
	EndIf;
	
	For Each VersionDetails In ActiveParameters.ListsRestrictionsVersions Do
		FullName = VersionDetails.Key;
		XMLFullName = XMLFullName(FullName, TablesTypesByNames);
		XMLRefTypeName  = XMLRefTypeName(FullName, TablesTypesByNames);
		XMLObjectTypeName = ObjectTypeOrXMLRecordSetName(FullName, TablesTypesByNames);
		
		If ValueIsFilled(XMLRefTypeName) Then
			AccessKeysValuesOwners.References.Add(XMLRefTypeName);
		EndIf;
		
		If StrStartsWith(XMLObjectTypeName, "DocumentObject.") Then
			AccessKeysValuesOwners.Documents.Add(XMLObjectTypeName);
			
		ElsIf StrStartsWith(XMLObjectTypeName, "CalculationRegisterRecordSet.") Then
			AccessKeysValuesOwners.CalculationRegisterRecordSets.Add(XMLObjectTypeName);
			
		ElsIf StrFind(XMLObjectTypeName, "RecordSet.") > 0 Then
			AccessKeysValuesOwners.RecordSets.Add(XMLObjectTypeName);
			
		ElsIf StrFind(XMLObjectTypeName, "Object.") > 0 Then
			AccessKeysValuesOwners.Objects.Add(XMLObjectTypeName);
		EndIf;
		
		If VersionDetails.Value = Undefined Then
			Continue;
		EndIf;
		
		AddRestrictionsInRoles(XMLFullName,
			FullName,
			RestrictionsInRoles.ForUsers,
			ActiveParameters.AdditionalContext.ForUsers.ListRestrictionsProperties,
			KeysRegistersDimensionsTypes,
			TablesTypesByNames,
			PredefinedIDs);
		
		AddRestrictionsInRoles(XMLFullName,
			FullName,
			RestrictionsInRoles.ForExternalUsers,
			ActiveParameters.AdditionalContext.ForExternalUsers.ListRestrictionsProperties,
			KeysRegistersDimensionsTypes,
			TablesTypesByNames,
			PredefinedIDs);
	EndDo;
	
	Settings = New Structure;
	Settings.Insert("RestrictionsInRoles",              RestrictionsInRoles);
	Settings.Insert("PredefinedIDs", PredefinedIDs);
	Settings.Insert("AccessKeysValuesOwners", AccessKeysValuesOwners);
	Settings.Insert("AccessValues",                AccessValues);
	Settings.Insert("KeysRegistersDimensionsTypes",   KeysRegistersDimensionsTypes);
	
	Return Settings;
	
EndFunction

// Returns access restriction check result for the developer tool.
//
// Parameters:
//  FullName - String - full name of a metadata object.
//  AdditionalParameters
//            - Undefined - check and return the current restriction.
//            - Structure - with the following properties:
//                * Text - String - a new restriction text for users.
//                * TextForExternalUsers - String - a new restriction text for external users.
//                * ConsiderDependencies - Boolean - consider dependencies between object restrictions.
//
// Returns:
//  Structure - with the following properties:
//   * RestrictionDetailsError - String - if not blank, then the restriction description cannot be received.
//       If ConsiderDependencies = True, this is a text of the first error when all details are received.
//
//   * TextInManagerModule - Undefined - when RestrictionDetailsError is filled in.
//                           - Boolean - returns a restriction text location, when True - in the 
//                               manager module, otherwise, in the overridable module.
//
//   * ForUsers - Structure - with the following properties:
//      * RestrictionToCheck - Undefined, String - a checked restriction text.
//      * ErrorDescription         - Undefined, Structure - see AccessManagement. RestrictionStructure.
//      * RestrictionParametersGenerationError - Undefined, String - an error text.
//      * QueriesTextsGenerationError - Undefined, String - an error text.
//      * RestrictionByOwnerPossible - Undefined, Boolean - a checked restriction property.
//      * RestrictionsInRoles - Undefined, Structure - with the following properties:
//          * TemplateForObject - Boolean - if True, the #ForObject template is used, if False, the 
//                                        #ForRegister template is used.
//          * Parameters - Array - array parameters (1 for the object, 6 for the register).
//              * Value - String - for example, the Owner field name, or a name of basic field of 
//                                    the Company register.
//      * RestrictionInModule - Undefined, String - a restriction text set in the configuration.
//      * ByOwnerWithoutWritingAccessKeys - Undefined, Boolean - a restriction setting set in the 
//                                    configuration.
//
//   * ForExternalUsers - Structure - with properties like ForUsers.
//
//   * AccessKeysValuesOwner - String - types for the same defined type.
//   * AccessKeysValuesOwnerObject - String - types for the same defined type.
//   * AccessKeysValuesOwnerRecordSet - String - types for the same defined type.
//   * AccessKeysValuesOwnerCalculationRegisterRecordSet - String - types for the same defined type.
//   * AccessKeysToRegistersRegisterField - String - types for the same defined type.
//   * AccessValue - String - types for the same defined type.
//
//   * SeparateKeysRegisterDimensionsTypes - Undefined, Structure - with the following properties:
//      * InformationRegisterName - String - an access key register name.
//      * DimensionsTypes - String - types for the corresponding register dimensions.
//
//   * PredefinedID - Undefined, Structure - with the following properties
//      * CatalogName - String - metadata object (or extension) IDs catalog name.
//      * PredefinedItemName - String - a predefined item name in the catalog.
//
Function AccessRestrictionCheckResult(FullName, AdditionalParameters = Undefined) Export
	
	Return ObjectAccessRestrictionCheckResult(FullName, AdditionalParameters);
	
EndFunction

// Returns a structure of the specified restriction text for a metadata object.
//
// Parameters:
//  FullName - String - a full metadata object name.
//  RestrictionText - String - a restriction text that will be parsed.
//
// Returns:
//  Structure - see a return value in AccessManagement.RestrictionStructure. 
//
Function RestrictionStructureFromDetails(FullName, RestrictionText) Export
	
	Return CalculatedRestrictionStructure(FullName,
		RestrictionText, Undefined, Undefined, True);
	
EndFunction

// Adds access update for the specified lists or all lists.
// 
// Parameters:
//  Lists - Undefined - schedule full access update.
//         - String - a full metadata object name.
//         - CatalogRef.MetadataObjectsIDs - an ID.
//         - Array - type values specified above, except for Undefined.
//
//  PlanningParameters - Undefined - use the default values.
//                        - Structure - see AccessUpdatePlanningParameters(). 
//
Procedure ScheduleAccessUpdate(Lists = Undefined, PlanningParameters = Undefined) Export
	
	If PlanningParameters = Undefined Then
		PlanningParameters = AccessUpdatePlanningParameters();
	EndIf;
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Not PlanningParameters.DataAccessKeys
	   AND Not PlanningParameters.AllowedAccessKeys Then
		
		Return;
	EndIf;
	
	RegistersIDs   = New Array;
	AllowedItemsIDs = New Array;
	
	If Lists = Undefined Then
		ClearAccessGroupsValuesCacheToCalculateRights();
		
		If PlanningParameters.ListsRestrictionsVersions = Undefined Then
			ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined);
			ListsRestrictionsVersions = New Map(ActiveParameters.ListsRestrictionsVersions);
		Else
			ListsRestrictionsVersions = PlanningParameters.ListsRestrictionsVersions;
		EndIf;
		Query = New Query;
		Query.Text =
		"SELECT DISTINCT
		|	VALUETYPE(DataAccessKeys.Object) AS RefType
		|FROM
		|	InformationRegister.AccessKeysForObjects AS DataAccessKeys
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT DISTINCT
		|	DataAccessKeys.Register AS Register
		|FROM
		|	InformationRegister.AccessKeysForRegisters AS DataAccessKeys
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT DISTINCT
		|	AccessKeys.List AS List
		|FROM
		|	Catalog.AccessKeys AS AccessKeys
		|WHERE
		|	(TRUE IN
		|				(SELECT TOP 1
		|					TRUE
		|				FROM
		|					InformationRegister.AccessGroupsAccessKeys AS AllowedAccessKeys
		|				WHERE
		|					AllowedAccessKeys.AccessKey = AccessKeys.Ref)
		|			OR TRUE IN
		|				(SELECT TOP 1
		|					TRUE
		|				FROM
		|					InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
		|				WHERE
		|					AllowedAccessKeys.AccessKey = AccessKeys.Ref)
		|			OR TRUE IN
		|				(SELECT TOP 1
		|					TRUE
		|				FROM
		|					InformationRegister.UsersAccessKeys AS AllowedAccessKeys
		|				WHERE
		|					AllowedAccessKeys.AccessKey = AccessKeys.Ref)
		|			OR TRUE IN
		|				(SELECT TOP 1
		|					TRUE
		|				FROM
		|					InformationRegister.ExternalUsersAccessKeys AS AllowedAccessKeys
		|				WHERE
		|					AllowedAccessKeys.AccessKey = AccessKeys.Ref))";
		QueryResults = Query.ExecuteBatch();
		
		Selection = QueryResults[0].Select();
		While Selection.Next() Do
			If TypeOf(Selection.RefType) <> Type("Type") Then
				Continue;
			EndIf;
			MetadataObject = Metadata.FindByType(Selection.RefType);
			If MetadataObject = Undefined Then
				Continue;
			EndIf;
			ListsRestrictionsVersions.Insert(MetadataObject.FullName(), True);
		EndDo;
		ListsRestrictionsVersions.Insert("Catalog.AccessGroupsSets", True);
		
		Lists = New Array;
		For Each KeyAndValue In ListsRestrictionsVersions Do
			Lists.Add(KeyAndValue.Key);
		EndDo;
		
		RegistersIDs   = QueryResults[1].Unload().UnloadColumn("Register");
		AllowedItemsIDs = QueryResults[2].Unload().UnloadColumn("List");
		// The following items are added when planning full update:
		// a) lists with a restriction b) lists that write access keys for restrictions by the owner field 
		// c) lists without restrictions, for which there are records in registers of access keys to data d) 
		// lists, for which allowed access keys are calculated e) lists without calculating allowed access 
		// keys, for which there are records in registers of allowed access keys.
		// 
		//    
		
	ElsIf TypeOf(Lists) <> Type("Array") Then
		Lists = CommonClientServer.ValueInArray(Lists);
	EndIf;
	
	If Lists.Count() = 0 Then
		Return;
	EndIf;
	
	If TypeOf(Lists[0]) = Type("String") Then
		IDs = Common.MetadataObjectIDs(Lists);
		
		If Not ValueIsFilled(RegistersIDs)
		   AND Not ValueIsFilled(AllowedItemsIDs) Then
			
			ListsIDs = IDs;
		Else
			ListsIDs = New Map;
			For Each IDDetails In IDs Do
				ListsIDs.Insert(IDDetails.Value, IDDetails.Value);
			EndDo;
		EndIf;
	Else
		ListsIDs = New Map;
		For Each ID In Lists Do
			ListsIDs.Insert(ID, ID);
		EndDo;
	EndIf;
	
	If ValueIsFilled(RegistersIDs)
	 Or ValueIsFilled(AllowedItemsIDs) Then
		
		For Each RegisterID In RegistersIDs Do
			ListsIDs.Insert(RegisterID, RegisterID);
		EndDo;
		For Each AllowedItemsID In AllowedItemsIDs Do
			ListsIDs.Insert(AllowedItemsID, AllowedItemsID);
		EndDo;
	EndIf;
	
	AccessGroupsSetsCatalogID =
		Common.MetadataObjectID("Catalog.AccessGroupsSets");
	
	CurrentSessionDate = CurrentSessionDate();
	RecordsUniqueKey = New UUID;
	MaxDate = MaxDate();
	
	DataAccessKeysUpdate       = ServiceRecordSet(InformationRegisters.DataAccessKeysUpdate);
	UsersAccessKeysUpdate = ServiceRecordSet(InformationRegisters.UsersAccessKeysUpdate);
	
	For Each IDDetails In ListsIDs Do
		ListID = IDDetails.Value;
		
		If PlanningParameters.DataAccessKeys Then
			If PlanningParameters.ForUsers Then
				NewRecord = DataAccessKeysUpdate.Add();
				NewRecord.UniqueKey = RecordsUniqueKey;
				NewRecord.List = ListID;
				NewRecord.LatestUpdatedItemDate = MaxDate;
				NewRecord.RegisterRecordChangeDate = CurrentSessionDate;
			EndIf;
			If PlanningParameters.ForExternalUsers Then
				NewRecord = DataAccessKeysUpdate.Add();
				NewRecord.UniqueKey = RecordsUniqueKey;
				NewRecord.List = ListID;
				NewRecord.ForExternalUsers = True;
				NewRecord.LatestUpdatedItemDate = MaxDate;
				NewRecord.RegisterRecordChangeDate = CurrentSessionDate;
			EndIf;
		EndIf;
		
		If IDDetails.Key = AccessGroupsSetsCatalogID Then
			Continue;
		EndIf;
		
		If PlanningParameters.AllowedAccessKeys Then
			If PlanningParameters.ForUsers Then
				NewRecord = UsersAccessKeysUpdate.Add();
				NewRecord.UniqueKey = RecordsUniqueKey;
				NewRecord.List = ListID;
				NewRecord.RegisterRecordChangeDate = CurrentSessionDate;
			EndIf;
			If PlanningParameters.ForExternalUsers Then
				NewRecord = UsersAccessKeysUpdate.Add();
				NewRecord.UniqueKey = RecordsUniqueKey;
				NewRecord.List = ListID;
				NewRecord.ForExternalUsers = True;
				NewRecord.RegisterRecordChangeDate = CurrentSessionDate;
			EndIf;
		EndIf;
	EndDo;
	
	If DataAccessKeysUpdate.Count() > 0 Then
		DataAccessKeysUpdate.Write(False);
	EndIf;
	
	If UsersAccessKeysUpdate.Count() > 0 Then
		UsersAccessKeysUpdate.Write(False);
	EndIf;
	
	If DataAccessKeysUpdate.Count() > 0
	 Or UsersAccessKeysUpdate.Count() > 0 Then
		
		SetAccessUpdate(True);
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// The constructor of additional parameter structure for the ScheduleAccessUpdate procedure.
//
// Returns:
//  Structure - with the following properties:
//    * DataAccessKeys - Boolean - True by default - schedule update of data access keys.
//                                  
//    * AllowedAccessKeys - Boolean - True by default - schedule update of access keys for users and 
//                                  access groups.
//    * ForUsers - Boolean - True by default - schedule an update for users.
//    * ForExternalUsers - Boolean - the default value of the EnableExternalUsers constant is 
//                                         schedule an update for external users.
//
Function AccessUpdatePlanningParameters() Export
	
	Result = New Structure;
	Result.Insert("DataAccessKeys", True);
	Result.Insert("AllowedAccessKeys", True);
	Result.Insert("ForUsers", True);
	Result.Insert("ForExternalUsers", Constants.UseExternalUsers.Get());
	Result.Insert("ListsRestrictionsVersions", Undefined);
	
	Return Result;
	
EndFunction

// Starts access update if it is scheduled and not started yet.
Procedure StartAccessUpdate() Export
	
	If Not LimitAccessAtRecordLevelUniversally(False) Then
		Return;
	EndIf;
	
	StartAccessUpdateAtRecordLevel();
	
EndProcedure

#EndRegion

////////////////////////////////////////////////////////////////////////////////
// Configuration subsystems event handlers.

// See BatchObjectModificationOverridable.OnDetermineObjectsWithEditableAttributes. 
Procedure OnDefineObjectsWithEditableAttributes(Objects) Export
	Objects.Insert(Metadata.Catalogs.AccessGroups.FullName(), "AttributesToSkipInBatchProcessing");
	Objects.Insert(Metadata.Catalogs.AccessGroupProfiles.FullName(), "AttributesToSkipInBatchProcessing");
EndProcedure

// See CommonOverridable.OnAddSessionParametersSettingHandlers. 
Procedure OnAddSessionParameterSettingHandlers(Handlers) Export
	
	Handlers.Insert("AccessRestrictionAtRecordLevelEnabled",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AccessKinds*",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllAccessKindsExceptSpecialOnes",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("TablesWithIndividualRightsSettings",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AccessValuesTypesWithGroups",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("RightsSettingsOwnersTypes",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("IDsOfTablesWithIndividualRightsSettings",
		"AccessManagementInternal.SessionParametersSetting");
	
	#Region UniversalRestriction
	
	Handlers.Insert("RecordLevelAccessRestrictionIsUniversal",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("DIsableAccessKeysUpdate",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AccessRestrictionTemplatesVersions",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllowedAccessGroupsSet",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllowedBlankAccessGroupsSet",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllowedUserGroupsSet",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllowedUser",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("ListsWithRestrictionByFields",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("ListWithRestrictionUsingAccessKeys*",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("ListsWithReadRestrictionDisabled",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AccessRestrictionParameters",
		"AccessManagementInternal.SessionParametersSetting");
	
	#EndRegion
	
EndProcedure

// See ScheduledJobsOverridable.OnDefineScheduledJobSettings. 
Procedure OnDefineScheduledJobSettings(Dependencies) Export
	
	Dependence = Dependencies.Add();
	Dependence.ScheduledJob = Metadata.ScheduledJobs.DataFillingForAccessRestriction;
	Dependence.FunctionalOption = Metadata.FunctionalOptions.LimitAccessAtRecordLevel;
	
	Dependence = Dependencies.Add();
	Dependence.DependenceByT = True;
	Dependence.ScheduledJob = Metadata.ScheduledJobs.AccessUpdateAtRecordLevel;
	Dependence.FunctionalOption = Metadata.FunctionalOptions.LimitAccessAtRecordLevelUniversally;
	
	Dependence = Dependencies.Add();
	Dependence.DependenceByT = True;
	Dependence.ScheduledJob = Metadata.ScheduledJobs.AccessUpdateAtRecordLevel;
	Dependence.FunctionalOption = Metadata.FunctionalOptions.LimitAccessAtRecordLevel;
	
EndProcedure

// Updates auxiliary data that depends only on configuration.
// Writes changes of this data (if any) by configuration versions to use these changes upon updating 
// other auxiliary data, for example, in the UpdateAuxiliaryDataByConfigurationChanges handler.
// 
//
Procedure UpdateAccessRestrictionParameters(HasChanges = Undefined) Export
	
	InformationRegisters.RolesRights.UpdateRegisterData(HasChanges);
	
	InformationRegisters.AccessRightsDependencies.UpdateRegisterData(HasChanges);
	
	UpdateAccessKindsPropertiesDetails(HasChanges);
	
	Catalogs.AccessGroupProfiles.UpdateSuppliedProfilesDescription(HasChanges);
	
	Catalogs.AccessGroupProfiles.UpdatePredefinedProfileComposition(HasChanges);
	
	InformationRegisters.ObjectsRightsSettings.UpdateAvailableRightsForObjectsRightsSettings(HasChanges);
	
EndProcedure

// Updates description of access kind properties in the application parameters.
// 
// Parameters:
//  HasChanges - Boolean - (return value) - if recorded, True is set, otherwise, it does not change.
//                  
//
Procedure UpdateAccessKindsPropertiesDetails(HasChanges = False) Export
	
	SetPrivilegedMode(True);
	
	AccessKindsProperties = AccessKindsProperties();
	
	BeginTransaction();
	Try
		HasCurrentChanges = False;
		PreviousValue = Undefined;
		
		StandardSubsystemsServer.UpdateApplicationParameter(
			"StandardSubsystems.AccessManagement.AccessKindsProperties",
			AccessKindsProperties, HasCurrentChanges, PreviousValue);
		
		HasChangesOfGroupsTypesAndAccessValues = HasCurrentChanges
			AND HasChangesOfGroupsTypesAndAccessValues(AccessKindsProperties, PreviousValue);
		
		StandardSubsystemsServer.AddApplicationParameterChanges(
			"StandardSubsystems.AccessManagement.GroupAndAccessValueTypes",
			?(HasChangesOfGroupsTypesAndAccessValues,
			  New FixedStructure("HasChanges", True),
			  New FixedStructure()) );
		
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If HasCurrentChanges Then
		HasChanges = True;
	EndIf;
	
EndProcedure

// See InfobaseUpdateSSL.OnAddUpdateHandlers. 
Procedure OnAddUpdateHandlers(Handlers) Export
	
	// Shared data update handlers.
	Handler = Handlers.Add();
	Handler.SharedData = True;
	Handler.HandlerManagement = True;
	Handler.Priority = 1;
	Handler.Version = "*";
	Handler.ExecutionMode = "Seamless";
	Handler.Procedure = "AccessManagementInternal.FillSeparatedDataHandlers";
	
	// Separated data update handlers.
	Handler = Handlers.Add();
	Handler.Version = "*";
	Handler.ExecutionMode = "Seamless";
	Handler.Procedure = "AccessManagementInternal.UpdateAuxiliaryRegisterDataByConfigurationChanges";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.2.8";
	Handler.Procedure = "InformationRegisters.DeleteRightsByAccessValues.MoveDataToNewRegister";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.2.8";
	Handler.Procedure = "AccessManagementInternal.ConvertRoleNamesToIDs";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.2.8";
	Handler.Procedure = "InformationRegisters.AccessValuesGroups.UpdateUsersGroupings";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.2.16";
	Handler.Procedure = "InformationRegisters.AccessGroupsTables.UpdateRegisterData";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.2.16";
	Handler.Procedure = "AccessManagement.UpdateUserRoles";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.3.5";
	Handler.Procedure = "InformationRegisters.AccessValuesGroups.UpdateUsersGroupings";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.4.15";
	Handler.Procedure = "Catalogs.AccessGroupProfiles.FillSuppliedDataIDs";
	Handler.ExecuteInMandatoryGroup = True;
	Handler.Priority = 1;
	
	// Executed after the FillSuppliedDataIDs handler.
	Handler = Handlers.Add();
	Handler.Version = "1.0.0.1";
	Handler.InitialFilling = True;
	Handler.Procedure = "Catalogs.AccessGroups.FillAdministratorsAccessGroupProfile";
	Handler.ExecutionMode = "Exclusive";
	Handler.ExecuteInMandatoryGroup = True;
	Handler.Priority = 1;
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "Catalogs.AccessGroupProfiles.ConvertAccessKindsIDs";
	Handler.ExecutionMode = "Exclusive";
	Handler.ExecuteInMandatoryGroup = True;
	Handler.Priority = 1;
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "InformationRegisters.AccessValuesGroups.UpdateUsersGroupings";
	Handler.ExecutionMode = "Exclusive";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "InformationRegisters.AccessGroupsValues.UpdateRegisterData";
	Handler.ExecutionMode = "Exclusive";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "InformationRegisters.DeleteAccessValuesGroups.MoveDataToNewRegister";
	Handler.ExecutionMode = "Exclusive";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "InformationRegisters.ObjectRightsSettingsInheritance.UpdateRegisterData";
	Handler.ExecutionMode = "Exclusive";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "InformationRegisters.ObjectsRightsSettings.UpdateAuxiliaryRegisterData";
	Handler.ExecutionMode = "Exclusive";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "AccessManagementInternal.EnableDataFillingForAccessRestriction";
	Handler.ExecutionMode = "Exclusive";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.35";
	Handler.Procedure = "InformationRegisters.AccessValuesGroups.UpdateEmptyAccessValueGroups";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.3.27";
	Handler.Procedure = "InformationRegisters.AccessGroupsValues.UpdateRegisterData";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.5.4";
	Handler.Procedure = "InformationRegisters.DeleteAccessValuesGroups.ClearRegister";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.5.7";
	Handler.Procedure = "AccessManagement.UpdateUserRoles";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.3.1.61";
	Handler.Procedure = "AccessManagementInternal.FillAccessGroupsProfilesAssignment";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.3.1.55";
	Handler.Procedure = "AccessManagementInternal.ReplaceDeletedRolesInAccessGroupProfiles";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.3.2.23";
	Handler.Procedure = "InformationRegisters.AccessGroupsValues.UpdateRegisterData";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.4.1.1";
	Handler.Procedure = "AccessManagementInternal.UpdateProfileDataOpenExternalReportsAndDataProcessors";
	Handler.ExecutionMode = "Seamless";
	Handler.ExecuteInMandatoryGroup = True;
	Handler.Priority = 1;
	
	Handler = Handlers.Add();
	Handler.Version = "3.0.1.196";
	Handler.Procedure = "Catalogs.AccessGroups.ProcessDataForMigrationToNewVersion";
	Handler.ExecutionMode = "Deferred";
	Handler.RunAlsoInSubordinateDIBNodeWithFilters = True;
	Handler.Comment = NStr("ru = 'Устраняет некорректное скрытие данных в некоторых списках при включенном ограничении на уровне записей.'; en = 'Eliminates incorrect data hiding in some lists with enabled restriction at the record level.'; pl = 'Eliminuje niepoprawne ukrywanie danych na niektórych listach, gdy włączone jest ograniczenie na poziomie zapisów.';es_ES = 'Remueve oculto incorrecto de datos en algunas listas con la restricción activada en nivel de registros.';es_CO = 'Remueve oculto incorrecto de datos en algunas listas con la restricción activada en nivel de registros.';tr = 'Kayıt düzeyi kısıtlaması etkinleştirildiğinde bazı listelerde verilerin yanlış gizlenmesini giderir.';it = 'Elimina i dati errati nascosti in alcuni elenchi con restrizione attivata a livello di registrazione.';de = 'Beseitigt das Verbergen falscher Daten in einigen Listen, wenn die Beschränkung der Datensatzebene aktiviert ist.'");
	Handler.ID = New UUID("b73c2481-f789-4b2d-b705-8219aea0e75d");
	Handler.CheckProcedure = "InfobaseUpdate.DataProcessingCompleted";
	Handler.UpdateDataFillingProcedure = "Catalogs.AccessGroups.RegisterDataToProcessForMigrationToNewVersion";
	Handler.DeferredProcessingQueue = 1;
	Handler.ObjectsToRead = "Catalog.AccessGroups";
	Handler.ObjectsToChange = "InformationRegister.AccessGroupsTables,InformationRegister.AccessGroupsValues,InformationRegister.DefaultAccessGroupsValues";
	
	If Not Common.SeparatedDataUsageAvailable()
	 Or LimitAccessAtRecordLevelUniversally(True) Then
		
		Handler = Handlers.Add();
		Handler.Version = "3.0.1.295";
		Handler.Procedure = "InformationRegisters.AccessRestrictionParameters.ProcessDataForMigrationToNewVersion1";
		Handler.ExecutionMode = "Deferred";
		Handler.RunAlsoInSubordinateDIBNodeWithFilters = True;
		Handler.Comment = NStr("ru = 'Планирование частичного обновления доступа по изменениям программы.'; en = 'Planning partial access update by application changes.'; pl = 'Planowanie częściowej aktualizacji dostępu przez zmiany programu.';es_ES = 'Planificación de actualización parcial de acceso por cambios del programa.';es_CO = 'Planificación de actualización parcial de acceso por cambios del programa.';tr = 'Program değişiklikleri için kısmi erişim güncellemesini planlama.';it = 'Pianificazione aggiornamento di accesso parziale in base alle modifiche all''applicazione.';de = 'Planung von teilweisen Aktualisierungen bei Programmänderungen.'");
		Handler.ID = New UUID("2721d667-858d-48ed-8736-f7ece8218697");
		Handler.UpdateDataFillingProcedure = "InformationRegisters.AccessRestrictionParameters.RegisterDataToProcessForMigrationToNewVersion1";
		Handler.DeferredProcessingQueue = 1;
		Handler.ObjectsToRead = "InformationRegister.AccessRestrictionParameters";
		Handler.ObjectsToChange = "InformationRegister.AccessRestrictionParameters";
	EndIf;
	
	Handler = Handlers.Add();
	Handler.Version = "3.0.1.330";
	Handler.Procedure = "InformationRegisters.AccessValuesGroups.ProcessDataForMigrationToNewVersion";
	Handler.ExecutionMode = "Deferred";
	Handler.Comment = NStr("ru = 'Обновление данных по изменениям программы.'; en = 'Data update by application changes.'; pl = 'Aktualizacja danych dotyczących zmian programu.';es_ES = 'Actualización de datos por cambios del programa.';es_CO = 'Actualización de datos por cambios del programa.';tr = 'Program değişiklik verilerini güncelleme.';it = 'Aggiornamento dati per modifiche all''applicazione.';de = 'Aktualisierung der Daten bei Programmänderungen.'");
	Handler.ID = New UUID("b3cb643e-d5cf-40b7-9db3-6315a88c063d");
	Handler.UpdateDataFillingProcedure = "InformationRegisters.AccessValuesGroups.RegisterDataToProcessForMigrationToNewVersion";
	Handler.DeferredProcessingQueue = 1;
	Handler.ObjectsToRead = "InformationRegister.AccessValuesGroups";
	Handler.ObjectsToChange = "InformationRegister.AccessValuesGroups";
	
EndProcedure

// See InfobaseUpdateSSL.AfterUpdateInfobase. 
Procedure AfterUpdateInfobase(Val PreviousVersion, Val CurrentVersion,
		Val CompletedHandlers, OutputUpdateDetails, ExclusiveMode) Export
	
	UpdateAuxiliaryDataOfItemsChangedOnImport();
	
	If Common.SeparatedDataUsageAvailable() Then
		SetAccessUpdate(True, True);
	EndIf;
	
EndProcedure

// Fills parameter structures required by the application client code.
// 
//
// Parameters:
//   Parameters - Structure - a parameter structure.
//
Procedure OnAddClientParameters(Parameters) Export
	
	Parameters.Insert("SimplifiedAccessRightsSetupInterface",
		SimplifiedAccessRightsSetupInterface());
	
EndProcedure

// See CommonOverridable.OnAddRefsSearchExceptions. 
Procedure OnAddReferenceSearchExceptions(Array) Export
	
	Array.Add(Metadata.InformationRegisters.AccessValuesGroups);
	Array.Add(Metadata.InformationRegisters.AccessRightsDependencies);
	Array.Add(Metadata.InformationRegisters.AccessGroupsValues);
	Array.Add(Metadata.InformationRegisters.DefaultAccessGroupsValues);
	Array.Add(Metadata.InformationRegisters.AccessValuesSets);
	Array.Add(Metadata.InformationRegisters.RolesRights);
	Array.Add(Metadata.InformationRegisters.ObjectRightsSettingsInheritance);
	Array.Add(Metadata.InformationRegisters.ObjectsRightsSettings);
	Array.Add(Metadata.InformationRegisters.AccessGroupsTables);
	
	OnAddRefsSearchExceptionsThatAllowDeletion(Array);
	
EndProcedure

// Objects with deferred deletion.
Procedure OnAddRefsSearchExceptionsThatAllowDeletion(Array) Export
	
	Array.Add(Metadata.Catalogs.AccessKeys);
	Array.Add(Metadata.Catalogs.AccessGroupsSets);
	Array.Add(Metadata.InformationRegisters.ExternalUsersAccessKeys);
	Array.Add(Metadata.InformationRegisters.AccessGroupsAccessKeys);
	Array.Add(Metadata.InformationRegisters.AccessGroupSetsAccessKeys);
	Array.Add(Metadata.InformationRegisters.AccessKeysForObjects);
	Array.Add(Metadata.InformationRegisters.AccessKeysForRegisters);
	Array.Add(Metadata.InformationRegisters.UsersAccessKeys);
	Array.Add(Metadata.InformationRegisters.DataAccessKeysUpdate);
	Array.Add(Metadata.InformationRegisters.UsersAccessKeysUpdate);
	Array.Add(Metadata.InformationRegisters.AccessRestrictionParameters);
	
	For Each InformationRegister In Metadata.InformationRegisters Do 
		If StrStartsWith(Upper(InformationRegister.Name), Upper("AccessKeysToRegister")) Then 
			Array.Add(InformationRegister);
		EndIf;
	EndDo;
	
EndProcedure

// This procedure is called when importing predefined item references while importing important data.
// Allows correcting or registering information on non-unique predefined items. Also allows you to 
// cancel further actions if the uniqueness issue cannot be solved.
//
// Parameters:
//   Object - CatalogObject, ChartOfCharacteristicTypesObject, ChartOfAccountsObject, 
//                     ChartOfCalculationTypesObject - a predefined item object whose recording resulted in uniqueness conflict.
//   WriteToLog - Boolean - a return value. Set to False not to add the uniqueness conflict details 
//                     to the event log in a common message.
//                     Set to False if the uniqueness conflict was resolved automatically.
//   Cancel - Boolean - a return value. Set to True to raise an exception with cancellation details.
//                     
//   CancelDetails - String - a return value. If Cancel is set to True, the description is added to 
//                     the list of the reasons preventing from further actions.
//
Procedure OnFindNotUniquePredefinedItem(Object, WriteToLog, Cancel, CancelDetails) Export
	
	If TypeOf(Object) = Type("CatalogObject.AccessGroupProfiles")
	   AND Object.PredefinedDataName = "Administrator" Then
		
		WriteToLog = False;
		
		Query = New Query;
		Query.SetParameter("Ref", Object.Ref);
		Query.SetParameter("PredefinedDataName", "Administrator");
		Query.Text =
		"SELECT
		|	AccessGroupProfiles.Ref AS Ref
		|FROM
		|	Catalog.AccessGroupProfiles AS AccessGroupProfiles
		|WHERE
		|	AccessGroupProfiles.Ref <> &Ref
		|	AND AccessGroupProfiles.PredefinedDataName = &PredefinedDataName";
		
		Selection = Query.Execute().Select();
		While Selection.Next() Do
			CurrentObject = Selection.Ref.GetObject();
			CurrentObject.PredefinedDataName = "";
			CurrentObject.SuppliedDataID = "";
			InfobaseUpdate.WriteData(CurrentObject);
		EndDo;
		
	ElsIf TypeOf(Object) = Type("CatalogObject.AccessGroups")
	        AND Object.PredefinedDataName = "Administrators" Then
		
		WriteToLog = False;
		
		Query = New Query;
		Query.SetParameter("PredefinedDataName", "Administrators");
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupsUsers.User
		|FROM
		|	Catalog.AccessGroups.Users AS AccessGroupsUsers
		|WHERE
		|	AccessGroupsUsers.Ref.PredefinedDataName = &PredefinedDataName";
		AllUsers = Query.Execute().Unload().UnloadColumn("User");
		
		Write = False;
		For each User In AllUsers Do
			If Object.Users.Find(User, "User") = Undefined Then
				Object.Users.Add().User = User;
				Write = True;
			EndIf;
		EndDo;
		
		If Write Then
			InfobaseUpdate.WriteData(Object);
		EndIf;
		
		Query.SetParameter("Ref", Object.Ref);
		Query.Text =
		"SELECT
		|	AccessGroups.Ref AS Ref
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Ref <> &Ref
		|	AND AccessGroups.PredefinedDataName = &PredefinedDataName";
		
		Selection = Query.Execute().Select();
		While Selection.Next() Do
			CurrentObject = Selection.Ref.GetObject();
			CurrentObject.PredefinedDataName = "";
			InfobaseUpdate.WriteData(CurrentObject);
		EndDo;
	EndIf;
	
EndProcedure

// See DataExchangeOverridable.OnSetUpSubordinateDIBNode. 
Procedure OnSetUpSubordinateDIBNode() Export
	
	// Extension roles are assigned independently in all DIB nodes.
	Catalogs.AccessGroupProfiles.DeleteExtensionsRolesInAllAccessGroupsProfiles();
	
	// Administrators are assigned independently in all DIB nodes.
	Catalogs.AccessGroups.DeleteMembersOfAdministratorsAccessGroupWithoutIBUser();
	
	If Common.IsStandaloneWorkplace() Then
		Catalogs.AccessGroupProfiles.UpdateSuppliedProfilesByConfigurationChanges();
	EndIf;
	
	If LimitAccessAtRecordLevelUniversally()
	   AND Common.IsSubordinateDIBNodeWithFilter() Then
		
		ScheduleAccessUpdate();
	EndIf;
	
EndProcedure

// See StandardSubsystemsServer.OnSendDataToMaster. 
Procedure OnSendDataToMaster(DataItem, ItemSend, Recipient) Export
	
	If AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataItem)
	 Or AccessManagementSubsystemObjectNameStartsWithDelete(DataItem) Then
		
		ItemSend = DataItemSend.Ignore;
		Return;
	EndIf;
	
	// Profile and access group of opening external reports and data processors are unavailable in the 
	// service, but available in an offline workplace.
	If Common.IsStandaloneWorkplace()
	   AND (    TypeOf(DataItem) = Type("CatalogObject.AccessGroupProfiles")
	        AND IsProfileOpenExternalReportsAndDataProcessors(DataItem)
	      Or TypeOf(DataItem) = Type("CatalogObject.AccessGroups")
	        AND Not DataItem.IsFolder
	        AND IsProfileOpenExternalReportsAndDataProcessors(DataItem.Profile) ) Then
		
		ItemSend = DataItemSend.Ignore;
	EndIf;
	
	// Extension roles are assigned independently in all DIB nodes.
	If TypeOf(DataItem) = Type("CatalogObject.AccessGroupProfiles") Then
		Catalogs.AccessGroupProfiles.DeleteExtensionsRoles(DataItem);
	EndIf;
	
EndProcedure

// See StandardSubsystemsServer.OnSendDataToSlave. 
Procedure OnSendDataToSlave(DataItem, ItemSend, InitialImageCreation, Recipient) Export
	
	// Extension roles are assigned independently in all DIB nodes.
	// Partially changing of objects when creating the initial image is not supported, see the deletion 
	// of extension roles in the OnSetUpSubordinateDIBNode procedure.
	
	// Administrators are assigned independently in all DIB nodes.
	// Partially changing of objects when creating the initial image is not supported, see clearing of 
	// administrators in the OnSetUpSubordinateDIBNode procedure.
	
	If InitialImageCreation Then
		Return;
	EndIf;
	
	If AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataItem)
	 Or AccessManagementSubsystemObjectNameStartsWithDelete(DataItem) Then
		
		ItemSend = DataItemSend.Ignore;
		Return;
	EndIf;
	
EndProcedure

// See StandardSubsystemsServer.OnReceiveDataFromMaster. 
Procedure OnReceiveDataFromMaster(DataItem, GetItem, SendBack, Sender) Export
	
	// Standard data processor cannot be overridden.
	If GetItem = DataItemReceive.Ignore Then
		Return;
	EndIf;
	
	If AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataItem)
	 Or AccessManagementSubsystemObjectNameStartsWithDelete(DataItem) Then
		
		GetItem = DataItemReceive.Ignore;
		Return;
	EndIf;
	
	OnReceiveDataFromMasterOrSlave(DataItem);
	
EndProcedure

// See StandardSubsystemsServer.OnReceiveDataFromSlave. 
Procedure OnReceiveDataFromSlave(DataItem, GetItem, SendBack, Sender) Export
	
	// Standard data processor cannot be overridden.
	If GetItem = DataItemReceive.Ignore Then
		Return;
	EndIf;
	
	If AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataItem)
	 Or AccessManagementSubsystemObjectNameStartsWithDelete(DataItem) Then
		
		GetItem = DataItemReceive.Ignore;
		Return;
	EndIf;
	
	If Not Common.DataSeparationEnabled() Then
		OnReceiveDataFromMasterOrSlave(DataItem);
		
	ElsIf TypeOf(DataItem) = Type("ConstantValueManager.LimitAccessAtRecordLevel")
	      Or TypeOf(DataItem) = Type("CatalogObject.AccessGroups")
	      Or TypeOf(DataItem) = Type("CatalogObject.AccessGroupProfiles")
	      Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessValuesGroups")
	      Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessValuesSets")
	      Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.ObjectRightsSettingsInheritance")
	      Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.ObjectsRightsSettings") Then
		
		// Getting data from a standalone workplace is skipped. Data is sent back to the standalone 
		// workplace to establish data mapping between the nodes.
		GetItem = DataItemReceive.Ignore;
		SendBack = True;
	EndIf;
	
EndProcedure

// See StandardSubsystemsServer.AfterGetData. 
Procedure AfterGetData(Sender, Cancel, GetFromMasterNode) Export
	
	If InfobaseUpdate.InfobaseUpdateInProgress() Then
		Return;
	EndIf;
	
	UpdateAuxiliaryDataOfItemsChangedOnImport();
	
EndProcedure

// See description in the FillAllExtensionsParameters procedure of the ExtensionsVersionsParameters 
// information register manager module.
//
Procedure OnFillAllExtensionsParameters() Export
	
	UpdateAccessGroupsTablesForEnabledExtensions();
	
EndProcedure

Procedure AfterChangeSettingsRightsOwnerInForm() Export
	
	AfterChangeRightsSettingsInForm();
	
EndProcedure

// Event handlers of the Users subsystem.

// See UsersOverridable.OnDefineSettings. 
Procedure OnDefineSettings(Settings) Export
	
	// Roles are set automatically by linking access group data this way: AccessGroupUsers -> Profile -> 
	// ProfileRoles.
	Settings.EditRoles = False;
	
EndProcedure

// See UsersOverridable.OnDefineActionsInForm. 
Procedure OnDefineActionsInForm(Ref, FormActions) Export
	
	FormActions.Roles = "";
	
EndProcedure

// See SSLSubsystemsIntegration.AfterWriteAdministratorOnAuthorization. 
Procedure AfterWriteAdministratorOnAuthorization(Comment) Export
	
	Comment =
		NStr("ru = 'Выполнен запуск от имени пользователя с ролью ""Полные права"",
		           |который не зарегистрирован в списке пользователей.
		           |Выполнена автоматическая регистрация в списке пользователей.
		           |Пользователь добавлен в группу доступа Администраторы.
		           |
		           |Для ведения списка и настройки прав пользователей предназначен список Пользователи,
		           |режим конфигурирования 1С:Предприятия для этого использовать не следует.'; 
		           |en = 'Launch under user with the ""Full rights"" role
		           |not registered in the user list is performed.
		           |Automatic registration in the user list is performed.
		           |The user is added to the Administrators access group.
		           |
		           |Use the Users list to manage the list and assign user rights,
		           |do not use 1C: Enterprise configuration mode for that.'; 
		           |pl = 'Uruchomiony w imieniu użytkownika z rolą ""Pełne prawa"",
		           |który nie jest zarejestrowany na liście użytkowników.
		           |Wykonana jest automatyczna rejestracja na liście użytkowników.
		           |Użytkownik dodany do grupy dostępu Administratorzy.
		           |
		           |Do prowadzenia listy i ustawienia uprawnień użytkowników przeznaczona jest lista Użytkowników,
		           |tryb konfiguracji 1C:Enterprise do tego celu używać nie należy.';
		           |es_ES = 'Se ha realizado el inicio del nombre de usuario con el rol ""Derechos completos""
		           |que no está registrado en la lista de usuarios.
		           |Se ha realizado el registro automático en la lista de usuarios.
		           |El usuario se ha añadido en el grupo de acceso Administradores.
		           |
		           |Para llevar la lista y los ajustes de usuarios está destinada la lista Usuarios
		           |no hay que usar el modo de configurar de 1C:Enterprise para esto.';
		           |es_CO = 'Se ha realizado el inicio del nombre de usuario con el rol ""Derechos completos""
		           |que no está registrado en la lista de usuarios.
		           |Se ha realizado el registro automático en la lista de usuarios.
		           |El usuario se ha añadido en el grupo de acceso Administradores.
		           |
		           |Para llevar la lista y los ajustes de usuarios está destinada la lista Usuarios
		           |no hay que usar el modo de configurar de 1C:Enterprise para esto.';
		           |tr = 'Kullanıcı listesinde kayıtlı olmayan 
		           |""Tam haklar"" rolüyle kullanıcı adına başlar. 
		           |Kullanıcı listesinde otomatik kayıt yapılır. 
		           |Kullanıcı Yöneticiler erişim grubuna eklendi.
		           |
		           |Bir liste ve kullanıcı hakları ayarını korumak için, 
		           |Kullanıcılar listesini kullanın, 1C: İşletme yapılandırma modu kullanılmamalıdır.';
		           |it = 'Viene eseguito l''avvio tramite l''utente con ruolo ""Pieni diritti""
		           |non registrato nell''elenco utenti.
		           |Viene eseguita la registrazione automatica nell''elenco utenti.
		           |L''utente è aggiunto al gruppo di accesso Amministratori.
		           |
		           |Utilizzare l''Elenco utenti per gestire l''elenco e assegnare diritti agli utenti,
		           |non utilizzare la modalità configurazione di 1C: Enterprise a questo scopo.';
		           |de = 'Wurde als Benutzer mit der Rolle ""Volle Rechte"" gestartet,
		           |der nicht in der Liste der Benutzer registriert ist.
		           |Die automatische Registrierung in der Liste der Benutzer wird durchgeführt.
		           |Der Benutzer wird der Zugriffsgruppe Administratoren hinzugefügt.
		           |
		           |Die Benutzerliste ist für die Pflege der Liste und die Einrichtung der Rechte von Benutzern gedacht,
		           |der Modus der Konfiguration von 1C:Enterprise sollte zu diesem Zweck nicht verwendet werden.'");
	
EndProcedure

// See SSLSubsystemsIntegration.AfterSetIBUser. 
Procedure AfterSetIBUser(Ref, ServiceUserPassword) Export
	
	AccessManagement.UpdateUserRoles(Ref, ServiceUserPassword);
	
EndProcedure

// See SSLSubsystemsIntegration.OnDefineQuestionTextBeforeWriteFirstAdministrator. 
Procedure OnDefineQuestionTextBeforeWriteFirstAdministrator(QuestionText) Export
	
	QuestionText =
		NStr("ru = 'В список пользователей программы добавляется первый пользователь,
		           |поэтому он будет автоматически включен в группу доступа Администраторы. 
		           |Продолжить?'; 
		           |en = 'The first user is added to the application user list,
		           |the user will be automatically included in the Administrators access group.
		           |Continue?'; 
		           |pl = 'Do listy użytkowników programu zostanie dodany pierwszy użytkownik,
		           |dlatego zostanie on automatycznie włączony do grupy dostępu Administratorzy.
		           |Kontynuować?';
		           |es_ES = 'El primer usuario se ha añadido a la lista de usuarios del programa,
		           |por lo tanto se incluirá automáticamente en el grupo de acceso Administradores. 
		           |¿Continuar?';
		           |es_CO = 'El primer usuario se ha añadido a la lista de usuarios del programa,
		           |por lo tanto se incluirá automáticamente en el grupo de acceso Administradores. 
		           |¿Continuar?';
		           |tr = 'İlk kullanıcı, uygulamanın 
		           |kullanıcı listesine eklenir, bu yüzden otomatik olarak Yöneticiler erişim grubuna dahil edilir. 
		           |Devam etmek istiyor musunuz?';
		           |it = 'Il primo utente è stato aggiunto all''elenco utenti dell''applicazione,
		           |l''utente sarà automaticamente incluso nel gruppo di accesso Amministratori.
		           |Proseguire?';
		           |de = 'Der erste Benutzer wird der Liste der Benutzer des Programms hinzugefügt,
		           |so dass er automatisch in die Gruppe Administratoren aufgenommen wird.
		           |Fortsetzen?'")
	
EndProcedure

// See SSLSubsystemsIntegration.OnCreateAdministrator. 
Procedure OnCreateAdministrator(Administrator, Clarification) Export
	
	If TypeOf(Administrator) <> Type("CatalogRef.Users") Then
		Return;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("User", Administrator);
	Query.Text =
	"SELECT
	|	TRUE AS TrueValue
	|FROM
	|	Catalog.AccessGroups.Users AS AccessGroupsUsers
	|WHERE
	|	AccessGroupsUsers.Ref = VALUE(Catalog.AccessGroups.Administrators)
	|	AND AccessGroupsUsers.User = &User";
	
	If Not Query.Execute().IsEmpty() Then
		Return;
	EndIf;
	
	CommentForLog = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("ru = 'Пользователь ""%1"" добавлен в группу доступа Администраторы по причине:
		           |%2'; 
		           |en = 'User ""%1"" was added to the Administrators access group due to:
		           |%2'; 
		           |pl = 'Użytkownik ""%1"" dodany do grupy dostępu Administratorzy, z powodu:
		           |%2';
		           |es_ES = 'El usuario ""%1"" se ha añadido en el grupo de acceso Administradores a causa de:
		           |%2';
		           |es_CO = 'El usuario ""%1"" se ha añadido en el grupo de acceso Administradores a causa de:
		           |%2';
		           |tr = 'Kullanıcı ""%1"" aşağıdaki nedenle Yöneticiler erişim grubuna eklendi: 
		           |%2';
		           |it = 'L''utente ""%1"" è stato aggiunto al gruppo di accesso Amministratori a causa di:
		           |%2';
		           |de = 'Der Benutzer ""%1"" wird aus diesem Grund der Zugriffsgruppe Administratoren hinzugefügt:
		           |%2'"),
		Administrator,
		Clarification);
	
	Object = Catalogs.AccessGroups.Administrators.GetObject();
	
	BeginTransaction();
	Try
		LockDataForEdit(Object.Ref, Object.DataVersion);
		If Object.Users.Find(Administrator, "User") = Undefined Then
			Object.Users.Add().User = Administrator;
			InfobaseUpdate.WriteData(Object);
			WriteLogEvent(
				NStr("ru = 'Управление доступом.Автоматическое изменение группы доступа Администраторы'; en = 'Access management.Automatic change of Administrators access group'; pl = 'Kontrola dostępu.Automatyczna zmiana grupy dostępu Administratorzy';es_ES = 'Gestión de acceso.Cambio automático del grupo de acceso Administradores';es_CO = 'Gestión de acceso.Cambio automático del grupo de acceso Administradores';tr = 'Erişim kontrolü. Yöneticiler erişim grubunun otomatik değişmesi';it = 'Gestione degli accessi.Modifica automatica del gruppo di accesso Amministratori';de = 'Zugriffskontrolle. Automatische Änderung der Zugriffsgruppe Administratoren'",
				     CommonClientServer.DefaultLanguageCode()),
				EventLogLevel.Information,
				Metadata.Catalogs.Users,
				Administrator,
				CommentForLog,
				EventLogEntryTransactionMode.Transactional);
		EndIf;
		UnlockDataForEdit(Object.Ref);
		
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// See SSLSubsystemsIntegration.AfterAddChangeUserOrGroup. 
Procedure AfterAddChangeUserOrGroup(Ref, IsNew) Export
	
	If IsNew Then
		If TypeOf(Ref) = Type("CatalogRef.UserGroups")
		 OR TypeOf(Ref) = Type("CatalogRef.ExternalUsersGroups") Then
		
			Parameters = New Structure;
			Parameters.Insert("UserGroups", Ref);
			InformationRegisters.AccessValuesGroups.UpdateUsersGroupings(Parameters);
		EndIf;
	EndIf;
	
	If LimitAccessAtRecordLevelUniversally() Then
		ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers(
			CommonClientServer.ValueInArray(Ref));
	EndIf;
	
EndProcedure

// See SSLSubsystemsIntegration.AfterUserGroupsUpdate. 
Procedure AfterUserGroupsUpdate(ItemsToChange, ModifiedGroups) Export
	
	Parameters = New Structure;
	Parameters.Insert("Users",        ItemsToChange);
	Parameters.Insert("UserGroups", ModifiedGroups);
	
	InformationRegisters.AccessValuesGroups.UpdateUsersGroupings(Parameters);
	
	AccessManagement.UpdateUserRoles(ItemsToChange);
	
	If LimitAccessAtRecordLevelUniversally() Then
		ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers(ModifiedGroups);
	EndIf;
	
EndProcedure

// See SSLSubsystemsIntegration.AfterChangeUserOrGroupInForm. 
Procedure AfterChangeUserOrGroupInForm() Export
	
	AfterChangeRightsSettingsInForm();
	
EndProcedure

// See SSLSubsystemsIntegration.AfterChangeExternalUserAuthorizationObject. 
Procedure AfterChangeExternalUserAuthorizationObject(ExternalUser,
                                                               PreviousAuthorizationObject,
                                                               NewAuthorizationObject) Export
	
	AuthorizationObjects = New Array;
	If PreviousAuthorizationObject <> NULL Then
		AuthorizationObjects.Add(PreviousAuthorizationObject);
	EndIf;
	AuthorizationObjects.Add(NewAuthorizationObject);
	
	Parameters = New Structure;
	Parameters.Insert("AuthorizationObjects", AuthorizationObjects);
	
	InformationRegisters.AccessValuesGroups.UpdateUsersGroupings(Parameters);
	
EndProcedure

// Copies rights from one user to another.
Procedure OnCopyRightsToNewUser(Source, Destination) Export
	
	SimplifiedInterface = SimplifiedAccessRightsSetupInterface();
	Query = New Query;
	Query.SetParameter("User", Source);
	
	If SimplifiedInterface Then
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupsUsers.Ref.Profile AS Profile
		|FROM
		|	Catalog.AccessGroups.Users AS AccessGroupsUsers
		|WHERE
		|	(AccessGroupsUsers.User = &User
		|			OR AccessGroupsUsers.User IN
		|				(SELECT
		|					UserGroupCompositions.UsersGroup
		|				FROM
		|					InformationRegister.UserGroupCompositions AS UserGroupCompositions
		|				WHERE
		|					UserGroupCompositions.User = &User))";
	Else
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupsUsers.Ref AS AccessGroup
		|FROM
		|	Catalog.AccessGroups.Users AS AccessGroupsUsers
		|WHERE
		|	(AccessGroupsUsers.User = &User
		|			OR AccessGroupsUsers.User IN
		|				(SELECT
		|					UserGroupCompositions.UsersGroup
		|				FROM
		|					InformationRegister.UserGroupCompositions AS UserGroupCompositions
		|				WHERE
		|					UserGroupCompositions.User = &User))";
	EndIf;
	
	QueryResult = Query.Execute();
	If QueryResult.IsEmpty() Then
		Return;
	EndIf;
	
	Selection = QueryResult.Select();
	
	If Not SimplifiedInterface Then
		Lock = New DataLock();
		LockItem = Lock.Add("Catalog.AccessGroups");
		LockItem.DataSource = QueryResult;
	EndIf;
	
	BeginTransaction();
	Try
		If SimplifiedInterface Then
			While Selection.Next() Do
				AccessManagement.EnableProfileForUser(Destination, Selection.Profile);
			EndDo;
		Else
			Lock.Lock();
			While Selection.Next() Do
				AccessGroupObject = Selection.AccessGroup.GetObject();
				If AccessGroupObject.Users.Find(Destination, "User") = Undefined Then
					Row = AccessGroupObject.Users.Add();
					Row.User = Destination;
					AccessGroupObject.Write();
				EndIf;
			EndDo;
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// Event handlers of the ReportsOptions subsystem.

// See ReportsOptionsOverridable.CustomizeReportOptions. 
Procedure OnSetUpReportsOptions(Settings) Export
	ModuleReportsOptions = Common.CommonModule("ReportsOptions");
	ModuleReportsOptions.CustomizeReportInManagerModule(Settings, Metadata.Reports.AccessRights);
EndProcedure

// AccessManagement subsystem event handlers.

// See AccessManagementOverridable.OnFillListsWithAccessRestriction. 
Procedure OnFillListsWithAccessRestriction(Lists) Export
	
	Lists.Insert(Metadata.Catalogs.AccessGroupProfiles, True);
	Lists.Insert(Metadata.Catalogs.AccessGroups, True);
	
EndProcedure

// Events handlers of the SaaSTechnology library.

// See DataExportImportOverridable.OnFillCommonDataTypesThatDoNotRequireMappingRefsOnImport. 
Procedure OnFillCommonDataTypesThatDoNotRequireMappingRefsOnImport(Types) Export
	
	// In separated data, references are used only to predefined items of the DeleteAccessKinds chart of 
	// characteristic types.
	Types.Add(Metadata.ChartsOfCharacteristicTypes.DeleteAccessKinds);
	
EndProcedure

// See ExportImportDataOverridable.OnFillTypesExcludedFromExportImport. 
Procedure OnFillTypesExcludedFromExportImport(Types) Export
	
	Types.Add(Metadata.ChartsOfCharacteristicTypes.DeleteAccessKinds);
	
EndProcedure

// See DataExportImportOverridable.OnRegisterDataExportHandlers. 
Procedure OnRegisterDataExportHandlers(HandlersTable) Export
	ModuleDataExportImportInternalEvents = Common.CommonModule("ExportImportDataInternalEvents");
	
	Handler = HandlersTable.Add();
	Handler.MetadataObject = Metadata.Catalogs.AccessGroupProfiles;
	Handler.Handler = Catalogs.AccessGroupProfiles;
	Handler.BeforeExportObject = True;
	Handler.Version = ModuleDataExportImportInternalEvents.HandlersVersion1_0_0_1();
	
	Handler = HandlersTable.Add();
	Handler.MetadataObject = Metadata.Catalogs.AccessGroups;
	Handler.Handler = Catalogs.AccessGroups;
	Handler.BeforeExportObject = True;
	Handler.Version = ModuleDataExportImportInternalEvents.HandlersVersion1_0_0_1();
EndProcedure

#EndRegion

#Region Private

// See DataExportImportOverridable.OnRegisterDataExportHandlers. 
Procedure BeforeExportObject(Container, ObjectExportManager, Serializer, Object, Artifacts, Cancel) Export
	
	// Extension roles are assigned independently both in the box and in the service.
	If TypeOf(Object) = Type("CatalogObject.AccessGroupProfiles") Then
		Catalogs.AccessGroupProfiles.DeleteExtensionsRoles(Object);
	EndIf;
	
	// In the SaaS mode, the right to open external reports and data processors is not used for data 
	// area users. The check is applied only when the Box -> Service transition occurs.
	If Common.DataSeparationEnabled() Then
		Return;
	EndIf;
	
	If TypeOf(Object) = Type("CatalogObject.AccessGroupProfiles") Then
		Profile = Object;
		
	ElsIf TypeOf(Object) = Type("CatalogObject.AccessGroups") AND Not Object.IsFolder Then
		Profile = Object.Profile;
	Else
		Return;
	EndIf;
	
	If IsProfileOpenExternalReportsAndDataProcessors(Profile) Then
		Cancel = True;
	EndIf;
	
EndProcedure

// See CommonOverridable.OnAddSessionParametersSettingHandlers. 
Procedure SessionParametersSetting(ParameterName, SpecifiedParameters) Export
	
	#Region UniversalRestriction
	If ParameterName = "AccessRestrictionParameters" Then
		SessionParameters.AccessRestrictionParameters = New FixedStructure(New Structure);
		SpecifiedParameters.Add("AccessRestrictionParameters");
		Return;
	EndIf;
	
	If ParameterName = "DIsableAccessKeysUpdate" Then
		Properties = New Structure;
		Properties.Insert("Standard",      False);
		Properties.Insert("Full",           False);
		Properties.Insert("EditedLists", New ValueStorage(New Map));
		SessionParameters.DIsableAccessKeysUpdate = New FixedStructure(Properties);
		SpecifiedParameters.Add("DIsableAccessKeysUpdate");
		Return;
	EndIf;
	
	LimitAccessAtRecordLevel = Constants.LimitAccessAtRecordLevel.Get();
	UniversalRestriction = Constants.LimitAccessAtRecordLevelUniversally.Get();
	
	SessionParameters.RecordLevelAccessRestrictionIsUniversal = UniversalRestriction;
	
	SpecifiedParameters.Add("RecordLevelAccessRestrictionIsUniversal");
	If ParameterName = "RecordLevelAccessRestrictionIsUniversal" Then
		Return;
	EndIf;
	#EndRegion
	
	// If you want the preprocessor to function correctly when the access is restricted, initialize all 
	// session parameters that can be required by the preprocessor.
	InfobaseLockedForUpdate = ValueIsFilled(
		InfobaseUpdateInternal.InfobaseLockedForUpdate(False));
	
	#Region UniversalRestriction
	If Not LimitAccessAtRecordLevel
	 Or Not UniversalRestriction
	 Or InfobaseLockedForUpdate Then
		
		SessionParameters.ListsWithReadRestrictionDisabled =
			?(InfobaseLockedForUpdate
				Or Not UniversalRestriction, "Undefined", "All");
		
		BlankAccessGroupsSet = Catalogs.AccessGroupsSets.EmptyRef();
		
		SessionParameters.AccessRestrictionTemplatesVersions   = AccessRestrictionTemplatesVersions();
		SessionParameters.AllowedAccessGroupsSet       = BlankAccessGroupsSet;
		SessionParameters.AllowedBlankAccessGroupsSet = BlankAccessGroupsSet;
		SessionParameters.AllowedUserGroupsSet = BlankAccessGroupsSet;
		SessionParameters.AllowedUser            = BlankAccessGroupsSet;
		SessionParameters.ListsWithAccessGroupsAccessKeysRestriction  = "";
		SessionParameters.ListsWithUsersAccessKeysRestriction = "";
		SessionParameters.ListsWithUsersAndAccessGroupsAccessKeysRestriction = "";
		SessionParameters.ListsWithRestrictionByFields = "";
		
		SpecifiedParameters.Add("ListsWithReadRestrictionDisabled");
		SpecifiedParameters.Add("AccessRestrictionTemplatesVersions");
		SpecifiedParameters.Add("AllowedAccessGroupsSet");
		SpecifiedParameters.Add("AllowedBlankAccessGroupsSet");
		SpecifiedParameters.Add("AllowedUserGroupsSet");
		SpecifiedParameters.Add("AllowedUser");
		SpecifiedParameters.Add("ListsWithAccessGroupsAccessKeysRestriction");
		SpecifiedParameters.Add("ListsWithUsersAccessKeysRestriction");
		SpecifiedParameters.Add("ListsWithUsersAndAccessGroupsAccessKeysRestriction");
		SpecifiedParameters.Add("ListsWithRestrictionByFields");
	EndIf;
	#EndRegion
	
	If Not LimitAccessAtRecordLevel
	 Or UniversalRestriction
	 Or InfobaseLockedForUpdate Then
		
		SessionParameters.AccessRestrictionAtRecordLevelEnabled =
			?(InfobaseLockedForUpdate
				Or UniversalRestriction, "", False);
		
		SessionParameters.AllAccessKindsExceptSpecialOnes             = "";
		SessionParameters.DisabledAccessKinds      = "";
		SessionParameters.AccessKindsWithoutGroupsForAccessValues      = "";
		SessionParameters.AccessKindsWithSingleGroupForAccessValue = "";
		
		SessionParameters.AccessValuesTypesWithGroups
			= New FixedArray(New Array);
		
		SessionParameters.TablesWithIndividualRightsSettings          = "";
		
		SessionParameters.IDsOfTablesWithIndividualRightsSettings
			= New FixedArray(New Array);
		
		SessionParameters.RightsSettingsOwnersTypes
			= New FixedArray(New Array);
		
		SpecifiedParameters.Add("AccessRestrictionAtRecordLevelEnabled");
		SpecifiedParameters.Add("AllAccessKindsExceptSpecialOnes");
		SpecifiedParameters.Add("DisabledAccessKinds");
		SpecifiedParameters.Add("AccessKindsWithoutGroupsForAccessValues");
		SpecifiedParameters.Add("AccessKindsWithSingleGroupForAccessValue");
		SpecifiedParameters.Add("AccessValuesTypesWithGroups");
		SpecifiedParameters.Add("TablesWithIndividualRightsSettings");
		SpecifiedParameters.Add("IDsOfTablesWithIndividualRightsSettings");
		SpecifiedParameters.Add("RightsSettingsOwnersTypes");
	EndIf;
	
	If Not LimitAccessAtRecordLevel
	 Or InfobaseLockedForUpdate Then
		Return;
	EndIf;
	
	#Region UniversalRestriction
	If UniversalRestriction Then
		ActiveAccessRestrictionParameters(Undefined, Undefined, True);
		Return;
	EndIf;
	#EndRegion
	
	SessionParameters.AccessRestrictionAtRecordLevelEnabled = True;
	
	Query = New Query;
	Query.SetParameter("CurrentUser", Users.AuthorizedUser());
	Query.Text =
	"SELECT DISTINCT
	|	DefaultValues.AccessValuesType AS ValuesType,
	|	DefaultValues.AllAllowedWithoutExceptions AS AllAllowedWithoutExceptions
	|INTO DefaultValuesForUser
	|FROM
	|	InformationRegister.DefaultAccessGroupsValues AS DefaultValues
	|WHERE
	|	TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				Catalog.AccessGroups.Users AS AccessGroupsUsers
	|					INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|					ON
	|						AccessGroupsUsers.Ref = DefaultValues.AccessGroup
	|							AND AccessGroupsUsers.User = UserGroupCompositions.UsersGroup
	|							AND UserGroupCompositions.User = &CurrentUser)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	DefaultValues.ValuesType
	|FROM
	|	DefaultValuesForUser AS DefaultValues
	|
	|GROUP BY
	|	DefaultValues.ValuesType
	|
	|HAVING
	|	MIN(DefaultValues.AllAllowedWithoutExceptions) = TRUE";
	
	ValuesTypesAllAllowedWithoutExceptions = Query.Execute().Unload().UnloadColumn("ValuesType");
	
	// Setting parameters AllAccessKindsExceptSpecialOnes and DisabledAccessKinds.
	AllAccessKindsExceptSpecialOnes        = New Array;
	DisabledAccessKinds = New Array;
	
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	
	For each AccessKindProperties In AccessKindsProperties.Array Do
		AllAccessKindsExceptSpecialOnes.Add(AccessKindProperties.Name);
		
		If NOT AccessKindUsed(AccessKindProperties.Ref)
		 OR ValuesTypesAllAllowedWithoutExceptions.Find(AccessKindProperties.Ref) <> Undefined Then
			
			DisabledAccessKinds.Add(AccessKindProperties.Name);
		EndIf;
	EndDo;
	
	SessionParameters.AllAccessKindsExceptSpecialOnes = AllAccessKindsCombinations(AllAccessKindsExceptSpecialOnes);
	
	SpecifiedParameters.Add("AllAccessKindsExceptSpecialOnes");
	
	AllAccessKindsExceptSpecialOnesDisabled = (AllAccessKindsExceptSpecialOnes.Count()
		= DisabledAccessKinds.Count());
	
	If AllAccessKindsExceptSpecialOnesDisabled Then
		SessionParameters.DisabledAccessKinds = "All";
	Else
		SessionParameters.DisabledAccessKinds
			= AllAccessKindsCombinations(DisabledAccessKinds);
	EndIf;
	
	SpecifiedParameters.Add("DisabledAccessKinds");
	
	// Setting the AccessKindsWithoutGroupsForAccessValues,
	// AccessKindsWithSingleGroupForAccessValue, and AccessValuesTypesWithGroups parameters.
	SessionParameters.AccessKindsWithoutGroupsForAccessValues =
		AllAccessKindsCombinations(AccessKindsProperties.NoGroupsForAccessValue);
	SessionParameters.AccessKindsWithSingleGroupForAccessValue =
		AllAccessKindsCombinations(AccessKindsProperties.WithOneGroupForAccessValue);
	
	AccessValuesTypesWithGroups = New Array;
	For each KeyAndValue In AccessKindsProperties.AccessValuesTypesWithGroups Do
		AccessValuesTypesWithGroups.Add(KeyAndValue.Value);
	EndDo;
	SessionParameters.AccessValuesTypesWithGroups = New FixedArray(AccessValuesTypesWithGroups);
	
	SpecifiedParameters.Add("AccessKindsWithoutGroupsForAccessValues");
	SpecifiedParameters.Add("AccessKindsWithSingleGroupForAccessValue");
	SpecifiedParameters.Add("AccessValuesTypesWithGroups");
	
	// Setting the TablesWithIndividualRightsSettings,
	// IDsOfTablesWithIndividualRightsSettings, and RightsSettingsOwnersTypes parameters.
	AvailableRights = AccessManagementInternalCached.RightsForObjectsRightsSettingsAvailable();
	SeparateTables = AvailableRights.SeparateTables;
	TablesWithIndividualRightsSettings = "";
	IDsOfTablesWithIndividualRightsSettings = New Array;
	For each KeyAndValue In SeparateTables Do
		TablesWithIndividualRightsSettings = TablesWithIndividualRightsSettings
			+ "|" + KeyAndValue.Value + ";" + Chars.LF;
		IDsOfTablesWithIndividualRightsSettings.Add(KeyAndValue.Key);
	EndDo;
	
	SessionParameters.TablesWithIndividualRightsSettings = TablesWithIndividualRightsSettings;
	
	SessionParameters.IDsOfTablesWithIndividualRightsSettings =
		New FixedArray(IDsOfTablesWithIndividualRightsSettings);
	
	SessionParameters.RightsSettingsOwnersTypes = AvailableRights.OwnersTypes;
	
	SpecifiedParameters.Add("TablesWithIndividualRightsSettings");
	SpecifiedParameters.Add("IDsOfTablesWithIndividualRightsSettings");
	SpecifiedParameters.Add("RightsSettingsOwnersTypes");
	
EndProcedure

// Updates a role list of infobase users by their current access groups.
// 
//  Users with the FullAccess role are skipped.
// 
// Parameters:
//  Users - CatalogRef.Users,
//                 CatalogRef.ExternalUsers.
//                 Array of values of the types specified above.
//               - Undefined - update all user roles.
//               - Type used for metadata object search:
//                 if Catalog.ExternalUsers is found, all external user roles are updated, otherwise, 
//                 all user roles are updated.
//                 
//
//  ServiceUserPassword - String - a password for authorization in the service manager.
//                        
//  HasChanges - Boolean (return value) - True is returned to this parameter if changes are saved. 
//                  Otherwise, not modified.
//
Procedure UpdateUserRoles(Val Users1 = Undefined,
                                    Val ServiceUserPassword = Undefined,
                                    HasChanges = False) Export
	
	If NOT UsersInternal.CannotEditRoles() Then
		// Roles are set by tools of Users and ExternalUsers subsystems.
		Return;
	EndIf;
	
	If Users1 = Undefined Then
		UsersArray = Undefined;
		Users.FindAmbiguousIBUsers(Undefined);
		
	ElsIf TypeOf(Users1) = Type("Array") Then
		UsersArray = Users1;
		If UsersArray.Count() = 0 Then
			Return;
		ElsIf UsersArray.Count() = 1 Then
			Users.FindAmbiguousIBUsers(UsersArray[0]);
		Else
			Users.FindAmbiguousIBUsers(Undefined);
		EndIf;
		
	ElsIf TypeOf(Users1) = Type("Type") Then
		UsersArray = Users1;
		Users.FindAmbiguousIBUsers(Undefined);
	Else
		UsersArray = New Array;
		UsersArray.Add(Users1);
		Users.FindAmbiguousIBUsers(Users1);
	EndIf;
	
	SetPrivilegedMode(True);
	
	CurrentUsersProperties = CurrentUsersProperties(UsersArray);
	
	// Checking parameters in the loop.
	AllRoles                       = UsersInternal.AllRoles().Map;
	IBUsersIDs = CurrentUsersProperties.IBUsersIDs;
	NewUsersRoles        = CurrentUsersProperties.UsersRoles;
	Administrators                = CurrentUsersProperties.Administrators;
	DataSeparationEnabled            = Common.DataSeparationEnabled();
	
	RequiredAdministratorRoles = New Map;
	RequiredAdministratorRoles.Insert("FullRights", True);
	If Not DataSeparationEnabled Then
		RequiredAdministratorRoles.Insert("SystemAdministrator", True);
	EndIf;
	AdditionalAdministratorRoles = New Map;
	AdditionalAdministratorRoles.Insert("InteractiveOpenExtReportsAndDataProcessors", True);
	
	// Expected result after the loop ends.
	NewIBAdministrators     = New Map;
	IBUsersToUpdate = New Map;
	
	For Each UserDetails In IBUsersIDs Do
		
		CurrentUser         = UserDetails.User;
		IBUserID = UserDetails.IBUserID;
		NewIBAdministrator        = False;
		
		Cancel = False;
		SaaSIntegration.OnUpdateIBUserRoles(IBUserID, Cancel);
		If Cancel Then
			Continue;
		EndIf;
		
		// Searching for an infobase user.
		If TypeOf(IBUserID) = Type("UUID") Then
			InfobaseUser = InfoBaseUsers.FindByUUID(
				IBUserID);
		Else
			InfobaseUser = Undefined;
		EndIf;
		
		If InfobaseUser = Undefined
		 Or Not ValueIsFilled(InfobaseUser.Name) Then
			Continue;
		EndIf;
		
		Filter = New Structure("User", CurrentUser);
		NewRoles = NewUsersRoles.Copy(
			NewUsersRoles.FindRows(Filter), "Role, RoleRef");
		
		NewRoles.Indexes.Add("Role");
		
		If Administrators[CurrentUser] <> Undefined Then
			CurrentNewRoles = NewRoles;
			NewRoles = CurrentNewRoles.Copy(New Array);
			For Each KeyAndValue In RequiredAdministratorRoles Do
				NewRoles.Add().Role = KeyAndValue.Key;
			EndDo;
			For Each KeyAndValue In AdditionalAdministratorRoles Do
				If CurrentNewRoles.Find(KeyAndValue.Key, "Role") = Undefined Then
					Continue;
				EndIf;
				NewRoles.Add().Role = KeyAndValue.Key;
			EndDo;
		EndIf;
		
		// Checking old roles.
		OldRoles        = New Map;
		RolesForAdding = New Map;
		RolesForDeletion   = New Map;
		
		For Each Role In InfobaseUser.Roles Do
			RoleName = Role.Name;
			OldRoles.Insert(RoleName, True);
			If NewRoles.Find(RoleName, "Role") = Undefined Then
				RolesForDeletion.Insert(RoleName, True);
			EndIf;
		EndDo;
		
		UnavailableRoles = UsersInternalCached.UnavailableRolesByUserType(
			TypeOf(CurrentUser) = Type("CatalogRef.ExternalUsers"));
		
		// Checking new roles.
		For Each Row In NewRoles Do
			
			If OldRoles[Row.Role] <> Undefined Then
				If DataSeparationEnabled
				   AND UnavailableRoles.Get(Row.Role) <> Undefined Then
					
					RegisterUnavailableRole(Row, CurrentUser);
					RolesForDeletion.Insert(Row.Role, True);
				EndIf;
				Continue;
			EndIf;
			
			If AllRoles.Get(Row.Role) = Undefined Then
				RegisterNotFoundRole(Row, CurrentUser);
				Continue;
			EndIf;
			
			If UnavailableRoles.Get(Row.Role) <> Undefined Then
				RegisterUnavailableRole(Row, CurrentUser);
				Continue;
			EndIf;
			
			RolesForAdding.Insert(Row.Role, True);
			
			If Row.Role = "SystemAdministrator" Then
				NewIBAdministrator = True;
			EndIf;
		EndDo;
		
		// Completing the current user processing.
		If RolesForAdding.Count() = 0
		   AND RolesForDeletion.Count()   = 0 Then
			Continue;
		EndIf;
		
		RolesChanges = New Structure;
		RolesChanges.Insert("UserRef", CurrentUser);
		RolesChanges.Insert("InfobaseUser",     InfobaseUser);
		RolesChanges.Insert("RolesForAdding",  RolesForAdding);
		RolesChanges.Insert("RolesForDeletion",    RolesForDeletion);
		
		If NewIBAdministrator Then
			NewIBAdministrators.Insert(CurrentUser, RolesChanges);
		Else
			IBUsersToUpdate.Insert(CurrentUser, RolesChanges);
		EndIf;
		
		HasChanges = True;
	EndDo;
	
	// Adding new administrators.
	If NewIBAdministrators.Count() > 0 Then
		UpdateIBUsersRoles(NewIBAdministrators, ServiceUserPassword);
	EndIf;
	
	// Deleting old administrators and updating other users.
	If IBUsersToUpdate.Count() > 0 Then
		UpdateIBUsersRoles(IBUsersToUpdate, ServiceUserPassword);
	EndIf;
	
EndProcedure

// Checking the Administrators access group before writing.
Procedure CheckAdministratorsAccessGroupForIBUser(GroupUsers, ErrorDescription) Export
	
	Users.FindAmbiguousIBUsers(Undefined);
	
	// Checking a blank list of infobase users in the Administrators access group.
	SetPrivilegedMode(True);
	ValidAdministratorFound = False;
	
	For Each UserDetails In GroupUsers Do
		
		If Not ValueIsFilled(UserDetails.User)
		 Or TypeOf(UserDetails.User) <> Type("CatalogRef.Users")
		   AND TypeOf(UserDetails.User) <> Type("CatalogRef.Users") Then
			Continue;
		EndIf;
		
		InfobaseUser = InfoBaseUsers.FindByUUID(
			UserDetails.User.IBUserID);
		
		If InfobaseUser <> Undefined
		   AND Users.CanSignIn(InfobaseUser) Then
			
			ValidAdministratorFound = True;
			Break;
		EndIf;
	EndDo;
	
	If NOT ValidAdministratorFound Then
		ErrorDescription =
			NStr("ru = 'В группе доступа Администраторы
			           |должен быть хотя бы один пользователь,
			           |которому разрешен вход в программу.'; 
			           |en = 'At least one user authorized to access
			           |the application must be included in
			           |the Administrators access group.'; 
			           |pl = 'W grupie dostępu Administratorzy
			           |musi być przynajmniej jeden użytkownik,
			           |któremu zezwolono na wejście do programu.';
			           |es_ES = 'En el grupo de acceso Administradores
			           |debe ser incluido aunque se un usuario
			           |al que le está permitido entrar en el programa.';
			           |es_CO = 'En el grupo de acceso Administradores
			           |debe ser incluido aunque se un usuario
			           |al que le está permitido entrar en el programa.';
			           |tr = 'Yöneticiler 
			           |erişim grubunda, uygulamaya erişebilecek 
			           |en az bir kullanıcı olmalıdır.';
			           |it = 'Almeno uno degli utenti autorizzati all''accesso
			           |nell''applicazione deve essere incluso
			           |nel gruppo di accesso Amministratori.';
			           |de = 'Die Administratoren müssen mindestens einen Benutzer in der Zugriffsgruppe
			           |haben,
			           |der sich am Programm anmelden darf.'");
	EndIf;
	
EndProcedure

// See AccessManagement.HasTableRestrictionByAccessKind. 
Function HasTableRestrictionByAccessKind(Table, AccessKind, AllAccessKinds) Export
	
	SetPrivilegedMode(True);
	
	DisabledAccessKinds = SessionParameters.DisabledAccessKinds;
	If DisabledAccessKinds = "All"
	 Or StrFind(DisabledAccessKinds, "," + AccessKind + ",") > 0 Then
		Return False;
	EndIf;
	
	AccessKindsArray = StrSplit(AllAccessKinds, ",", False);
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	
	ErrorTitle =
		NStr("ru = 'Ошибка в функции HasTableRestrictionByAccessKind общего модуля AccessManagement.'; en = 'An error occurred in the HasTableRestrictionByAccessKind function of the AccessManagement common module.'; pl = 'Błąd w funkcji HasTableRestrictionByAccessKind wspólnego modułu AccessManagement.';es_ES = 'Error en la función HasTableRestrictionByAccessKind del módulo común AccessManagement.';es_CO = 'Error en la función HasTableRestrictionByAccessKind del módulo común AccessManagement.';tr = 'AccessManagement ortak modülünün HasTableRestrictionByAccessKind işlevinde hata oluştu.';it = 'Si è verificato un errore nella funzione HasTableRestrictionByAccessKind del modulo comune AccessManagement.';de = 'Fehler in der Funktion HasTableRestrictionByAccessKind des allgemeinen Moduls AccessManagement.'")
		+ Chars.LF;
	
	AccessKindProperties = AccessKindsProperties.ByNames.Get(AccessKind);
	If AccessKindProperties = Undefined Then
		ErrorText = ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не найден вид доступа ""%1"", указанный в параметре AccessKind.'; en = 'The ""%1"" access kind specified in the AccessKind parameter is not found.'; pl = 'Nie znaleziono rodzaj dostępu ""%1"", określony w parametrze AccessKind.';es_ES = 'No se ha encontrado el tipo de acceso ""%1"" indicado en el parámetro AccessKind.';es_CO = 'No se ha encontrado el tipo de acceso ""%1"" indicado en el parámetro AccessKind.';tr = 'AccessKind parametresinde belirtilen ""%1"" erişim türü bulunamadı.';it = 'Il tipo di accesso ""%1"" indicato nel parametro AccessKind non è stato trovato.';de = 'Die im Parameter ""%1"" AccessKind angegebene Zugriffsart wurde nicht gefunden.'"), AccessKind);
		Raise ErrorText;
	EndIf;
	AccessKindRef = AccessKindProperties.Ref;
	
	AllDisabledTableAccessKinds = True;
	AccessKindsUse = New Map;
	AccessKindSpecifiedInAllAccessKinds = False;
	
	For Each CurrentAccessKind In AccessKindsArray Do
		CurrentAccessKind = TrimAll(CurrentAccessKind);
		AccessKindProperties = AccessKindsProperties.ByNames.Get(CurrentAccessKind);
		If AccessKindProperties = Undefined Then
			ErrorText = ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Не найден вид доступа ""%1"", указанный в параметре
				           |AllAccessKinds: ""%2"".'; 
				           |en = 'The ""%1"" access kind specified in the AllAccessKinds parameter
				           |is not found: ""%2"".'; 
				           |pl = 'Nie znaleziono rodzaj dostępu ""%1"", określony w parametrze
				           | AllAccessKinds: ""%2"".';
				           |es_ES = 'No se ha encontrado el tipo de acceso ""%1"" indicado en el parámetro
				           |AllAccessKinds ""%2"".';
				           |es_CO = 'No se ha encontrado el tipo de acceso ""%1"" indicado en el parámetro
				           |AllAccessKinds ""%2"".';
				           |tr = 'TümErişimTürleri
				           | parametresinde belirtilen ""%1"" erişim türü %2bulunamadı.';
				           |it = 'Il tipo di accesso ""%1"" indicato nel parametro AllAccessKind
				           | non è stato trovato: ""%2"".';
				           |de = 'Der im Parameter ""%1"" AllAccessKinds angegebene
				           |Zugriffsart wurde nicht gefunden:""%2"".'"), CurrentAccessKind, AllAccessKinds);
			Raise ErrorText;
		EndIf;
		If AccessKindProperties.Name = AccessKind Then
			AccessKindSpecifiedInAllAccessKinds = True;
		EndIf;
		Used = StrFind(DisabledAccessKinds, "," + AccessKindProperties.Name + ",") = 0;
		AccessKindsUse.Insert(AccessKindProperties.Ref, Used);
		If Used Then
			AllDisabledTableAccessKinds = False;
		EndIf;
	EndDo;
	
	If Not AccessKindSpecifiedInAllAccessKinds Then
		ErrorText = ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Вид доступа ""%1"", указанный в параметре AccessKind не найден в параметре
			           |AllAccessKinds: ""%2"".'; 
			           |en = 'The ""%1"" access kind specified in the AccessKind parameter is not found in
			           |the AllAccessKinds parameter: ""%2"".'; 
			           |pl = 'Rodzaj dostępu ""%1"", określony w parametrze AccessKind nie znaleziony w parametrze
			           |AllAccessKinds: ""%2"".';
			           |es_ES = 'El tipo de acceso ""%1"" indicado en el parámetro AccessKind no se ha encontrado en el parámetro
			           | AllAccessKinds: ""%2"".';
			           |es_CO = 'El tipo de acceso ""%1"" indicado en el parámetro AccessKind no se ha encontrado en el parámetro
			           | AllAccessKinds: ""%2"".';
			           |tr = 'AccessKind parametresinde belirtilen erişim türü ""%1"" AllAccessKinds parametresinde
			           | bulunamadı: ""%2"".';
			           |it = 'Il tipo di accesso ""%1"" indicato nel parametro AccessKind non è stato trovato nel
			           | parametro AllAccessKinds: ""%2"".';
			           |de = 'Der im Parameter AccessKind angegebene Zugriffstyp ""%1"" wurde im Parameter
			           |AllAccessKinds nicht gefunden: ""%2"".'"), AccessKind, AllAccessKinds);
		Raise ErrorText;
	EndIf;
	
	If AllDisabledTableAccessKinds Then
		Return False;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("MainListTableName", Table);
	Query.SetParameter("AuthorizedUser", Users.AuthorizedUser());
	
	Query.Text = AccessGroupsRequestText();
	
	QueryText =
	"SELECT
	|	DefaultValues.AccessGroup AS AccessGroup,
	|	DefaultValues.AccessValuesType AS AccessKind
	|FROM
	|	InformationRegister.DefaultAccessGroupsValues AS DefaultValues
	|		INNER JOIN UserAccessGroups AS UserAccessGroups
	|		ON DefaultValues.AccessGroup = UserAccessGroups.Ref
	|WHERE
	|	NOT DefaultValues.AllAllowedWithoutExceptions
	|	AND TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				Catalog.AccessGroups.Users AS AccessGroupsUsers
	|					INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|					ON
	|						AccessGroupsUsers.Ref = DefaultValues.AccessGroup
	|							AND AccessGroupsUsers.User = UserGroupCompositions.UsersGroup
	|							AND UserGroupCompositions.User = &AuthorizedUser)";
	
	AddQueryToPackage(Query.Text, QueryText);
	Selection = Query.Execute().Select();
	
	SetAccessGroupsOfAccessKinds = New Map;
	HasAccessGroupWithRestrictionByAccessKind = False;
	
	While Selection.Next() Do
		SetAccessKinds = SetAccessGroupsOfAccessKinds.Get(Selection.AccessGroup);
		If SetAccessKinds = Undefined Then
			SetAccessKinds = New Map;
			SetAccessGroupsOfAccessKinds.Insert(Selection.AccessGroup, SetAccessKinds);
		EndIf;
		If AccessKindsUse.Get(Selection.AccessKind) = Undefined Then
			Continue;
		EndIf;
		SetAccessKinds.Insert(Selection.AccessKind, True);
		If Selection.AccessKind = AccessKindRef Then
			HasAccessGroupWithRestrictionByAccessKind = True;
		EndIf;
	EndDo;
	
	HasAccessGroupWithoutRestrictionsByAllAccessKinds = False;
	
	For Each AccessGroupDetails In SetAccessGroupsOfAccessKinds Do
		SetAccessKinds = AccessGroupDetails.Value;
		AllTableAccessKindsWithoutRestrictionsInAccessGroup = True;
		For Each AccessKindUsageDetails In AccessKindsUse Do
			If Not AccessKindUsageDetails.Value Then
				Continue; // Obsolete attribute.
			EndIf;
			If SetAccessKinds.Get(AccessKindUsageDetails.Key) = Undefined Then
				Continue; // AllAllowedWithoutExceptions or there are no restrictions by access kind.
			EndIf;
			AllTableAccessKindsWithoutRestrictionsInAccessGroup = False;
			Break;
		EndDo;
		If AllTableAccessKindsWithoutRestrictionsInAccessGroup Then
			HasAccessGroupWithoutRestrictionsByAllAccessKinds = True;
			Break;
		EndIf;
	EndDo;
	
	If HasAccessGroupWithoutRestrictionsByAllAccessKinds Then
		Return False;
	EndIf;
	
	Return HasAccessGroupWithRestrictionByAccessKind;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Event subscription handlers.

// UpdateAccessValuesGroups subscription handler responds to the BeforeWrite event by calling:
// - a method for recording access value groups to the AccessValuesGroups information register for 
//   required metadata objects
//
Procedure UpdateAccessValuesGroups(Val Object, Cancel) Export
	
	If Object.DataExchange.Load Then
		Return;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Object) Then
		Return;
	EndIf;
	
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	AccessValuesWithGroups = AccessKindsProperties.AccessValuesWithGroups;
	
	If AccessValuesWithGroups.ByTypesForUpdate.Get(TypeOf(Object)) <> Undefined Then
		InformationRegisters.AccessValuesGroups.UpdateAccessValuesGroups(Object);
	EndIf;
	
EndProcedure

// The UpdateRightsSettingsOwnersGroups subscription handler responds to the BeforeWrite event by calling:
// - a method for recording a hierarchy of the object right settings owner to the 
//   InheritObjectsRightsSettings information register for required metadata objects.
//
Procedure UpdateRightsSettingsOwnersGroups(Val Object, Cancel) Export
	
	If Object.DataExchange.Load Then
		Return;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Object) Then
		Return;
	EndIf;
	
	AvailableRights = AccessManagementInternalCached.RightsForObjectsRightsSettingsAvailable();
	AvailableRightsByTypes = AvailableRights.ByTypes;
	
	If AvailableRightsByTypes.Get(TypeOf(Object)) <> Undefined Then
		InformationRegisters.ObjectRightsSettingsInheritance.UpdateRegisterData(Object);
	EndIf;
	
EndProcedure

// The WriteAccessValuesSets subscription handler responds to the OnWrite event by calling the 
// method used for recording object access values to InformationRegister.AccessValuesSets.
//  The AccessManagement subsystem can be used when
// the specified subscription does not exist if access value sets are not applied.
//
Procedure WriteAccessValuesSetsOnWrite(Val Object, Cancel) Export
	
	// Check of the DataExchange.Import is ignored only when the WriteAccessValuesSets property is set.
	// 
	// In this case, when recording the leading object for its correct RLS operations, a program 
	// recording of the subordinate object is performed to update the AccessValuesSets service tabular section.
	If Object.DataExchange.Load
	   AND NOT Object.AdditionalProperties.Property("WriteAccessValuesSets") Then
		
		Return;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Object) Then
		Return;
	EndIf;
	
	WriteAccessValuesSets(Object, , Object.AdditionalProperties.Property(
		"WriteAccessValueSetsOnUpdateIB"));
	
EndProcedure

// WriteDependentAccessValuesSets subscription handler responds to the OnWrite event by overwriting 
// dependent access value sets in the AccessValuesSets information register.
//
//  The AccessManagement subsystem can be used when
// the specified subscription does not exist if dependent access value sets are not applied.
//
Procedure WriteDependentAccessValuesSetsOnWrite(Val Object, Cancel) Export
	
	// Check of the DataExchange.Import is ignored only when the WriteAccessValuesSets property is set.
	// 
	// In this case, when recording the leading object for its correct RLS operations, a program 
	// recording of the subordinate object is performed to update the AccessValuesSets service tabular section.
	If Object.DataExchange.Load
	   AND NOT Object.AdditionalProperties.Property("WriteDependentAccessValuesSets") Then
		
		Return;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Object) Then
		Return;
	EndIf;
	
	WriteDependentAccessValuesSets(Object, Object.AdditionalProperties.Property(
		"WriteAccessValueSetsOnUpdateIB"));
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Scheduled job handlers.

// DataFillingForAccessRestriction scheduled job handler.
Procedure DataFillingForAccessRestrictionJobHandler() Export
	
	Common.OnStartExecuteScheduledJob(
		Metadata.ScheduledJobs.DataFillingForAccessRestriction);
	
	DataFillingForAccessRestriction();
	
EndProcedure

// Sequentially fills and updates the data required for the AccessManagement subsystem in the access 
// restriction mode at the record level.
// 
//  Fills sets of access values when the access restriction mode is enabled
//  at the record level. The sets are filled in by portions during each run, until all access value 
// sets are filled in.
//  When the access restriction mode at the record level is disabled, access value sets
// (filled previously) are deleted upon overwriting objects, not all at once.
//  The procedure updates cache attributes at the record level regardless of the access restriction mode.
//  Disables the scheduled job after all updates are completed and data is filled.
//
//  The progress information is written to the event log.
//
//  The procedure can be called programmatically, for example, when updating the infobase.
// For data update purposes, the Catalog.AccessGroups.UpdateDataRestrictionAccess form is available. 
// This form can be used for interactive update of access restriction data when updating the 
// infobase.
//
Procedure DataFillingForAccessRestriction(DataVolume = 0, OnlyCacheAttributes = False, HasChanges = Undefined) Export
	
	SetPrivilegedMode(True);
	
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	AccessValuesWithGroups = AccessKindsProperties.AccessValuesWithGroups;
	
	If AccessManagement.LimitAccessAtRecordLevel() AND NOT OnlyCacheAttributes Then
		
		// Filling access value groups in the AccessValuesGroups information register.
		For Each TableName In AccessValuesWithGroups.NamesOfTablesToUpdate Do
			
			If DataVolume < 10000 Then
				
				Query = New Query;
				Query.Text =
				"SELECT TOP 10000
				|	CurrentTable.Ref AS Ref
				|FROM
				|	&CurrentTable AS CurrentTable
				|		LEFT JOIN InformationRegister.AccessValuesGroups AS AccessValuesGroups
				|		ON CurrentTable.Ref = AccessValuesGroups.AccessValue
				|			AND (AccessValuesGroups.DataGroup = 0)
				|WHERE
				|	AccessValuesGroups.AccessValue IS NULL ";
				
				Query.Text = StrReplace(Query.Text, "&CurrentTable", TableName);
				Values = Query.Execute().Unload().UnloadColumn("Ref");
				
				InformationRegisters.AccessValuesGroups.UpdateAccessValuesGroups(Values, HasChanges);
				
				DataVolume = DataVolume + Values.Count();
			EndIf;
			
		EndDo;
		
		If DataVolume < 10000
		   AND NOT InformationRegisters.DeleteAccessValuesSets.MoveDataToNewRegister() Then
			// Before filling the access value sets, all access value sets are moved from the old register.
			// 
			Return;
			
		ElsIf DataVolume < 10000 Then
			
			// Filling the AccessValuesSets information register.
			ObjectsTypes = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
				"WriteAccessValuesSets");
			
			For each TypeDetails In ObjectsTypes Do
				Type = TypeDetails.Key;
				
				If DataVolume < 10000 AND Type <> Type("String") Then
				
					Query = New Query;
					Query.Text =
					"SELECT TOP 10000
					|	CurrentTable.Ref AS Ref
					|FROM
					|	&CurrentTable AS CurrentTable
					|		LEFT JOIN InformationRegister.AccessValuesSets AS InformationRegisterAccessValuesSets
					|		ON CurrentTable.Ref = InformationRegisterAccessValuesSets.Object
					|WHERE
					|	InformationRegisterAccessValuesSets.Object IS NULL ";
					Query.Text = StrReplace(Query.Text, "&CurrentTable", Metadata.FindByType(Type).FullName());
					Selection = Query.Execute().Select();
					DataVolume = DataVolume + Selection.Count();
					
					While Selection.Next() Do
						UpdateAccessValuesSets(Selection.Ref, HasChanges);
					EndDo;
				EndIf;
			EndDo;
		EndIf;
	Else
		InformationRegisters.DeleteAccessValuesSets.MoveDataToNewRegister();
	EndIf;
	
	// Updating cache attributes in access value sets.
	If DataVolume < 10000 Then
		
		AccessValuesTypes          = AccessKindsProperties.ByValuesTypes;
		AccessValuesTypesWithGroups = AccessKindsProperties.AccessValuesTypesWithGroups;
		
		ValuesTypesTable = New ValueTable;
		ValuesTypesTable.Columns.Add("ValuesType", Metadata.DefinedTypes.AccessValue.Type);
		For each KeyAndValue In AccessValuesTypes Do
			ValuesTypesTable.Add().ValuesType = MetadataObjectEmptyRef(KeyAndValue.Key);
		EndDo;
		
		TableOfValuesTypesWithGroups = New ValueTable;
		TableOfValuesTypesWithGroups.Columns.Add("ValuesType", Metadata.DefinedTypes.AccessValue.Type);
		For each KeyAndValue In AccessValuesTypesWithGroups Do
			TableOfValuesTypesWithGroups.Add().ValuesType = MetadataObjectEmptyRef(KeyAndValue.Key);
		EndDo;
		
		Query = New Query;
		Query.SetParameter("ValuesTypesTable", ValuesTypesTable);
		Query.SetParameter("TableOfValuesTypesWithGroups", TableOfValuesTypesWithGroups);
		Query.Text =
		"SELECT
		|	TableTypes.ValuesType
		|INTO ValuesTypesTable
		|FROM
		|	&ValuesTypesTable AS TableTypes
		|
		|INDEX BY
		|	TableTypes.ValuesType
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT
		|	TableTypes.ValuesType
		|INTO TableOfValuesTypesWithGroups
		|FROM
		|	&TableOfValuesTypesWithGroups AS TableTypes
		|
		|INDEX BY
		|	TableTypes.ValuesType
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT TOP 10000
		|	AccessValuesSets.Object,
		|	AccessValuesSets.SetNumber,
		|	AccessValuesSets.AccessValue,
		|	AccessValuesSets.Clarification,
		|	AccessValuesSets.Read,
		|	AccessValuesSets.Update
		|FROM
		|	InformationRegister.AccessValuesSets AS AccessValuesSets
		|WHERE
		|	CASE
		|			WHEN AccessValuesSets.StandardValue <> TRUE IN
		|					(SELECT TOP 1
		|						TRUE
		|					FROM
		|						ValuesTypesTable AS ValuesTypesTable
		|					WHERE
		|						VALUETYPE(ValuesTypesTable.ValuesType) = VALUETYPE(AccessValuesSets.AccessValue))
		|				THEN TRUE
		|			WHEN AccessValuesSets.StandardValue = TRUE
		|				THEN AccessValuesSets.ValueWithoutGroups = TRUE IN
		|						(SELECT TOP 1
		|							TRUE
		|						FROM
		|							TableOfValuesTypesWithGroups AS TableOfValuesTypesWithGroups
		|						WHERE
		|							VALUETYPE(TableOfValuesTypesWithGroups.ValuesType) = VALUETYPE(AccessValuesSets.AccessValue))
		|			ELSE AccessValuesSets.ValueWithoutGroups = TRUE
		|		END";
		Selection = Query.Execute().Select();
		DataVolume = DataVolume + Selection.Count();
		
		While Selection.Next() Do
			RecordManager = InformationRegisters.AccessValuesSets.CreateRecordManager();
			FillPropertyValues(RecordManager, Selection);
			
			AccessValueType = TypeOf(Selection.AccessValue);
			
			If AccessValuesTypes.Get(AccessValueType) <> Undefined Then
				RecordManager.StandardValue = True;
				If AccessValuesTypesWithGroups.Get(AccessValueType) = Undefined Then
					RecordManager.ValueWithoutGroups = True;
				EndIf;
			EndIf;
			
			RecordManager.Write();
			HasChanges = True;
		EndDo;
	EndIf;
	
	If DataVolume < 10000 Then
		WriteLogEvent(
			NStr("ru = 'Управление доступом.Заполнение данных для ограничения доступа'; en = 'Access management.Data filling for access restriction'; pl = 'Zarządzanie dostępem. Wprowadzenie danych w celu ograniczenia dostępu';es_ES = 'Gestión de acceso.Población de datos para la restricción de acceso';es_CO = 'Gestión de acceso.Población de datos para la restricción de acceso';tr = 'Erişim yönetimi. Erişim kısıtlaması için veri doldurulması';it = 'Gestione accesso. Compilazione dati per restrizioni all''accesso';de = 'Zugriffsverwaltung. Datenausfüllung für Zugriffsbeschränkung'",
				 CommonClientServer.DefaultLanguageCode()),
			EventLogLevel.Information,
			,
			,
			NStr("ru = 'Завершено заполнение данных для ограничения доступа.'; en = 'Data filling for access restriction is completed.'; pl = 'Zakończono wprowadzenie danych w celu ograniczenia dostępu.';es_ES = 'Población de datos para la restricción de acceso se ha finalizado.';es_CO = 'Población de datos para la restricción de acceso se ha finalizado.';tr = 'Erişim kısıtlaması için veri doldurulma işlemi tamamlandı.';it = 'La compilazione dati per la restrizione accesso è stata completata.';de = 'Die Datenpopulation für die Zugriffsbeschränkung ist abgeschlossen.'"),
			EventLogEntryTransactionMode.Transactional);
			
		SetDataFillingForAccessRestriction(False);
	Else
		WriteLogEvent(
			NStr("ru = 'Управление доступом.Заполнение данных для ограничения доступа'; en = 'Access management.Data filling for access restriction'; pl = 'Zarządzanie dostępem. Wprowadzenie danych w celu ograniczenia dostępu';es_ES = 'Gestión de acceso.Población de datos para la restricción de acceso';es_CO = 'Gestión de acceso.Población de datos para la restricción de acceso';tr = 'Erişim yönetimi. Erişim kısıtlaması için veri doldurulması';it = 'Gestione accesso. Compilazione dati per restrizioni all''accesso';de = 'Zugriffsverwaltung. Datenausfüllung für Zugriffsbeschränkung'",
				 CommonClientServer.DefaultLanguageCode()),
			EventLogLevel.Information,
			,
			,
			NStr("ru = 'Выполнена запись части данных для ограничения доступа.'; en = 'A part of data was recorded for access restriction.'; pl = 'Część danych dotyczących ograniczeń dostępu jest zapisana.';es_ES = 'Parte de los datos para la restricción de acceso se ha grabado.';es_CO = 'Parte de los datos para la restricción de acceso se ha grabado.';tr = 'Erişim kısıtlaması için verilerin bir kısmı yazılmıştır.';it = 'Una parte di dati è stata registrata per le restrizioni all''accesso.';de = 'Ein Teil der Daten für die Zugriffsbeschränkung wird geschrieben.'"),
			EventLogEntryTransactionMode.Transactional);
	EndIf;
	
EndProcedure

// Determines usage of a scheduled job for filling access management data.
//
// Parameters:
// Use - Boolean - True if the job must be enabled, otherwise, False.
//
Procedure SetDataFillingForAccessRestriction(Val Usage) Export
	
	ScheduledJobsServer.SetPredefinedScheduledJobUsage(
		Metadata.ScheduledJobs.DataFillingForAccessRestriction, Usage);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Procedures and functions for access kind management.

// Returns True if the access kind is enabled by functional options for all sessions.
//
// Parameters:
//  AccessKind - String - a blank reference of the main type.
//             - String - an access kind name.
//
// Returns:
//  Boolean.
//
Function AccessKindUsed(Val AccessKind) Export
	
	Used = False;
	
	AccessKindProperties = AccessKindProperties(AccessKind);
	If AccessKindProperties = Undefined Then
		Return Used;
	EndIf;
	
	If AccessKindProperties.Name = "ExternalUsers"
	 Or AccessKindProperties.Name = "Users" Then
		// These access kinds cannot be disabled by functional options.
		Return True;
	EndIf;
	
	Used = True;
	
	SSLSubsystemsIntegration.OnFillAccessKindUsage(AccessKindProperties.Name, Used);
	AccessManagementOverridable.OnFillAccessKindUsage(AccessKindProperties.Name, Used);
	
	Return Used;
	
EndFunction

// Returns the properties of an access kind or all access kinds.
//
// Parameters:
//  AccessKind - String - a blank reference of the main type;
//             - String - an access kind name.
//             - Undefined - return an array of properties of all access kinds.
//
// Returns:
//  Undefined - when no properties are found for an access kind.
//  Structure    - properties of the found access kind. For the description of the properties, see 
//                 comments to the AccessKindsProperties function of this module.
//  Array - with the following values:
//    * Structure - with properties like of the structure specified above.
//
Function AccessKindProperties(Val AccessKind = Undefined) Export
	
	Properties = AccessManagementInternalCached.AccessKindsProperties();
	
	If AccessKind = Undefined Then
		Return Properties.Array;
	EndIf;
	
	AccessKindProperties = Properties.ByNames.Get(AccessKind);
	
	If AccessKindProperties = Undefined Then
		AccessKindProperties = Properties.ByRefs.Get(AccessKind);
	EndIf;
	
	Return AccessKindProperties;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Procedures and functions for access value set management.

// Returns new sets to be used to fill a tabular section.
Function GetAccessValuesSetsOfTabularSection(Object) Export
	
	ValueTypeObject = TypeOf(Object);
	
	If Object.Metadata().TabularSections.Find("AccessValuesSets") = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Неверные параметры.
			           |У объекта типа ""%1""
			           |не найдена табличная часть ""Наборы значений доступа"".'; 
			           |en = 'Incorrect parameters.
			           |Tabular section 
			           |""Access value sets"" of object ""%1"" is not found.'; 
			           |pl = 'Nieprawidłowe ustawienia.
			           |Obiekt typu ""%1""
			           |nie znaleziono arkusza kalkulacyjnego część ""Zestawy wartości dostępu"".';
			           |es_ES = 'Parámetros incorrectos.
			           |El objeto del tipo ""%1"" 
			           |no tiene sección tabular ""Conjuntos de valores de acceso"".';
			           |es_CO = 'Parámetros incorrectos.
			           |El objeto del tipo ""%1"" 
			           |no tiene sección tabular ""Conjuntos de valores de acceso"".';
			           |tr = 'Yanlış parametreler. "
"Erişim değeri kümeleri 
			           |""sekmeli bölüm, "" %1"" türündeki nesnede bulunamadı.';
			           |it = 'Parametri non corretti.
			           |La sezione tabellare
			           |""Insiemi valori di accesso"" dell''oggetto ""%1"" non è stata trovata.';
			           |de = 'Falsche Parameter.
			           |Der tabellarische Teil von ""Zugriffswerte-Sets"" befindet sich nicht im Objekt vom Typ%1"
".'"),
			ValueTypeObject);
		Raise ErrorText;
	EndIf;
	
	Table = AccessManagement.AccessValuesSetsTable();
	
	If NOT AccessManagement.LimitAccessAtRecordLevel() Then
		Return Table;
	EndIf;
	
	AccessManagement.FillAccessValuesSets(Object, Table);
	
	AccessManagement.AddAccessValuesSets(
		Table, AccessManagement.AccessValuesSetsTable(), False, True);
	
	Return Table;
	
EndFunction

// Updates object access value sets if they are changed.
// The sets are updated both in the tabular section (if used) and in the AccessValuesSets 
// information register.
//
// Parameters:
//  RefOrObject - CatalogRef, DocumentRef and other reference or object types - a reference or an 
//                    object, for which the access value sets are filled.
//
//  IBUpdate - Boolean - if True, it is necessary to write data without doing unnecessary redundant 
//                            actions with the data.
//                            See InfobaseUpdate.WriteData. 
//
Procedure UpdateAccessValuesSets(ReferenceOrObject, HasChanges = Undefined, IBUpdate = False) Export
	
	SetPrivilegedMode(True);
	
	Object = ?(ReferenceOrObject = ReferenceOrObject.Ref, ReferenceOrObject.GetObject(), ReferenceOrObject);
	ObjectRef = Object.Ref;
	ValueTypeObject = TypeOf(Object);
	
	SetsRecorded = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
		"WriteAccessValuesSets").Get(ValueTypeObject) <> Undefined;
	
	If NOT SetsRecorded Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Неверные параметры.
			           |Тип объекта ""%1""
			           |не найден в подписке на события
			           |""Записать наборы значений доступа"".'; 
			           |en = 'Incorrect parameters.
			           |Object type ""%1""
			           |is not found in event subscription
			           |""Write access value sets"".'; 
			           |pl = 'Nieprawidłowe ustawienia.
			           |Obiekt typu ""%1""
			           |nie znaleziono w subskrypcji wydarzeń
			           |""Zapisz zestawy znaczeń dostępu"".';
			           |es_ES = 'Parámetros incorrectos.
			           |Tipo del objeto ""%1""
			           |no se ha encontrado en la suscripción de eventos
			           | ""Guardar conjuntos de valores de acceso"".';
			           |es_CO = 'Parámetros incorrectos.
			           |Tipo del objeto ""%1""
			           |no se ha encontrado en la suscripción de eventos
			           | ""Guardar conjuntos de valores de acceso"".';
			           |tr = 'Yanlış parametreler. %1""Erişim değeri kümeleri yaz"" 
			           |olaylarına aboneliklerde 
			           |Ntürü "
" bulunmadı.';
			           |it = 'Parametri errati.
			           |Il tipo di Oggetto ""%1""
			           |non è stato trovato nella registrazione dell''evento
			           |""Registrare set valori di accesso"".';
			           |de = 'Ungültige Parameter.
			           |Der Objekttyp ""%1""
			           |wurde in der Subskription des Ereignisses
			           |""Aufzeichnen von Zugriffswerte-Sets"" nicht gefunden.'"),
			ValueTypeObject);
		Raise ErrorText;
	EndIf;
	
	If Metadata.InformationRegisters.AccessValuesSets.Dimensions.Object.Type.Types().Find(TypeOf(ObjectRef)) = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Ошибка при записи наборов значений доступа:
			           |в регистре сведений AccessValuesSets в измерении Object
			           |не задан тип %1'; 
			           |en = 'An error occurred when writing access value sets:
			           |in the AccessValuesSets information register in dimension 
			           |Object, type %1 is not specified'; 
			           |pl = 'Błąd podczas zapisywania zestawów wartości dostępu:
			           |w rejestrze informacji AccessValuesSets w wymiarze Object
			           |nie został określony typ %1';
			           |es_ES = 'Error al guardar los conjuntos de valores de acceso: 
			           |en el registro de información AccessValuesSets en la dimensión Object
			           |no se ha establecido el tipo %1';
			           |es_CO = 'Error al guardar los conjuntos de valores de acceso: 
			           |en el registro de información AccessValuesSets en la dimensión Object
			           |no se ha establecido el tipo %1';
			           |tr = 'Erişim değeri kümeleri yazılırken hata oluştu:
			           |AccessValuesSets bilgi kaydında Object boyutunda
			           |%1 türü belirtilmedi';
			           |it = 'Si è verificato un errore durante la registrazione dei set di valori di accesso:
			           |nel registro indormazioni AccessValuesSets nella dimensione
			           |Oggetto, il tipo %1 non è indicato';
			           |de = 'Fehler beim Schreiben von Zugriffswerte-Sets:
			           |im Informationsregister AccessValuesSets in der Dimension Object
			           |ist kein Typ %1 angegeben'"),
			ObjectRef.Metadata().FullName());
		Raise ErrorText;
	EndIf;
	
	If ObjectRef.Metadata().TabularSections.Find("AccessValuesSets") <> Undefined Then
		// Object update is required.
		Table = GetAccessValuesSetsOfTabularSection(Object);
		
		If AccessValuesSetsOfTabularSectionChanged(ObjectRef, Table) Then
			PrepareAccessValuesSetsForWrite(Undefined, Table, False);
			
			Object.AdditionalProperties.Insert("WriteAccessValuesSets");
			Object.AdditionalProperties.Insert("WriteDependentAccessValuesSets");
			Object.AdditionalProperties.Insert("AccessValuesSetsOfTabularSectionAreFilled");
			Object.AccessValuesSets.Load(Table);
			If IBUpdate Then
				Object.AdditionalProperties.Insert("WriteAccessValueSetsOnUpdateIB");
				InfobaseUpdate.WriteData(Object);
			Else
				Object.DataExchange.Load = True;
				Object.Write();
			EndIf;
			HasChanges = True;
		EndIf;
	EndIf;
	
	// Object update is not required, or it has already been updated.
	WriteAccessValuesSets(Object, HasChanges, IBUpdate);
	
EndProcedure

// Fills auxiliary data that speeds up access restriction template operations.
//  It is executed before writing to the AccessValuesSets register.
//
// Parameters:
//  ObjectRef - CatalogRef.*, DocumentRef.*, ...
//  Table - ValueTable.
//
Procedure PrepareAccessValuesSetsForWrite(ObjectRef, Table, AddCacheAttributes = False) Export
	
	If AddCacheAttributes Then
		
		Table.Columns.Add("Object", Metadata.InformationRegisters.AccessValuesSets.Dimensions.Object.Type);
		Table.Columns.Add("StandardValue", New TypeDescription("Boolean"));
		Table.Columns.Add("ValueWithoutGroups", New TypeDescription("Boolean"));
		
		AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
		
		AccessValuesTypesWithGroups = AccessKindsProperties.AccessValuesTypesWithGroups;
		AccessValuesTypes          = AccessKindsProperties.ByValuesTypes;
	EndIf;
	
	// Normalizing Read, Update resources
	SetNumber = -1;
	For each Row In Table Do
		
		If AddCacheAttributes Then
			// Setting the Object dimension value.
			Row.Object = ObjectRef;
			
			AccessValueType = TypeOf(Row.AccessValue);
			
			If AccessValuesTypes.Get(AccessValueType) <> Undefined Then
				Row.StandardValue = True;
				If AccessValuesTypesWithGroups.Get(AccessValueType) = Undefined Then
					Row.ValueWithoutGroups = True;
				EndIf;
			EndIf;
			
		EndIf;
		
		// Clearing rights and matching secondary data for all rows of each set except for the first row.
		// 
		If SetNumber = Row.SetNumber Then
			Row.Read    = False;
			Row.Update = False;
		Else
			SetNumber = Row.SetNumber;
		EndIf;
	EndDo;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Procedures and functions for actions performed upon changing subsystem settings.

// Enables data filling for access restriction and updates some data immediately if necessary.
// 
//
// The procedure is called from the OnWrite handler of the LimitAccessAtRecordLevel constant.
//
Procedure OnChangeAccessRestrictionAtRecordLevel(AccessRestrictionAtRecordLevelEnabled) Export
	
	SetPrivilegedMode(True);
	
	If AccessRestrictionAtRecordLevelEnabled Then
		
		WriteLogEvent(
			NStr("ru = 'Управление доступом.Заполнение данных для ограничения доступа'; en = 'Access management.Data filling for access restriction'; pl = 'Zarządzanie dostępem. Wprowadzenie danych w celu ograniczenia dostępu';es_ES = 'Gestión de acceso.Población de datos para la restricción de acceso';es_CO = 'Gestión de acceso.Población de datos para la restricción de acceso';tr = 'Erişim yönetimi. Erişim kısıtlaması için veri doldurulması';it = 'Gestione accesso. Compilazione dati per restrizioni all''accesso';de = 'Zugriffsverwaltung. Datenausfüllung für Zugriffsbeschränkung'",
			     CommonClientServer.DefaultLanguageCode()),
			EventLogLevel.Information,
			,
			,
			NStr("ru = 'Начато заполнение данных для ограничения доступа.'; en = 'Data filling for access restriction is started.'; pl = 'Rozpoczęto wprowadzenia danych w celu ograniczenia dostępu.';es_ES = 'Población de datos para la restricción de acceso se ha empezado.';es_CO = 'Población de datos para la restricción de acceso se ha empezado.';tr = 'Erişim kısıtlaması için veri doldurulma işlemi başladı.';it = 'La compilazione dati per la restrizione accesso è stata avviata.';de = 'Die Datenpopulation für die Zugriffsbeschränkung wird gestartet.'"),
			EventLogEntryTransactionMode.Transactional);
		
		SetDataFillingForAccessRestriction(True);
	EndIf;
	
	// Updating session parameters.
	// It is required so that the administrator does not have to restart.
	SpecifiedParameters = New Array;
	SessionParametersSetting("", SpecifiedParameters);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Management of AccessKinds and AccessValues tables in edit forms.

// Fills the auxiliary data required for the form. The data does not depend on the object content or 
// filled for a new object.
//
// The form has to contain the attributes listed below.
// Attributes marked with an asterisk (*) are filled automatically, but they must be created in the form.
// Attributes marked with a number sign (#) must be created in the form if the CurrentAccessGroup 
// attribute is to be created in the form (see below).
// Attributes marked with the at sign (@) are created automatically.
//
//  CurrentAccessGroup - an optional attribute, it is not used unless created in the form.
//                         
//
//  AccessKinds - a table with the following fields:
//    #AccessGroup - CatalogRef.AccessGroups,
//    AccessKind - DefinedType.AccessValue,
//    PresetAccessKind - Boolean (for the profile only),
//    AllAllowed - Boolean,
//    *AccessKindPresentation - String - a setting presentation,
//    *AllAllowedPresentation - String - a setting presentation,
//    @IsInUse - Boolean.
//
//  AccessValues - a table with the following fields:
//    #AccessGroup - CatalogRef.AccessGroups,
//    *AccessKind - DefinedType.AccessValue,
//    AccessValue - DefinedType.AccessValue,
//    *RowNumberByKind - Number.
//
//  *EnableExternalUsers - Boolean - an attribute will be created if it is not in the form.
//  *AccessKindLabel - String - a presentation of the current access kind in the form.
//  @IsAccessGroupsProfile - Boolean.
//  @CurrentAccessKind - DefinedType.AccessValue.
//  @CurrentTypesOfValuesToSelect - ValueList.
//  @CurrentTypeOfValuesToSelect - DefinedType.AccessValue.
//  @TablesStorageAttributeName - String.
//  @AccessKindUsers - DefinedType.AccessValue.
//  @AccessKindExternalUsers - DefinedType.AccessValue.
//  
//  @AllAccessKinds - a table with the following fields:
//    @Ref - DefinedType.AccessValue,
//    @Presentation - String
//    @IsInUse - Boolean
//
//  @PresentationsAllAllowed - a table with the following fields:
//    @Name - String
//    @Presentation - String
//
//  @AllTypesOfValuesToSelect - a table with the following fields:
//    @AccessKind - DefinedType.AccessValue
//    @ValuesType - DefinedType.AccessValue
//    @TypePresentation - String
//    @TableName - String
//
// Parameters:
//  Form - ClientApplicationForm that must be set up to edit allowed values.
//               
//
//  IsProfile - Boolean - indicates that access kinds can be set up, also settings presentation 
//               contains 4 values, not 2.
//
//  TablesStorageAttributeName - a row containing, for example, the Object row that contains the 
//               AccessKinds and AccessValues tables (see below).
//               If a blank row is specified, the tables are considered to be stored in the form 
//               attributes.
//
Procedure OnCreateAtServerAllowedValuesEditForm(Form, ThisProfile = False, TablesStorageAttributeName = "Object") Export
	
	AddAuxiliaryDataAttributesToForm(Form, TablesStorageAttributeName);
	
	Form.TablesStorageAttributeName = TablesStorageAttributeName;
	Form.IsAccessGroupProfile = ThisProfile;
	
	// Filling access value types of all access kinds.
	For each AccessKindProperties In AccessKindProperties() Do
		For each Type In AccessKindProperties.TypesOfValuesToSelect Do
			TypesArray = New Array;
			TypesArray.Add(Type);
			TypeDetails = New TypeDescription(TypesArray);
			
			TypeMetadata = Metadata.FindByType(Type);
			If Metadata.Enums.Find(TypeMetadata.Name) = TypeMetadata Then
				TypePresentation = TypeMetadata.Presentation();
			Else
				TypePresentation = ?(ValueIsFilled(TypeMetadata.ObjectPresentation),
					TypeMetadata.ObjectPresentation,
					TypeMetadata.Presentation());
			EndIf;
			
			NewRow = Form.AllTypesOfValuesToSelect.Add();
			NewRow.AccessKind        = AccessKindProperties.Ref;
			NewRow.ValuesType       = TypeDetails.AdjustValue(Undefined);
			NewRow.TypePresentation = TypePresentation;
			NewRow.TableName        = TypeMetadata.FullName();
		EndDo;
	EndDo;
	
	Form.AccessKindUsers           = Catalogs.Users.EmptyRef();
	Form.AccessKindExternalUsers    = Catalogs.ExternalUsers.EmptyRef();
	Form.UseExternalUsers = ExternalUsers.UseExternalUsers();
	
	FillTableAllAccessKindsInForm(Form);
	
	FillPresentationTableAllAllowedInForm(Form, ThisProfile);
	
	ApplyTableAccessKindsInForm(Form);
	
	DeleteNonExistentAccessKindsAndValues(Form);
	AccessManagementInternalClientServer.FillAccessKindsPropertiesInForm(Form);
	
	RefreshUnusedAccessKindsRepresentation(Form, True);
	
	StandardSubsystemsServer.SetGroupTitleRepresentation(
		Form, "AccessValuesByAccessKind");
	
	// Parameter settings of access value selection.
	ChoiceParameters = New Array;
	ChoiceParameters.Add(New ChoiceParameter("IsAccessValueSelection", True));
	Form.Items.AccessValuesAccessValue.ChoiceParameters = New FixedArray(ChoiceParameters);
	
EndProcedure

// When rereading data, it fills or updates required auxiliary data that depends on the object 
// content.
//
Procedure OnRereadAtServerAllowedValuesEditForm(Form, CurrentObject) Export
	
	DeleteNonExistentAccessKindsAndValues(Form, CurrentObject);
	DeleteNonExistentAccessKindsAndValues(Form);
	
	AccessManagementInternalClientServer.FillAccessKindsPropertiesInForm(Form);
	
	AccessManagementInternalClientServer.OnChangeCurrentAccessKind(Form, False);
	
EndProcedure

// Deletes unused access values before writing.
// Unused access values are sometimes created when you replace or delete an access kind with filled 
// access values.
//
Procedure BeforeWriteAtServerAllowedValuesEditForm(Form, CurrentObject) Export
	
	DeleteExcessAccessValues(Form, CurrentObject);
	DeleteExcessAccessValues(Form);
	
EndProcedure

// Updates access kind properties.
Procedure AfterWriteAtServerAllowedValuesEditForm(Form, CurrentObject, WriteParameters) Export
	
	AccessManagementInternalClientServer.FillAccessKindsPropertiesInForm(Form);
	
EndProcedure

// Hides or shows unused access kinds.
Procedure RefreshUnusedAccessKindsRepresentation(Form, OnCreateAtServer = False) Export
	
	Items = Form.Items;
	
	If Not OnCreateAtServer Then
		Items.SnowUnusedAccessKinds.Check =
			NOT Items.SnowUnusedAccessKinds.Check;
	EndIf;
	
	Filter = AccessManagementInternalClientServer.FilterInAllowedValuesEditFormTables(
		Form);
	
	If Not Items.SnowUnusedAccessKinds.Check Then
		Filter.Insert("Used", True);
	EndIf;
	
	Items.AccessKinds.RowFilter = New FixedStructure(Filter);
	
	Items.AccessKindsAccessKindPresentation.ChoiceList.Clear();
	
	For each Row In Form.AllAccessKinds Do
		
		If Not Items.SnowUnusedAccessKinds.Check
		   AND Not Row.Used Then
			
			Continue;
		EndIf;
		
		Items.AccessKindsAccessKindPresentation.ChoiceList.Add(Row.Presentation);
	EndDo;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Universal procedures and functions.

// For internal use only.
Procedure SetFilterCriterionInQuery(Val Query, Val Values, Val ValuesParameterName, Val ParameterNameFilterConditionsFieldName) Export
	
	If Values = Undefined Then
		
	ElsIf TypeOf(Values) <> Type("Array")
	        AND TypeOf(Values) <> Type("FixedArray") Then
		
		Query.SetParameter(ValuesParameterName, Values);
		
	ElsIf Values.Count() = 1 Then
		Query.SetParameter(ValuesParameterName, Values[0]);
	Else
		Query.SetParameter(ValuesParameterName, Values);
	EndIf;
	
	For RowNumber = 1 To StrLineCount(ParameterNameFilterConditionsFieldName) Do
		CurrentRow = StrGetLine(ParameterNameFilterConditionsFieldName, RowNumber);
		If NOT ValueIsFilled(CurrentRow) Then
			Continue;
		EndIf;
		SeparatorIndex = StrFind(CurrentRow, ":");
		If SeparatorIndex = 0 Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Ошибка при выполнении процедуры AccessManagement.SetFilterCriterionInQuery().
				           |
				           |В параметре ParameterNameFilterConditionsFieldName не найден разделитель (двоеточие)
				           |в следующей строке формата ""<Имя параметра условия>:<Имя поля>"
"%1"".'; 
				           |en = 'An error occurred when executing the AccessManagement.SetFilterCriterionInQuery() procedure.
				           |
				           |Separator (a colon) is not found in the ParameterNameFilterConditionsFieldName parameter
				           |in the following string of format ""<Condition parameter name>:<Field name>"
"%1"".'; 
				           |pl = 'Błąd podczas wykonywania procedury AccessManagement.SetFilterCriterionInQuery().
				           |
				           |W parametrze ParameterNameFilterConditionsFieldName nie odnaleziony rozdzielnik (dwukropek)
				           |w następującym wierszu formatu ""<Imię parametru warunku>:<Imię pola>""<Field name>"
"%1"".';
				           |es_ES = 'Error al realizar el procedimiento AccessManagement.SetFilterCriterionInQuery().
				           |
				           |En el parámetro NameFilterConditionsFieldName no se ha encontrado separador (dos puntos)
				           |en la siguiente línea del formato ""<Nombre del parámetro de condición>:<Field name>"
"%1"".';
				           |es_CO = 'Error al realizar el procedimiento AccessManagement.SetFilterCriterionInQuery().
				           |
				           |En el parámetro NameFilterConditionsFieldName no se ha encontrado separador (dos puntos)
				           |en la siguiente línea del formato ""<Nombre del parámetro de condición>:<Field name>"
"%1"".';
				           |tr = 'ErişimYönetimi prosedürü yürütülürken bir hata oluştu. TalepteSeçimKoşulunuBelirle (). 
				           |
				           |ParametreAdıSeçimKoşullarıAlanAdı 
				           |parametresinde ""<Koşul parametresinin adı> formatın satırında ayırıcı (iki nokta) bulunamadı: <Alan adı>"" ""%1"
".';
				           |it = 'Si è verificato un errore durante l''esecuzione della procedura AccessManagement.SetFilterCriterionInQuery().
				           |
				           |Il separatore (due punti) non è stato trovato nel parametro ParameterNameFilterConditionsFieldName 
				           |nella seguente stringa di formato ""<Nome del parametro della condizione>:<Nome del campo>"
"%1"".';
				           |de = 'Beim Ausführen der AccessManagement.SetFilterCriterionInQuery() ist ein Fehler aufgetreten.
				           |
				           |Im Parameter ParameterNameFilterConditionsFieldName wurde das Trennzeichen (Doppelpunkt)
				           |in der folgenden Zeile des Formats ""<Name des Bedingungsparameters>: <Field name>"
"%1"" nicht gefunden.'"),
				CurrentRow);
			Raise ErrorText;
		EndIf;
		FilterCriterionParameterName = Left(CurrentRow, SeparatorIndex-1);
		FieldName = Mid(CurrentRow, SeparatorIndex+1);
		If Values = Undefined Then
			FilterCriterion = "True";
			
		ElsIf TypeOf(Values) <> Type("Array")
		        AND TypeOf(Values) <> Type("FixedArray") Then
			
			FilterCriterion = FieldName + " = &" + ValuesParameterName;
			
		ElsIf Values.Count() = 1 Then
			FilterCriterion = FieldName + " = &" + ValuesParameterName;
		Else
			FilterCriterion = FieldName + " IN (&" + ValuesParameterName + ")";
		EndIf;
		Query.Text = StrReplace(Query.Text, FilterCriterionParameterName, FilterCriterion);
	EndDo;
	
EndProcedure

// Updates a record set in the database if the set records do not match the database records.
// 
//
// Parameters:
//  Data - Structure - with the following properties:
//    * RecordSet - a blank or read RecordSet with or without set filter.
//                              Register manager to create a record set.
//
//    * NewRecords - a ValueTable in a register format.
//
//    * ComparisonFields - String - contains a list of fields whose values are required to calculate 
//                               record set differences. For example, "Dimension1, Dimension2, 
//                               Resource1" but DimensionData attribute does not belong to the list.
//
//    * FilterField - Undefined - an entire registry is written or the filter is already set in a 
//                                              record set.
//                               String - a field name, for which the filter is to be set.
//
//    * FilterValue - a value that will be set as a filter by a filter field if the filter field is 
//                               set.
//
//    * RecordSetRead - Boolean, if True, then not specified record set already contains the read 
//                               records. Data lock of these records is set and transaction is open.
//                               
//
//    * CheckOnly - Boolean - if True, do not write, only find out if writing is required and set 
//                               the HasChanges property.
//                               
//
//    * AdditionalProperties - Undefined, Structure. If Structure, all structure parameters will be 
//                               added to the AdditionalProperties property of the 
//                               <Register*>RecordSet objects.
//
//    * IBUpdate - Boolean - if True, write data without performing unnecessary and redundant 
//                               actions with the data.
//                               See InfobaseUpdate.WriteData. 
//                               If the property is not inserted, the value is calculated by Or using the following functions:
//                               InfobaseUpdateInProgress and IsCallFromUpdateHandler of the 
//                               InfobaseUpdate common module.
//
//  HasChanges - Boolean (return value) - if recorded, True is set, otherwise, it does not change.
//                          
//
//  ModifiedRecords - Undefined - no actions, otherwise, it returns a value table in the register 
//                          format with the RowChangeKind field of the Number type (-1 the record is 
//                          deleted, 1 the record is added).
//
Procedure UpdateRecordSet(Val Data, HasChanges = Undefined, ModifiedRecords = Undefined) Export
	
	AllParameters = New Structure;
	AllParameters.Insert("RecordSet");
	AllParameters.Insert("NewRecords");
	AllParameters.Insert("ComparisonFields");
	AllParameters.Insert("FilterField");
	AllParameters.Insert("FilterValue");
	AllParameters.Insert("RecordSetRead", False);
	AllParameters.Insert("NoOverwriting", False);
	AllParameters.Insert("CheckOnly", False);
	AllParameters.Insert("AdditionalProperties");
	AllParameters.Insert("IBUpdate",
		    InfobaseUpdate.InfobaseUpdateInProgress()
		Or InfobaseUpdate.IsCallFromUpdateHandler());
	
	FillParameters(Data, AllParameters, "RecordSet, NewRecords");
	
	FullRegisterName = Metadata.FindByType(TypeOf(Data.RecordSet)).FullName();
	RegisterManager = Common.ObjectManagerByFullName(FullRegisterName);
	If Data.RecordSet = RegisterManager Then
		Data.RecordSet = RegisterManager.CreateRecordSet();
	EndIf;
	
	If ValueIsFilled(Data.FilterField) Then
		SetFilter(Data.RecordSet.Filter[Data.FilterField], Data.FilterValue);
	EndIf;
	
	If NOT Data.RecordSetRead Then
		LockRecordSetArea(Data.RecordSet, FullRegisterName);
		Data.RecordSet.Read();
	EndIf;
	
	Data.ComparisonFields = ?(Data.ComparisonFields = Undefined,
		RecordSetFields(Data.RecordSet), Data.ComparisonFields);
	
	If Data.NoOverwriting Then
		SingleRecordSet = RegisterManager.CreateRecordSet();
		RecordKeyDetails = AccessManagementInternalCached.RecordKeyDetails(FullRegisterName);
		FilterRecords = New Structure(RecordKeyDetails.FieldsString);
		OtherDimensionsFields = New Array;
		For each Field In RecordKeyDetails.FieldArray Do
			If Field <> Data.FilterField Then
				OtherDimensionsFields.Add(Field);
			EndIf;
		EndDo;
		RecordsToDelete = New ValueTable;
		For each Field In OtherDimensionsFields Do
			RecordsToDelete.Columns.Add(Field);
		EndDo;
		Data.NewRecords = Data.NewRecords.Copy();
	EndIf;
	
	HasCurrentChanges = False;
	If ModifiedRecords = Undefined Then
		If Data.RecordSet.Count() = Data.NewRecords.Count() OR Data.NoOverwriting Then
			Filter = New Structure(Data.ComparisonFields);
			Data.NewRecords.Indexes.Add(Data.ComparisonFields);
			For each Record In Data.RecordSet Do
				FillPropertyValues(Filter, Record);
				FoundRows = Data.NewRecords.FindRows(Filter);
				If FoundRows.Count() = 0 Then
					HasCurrentChanges = True;
					HasChanges = True;
					If Data.NoOverwriting Then
						FillPropertyValues(FilterRecords, Record);
						If Data.NewRecords.FindRows(FilterRecords).Count() = 0 Then
							FillPropertyValues(RecordsToDelete.Add(), FilterRecords);
						EndIf;
					Else
						Break;
					EndIf;
				ElsIf Data.NoOverwriting Then
					Data.NewRecords.Delete(FoundRows[0]);
				EndIf;
			EndDo;
			If Data.NoOverwriting AND Data.NewRecords.Count() > 0 Then
				HasCurrentChanges = True;
				HasChanges = True;
			EndIf;
		Else
			HasCurrentChanges = True;
			HasChanges = True;
		EndIf;
	Else
		If Data.RecordSet.Count() <> Data.NewRecords.Count() Then
			HasCurrentChanges = True;
			HasChanges = True;
		EndIf;
		If Data.RecordSet.Count() > Data.NewRecords.Count() Then
			ModifiedRecords = Data.RecordSet.Unload();
			SearchedRecords   = Data.NewRecords;
			RowChangeKind = -1;
		Else
			ModifiedRecords = Data.NewRecords.Copy();
			SearchedRecords   = Data.RecordSet.Unload();
			RowChangeKind = 1;
		EndIf;
		ModifiedRecords.Columns.Add("RowChangeKind", New TypeDescription("Number"));
		ModifiedRecords.FillValues(RowChangeKind, "RowChangeKind");
		RowChangeKind = ?(RowChangeKind = 1, -1, 1);
		Filter = New Structure(Data.ComparisonFields);
		
		For each Row In SearchedRecords Do
			FillPropertyValues(Filter, Row);
			Rows = ModifiedRecords.FindRows(Filter);
			If Rows.Count() = 0 Then
				NewRow = ModifiedRecords.Add();
				FillPropertyValues(NewRow, Filter);
				NewRow.RowChangeKind = RowChangeKind;
				HasCurrentChanges = True;
				HasChanges = True;
			Else
				ModifiedRecords.Delete(Rows[0]);
			EndIf;
		EndDo;
	EndIf;
	
	If HasCurrentChanges Then
		If Data.CheckOnly Then
			Return;
		EndIf;
		If Data.NoOverwriting Then
			SetAdditionalProperties(SingleRecordSet, Data.AdditionalProperties);
			For each Row In RecordsToDelete Do
				If ValueIsFilled(Data.FilterField) Then
					SetFilter(SingleRecordSet.Filter[Data.FilterField], Data.FilterValue);
				EndIf;
				For each Field In OtherDimensionsFields Do
					SetFilter(SingleRecordSet.Filter[Field], Row[Field]);
				EndDo;
				WriteObjectOrRecordSet(Data, SingleRecordSet);
			EndDo;
			SingleRecordSet.Add();
			For each Row In Data.NewRecords Do
				If ValueIsFilled(Data.FilterField) Then
					SetFilter(SingleRecordSet.Filter[Data.FilterField], Data.FilterValue);
				EndIf;
				For each Field In OtherDimensionsFields Do
					SetFilter(SingleRecordSet.Filter[Field], Row[Field]);
				EndDo;
				FillPropertyValues(SingleRecordSet[0], Row);
				WriteObjectOrRecordSet(Data, SingleRecordSet);
			EndDo;
		Else
			SetAdditionalProperties(Data.RecordSet, Data.AdditionalProperties);
			Data.RecordSet.Load(Data.NewRecords);
			WriteObjectOrRecordSet(Data, Data.RecordSet);
		EndIf;
	EndIf;
	
EndProcedure

// Updates register rows with a multiple-value filter for one or two register dimensions. Checks for 
// changes; if no changes are found, no data is overwritten.
// 
//
// Parameters:
//  Data - Structure - with the following properties:
//    * RegisterManager - a register manager used to create the <Register*>RecordSet type.
//
//    * NewRecords - a ValueTable in a register format.
//
//    * ComparisonFields - String - contains a list of fields whose values are required to calculate 
//                                  record set differences, for example, Dimension1, Dimension2,
//                                  Source1. The ChangeDate attribute is not included in the list.
//
//    * FirstDimensionName - Undefined - there is no filter by dimension.
//                                  String - contains the first dimension name, for which multiple 
//                                                 values are set.
//
//    * FirstDimensionValues  - Undefined - there is no filter by dimension, similar to
//                                                 FirstDimensionName = Undefined.
//                                  AnyRef - contains one register filter value for the records 
//                                                 being updated.
//                                  Array       - contains a register filter value array for the 
//                                                 records being updated. If the array is blank, no 
//                                                 action is required.
//
//    * SecondDimensionName       - similar to FirstDimensionName.
//    * SecondDimensionValues  - similar to FirstDimensionValues.
//    * ThirdDimensionName      - similar to FirstDimensionName.
//    * ThirdDimensionValues - similar to FirstDimensionValues.
//
//    * CheckOnly            - Boolean - if True, do not write, only find out if writing is required 
//                                  and set the HasChanges property.
//                                  
//
//    * AdditionalProperties    - Undefined, Structure. If Structure,  all structure parameters will 
//                                  be added to the 
//                                  AdditionalProperties all structure parameters will be inserted.
//
//    * IBUpdate              - Boolean - if True, write data without performing unnecessary and 
//                                  redundant actions with the data.
//                                  See InfobaseUpdate.WriteData. 
//                                  If the property is not inserted, the value is calculated by Or using the following functions:
//                                  InfobaseUpdateInProgress and IsCallFromUpdateHandler of the 
//                                  InfobaseUpdate common module.
//
//  HasChanges             - Boolean (return value) - if recorded, True is set, otherwise, it does 
//                              not change.
//
Procedure UpdateRecordSets(Val Data, HasChanges) Export
	
	AllParameters = New Structure;
	AllParameters.Insert("RegisterManager");
	AllParameters.Insert("NewRecords");
	AllParameters.Insert("ComparisonFields");
	AllParameters.Insert("FirstDimensionName");
	AllParameters.Insert("FirstDimensionValues");
	AllParameters.Insert("SecondDimensionName");
	AllParameters.Insert("SecondDimensionValues");
	AllParameters.Insert("ThirdDimensionName");
	AllParameters.Insert("ThirdDimensionValues");
	AllParameters.Insert("NewRecordsContainOnlyDifferences", False);
	AllParameters.Insert("FixedFilter");
	AllParameters.Insert("CheckOnly", False);
	AllParameters.Insert("AdditionalProperties");
	AllParameters.Insert("IBUpdate",
		    InfobaseUpdate.InfobaseUpdateInProgress()
		Or InfobaseUpdate.IsCallFromUpdateHandler());
	
	FillParameters(Data, AllParameters, "RegisterManager, NewRecords");
	
	// Preprocessing parameters.
	
	If NOT DimensionParametersGroupProcessed(Data.FirstDimensionName, Data.FirstDimensionValues) Then
		HasChanges = True;
		Return;
	EndIf;
	If NOT DimensionParametersGroupProcessed(Data.SecondDimensionName, Data.SecondDimensionValues) Then
		HasChanges = True;
		Return;
	EndIf;
	If NOT DimensionParametersGroupProcessed(Data.ThirdDimensionName, Data.ThirdDimensionValues) Then
		HasChanges = True;
		Return;
	EndIf;
	
	OrderDimensionsParametersGroups(Data);
	
	// Checking and updating data.
	Data.Insert("RecordSet",       Data.RegisterManager.CreateRecordSet());
	Data.Insert("RegisterMetadata", Metadata.FindByType(TypeOf(Data.RecordSet)));
	Data.Insert("FullRegisterName",  Data.RegisterMetadata.FullName());
	
	If Data.NewRecordsContainOnlyDifferences Then
		Data.Insert("SetForSingleRecord", Data.RegisterManager.CreateRecordSet());
	EndIf;
	
	If Data.FixedFilter <> Undefined Then
		For each KeyAndValue In Data.FixedFilter Do
			SetFilter(Data.RecordSet.Filter[KeyAndValue.Key], KeyAndValue.Value);
		EndDo;
	EndIf;
	
	If Data.NewRecordsContainOnlyDifferences Then
		
		If Data.FirstDimensionName = Undefined Then
			ErrorText = NStr("ru = 'Некорректные параметры в процедуре UpdateRecordSets.'; en = 'Invalid UpdateRecordSets procedure parameters.'; pl = 'Niepoprawne parametry w procedurze UpdateRecordSets.';es_ES = 'Parámetros incorrectos en el procedimiento UpdateRecordsets.';es_CO = 'Parámetros incorrectos en el procedimiento UpdateRecordsets.';tr = 'UpdateRecordSets prosedüründe yanlış parametreler.';it = 'Parametri incorretti nella procedura AggiornareSetRegistrazioni.';de = 'Falsche Parameter in der Prozedur UpdateRecordSets.'");
			Raise ErrorText;
		Else
			If Data.SecondDimensionName = Undefined Then
				RecordByMultipleSets = False;
			Else
				RecordByMultipleSets = RecordByMultipleSets(
					Data, New Structure, Data.FirstDimensionName, Data.FirstDimensionValues);
			EndIf;
			
			If RecordByMultipleSets Then
				FieldsList = Data.FirstDimensionName + ", " + Data.SecondDimensionName;
				Data.NewRecords.Indexes.Add(FieldsList);
				
				CountByFirstDimensionValues = Data.CountByValues;
				
				For each FirstValue In Data.FirstDimensionValues Do
					Filter = New Structure(Data.FirstDimensionName, FirstValue);
					SetFilter(Data.RecordSet.Filter[Data.FirstDimensionName], FirstValue);
					
					If Data.ThirdDimensionName = Undefined Then
						RecordByMultipleSets = False;
					Else
						RecordByMultipleSets = RecordByMultipleSets(
							Data, Filter, Data.SecondDimensionName, Data.SecondDimensionValues);
					EndIf;
					
					If RecordByMultipleSets Then
						For each SecondValue In Data.SecondDimensionValues Do
							Filter.Insert(Data.SecondDimensionName, SecondValue);
							SetFilter(Data.RecordSet.Filter[Data.SecondDimensionName], SecondValue);
							
							// Updating by three dimensions.
							RefreshNewSetRecordsByVariousNewRecords(Data, Filter, HasChanges);
						EndDo;
						Data.RecordSet.Filter[Data.SecondDimensionName].Use = False;
					Else
						// Updating by two dimensions.
						Data.Insert("CountByValues", CountByFirstDimensionValues);
						RefreshNewSetRecordsByVariousNewRecords(Data, Filter, HasChanges);
					EndIf;
				EndDo;
			Else
				// Updating by one dimension.
				ReadCountForReading(Data);
				RefreshNewSetRecordsByVariousNewRecords(Data, New Structure, HasChanges);
			EndIf;
		EndIf;
	Else
		If Data.FirstDimensionName = Undefined Then
			// Updating all records.
			
			CurrentData = New Structure("RecordSet, NewRecords, ComparisonFields,
				|CheckOnly, AdditionalProperties, IBUpdate");
			FillPropertyValues(CurrentData, Data);
			UpdateRecordSet(CurrentData, HasChanges);
			
		ElsIf Data.SecondDimensionName = Undefined Then
			// Updating by one dimension.
			Filter = New Structure(Data.FirstDimensionName);
			For each Value In Data.FirstDimensionValues Do
				
				SetFilter(Data.RecordSet.Filter[Data.FirstDimensionName], Value);
				Filter[Data.FirstDimensionName] = Value;
				
				If Data.FirstDimensionValues.Count() <> 1 Then
					NewSetRecords = Data.NewRecords;
				Else
					NewSetRecords = Data.NewRecords.Copy(Filter);
				EndIf;
				
				CurrentData = New Structure("RecordSet, ComparisonFields,
					|CheckOnly, AdditionalProperties, IBUpdate");
				FillPropertyValues(CurrentData, Data);
				CurrentData.Insert("NewRecords", NewSetRecords);
				
				UpdateRecordSet(CurrentData, HasChanges);
			EndDo;
			
		ElsIf Data.ThirdDimensionName = Undefined Then
			// Updating by two dimensions.
			FieldsList = Data.FirstDimensionName + ", " + Data.SecondDimensionName;
			Data.NewRecords.Indexes.Add(FieldsList);
			Filter = New Structure(FieldsList);
			
			For each FirstValue In Data.FirstDimensionValues Do
				SetFilter(Data.RecordSet.Filter[Data.FirstDimensionName], FirstValue);
				Filter[Data.FirstDimensionName] = FirstValue;
				
				UpdateNewSetRecordsByAllNewRecords(
					Data,
					Filter,
					FieldsList,
					Data.SecondDimensionName,
					Data.SecondDimensionValues,
					HasChanges);
			EndDo;
		Else
			// Updating by three dimensions.
			FieldsList = Data.FirstDimensionName + ", " + Data.SecondDimensionName + ", " + Data.ThirdDimensionName;
			Data.NewRecords.Indexes.Add(FieldsList);
			Filter = New Structure(FieldsList);
			
			For each FirstValue In Data.FirstDimensionValues Do
				SetFilter(Data.RecordSet.Filter[Data.FirstDimensionName], FirstValue);
				Filter[Data.FirstDimensionName] = FirstValue;
				
				For each SecondValue In Data.SecondDimensionValues Do
					SetFilter(Data.RecordSet.Filter[Data.SecondDimensionName], SecondValue);
					Filter[Data.SecondDimensionName] = SecondValue;
					
					UpdateNewSetRecordsByAllNewRecords(
						Data,
						Filter,
						FieldsList,
						Data.SecondDimensionName,
						Data.SecondDimensionValues,
						HasChanges);
				EndDo;
			EndDo;
		EndIf;
	EndIf;
	
EndProcedure

// Updates an information register by data in the RowsChanges value table.
//
// Parameters:
//  Data - Structure - with the following properties:
//
//  * RegisterManager - a register manager used to create the <Register*>RecordSet type.
//
//  * RowComponentsChanges - a ValueTable containing the register fields and the RowChangeKind field 
//                             (Number):
//                                1 means that a row must be added.
//                               -1 means that a row must be deleted.
//
//  * FixedFilter     - Structure containing a dimension name in the key and a filter value in the 
//                             value. It can be used when there are more than 3 dimensions and it is 
//                             known in advance that the dimensions above 3 will have a single value.
//                              Dimensions specified in a fixed filter are not used when generating 
//                             record sets for updating.
//                             
//
//  * FilterDimensions        - a string of comma-separated dimensions that must be used when 
//                             generating record sets for updating (no more than 3).
//                              Any unspecified dimensions will be converted to a fixed filter if 
//                             all their values match.
//                             
//
//  * CheckOnly - Boolean - if True, do not write, only find out if writing is required and set the 
//                             HasChanges property.
//                             
//
//  * AdditionalProperties - Undefined, Structure. If Structure,  all structure parameters will be 
//                             added to the 
//                             AdditionalProperties all structure parameters will be inserted.
//
//  * IBUpdate - Boolean - if True, write data without performing unnecessary and redundant actions 
//                             with the data.
//                             See InfobaseUpdate.WriteData. 
//                             If the property is not inserted, the value is calculated by Or using the following functions:
//                             InfobaseUpdateInProgress and IsCallFromUpdateHandler of the 
//                             InfobaseUpdate common module.
//
//  HasChanges - Boolean (return value) - if recorded, True is set, otherwise, it does not change.
//                          
//
Procedure UpdateInformationRegister(Val Data, HasChanges = Undefined) Export
	
	If Data.EditStringContent.Count() = 0 Then
		Return;
	EndIf;
	
	AllParameters = New Structure;
	AllParameters.Insert("RegisterManager");
	AllParameters.Insert("EditStringContent");
	AllParameters.Insert("FixedFilter", New Structure);
	AllParameters.Insert("FilterDimensions");
	AllParameters.Insert("CheckOnly", False);
	AllParameters.Insert("AdditionalProperties");
	AllParameters.Insert("IBUpdate",
		    InfobaseUpdate.InfobaseUpdateInProgress()
		Or InfobaseUpdate.IsCallFromUpdateHandler());
	
	FillParameters(Data, AllParameters, "RegisterManager, EditStringContent");
	
	RegisterMetadata = Metadata.FindByType(TypeOf(Data.RegisterManager.EmptyKey()));
	RecordKeyDetails = AccessManagementInternalCached.RecordKeyDetails(RegisterMetadata.FullName());
	
	If Data.FilterDimensions <> Undefined Then
		Data.FilterDimensions = New Structure(Data.FilterDimensions);
	EndIf;
	
	FilterDimensionsArray   = New Array;
	FilterDimensionsValues = New Structure;
	ChangeWithoutFixedFilter = New Structure;
	
	For Each Field In RecordKeyDetails.FieldArray Do
		If Not Data.FixedFilter.Property(Field) Then
			Values = TableColumnValues(Data.EditStringContent, Field);
			
			If Values.Count() = 1 Then
				Data.FixedFilter.Insert(Field, Values[0]);
				Continue;
			EndIf;
			
			If Data.FilterDimensions = Undefined
			 Or Data.FilterDimensions.Property(Field) Then
				
				FilterDimensionsArray.Add(Field);
				FilterDimensionsValues.Insert(Field, Values);
				
			ElsIf Not ValueIsFilled(ChangeWithoutFixedFilter) Then
				ChangeWithoutFixedFilter.Insert("Field",     Field);
				ChangeWithoutFixedFilter.Insert("Values", Values);
			EndIf;
		EndIf;
	EndDo;
	
	If FilterDimensionsArray.Count() = 0 Then
		If ValueIsFilled(ChangeWithoutFixedFilter) Then
			Field     = ChangeWithoutFixedFilter.Field;
			Values = ChangeWithoutFixedFilter.Values;
		EndIf;
		FilterDimensionsArray.Add(Field);
		FilterDimensionsValues.Insert(Field, Values);
	EndIf;
	
	Data.Insert("FirstDimensionName", FilterDimensionsArray[0]);
	Data.Insert("FirstDimensionValues", FilterDimensionsValues[Data.FirstDimensionName]);
	
	If FilterDimensionsArray.Count() > 1 Then
		Data.Insert("SecondDimensionName", FilterDimensionsArray[1]);
		Data.Insert("SecondDimensionValues", FilterDimensionsValues[Data.SecondDimensionName]);
	Else
		Data.Insert("SecondDimensionName", Undefined);
		Data.Insert("SecondDimensionValues", Undefined);
	EndIf;
	
	If FilterDimensionsArray.Count() > 2 Then
		Data.Insert("ThirdDimensionName", FilterDimensionsArray[2]);
		Data.Insert("ThirdDimensionValues", FilterDimensionsValues[Data.ThirdDimensionName]);
	Else
		Data.Insert("ThirdDimensionName", Undefined);
		Data.Insert("ThirdDimensionValues", Undefined);
	EndIf;
	
	Data.Insert("ComparisonFields", RecordKeyDetails.FieldsString);
	Data.Insert("NewRecordsContainOnlyDifferences", True);
	Data.Insert("NewRecords", Data.EditStringContent);
	Data.Delete("EditStringContent");
	Data.Delete("FilterDimensions");
	
	UpdateRecordSets(Data, HasChanges);
	
EndProcedure

// Returns a blank reference of a metadata object of a reference type.
//
// Parameters:
//  MetadataObjectDetails - MetadataObject,
//                            - Type used to find a metadata object.
//                            - String - a full metadata object name.
// Returns:
//  Ref.
//
Function MetadataObjectEmptyRef(MetadataObjectDetails) Export
	
	If TypeOf(MetadataObjectDetails) = Type("MetadataObject") Then
		MetadataObject = MetadataObjectDetails;
		
	ElsIf TypeOf(MetadataObjectDetails) = Type("Type") Then
		MetadataObject = Metadata.FindByType(MetadataObjectDetails);
	Else
		MetadataObject = Metadata.FindByFullName(MetadataObjectDetails);
	EndIf;
	
	If MetadataObject = Undefined Then
		ErrorText =
			NStr("ru = 'Ошибка в функции MetadataObjectEmptyRef
			           |общего модуля AccessManagementInternal.
			           |
			           |Неверный параметр MetadataObjectDetails.'; 
			           |en = 'An error occurred in the MetadataObjectEmptyRef
			           |function of the AccessManagementInternal common module.
			           |
			           |Incorrect parameter MetadataObjectDetails.'; 
			           |pl = 'Błąd funkcji MetadataObjectEmptyRef
			           |wspólnego modułu AccessManagementInternal.
			           |
			           |Nieprawidłowy parametr MetadataObjectDetails.';
			           |es_ES = 'Error en la función MetadataObjectEmptyRef
			           |del módulo común AccessManagementInternal.
			           |
			           |Parámetro incorrecto MetadataObjectDetails.';
			           |es_CO = 'Error en la función MetadataObjectEmptyRef
			           |del módulo común AccessManagementInternal.
			           |
			           |Parámetro incorrecto MetadataObjectDetails.';
			           |tr = 'AccessManagementInternal genel modülünün
			           | MetadataObjectEmptyRef işlevinde bir hata oluştu. 
			           |
			           |Yanlış parametre MetadataObjectDetails.';
			           |it = 'Si è verificato un errore nella funzione
			           |MetadataObjectEmptyRef del modulo comune AccessManagementInternal.
			           |
			           |Parametro MetadataObjectDetails incorretto.';
			           |de = 'Fehler in der Funktion MetadataObjectEmptyRef
			           |des allgemeinen Moduls AccessManagementInternal.
			           |
			           |Falscher Parameter Metadaten MetadataObjectDetails.'");
		Raise ErrorText;
	EndIf;
	
	BlankRef = Undefined;
	Try
		ObjectManager = Common.ObjectManagerByFullName(MetadataObject.FullName());
		BlankRef = ObjectManager.EmptyRef();
	Except
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Ошибка в функции MetadataObjectEmptyRef
			           |общего модуля AccessManagementInternal.
			           |
			           |Не удалось получить пустую ссылка для объекта метаданных
			           |""%1"".'; 
			           |en = 'An error occurred in the MetadataObjectEmptyRef function
			           |of the AccessManagementInternal common module.
			           |
			           |Cannot get an empty reference for metadata object
			           |""%1"".'; 
			           |pl = 'Wystąpił błąd
			           |w funkcji MetadataObjectEmptyRef modułu ogólnego AccessManagementInternal.
			           |
			           |Nie można odebrać pustego linku
			           |dla obiektu metadanych ""%1"".';
			           |es_ES = 'Ha ocurrido un error
			           |en la función MetadataObjectEmptyRef del módulo general AccessManagementService.
			           |
			           |No se puede recibir una referencia vacía para
			           |el objeto de metadatos ""%1"".';
			           |es_CO = 'Ha ocurrido un error
			           |en la función MetadataObjectEmptyRef del módulo general AccessManagementService.
			           |
			           |No se puede recibir una referencia vacía para
			           |el objeto de metadatos ""%1"".';
			           |tr = 'AccessManagementInternal genel modülünün
			           |MetadataObjectEmptyRef işlevinde bir hata oluştu.
			           |
			           |Meta veri nesnesi ""%1"" için boş bir ref alınamıyor.
			           |';
			           |it = 'Si è verificato un errore nella funzione
			           |MetadataObjectEmptyRef del modulo comune AccessManagementInternal.
			           |
			           |Impossibile ottenere un riferimento vuoto per l''oggetto di metadati
			           |""%1"".';
			           |de = 'Ein Fehler ist
			           |in der MetadataObjectEmptyRef Funktion des allgemeinen AccessManagementInternal Moduls aufgetreten.
			           |
			           |Es konnte keine leere Referenz für
			           |das Metadatenobjekt ""%1"" empfangen werden.'"),
			MetadataObject.FullName());
		Raise ErrorText;
	EndTry;
	
	Return BlankRef;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Other procedures and functions

// Creates a query to find differences between the register rows in the specified data area (based 
// on filters in the FieldsAndFilter parameter).
//
// Parameters:
//  NewDataSelectionQueryText - String.
//
//  FieldsAndFilter   - an array of Structure type items (FieldName, FilterConditionParameterName).
//
//  FullRegisterName
//               - String - a query for old data is generated automatically.
//                 Undefined - a query for old data is received from the next parameter.
//
//  OldDataSelectionQueryText
//               - String - a query for old data, with nonstandard filters.
//               - Undefined - used when a full register name is defined.
//
// Returns:
//  String - a query text optimized for PostgreSQL DBMS.
//
Function ChangesSelectionQueryText(NewDataSelectionQueryText,
                                    FieldsAndFilter,
                                    FullRegisterName            = Undefined,
                                    TemporaryTablesQueriesText = Undefined,
                                    OldDataSelectionQueryText     = Undefined) Export
	
	// Preparing the old data query text.
	If FullRegisterName <> Undefined Then
		OldDataSelectionQueryText =
		"SELECT
		|	&SelectedFields,
		|	&RowChangeKindFieldSubstitution
		|FROM
		|	FullRegisterName AS OldData
		|WHERE
		|	&FilterConditions";
	EndIf;
	
	FieldsToSelect = "";
	FilterConditions = "True";
	For each FieldDetails In FieldsAndFilter Do
		// Aggregating the selected fields.
		FieldsToSelect = FieldsToSelect + StrReplace(
			"
			|	OldData.Field,",
			"Field",
			KeyAndValue(FieldDetails).Key);
			
		// Assembling filter conditions.
		If ValueIsFilled(KeyAndValue(FieldDetails).Value) Then
			FilterConditions = FilterConditions + StrReplace(
				"
				|	AND &FilterCriterionParameterName", "&FilterCriterionParameterName",
				KeyAndValue(FieldDetails).Value);
		EndIf;
	EndDo;
	
	OldDataSelectionQueryText =
		StrReplace(OldDataSelectionQueryText, "&SelectedFields,",  FieldsToSelect);
	
	OldDataSelectionQueryText =
		StrReplace(OldDataSelectionQueryText, "&FilterConditions",    FilterConditions);
	
	OldDataSelectionQueryText =
		StrReplace(OldDataSelectionQueryText, "FullRegisterName", FullRegisterName);
	
	If StrFind(NewDataSelectionQueryText, "&RowChangeKindFieldSubstitution") = 0 Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Ошибка в значении параметра OldDataSelectionQueryText
			           |процедуры ChangesSelectionQueryText модуля AccessManagementInternal.
			           |
			           |В тексте запроса не найдена строка ""%1"".'; 
			           |en = 'An error occurred in the OldDataSelectionQueryText
			           |parameter value of the ChangesSelectionQueryText procedure of the AccessManagementInternal module.
			           |
			           |The ""%1"" string is not found in the query text.'; 
			           |pl = 'Błąd w ustawieniu parametru OldDataSelectionQueryText
			           | procedury ChangesSelectionQueryText modułu AccessManagementInternal.
			           |
			           |W treści zapytania brakuje wiersza ""%1"".';
			           |es_ES = 'Error en el valor del parámetro OldDataSelectionQueryText
			           |del procedimiento ChangesSelectionQueryText del módulo AccessManagementInternal.
			           |
			           |En el texto de la solicitud no se ha encontrado línea ""%1"".';
			           |es_CO = 'Error en el valor del parámetro OldDataSelectionQueryText
			           |del procedimiento ChangesSelectionQueryText del módulo AccessManagementInternal.
			           |
			           |En el texto de la solicitud no se ha encontrado línea ""%1"".';
			           |tr = 'AccessManagementInternal genel modülünün
			           |ChangesSelectionQueryText prosedürün OldDataSelectionQueryText parametresinin değerinde bir hata oluştu.
			           |
			           |Dize ""%1"" sorgu metninde bulunamadı.';
			           |it = 'Si è verificato un errore nel valore di parametro
			           |OldDataSelectionQueryText della procedura ChangesSelectionQueryText del modulo AccessManagementInternal 
			           |
			           |La stringa ""%1"" non è stata trovata nel testo di query.';
			           |de = 'Fehler im Wert des Parameters OldDataSelectionQueryText
			           |der Prozedur ChangesSelectionQueryText des Moduls AccessManagementInternal.
			           |
			           |Die Zeile ""%1"" wurde nicht im Anforderungstext gefunden.'"),
			"&RowChangeKindFieldSubstitution");
		Raise ErrorText;
	EndIf;
	
	OldDataSelectionQueryText = StrReplace(
		OldDataSelectionQueryText, "&RowChangeKindFieldSubstitution", "-1 AS RowChangeKind");
	
	If StrFind(NewDataSelectionQueryText, "&RowChangeKindFieldSubstitution") = 0 Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Ошибка в значении параметра NewDataSelectionQueryText
			           |процедуры ChangesSelectionQueryText модуля AccessManagementInternal.
			           |
			           |В тексте запроса не найдена строка ""%1"".'; 
			           |en = 'An error occurred in the NewDataSelectionQueryText
			           |parameter value of the ChangesSelectionQueryText procedure of the AccessManagementInternal module.
			           |
			           |The ""%1"" string is not found in the query text.'; 
			           |pl = 'Błąd w ustawieniu parametru NewDataSelectionQueryText
			           |procedury ChangesSelectionQueryText modułu AccessManagementInternal.
			           |
			           |W treści zapytania brakuje wiersza ""%1"".';
			           |es_ES = 'Error en el valor del parámetro NewDataSelectionQueryText
			           |del procedimiento ChangesSelectionQueryText del módulo AccessManagementInternal.
			           |
			           |En el texto de solicitud no se ha encontrado línea ""%1"".';
			           |es_CO = 'Error en el valor del parámetro NewDataSelectionQueryText
			           |del procedimiento ChangesSelectionQueryText del módulo AccessManagementInternal.
			           |
			           |En el texto de solicitud no se ha encontrado línea ""%1"".';
			           |tr = 'ErişimYönetimiServis 
			           |genel modülünün DeğişiklikSeçimTalepMetni prosedürün EskiSeçimTalepMetni parametresinin değerinde bir hata oluştu. 
			           |
			           | Dize ""%1"" sorgu metninde bulunamadı.';
			           |it = 'Si è verificato un errore nel valore di parametro
			           |NewDataSelectionQueryText della procedura ChangesSelectionQueryText del modulo AccessManagementInternal.
			           |
			           |La stringa ""%1"" non è stata trovata nel testo di query.';
			           |de = 'Fehler im Wert des Parameters NewDataSelectionQueryText
			           |der Prozedur ChangesSelectionQueryText des Moduls AccessManagementInternal.
			           |
			           |Der Anforderungstext enthält nicht die Zeile ""%1"".'"),
			"&RowChangeKindFieldSubstitution");
		Raise ErrorText;
	EndIf;
	
	NewDataSelectionQueryText = StrReplace(
		NewDataSelectionQueryText,  "&RowChangeKindFieldSubstitution", "1 AS RowChangeKind");
	
	// Preparing a text of change selection query.
	QueryText =
	"SELECT
	|	&SelectedFields,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind
	|FROM
	|	(NewDataSelectionQueryText
	|	
	|	UNION ALL
	|	
	|	OldDataSelectionQueryText) AS AllRows
	|	
	|GROUP BY
	|	&GroupFields
	|	
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0";
	
	FieldsToSelect = "";
	GroupFields = "";
	For each FieldDetails In FieldsAndFilter Do
		// Aggregating the selected fields.
		FieldsToSelect = FieldsToSelect + StrReplace(
			"
			|	AllRows.Field,",
			"Field",
			KeyAndValue(FieldDetails).Key);
		
		// Assembling join fields.
		GroupFields = GroupFields + StrReplace(
			"
			|	AllRows.Field,",
			"Field",
			KeyAndValue(FieldDetails).Key);
	EndDo;
	GroupFields = Left(GroupFields, StrLen(GroupFields)-1);
	QueryText = StrReplace(QueryText, "&SelectedFields,",  FieldsToSelect);
	QueryText = StrReplace(QueryText, "&GroupFields", GroupFields);
	
	QueryText = StrReplace(
		QueryText, "NewDataSelectionQueryText",  NewDataSelectionQueryText);
	
	QueryText = StrReplace(
		QueryText, "OldDataSelectionQueryText", OldDataSelectionQueryText);
	
	If ValueIsFilled(TemporaryTablesQueriesText) Then
		QueryText = TemporaryTablesQueriesText
		+ "
		  |;
		  |" + QueryText;
	EndIf;
	
	Return QueryText;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Updating an infobase.

// Fills in separated data handler that depends on shared data change.
//
// Parameters:
//   Handlers - ValueTable, Undefined - see description of the NewUpdateHandlersTable function of 
//    the common module.
//    InfobaseUpdate.
//    Undefined is passed upon direct call (without using the infobase version update functionality).
//    
// 
Procedure FillSeparatedDataHandlers(Parameters = Undefined) Export
	
	If Parameters <> Undefined AND HasChangesOfAccessRestrictionParameters() Then
		Handlers = Parameters.SeparatedHandlers;
		Handler = Handlers.Add();
		Handler.Version = "*";
		Handler.ExecutionMode = "Seamless";
		Handler.Procedure = "AccessManagementInternal.UpdateAuxiliaryRegisterDataByConfigurationChanges";
	EndIf;
	
EndProcedure

// Updates auxiliary data that partially depends on the configuration.
//
// Updated when there are configuration changes recorded in access restriction parameters when 
// updating the infobase to the current configuration version.
//
Procedure UpdateAuxiliaryRegisterDataByConfigurationChanges(Parameters = Undefined) Export
	
	Lock = New DataLock;
	Lock.Add("InformationRegister.AccessGroupsTables");
	Lock.Add("InformationRegister.ObjectsRightsSettings");
	Lock.Add("Catalog.AccessGroupProfiles");
	Lock.Add("Catalog.AccessGroups");
	
	BeginTransaction();
	Try
		Lock.Lock();
		
		InformationRegisters.AccessGroupsTables.UpdateRegisterDataByConfigurationChanges();
		InformationRegisters.AccessValuesGroups.UpdateAuxiliaryRegisterDataByConfigurationChanges();
		InformationRegisters.ObjectsRightsSettings.UpdateAuxiliaryRegisterDataByConfigurationChanges();
		Catalogs.AccessGroupProfiles.UpdateSuppliedProfilesByConfigurationChanges();
		Catalogs.AccessGroups.MarkForDeletionSelectedProfilesAccessGroups();
		InformationRegisters.AccessValuesSets.UpdateAuxiliaryRegisterDataByConfigurationChanges();
		InformationRegisters.AccessRestrictionParameters.UpdateRegisterData();
		
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// Converts the DeleteRole attribute to the Role attribute in the Roles tabular section of the 
// Access group profiles catalog.
//
Procedure ConvertRoleNamesToIDs() Export
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	Roles.Ref AS Ref
	|FROM
	|	Catalog.AccessGroupProfiles.Roles AS Roles
	|WHERE
	|	NOT(Roles.Role <> VALUE(Catalog.MetadataObjectIDs.EmptyRef)
	|				AND Roles.DeleteRole = """")";
	
	Selection = Query.Execute().Select();
	
	While Selection.Next() Do
		Object = Selection.Ref.GetObject();
		Index = Object.Roles.Count()-1;
		While Index >= 0 Do
			Row = Object.Roles[Index];
			If ValueIsFilled(Row.Role) Then
				Row.DeleteRole = "";
			ElsIf ValueIsFilled(Row.DeleteRole) Then
				RoleMetadata = Metadata.Roles.Find(Row.DeleteRole);
				If RoleMetadata <> Undefined Then
					Row.DeleteRole = "";
					Row.Role = Common.MetadataObjectID(
						RoleMetadata);
				Else
					Object.Roles.Delete(Index);
				EndIf;
			Else
				Object.Roles.Delete(Index);
			EndIf;
			Index = Index-1;
		EndDo;
		InfobaseUpdate.WriteData(Object);
	EndDo;
	
EndProcedure

// Updates settings and enables a scheduled job.
Procedure EnableDataFillingForAccessRestriction() Export
	
	Usage = Constants.LimitAccessAtRecordLevel.Get();
	
	If Common.DataSeparationEnabled() Then
		SetDataFillingForAccessRestriction(Usage);
	Else
		Schedule = New JobSchedule;
		Schedule.WeeksPeriod = 1;
		Schedule.DaysRepeatPeriod = 1;
		Schedule.RepeatPeriodInDay = 300;
		Schedule.RepeatPause = 90;
		
		MetadataJob = Metadata.ScheduledJobs.DataFillingForAccessRestriction;
		Job = ScheduledJobsServer.GetScheduledJob(MetadataJob);
		
		Job.Use = Usage;
		Job.Schedule = Schedule;
		
		Job.RestartIntervalOnFailure
			= MetadataJob.RestartIntervalOnFailure;
		
		Job.RestartCountOnFailure
			= MetadataJob.RestartCountOnFailure;
		
		Job.Write();
	EndIf;
	
EndProcedure

// Fills an assignment of access group profiles.
Procedure FillAccessGroupsProfilesAssignment() Export
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	AccessGroupProfiles.Ref AS Ref
	|FROM
	|	Catalog.AccessGroupProfiles AS AccessGroupProfiles
	|WHERE
	|	NOT(AccessGroupProfiles.SuppliedDataID <> &EmptyUniqueID
	|				AND NOT AccessGroupProfiles.SuppliedProfileChanged)
	|	AND NOT AccessGroupProfiles.IsFolder
	|	AND NOT AccessGroupProfiles.Ref IN
	|				(SELECT DISTINCT
	|					AccessGroupProfilesAssignment.Ref
	|				FROM
	|					Catalog.AccessGroupProfiles.Purpose AS AccessGroupProfilesAssignment)";
	
	Query.SetParameter("EmptyUniqueID",
		New UUID("00000000-0000-0000-0000-000000000000"));
		
	Result = Query.Execute();
	Selection = Result.Select();
	
	While Selection.Next() Do
		ProfileObject = Selection.Ref.GetObject();
		NewRow = ProfileObject.Purpose.Add();
		NewRow.UsersType = Catalogs.Users.EmptyRef();
		InfobaseUpdate.WriteData(ProfileObject);
	EndDo;
	
EndProcedure

// Replaces deleted roles with the new ones.
Procedure ReplaceDeletedRolesInAccessGroupProfiles() Export
	
	// Filling a list of deleted roles and the matching new roles.
	RolesMap = New Map;
	
	// AddEditBasicMasterData
	RoleName = "? AddEditBasicMasterData";
	
	RolesArray = New Array;
	If Common.SubsystemExists("StandardSubsystems.Properties") Then
		RolesArray.Add("AddEditAdditionalAttributesAndInfo");
	EndIf;
	If Common.SubsystemExists("StandardSubsystems.Currencies") Then
		RolesArray.Add("AddEditCurrencyRates");
	EndIf;
	If Common.SubsystemExists("StandardSubsystems.WorkSchedules") Then
		RolesArray.Add("AddEditWorkSchedules");
	EndIf;
	If Common.SubsystemExists("StandardSubsystems.ContactInformation") Then
		RolesArray.Add("AddEditContactInfoKind");
	EndIf;
	RolesMap.Insert(RoleName, RolesArray);
	
	// AddEditCommonBasicMasterData
	RoleName = "? AddEditCommonBasicMasterData";
	
	RolesArray = New Array;
	If Common.SubsystemExists("StandardSubsystems.AddressClassifier") Then
		RolesArray.Add("AddEditAddressInfo");
	EndIf;
	If Common.SubsystemExists("StandardSubsystems.Banks") Then
		RolesArray.Add("AddEditBanks");
	EndIf;
	If Common.SubsystemExists("StandardSubsystems.CalendarSchedules") Then
		RolesArray.Add("AddEditCalendarSchedules");
	EndIf;
	RolesMap.Insert(RoleName, RolesArray);
	
	// EditCurrentUser
	RoleName = "? EditCurrentUser";
	
	RolesArray = New Array;
	RolesMap.Insert(RoleName, RolesArray);
	
	// EditCurrentExternalUser
	RoleName = "? EditCurrentExternalUser";
	
	RolesArray = New Array;
	RolesMap.Insert(RoleName, RolesArray);
	
	// ReadBasicMasterData
	RoleName = "? ReadBasicMasterData";
	
	RolesArray = New Array;
	If Common.SubsystemExists("StandardSubsystems.WorkSchedules") Then
		RolesArray.Add("ReadWorkSchedules");
	EndIf;
	If Common.SubsystemExists("StandardSubsystems.Currencies") Then
		RolesArray.Add("ReadCurrencyRates");
	EndIf;
	RolesMap.Insert(RoleName, RolesArray);
	
	// ReadCommonBasicMasterData
	RoleName = "? ReadCommonBasicMasterData";
	
	RolesArray = New Array;
	RolesMap.Insert(RoleName, RolesArray);
	
	// AddEditWorldCountries
	RoleName = "? AddEditWorldCountries";
	
	RolesArray = New Array;
	If Common.SubsystemExists("StandardSubsystems.ContactInformation") Then
		RolesArray.Add("AddEditContactInfoKind");
	EndIf;
	RolesMap.Insert(RoleName, RolesArray);
	
	AccessManagement.ReplaceRolesInProfiles(RolesMap);
	
EndProcedure

// Updates data of the InteractiveOpenOfExternalReportsAndDataProcessors profile.
Procedure UpdateProfileDataOpenExternalReportsAndDataProcessors() Export
	
	ProfileUUID = New UUID(
		OpenExternalReportsAndDataProcessorsProfileID());
	
	Ref = Catalogs.AccessGroupProfiles.GetRef(ProfileUUID);
	If Common.ObjectAttributeValue(Ref, "Ref") = Undefined Then
		Return;
	EndIf;
	MarkForDeletionRef = False;
	
	If Common.DataSeparationEnabled() Then
		MarkForDeletionRef = True;
	Else
		ProfileDetails = OpenExternalReportsAndDataProcessorsProfileDetails();
		SuppliedProfileReference = Catalogs.AccessGroupProfiles.SuppliedProfileByID(
			ProfileDetails.Name);
		
		If Ref <> SuppliedProfileReference Then
			If SuppliedProfileReference <> Undefined Then
				MarkForDeletionRef = True;
			Else
				// Setting a supplied data ID.
				ProfileObject = Ref.GetObject();
				ProfileObject.SuppliedDataID = ProfileUUID;
				ProfileObject.Comment = "";
				InfobaseUpdate.WriteObject(ProfileObject, False);
			EndIf;
		EndIf;
	EndIf;
	
	If MarkForDeletionRef Then
		ProfileObject = Ref.GetObject();
		ProfileObject.DeletionMark = True;
		InfobaseUpdate.WriteObject(ProfileObject, False);
		
		ProfileGroups = ProfileGroups(Ref, False);
		For Each GroupRef In ProfileGroups Do
			GroupObject = GroupRef.GetObject();
			GroupObject.DeletionMark = True;
			InfobaseUpdate.WriteObject(GroupObject, False);
		EndDo;
	EndIf;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Auxiliary procedures and functions.

Function ExtensionsRolesRights() Export
	
	ExtensionsRolesRights = Undefined;
	
	UpdateAccessGroupsTablesForEnabledExtensions(ExtensionsRolesRights);
	
	Return ExtensionsRolesRights;
	
EndFunction

Procedure UpdateAccessGroupsTablesForEnabledExtensions(ExtensionsRolesRights = Undefined)
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Common.SubsystemExists("StandardSubsystems.DataExchange") Then
		ModuleDataExchangeServer = Common.CommonModule("DataExchangeServer");
		If ModuleDataExchangeServer.SubordinateDIBNodeSetup() Then
			ExtensionsRolesRights = InformationRegisters.RolesRights.RolesRightsTable(True, True);
			Return;
		EndIf;
	EndIf;
	
	CurrentExtensionsVersion = SessionParameters.AttachedExtensions;
	
	// Filling rights of extension roles, which consist of right changes to configuration objects and 
	// rights to extension objects.
	SetNewExtenstionsRolesRights = False;
	If ValueIsFilled(CurrentExtensionsVersion) Then
		ExtensionsRolesRights = StandardSubsystemsServer.ExtensionParameter(
			"StandardSubsystems.AccessManagement.RolesRights");
		
		If ExtensionsRolesRights = Undefined Then
			Query = InformationRegisters.RolesRights.ChangesQuery(True);
			ExtensionsRolesRights = Query.Execute().Unload();
			SetNewExtenstionsRolesRights = True;
		Else
			ExtensionsRolesRights = ExtensionsRolesRights.Get();
		EndIf;
	Else
		ExtensionsRolesRights = InformationRegisters.RolesRights.RolesRightsTable(True, True);
	EndIf;
	
	// Checking whether it is required to update the AccessGroupsTables register.
	UpdateParameters = StandardSubsystemsServer.ExtensionParameter(
		"StandardSubsystems.AccessManagement.AccessGroupTablesUpdateParameters", True);
	
	If TypeOf(UpdateParameters) <> Type("Structure")
	 Or Not UpdateParameters.Property("LastExtensionsVersion")
	 Or Not UpdateParameters.Property("LastObjectsWithRightsChanges")
	 Or TypeOf(UpdateParameters.LastObjectsWithRightsChanges) <> Type("FixedArray") Then
		
		UpdateRequired = True;
		LastObjectsWithRightsChanges = Undefined;
	Else
		LastObjectsWithRightsChanges = UpdateParameters.LastObjectsWithRightsChanges;
		UpdateRequired = UpdateParameters.LastExtensionsVersion <> CurrentExtensionsVersion;
	EndIf;
	
	If Not UpdateRequired Then
		If SetNewExtenstionsRolesRights Then;
			StandardSubsystemsServer.SetExtensionParameter(
				"StandardSubsystems.AccessManagement.RolesRights", New ValueStorage(ExtensionsRolesRights));
		EndIf;
		Return;
	EndIf;
	
	CurrentObjectsWithRightsChanges = InformationRegisters.RolesRights.ChangedMetadataObjects(
		ExtensionsRolesRights.Copy());
	
	If LastObjectsWithRightsChanges = Undefined Then
		// Since the latest changes are unavailable, you need to update the entire register.
		ObjectsWithUpdateRightsChanges = Undefined;
	Else
		ObjectsWithUpdateRightsChanges = New Array(CurrentObjectsWithRightsChanges);
		For Each ID In LastObjectsWithRightsChanges Do
			ObjectsWithUpdateRightsChanges.Add(ID);
		EndDo;
	EndIf;
	
	UpdateParameters = New Structure;
	UpdateParameters.Insert("LastExtensionsVersion",       CurrentExtensionsVersion);
	UpdateParameters.Insert("LastObjectsWithRightsChanges", CurrentObjectsWithRightsChanges);
	
	Lock = New DataLock;
	Lock.Add("InformationRegister.AccessGroupsTables");
	BeginTransaction();
	Try
		Lock.Lock();
		If SetNewExtenstionsRolesRights Then;
			StandardSubsystemsServer.SetExtensionParameter(
				"StandardSubsystems.AccessManagement.RolesRights", New ValueStorage(ExtensionsRolesRights));
		EndIf;
		StandardSubsystemsServer.SetExtensionParameter(
			"StandardSubsystems.AccessManagement.AccessGroupTablesUpdateParameters", UpdateParameters, True);
		InformationRegisters.AccessGroupsTables.UpdateRegisterData(, ObjectsWithUpdateRightsChanges);
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

Procedure OnChangeAccessValuesSets(Val ObjectRef, IBUpdate = False)
	
	RefsToDependentObjects = New Array;
	
	AccessManagementOverridable.OnChangeAccessValuesSets(
		ObjectRef, RefsToDependentObjects);
	
	For each DependentObjectRef In RefsToDependentObjects Do
		
		If DependentObjectRef.Metadata().TabularSections.Find("AccessValuesSets") = Undefined Then
			// No object change is required.
			WriteAccessValuesSets(DependentObjectRef, , IBUpdate);
		Else
			// Object change is required.
			Object = DependentObjectRef.GetObject();
			Table = GetAccessValuesSetsOfTabularSection(Object);
			If NOT AccessValuesSetsOfTabularSectionChanged(DependentObjectRef, Table) Then
				Continue;
			EndIf;
			PrepareAccessValuesSetsForWrite(Undefined, Table, False);
			Try
				LockDataForEdit(DependentObjectRef, Object.DataVersion);
				Object.AdditionalProperties.Insert("WriteAccessValuesSets");
				Object.AdditionalProperties.Insert("WriteDependentAccessValuesSets");
				Object.AdditionalProperties.Insert("AccessValuesSetsOfTabularSectionAreFilled");
				Object.AccessValuesSets.Load(Table);
				If IBUpdate Then
					Object.AdditionalProperties.Insert("WriteAccessValueSetsOnUpdateIB");
					InfobaseUpdate.WriteData(Object);
				Else
					Object.DataExchange.Load = True;
					Object.Write();
				EndIf;
				UnlockDataForEdit(DependentObjectRef);
			Except
				ErrorInformation = ErrorInfo();
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'При обновлении зависимого набора значений доступа объекта
					           |""%1"" возникла ошибка:
					           |
					           |%2'; 
					           |en = 'An error occurred while updating a dependent set of access values for
					           |the ""%1"" object: 
					           |
					           |%2'; 
					           |pl = 'Podczas aktualizacji niezależnego zestawu wartości dostępu do obiektu
					           |""%1"" wystąpił błąd:
					           |
					           |%2';
					           |es_ES = 'Al actualizar el conjunto dependiente de valores de acceso del objeto
					           |""%1"" se ha producido un error: 
					           |
					           |%2';
					           |es_CO = 'Al actualizar el conjunto dependiente de valores de acceso del objeto
					           |""%1"" se ha producido un error: 
					           |
					           |%2';
					           |tr = 'Bağımlı nesne erişim değerleri kümesini güncelleştirirken %1"
" bir hata oluştu:
					           |
					           |%2';
					           |it = 'Durante l''aggiornamento di un set di valori di accesso dipendente dell''oggetto
					           |""%1"" si è verificato un errore:
					           |
					           |%2';
					           |de = 'Beim Aktualisieren des abhängigen Sets von Zugriffswerten des Objekts
					           |""%1"" ist ein Fehler aufgetreten:
					           |
					           |%2'"),
					String(DependentObjectRef),
					BriefErrorDescription(ErrorInformation));
				Raise ErrorText;
			EndTry;
		EndIf;
	EndDo;
	
EndProcedure

Function OpenExternalReportsAndDataProcessorsProfileID()
	
	Return "1b3472f6-4d87-11e6-8264-5404a6a6895d";
	
EndFunction

Function IsProfileOpenExternalReportsAndDataProcessors(Profile) Export
	
	If TypeOf(Profile) = Type("CatalogRef.AccessGroupProfiles") Then
		ProfileID = Common.ObjectAttributeValue(Profile, "SuppliedDataID");
		
	ElsIf Not Profile.IsFolder Then
		ProfileID = Profile.SuppliedDataID;
	Else
		Return False;
	EndIf;
	
	Return Upper(String(ProfileID)) = Upper(OpenExternalReportsAndDataProcessorsProfileID());
	
EndFunction

Function OpenExternalReportsAndDataProcessorsProfileDetails() Export
	
	ProfileDetails = AccessManagement.NewAccessGroupProfileDescription();
	ProfileDetails.Name           = "OpenExternalReportsAndDataProcessors";
	ProfileDetails.ID = OpenExternalReportsAndDataProcessorsProfileID();
	
	ProfileDetails.Description =
		NStr("ru = 'Открытие внешних отчетов и обработок'; en = 'Open external reports and data processors'; pl = 'Otwieranie zewnętrznych raportów i traktowania';es_ES = 'Abrir informes y procesamientos externos';es_CO = 'Abrir informes y procesamientos externos';tr = 'Harici raporları ve veri işlemcilerini aç';it = 'Apertura di rapporti e elaborazioni esterne';de = 'Öffnung von externen Berichten und Bearbeitungen'", Metadata.DefaultLanguage.LanguageCode);
	
	ProfileDetails.Details =
		NStr("ru = 'Предоставляет право открытия внешних отчетов и обработок из меню ""Файл - Открыть"".
		           |Состав ролей профиля не рекомендуется изменять.'; 
		           |en = 'Allows you to open external reports and data processors from the File-Open menu.
		           |It is not recommended that you change profile roles.'; 
		           |pl = 'Daje prawo do otwierania zewnętrznych raportów i zabiegów z menu Plik - Otwórz.
		           |Nie zaleca się zmiany składu ról profilu.';
		           |es_ES = 'Permite abrir informes y procesamientos externos del menú ""Archivo - Abrir"".
		           |No se recomienda cambiar el contenido de roles de perfiles.';
		           |es_CO = 'Permite abrir informes y procesamientos externos del menú ""Archivo - Abrir"".
		           |No se recomienda cambiar el contenido de roles de perfiles.';
		           |tr = '""Dosya Aç"" menüsünden Dış raporları ve işlemleri açma hakkını sağlar. 
		           |Profil rollerinin kapsamının değiştirilmesi önerilmez.';
		           |it = 'Permette l''apertura di report esterni ed elaboratori dati dal menu File-Aprire.
		           |È sconsigliata la modifica dei ruoli di profilo.';
		           |de = 'Bietet das Recht, externe Berichte und Prozesse aus dem Menü ""Datei- Öffnen"" zu öffnen.
		           |Es wird nicht empfohlen, die Zusammensetzung der Profilrollen zu ändern.'", Metadata.DefaultLanguage.LanguageCode);
	
	ProfileDetails.Roles.Add("InteractiveOpenExtReportsAndDataProcessors");
	
	Return ProfileDetails;
	
EndFunction

Function OpenExternalReportsAndDataProcessorsAccessGroup(ProfileProperties)
	
	// Search by ID.
	UUID = New UUID("f6929bcb-532f-11e6-a20f-5404a6a6895d");
	Ref = Catalogs.AccessGroups.GetRef(UUID);
	RefExists = (Common.ObjectAttributeValue(Ref, "Ref") <> Undefined);
	If RefExists Then
		Return Ref;
	EndIf;
	
	// Search by profile.
	ProfileGroups = ProfileGroups(ProfileProperties.Ref, Undefined);
	If ProfileGroups.Count() > 0 Then
		Return ProfileGroups[0];
	EndIf;
	
	// Creating a group.
	AccessGroupObject = Catalogs.AccessGroups.CreateItem();
	AccessGroupObject.SetNewObjectRef(Ref);
	AccessGroupObject.Description = ProfileProperties.Description;
	AccessGroupObject.Profile      = ProfileProperties.Ref;
	AccessGroupObject.Comment  =
		NStr("ru = 'Предоставляет право открытия внешних отчетов и обработок из меню ""Файл - Открыть"".'; en = 'Allows you to open external reports and data processors from the File-Open menu.'; pl = 'Daje prawo do otwierania zewnętrznych raportów i zabiegów z menu ""Plik - Otwórz"".';es_ES = 'Permite abrir informes y procesamientos externos del menú ""Archivo - Abrir"".';es_CO = 'Permite abrir informes y procesamientos externos del menú ""Archivo - Abrir"".';tr = '""Dosya Aç"" menüsünden Dış raporları ve işlemleri açma hakkını sağlar.';it = 'Fornisce il diritto di aprire rapporti e elaborazioni esterne dal menu ""File - Apri"".';de = 'Gibt das Recht, externe Berichte und Prozesse aus dem Menü ""Datei- Öffnen"" zu öffnen.'",
			Metadata.DefaultLanguage.LanguageCode);
	
	AccessGroupObject.Write(); // It is important that the created group belongs to the subordinate node.
	
	Return AccessGroupObject.Ref;
	
EndFunction

Function ProfileGroups(ProfileRef, DeletionMark)
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	AccessGroups.Ref
	|FROM
	|	Catalog.AccessGroups AS AccessGroups
	|WHERE
	|	AccessGroups.Profile = &Profile
	|	AND AccessGroups.DeletionMark = &DeletionMark
	|
	|ORDER BY
	|	AccessGroups.DeletionMark";
	
	Query.SetParameter("Profile", ProfileRef);
	
	If DeletionMark = Undefined Then
		Query.Text = StrReplace(Query.Text, "AND AccessGroups.DeletionMark = &DeletionMark", "");
	Else
		Query.SetParameter("DeletionMark", DeletionMark);
	EndIf;
	
	Return Query.Execute().Unload().UnloadColumn("Ref");
	
EndFunction

// For AllowedDynamicListValues and HasRestrictionByAccessKind functions.
Function AccessGroupsRequestText()
	
	Return
	"SELECT
	|	AccessGroups.Ref AS Ref
	|INTO UserAccessGroups
	|FROM
	|	Catalog.MetadataObjectIDs AS CurrentTableProperties
	|		INNER JOIN Catalog.AccessGroups AS AccessGroups
	|		ON (CurrentTableProperties.FullName = &MainListTableName)
	|			AND (TRUE IN
	|				(SELECT TOP 1
	|					TRUE
	|				FROM
	|					InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|				WHERE
	|					AccessGroupsTables.Table = CurrentTableProperties.Ref
	|					AND AccessGroupsTables.AccessGroup = AccessGroups.Ref))
	|			AND (AccessGroups.Ref IN
	|				(SELECT
	|					AccessGroupsUsers.Ref AS AccessGroup
	|				FROM
	|					Catalog.AccessGroups.Users AS AccessGroupsUsers
	|						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|						ON
	|							UserGroupCompositions.User = &AuthorizedUser
	|								AND UserGroupCompositions.UsersGroup = AccessGroupsUsers.User))";
	
EndFunction

// For the UpdateRecordSet, UpdateRecordSets, and UpdateInformationRegister procedures.
Procedure FillParameters(InputParameters, Val AllParameters, Val RequiredParameters = "")
	
	If TypeOf(InputParameters) = Type("Structure") Then
		Parameters = InputParameters;
	ElsIf InputParameters = Undefined Then
		Parameters = New Structure;
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Некорректный тип набора свойств ""%1"".
			           |Допустимые типы: Структура, Неопределено.'; 
			           |en = 'Incorrect type of property set ""%1"".
			           |Available types: Structure, Undefined.'; 
			           |pl = 'Niepoprawny typ zestawu właściwości ""%1"".
			           |Dozwolone typy: Struktura, Nieokreślony.';
			           |es_ES = 'Tipo del conjunto de propiedades incorrectas ""%1"".
			           |Tipos permitidos: Estructura, No definida.';
			           |es_CO = 'Tipo del conjunto de propiedades incorrectas ""%1"".
			           |Tipos permitidos: Estructura, No definida.';
			           |tr = 'Yanlış özellikler kümesi türü ""%1"". 
			           | İzin verilen türler: Yapı, Belirlenmemiş.';
			           |it = 'Tipo errato di set di proprietà ""%1"".
			           |Tipi disponibili: Struttura, Indefinito.';
			           |de = 'Inkorrekte Eigenschaften legen den Typ ""%1"" fest.
			           |Zulässige Typen: Struktur, Nicht definiert.'"),
			TypeOf(InputParameters));
		Raise ErrorText;
	EndIf;
	
	For each KeyAndValue In Parameters Do
		If Not AllParameters.Property(KeyAndValue.Key) Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Указан несуществующий параметр %1'; en = 'Non-existing parameter %1 is specified'; pl = 'Określono nieistniejący parametr %1';es_ES = 'Parámetro no existente %1 está especificado';es_CO = 'Parámetro no existente %1 está especificado';tr = 'Mevcut olmayan parametre %1 belirlendi';it = 'Specificato il parametro non esistente %1';de = 'Nicht existierender Parameter %1 ist angegeben'"),
				KeyAndValue.Key);
			Raise ErrorText;
		EndIf;
		AllParameters[KeyAndValue.Key] = Parameters[KeyAndValue.Key];
	EndDo;
	
	If ValueIsFilled(RequiredParameters) Then
		RequiredParameters = New Structure(RequiredParameters);
		
		For each KeyAndValue In RequiredParameters Do
			If Not Parameters.Property(KeyAndValue.Key) Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Не указан обязательный параметр %1'; en = 'Required parameter %1 is not specified'; pl = 'Wymagany parametr %1 nie został określony';es_ES = 'Parámetro requerido %1 no está especificado';es_CO = 'Parámetro requerido %1 no está especificado';tr = 'Gerekli parametre %1 belirlenmedi';it = 'Il parametro richiesto %1 non è specificato';de = 'Erforderlicher Parameter %1 ist nicht angegeben'"),
					KeyAndValue.Key);
				Raise ErrorText;
			EndIf;
		EndDo;
	EndIf;
	
	InputParameters = AllParameters;
	
EndProcedure

// For procedures OnSendDataToMaster, OnSendDataToSlave,
// OnReceiveDataFromMaster, OnReceiveDataFromSlave.
//
Function AccessManagementSubsystemObjectNameStartsWithDelete(DataItem)
	
	Return TypeOf(DataItem) = Type("ChartOfCharacteristicTypesObject.DeleteAccessKinds")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.DeleteAccessValuesGroups")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.DeleteAccessValuesSets")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.DeleteRightsByAccessValues");
	
EndFunction

// For procedures OnSendDataToMaster, OnSendDataToSlave,
// OnReceiveDataFromMaster, OnReceiveDataFromSlave.
//
Function AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataItem)
	
	Return TypeOf(DataItem) = Type("InformationRegisterRecordSet.RolesRights")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessRightsDependencies")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessGroupsTables")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessGroupsValues")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.DefaultAccessGroupsValues")
	    Or TypeOf(DataItem) = Type("CatalogObject.AccessKeys")
	    Or TypeOf(DataItem) = Type("CatalogObject.AccessGroupsSets")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.ExternalUsersAccessKeys")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessGroupsAccessKeys")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessGroupSetsAccessKeys")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessKeysForObjects")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessKeysForRegisters")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.UsersAccessKeys")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.DataAccessKeysUpdate")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.UsersAccessKeysUpdate")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessRestrictionParameters");
	
EndFunction

// For procedures OnReceiveDataFromMaster, OnReceiveDataFromSlave
Procedure OnReceiveDataFromMasterOrSlave(DataItem)
	
	If TypeOf(DataItem) = Type("CatalogObject.AccessGroupProfiles") Then
		// Extension roles are assigned independently in all DIB nodes.
		Catalogs.AccessGroupProfiles.RestoreExtensionsRolesComponents(DataItem);
		// Registering a modified profile to update auxiliary data.
		Catalogs.AccessGroupProfiles.RegisterProfileChangedOnImport(DataItem);
	EndIf;
	
	If TypeOf(DataItem) = Type("CatalogObject.AccessGroups") Then
		// Administrators are assigned independently in all DIB nodes.
		Catalogs.AccessGroups.RestoreAdministratorsAccessGroupMembers(DataItem);
		// Registering a modified access group to update auxiliary data.
		Catalogs.AccessGroups.RegisterAccessGroupChangedOnImport(DataItem);
	EndIf;
	
	// Registering users changed in a user group to update roles after receiving data.
	If TypeOf(DataItem) = Type("CatalogObject.UserGroups")
	 Or TypeOf(DataItem) = Type("CatalogObject.ExternalUsersGroups") Then
		Catalogs.AccessGroups.RegisterUsersOfUserGroupChangedOnImport(DataItem);
	EndIf;
	
	// Registering a user changed upon import to update roles after importing.
	If TypeOf(DataItem) = Type("CatalogObject.Users")
	 Or TypeOf(DataItem) = Type("CatalogObject.ExternalUsers") Then
		Catalogs.AccessGroups.RegisterUserChangedOnImport(DataItem);
	EndIf;
	
	If TypeOf(DataItem) <> Type("ObjectDeletion") Then
		Return;
	EndIf;
	
	// Registering a changed profile to update auxiliary data after importing.
	If TypeOf(DataItem.Ref) = Type("CatalogRef.AccessGroupProfiles") Then
		Catalogs.AccessGroupProfiles.RegisterProfileChangedOnImport(DataItem);
	EndIf;
	
	// Registering a changed access group to update auxiliary data after importing.
	If TypeOf(DataItem.Ref) = Type("CatalogRef.AccessGroups") Then
		Catalogs.AccessGroups.RegisterAccessGroupChangedOnImport(DataItem);
	EndIf;
	
	// Registering users changed in a user group to update roles after importing.
	If TypeOf(DataItem.Ref) = Type("CatalogRef.UserGroups")
	 Or TypeOf(DataItem.Ref) = Type("CatalogRef.ExternalUsersGroups") Then
		Catalogs.AccessGroups.RegisterUsersOfUserGroupChangedOnImport(DataItem);
	EndIf;
	
	// Registering a user changed upon import to update roles after importing.
	If TypeOf(DataItem.Ref) = Type("CatalogRef.Users")
	 Or TypeOf(DataItem.Ref) = Type("CatalogRef.ExternalUsers") Then
		Catalogs.AccessGroups.RegisterUserChangedOnImport(DataItem);
	EndIf;
	
EndProcedure

// For AfterReceiveData and AfterUpdateInfobase procedures.
Procedure UpdateAuxiliaryDataOfItemsChangedOnImport()
	
	Catalogs.AccessGroupProfiles.UpdateAuxiliaryProfilesDataChangedOnImport();
	Catalogs.AccessGroups.UpdateAccessGroupsAuxiliaryDataChangedOnImport();
	Catalogs.AccessGroups.UpdateUsersRolesChangedOnImport();
	
EndProcedure

// For AddUserToAccessGroup procedure, RemoveUserFromAccessGroup procedure, and 
// FindUserInAccessGroup function.

Function ProcessUserLinkToAccessGroup(User, SuppliedProfile, Enable = Undefined)
	
	If TypeOf(User) <> Type("CatalogRef.Users")
	   AND TypeOf(User) <> Type("CatalogRef.UserGroups")
	   AND TypeOf(User) <> Type("CatalogRef.ExternalUsers")
	   AND TypeOf(User) <> Type("CatalogRef.ExternalUsersGroups") Then
		
		Return False;
	EndIf;
	
	SuppliedProfileID = Undefined;
	
	If TypeOf(SuppliedProfile) = Type("String") Then
		If StringFunctionsClientServer.IsUUID(SuppliedProfile) Then
			
			SuppliedProfileID = SuppliedProfile;
			
			SuppliedProfile = Catalogs.AccessGroupProfiles.SuppliedProfileByID(
				SuppliedProfileID);
		Else
			Return False;
		EndIf;
	EndIf;
	
	If TypeOf(SuppliedProfile) <> Type("CatalogRef.AccessGroupProfiles") Then
		Return False;
	EndIf;
	
	If SuppliedProfileID = Undefined Then
		SuppliedProfileID =
			Catalogs.AccessGroupProfiles.SuppliedProfileID(SuppliedProfile);
	EndIf;
	
	If SuppliedProfileID = Catalogs.AccessGroupProfiles.AdministratorProfileID() Then
		Return False;
	EndIf;
	
	SuppliedProfiles = AccessManagementInternalCached.SuppliedProfilesDescription();
	ProfileProperties = SuppliedProfiles.ProfilesDetails.Get(SuppliedProfileID);
	
	If ProfileProperties = Undefined
	 OR ProfileProperties.AccessKinds.Count() <> 0 Then
		
		Return False;
	EndIf;
	
	AccessGroup = Undefined;
	
	If SimplifiedAccessRightsSetupInterface() Then
		
		If TypeOf(User) <> Type("CatalogRef.Users")
		   AND TypeOf(User) <> Type("CatalogRef.ExternalUsers") Then
			
			Return False;
		EndIf;
		
		Query = New Query;
		Query.SetParameter("Profile", SuppliedProfile);
		Query.SetParameter("User", User);
		Query.Text =
		"SELECT
		|	AccessGroups.Ref AS Ref
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile = &Profile
		|	AND AccessGroups.User = &User";
		Selection = Query.Execute().Select();
		If Selection.Next() Then
			AccessGroup = Selection.Ref;
		EndIf;
		
		If AccessGroup = Undefined Then
			If Enable <> True Then
				Return False;
			Else
				AccessGroup = Catalogs.AccessGroups.CreateItem();
				AccessGroup.Description = ProfileProperties.Description;
				AccessGroup.Profile      = SuppliedProfile;
				AccessGroup.User = User;
				AccessGroup.Users.Add().User = User;
				AccessGroup.Write();
				Return True;
			EndIf;
		EndIf;
	Else
		Query = New Query;
		Query.SetParameter("SuppliedProfile", SuppliedProfile);
		Query.Text =
		"SELECT
		|	AccessGroups.Ref AS Ref,
		|	AccessGroups.MainSuppliedProfileAccessGroup
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile = &SuppliedProfile
		|
		|ORDER BY
		|	AccessGroups.MainSuppliedProfileAccessGroup DESC";
		Selection = Query.Execute().Select();
		If Selection.Next() Then
			AccessGroup = Selection.Ref;
		EndIf;
		
		If AccessGroup = Undefined Then
			If Enable <> True Then
				Return False;
			Else
				AccessGroup = Catalogs.AccessGroups.CreateItem();
				AccessGroup.MainSuppliedProfileAccessGroup = True;
				AccessGroup.Description = ProfileProperties.Description;
				AccessGroup.Profile = SuppliedProfile;
				AccessGroup.Users.Add().User = User;
				AccessGroup.Write();
				Return True;
			EndIf;
		EndIf;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("Ref", AccessGroup);
	Query.SetParameter("User", User);
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	Catalog.AccessGroups.Users AS GroupMembers
	|WHERE
	|	GroupMembers.Ref = &Ref
	|	AND GroupMembers.User = &User";
	UserFound = NOT Query.Execute().IsEmpty();
	
	If Enable = Undefined Then
		Return UserFound;
	EndIf;
	
	If Enable AND UserFound Then
		Return True;
	EndIf;
	
	If NOT Enable AND NOT UserFound Then
		Return True;
	EndIf;
	
	AccessGroup = AccessGroup.GetObject();
	
	If NOT SimplifiedAccessRightsSetupInterface()
	   AND NOT AccessGroup.MainSuppliedProfileAccessGroup Then
		
		AccessGroup.MainSuppliedProfileAccessGroup = True;
	EndIf;
	
	If Enable Then
		AccessGroup.Users.Add().User = User;
	Else
		Filter = New Structure("User", User);
		Rows = AccessGroup.Users.FindRows(Filter);
		For each Row In Rows Do
			AccessGroup.Users.Delete(Row);
		EndDo;
	EndIf;
	
	AccessGroup.Write();
	
	Return True;
	
EndFunction

// For the WriteAccessValuesSetsOnWrite procedure.

// Overwrites access value sets of the object being checked in InformationRegister.AccessValuesSets 
// using the
// AccessManagement.FillAccessValuesSets() procedure.
//
// Procedure is called from AccessManagementInternal.WriteAccessValuesSets() but it can be called 
// from anywhere, for example, when you enable access restrictions at the record level.
// 
//
// Calls the applied developer procedure
// AccessManagementOverridable.OnChangeAccessValueSets() used to rewrite dependent access value sets.
// 
//
// Parameters:
//  Object - CatalogObject, DocumentObject, ..., or CatalogRef, DocumentRef, ...
//                 The client call can pass only a reference, while an object is required.
//                 The object can be obtained by reference.
//  IBUpdate - Boolean - if True, write data without performing unnecessary and redundant actions 
//                 with the data.
//                 See InfobaseUpdate.WriteData. 
//
Procedure WriteAccessValuesSets(Val Object, HasChanges = Undefined, IBUpdate = False)
	
	SetPrivilegedMode(True);
	
	// If the Object parameter is passed from client to server, a reference is passed and the object 
	// must be obtained.
	Object = ?(Object = Object.Ref, Object.GetObject(), Object);
	ObjectRef = Object.Ref;
	ValueTypeObject = TypeOf(Object);
	
	SetsRecorded = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
		"WriteAccessValuesSets").Get(ValueTypeObject) <> Undefined;
	
	If NOT SetsRecorded Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Неверные параметры.
			           |Тип объекта ""%1""
			           |не найден в подписках на события
			           |""Записать наборы значений доступа"".'; 
			           |en = 'Incorrect parameters.
			           |Object type ""%1""
			           |is not found in subscriptions of the
			           |""Write access value sets"" events.'; 
			           |pl = 'Nieprawidłowe parametry.
			           |Typ obiektu ""%1""
			           |nie został znaleziony w subskrypcjach wydarzenia
			           |""Zapisuj zestawy wartości dostępu"".';
			           |es_ES = 'Parámetros incorrectos.
			           |Tipo del objeto ""%1""
			           |no se ha encontrado en las suscripciones de eventos
			           | ""Guardar conjuntos de valores de acceso"".';
			           |es_CO = 'Parámetros incorrectos.
			           |Tipo del objeto ""%1""
			           |no se ha encontrado en las suscripciones de eventos
			           | ""Guardar conjuntos de valores de acceso"".';
			           |tr = 'Yanlış parametreler. %1""Erişim değeri kümeleri yaz"" 
			           |olaylarına aboneliklerde 
			           |Nesne türü "
" bulunmadı.';
			           |it = 'Parametri errati.
			           |Il tipo di oggetto ""%1""
			           |non è stato trovato nelle registrazioni degli eventi
			           |""Registrazione set valori di accesso"".';
			           |de = 'Falsche Parameter.
			           |Der Objekttyp ""%1""
			           |ist in den Ereignis-Abonnements
			           |""Schreiben von Zugriffswerte-Sets"" nicht enthalten.'"),
			ValueTypeObject);
		Raise ErrorText;
	EndIf;
	
	PossibleObjectsTypes = AccessManagementInternalCached.TableFieldTypes(
		"InformationRegister.AccessValuesSets.Dimension.Object");
	
	If PossibleObjectsTypes.Get(TypeOf(ObjectRef)) = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Ошибка при записи наборов значений доступа:
			           |в регистре сведений AccessValuesSets в измерении Object
			           |не задан тип ""%1"".'; 
			           |en = 'An error occurred when writing access value sets:
			           |type ""%1"" is not specified
			           |in the AccessValuesSets information register in the Object dimension.'; 
			           |pl = 'Błąd podczas zapisywania zestawów wartości dostępu:
			           |w rejestrze informacyjnym AccessValuesSets w wymiarze Obiekt
			           |nie jest określony typ ""%1"".';
			           |es_ES = 'Error al guardar los conjuntos de valores de acceso: 
			           |en el registro de información AccessValuesSets en la dimensión Objeto
			           |no se ha establecido el tipo ""%1"".';
			           |es_CO = 'Error al guardar los conjuntos de valores de acceso: 
			           |en el registro de información AccessValuesSets en la dimensión Objeto
			           |no se ha establecido el tipo ""%1"".';
			           |tr = 'Erişim değeri kümeleri yazılırken %1 bir hata oluştu: "
" türü, 
			           |Nesne boyutunda AccessValuesSets bilgi kaydında belirtilmemiş.';
			           |it = 'Si è verificato un errore durante la registrazione dei set di valori di accesso:
			           |il tipo ""%1"" non è indicato
			           |nel registro informazioni AccessValuesSets nella dimensione Oggetto.';
			           |de = 'Fehler beim Schreiben von Zugriffswerte-Sets:
			           |Informationsregister AccessValuesSets
			           |Das Objekt wird in der Messungnicht als Typ ""%1"" angegeben.'"),
			ObjectRef.Metadata().FullName());
		Raise ErrorText;
	EndIf;
	
	If AccessManagement.LimitAccessAtRecordLevel()
	   AND Not LimitAccessAtRecordLevelUniversally() Then
		
		If Metadata.FindByType(ValueTypeObject).TabularSections.Find("AccessValuesSets") = Undefined Then
			
			Table = AccessManagement.AccessValuesSetsTable();
			AccessManagement.FillAccessValuesSets(Object, Table);
			
			AccessManagement.AddAccessValuesSets(
				Table, AccessManagement.AccessValuesSetsTable(), False, True);
		Else
			TabularSectionBeingFilled = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
				"FillAccessValuesSetsForTabularSections").Get(ValueTypeObject) <> Undefined;
			
			If NOT TabularSectionBeingFilled Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Неверные параметры.
					           |Тип объекта ""%1""
					           |не найден в подписках на события
					           |""Заполнить наборы значений доступа табличных частей"".'; 
					           |en = 'Incorrect parameters.
					           |Object type ""%1""
					           |is not found in subscriptions to the
					           |""Fill access value sets of tabular sections"" events.'; 
					           |pl = 'Nieprawidłowe parametry.
					           |Typ obiektu ""%1""
					           |nie został znaleziony w subskrypcjach wydarzenia
					           |""Zapisuj zestawy wartości dostępu części tabelarycznych"".';
					           |es_ES = 'Parámetros incorrectos.
					           |Tipo del objeto ""%1""
					           |no se ha encontrado en las suscripciones de eventos
					           | ""Rellenar los conjuntos de valores de secciones tabulares"".';
					           |es_CO = 'Parámetros incorrectos.
					           |Tipo del objeto ""%1""
					           |no se ha encontrado en las suscripciones de eventos
					           | ""Rellenar los conjuntos de valores de secciones tabulares"".';
					           |tr = 'Yanlış parametreler. %1""Sekmeli bölümlerin erişim değeri kümeleri yaz"" 
					           |olaylarına aboneliklerde 
					           |Nesne türü "
" bulunmadı.';
					           |it = 'Parametri errati.
					           |Il tipo di Oggetto ""%1""
					           |non è stato trovato nelle registrazione degli eventi
					           |""Compilare set di valori di accesso delle sezioni tabellari"".';
					           |de = 'Falsche Parameter.
					           |Der Objekttyp ""%1""
					           |ist in den Abonnements der Ereignisse
					           |""Füllen Sie die Mengen der Zugriffswerte für Tabellenteile aus"" nicht enthalten.'"),
					ValueTypeObject);
				Raise ErrorText;
			EndIf;
			// The object with already filled AccessValuesSets tabular section is written.
			Table = Object.AccessValuesSets.Unload();
		EndIf;
		
		PrepareAccessValuesSetsForWrite(ObjectRef, Table, True);
		
		Data = New Structure;
		Data.Insert("RegisterManager",   InformationRegisters.AccessValuesSets);
		Data.Insert("FixedFilter", New Structure("Object", ObjectRef));
		Data.Insert("NewRecords",        Table);
		Data.Insert("IBUpdate",       IBUpdate);
		
		BeginTransaction();
		Try
			UpdateRecordSets(Data, HasChanges);
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If HasChanges = True Then
			OnChangeAccessValuesSets(ObjectRef, IBUpdate);
		EndIf;
	Else
		Query = New Query(
		"SELECT TOP 1
		|	TRUE AS TrueValue
		|FROM
		|	InformationRegister.AccessValuesSets AS AccessValuesSets
		|WHERE
		|	AccessValuesSets.Object = &ObjectRef");
		
		Query.SetParameter("ObjectRef", ObjectRef);
		
		If NOT Query.Execute().IsEmpty() Then
			// Clearing an obsolete set.
			// A new set will be written using a scheduled job after enabling restriction at the record level.
			// 
			RecordSet = InformationRegisters.AccessValuesSets.CreateRecordSet();
			RecordSet.Filter.Object.Set(ObjectRef);
			RecordSet.Write();
			HasChanges = True;
			
			// Clearing obsolete dependent sets.
			OnChangeAccessValuesSets(ObjectRef, IBUpdate);
		EndIf;
	EndIf;
	
EndProcedure

// For the WriteDependentAccessValuesSetsOnWrite procedure.

// Overwrites access value sets of dependent objects.
//
//  Procedure is called from AccessManagementInternal.WriteDependentAccessValuesSets()
// The subscription type content complements (without overlapping) the WriteAccessValuesSets 
// subscription type content with types that do not require recording sets to the AccessValuesSets 
// information register but the sets themselves belong to other sets. Example: a set of files from 
// the Files catalog might belong to several Job business processes created based on files. 
// Recording the file sets to the register is not required.
//
// Calls the applied developer procedure
// AccessManagementOverridable.OnChangeAccessValueSets() used for overwriting dependent value sets, 
// thus creating a recursion.
// 
//
// Parameters:
//  Object - CatalogObject, DocumentObject, ..., or CatalogRef, DocumentRef, ...
//                 The client call can pass only a reference, while an object is required.
//                 The object can be obtained by reference.
//
//  IBUpdate - Boolean - if True, write data without performing unnecessary and redundant actions 
//                 with the data.
//                 See InfobaseUpdate.WriteData. 
//
Procedure WriteDependentAccessValuesSets(Val Object, IBUpdate = False)
	
	SetPrivilegedMode(True);
	
	// If the Object parameter is passed from client to server, a reference is passed and the object 
	// must be obtained.
	Object = ?(Object = Object.Ref, Object.GetObject(), Object);
	ObjectRef = Object.Ref;
	ValueTypeObject = TypeOf(Object);
	
	IsLeadingObject = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
		"WriteDependentAccessValuesSets").Get(ValueTypeObject) <> Undefined;
	
	If NOT IsLeadingObject Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Неверные параметры.
			           |Тип объекта ""%1""
			           |не найден в подписке на события
			           |""Записать зависимые наборы значений доступа"".'; 
			           |en = 'Incorrect parameters.
			           |Object type ""%1""
			           |is not found in subscriptions to the
			           |""Write dependent access value sets"" events.'; 
			           |pl = 'Nieprawidłowe parametry.
			           |Typ obiektu ""%1""
			           |nie został znaleziony w subskrypcjach wydarzenia
			           |""Zapisuj zależne zestawy wartości dostępu"".';
			           |es_ES = 'Parámetros incorrectos.
			           |Tipo del objeto ""%1""
			           |no se ha encontrado en la suscripción de eventos
			           | ""Guardar conjuntos dependientes de valores de acceso"".';
			           |es_CO = 'Parámetros incorrectos.
			           |Tipo del objeto ""%1""
			           |no se ha encontrado en la suscripción de eventos
			           | ""Guardar conjuntos dependientes de valores de acceso"".';
			           |tr = 'Yanlış parametreler. %1""Bağımlı erişim değeri kümeleri yaz"" 
			           |olaylarına aboneliklerde 
			           |Nesne türü "
" bulunmadı.';
			           |it = 'Parametri errati.
			           |Il tipo di oggetto ""%1""
			           |non è stato trovato nelle registrazioni degli eventi
			           |""Registrare set di valori di accesso dipendenti"".';
			           |de = 'Falsche Parameter.
			           |Der Objekttyp ""%1""
			           |wird im Ereignisabonnement
			           |""Abhängige Zugriffswerte schreiben"" nicht gefunden.'"),
			ValueTypeObject);
		Raise ErrorText;
	EndIf;
	
	OnChangeAccessValuesSets(ObjectRef, IBUpdate);
	
EndProcedure

// For the UpdateAuxiliaryDataByConfigurationChanges and
// FillSeparatedDataHandlers procedures.

// Checks whether shared data was changed for any data area.
Function HasChangesOfAccessRestrictionParameters()
	
	SetPrivilegedMode(True);
	
	Parameters = New Array;
	Parameters.Add("StandardSubsystems.AccessManagement.RoleRightMetadataObjects");
	Parameters.Add("StandardSubsystems.AccessManagement.RightsForObjectsRightsSettingsAvailable");
	Parameters.Add("StandardSubsystems.AccessManagement.SuppliedProfilesDescription");
	Parameters.Add("StandardSubsystems.AccessManagement.AccessGroupPredefinedProfiles");
	Parameters.Add("StandardSubsystems.AccessManagement.GroupAndAccessValueTypes");
	
	For Each Parameter In Parameters Do
		
		LastChanges = StandardSubsystemsServer.ApplicationParameterChanges(Parameter);
		
		If LastChanges = Undefined
		 OR LastChanges.Count() > 0 Then
			
			Return True;
		EndIf;
		
	EndDo;
	
	Return False;
	
EndFunction

// For the UpdateUsersRoles procedure.

Function CurrentUsersProperties(UsersArray)
	
	Query = New Query;
	
	Query.SetParameter("BlankID",
		New UUID("00000000-0000-0000-0000-000000000000"));
	
	If UsersArray = Undefined Then
		Query.Text =
		"SELECT
		|	Users.Ref AS User,
		|	Users.IBUserID
		|INTO UsersToCheck
		|FROM
		|	Catalog.Users AS Users
		|WHERE
		|	Users.Internal = FALSE
		|	AND Users.IBUserID <> &BlankID
		|
		|UNION ALL
		|
		|SELECT
		|	ExternalUsers.Ref,
		|	ExternalUsers.IBUserID
		|FROM
		|	Catalog.ExternalUsers AS ExternalUsers
		|WHERE
		|	ExternalUsers.IBUserID <> &BlankID";
		
	ElsIf TypeOf(UsersArray) = Type("Type") Then
		If Metadata.FindByType(UsersArray) = Metadata.Catalogs.ExternalUsers Then
			Query.Text =
			"SELECT
			|	ExternalUsers.Ref AS User,
			|	ExternalUsers.IBUserID
			|INTO UsersToCheck
			|FROM
			|	Catalog.ExternalUsers AS ExternalUsers
			|WHERE
			|	ExternalUsers.IBUserID <> &BlankID";
		Else
			Query.Text =
			"SELECT
			|	Users.Ref AS User,
			|	Users.IBUserID
			|INTO UsersToCheck
			|FROM
			|	Catalog.Users AS Users
			|WHERE
			|	Users.Internal = FALSE
			|	AND Users.IBUserID <> &BlankID";
		EndIf;
	Else
		InitialUsers = New ValueTable;
		InitialUsers.Columns.Add("User", New TypeDescription(
			"CatalogRef.Users, CatalogRef.ExternalUsers"));
		
		For each User In UsersArray Do
			InitialUsers.Add().User = User;
		EndDo;
		
		Query.SetParameter("InitialUsers", InitialUsers);
		Query.Text =
		"SELECT DISTINCT
		|	InitialUsers.User
		|INTO InitialUsers
		|FROM
		|	&InitialUsers AS InitialUsers
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT
		|	Users.Ref AS User,
		|	Users.IBUserID
		|INTO UsersToCheck
		|FROM
		|	Catalog.Users AS Users
		|		INNER JOIN InitialUsers AS InitialUsers
		|		ON Users.Ref = InitialUsers.User
		|			AND (Users.Internal = FALSE)
		|			AND (Users.IBUserID <> &BlankID)
		|
		|UNION ALL
		|
		|SELECT
		|	ExternalUsers.Ref,
		|	ExternalUsers.IBUserID
		|FROM
		|	Catalog.ExternalUsers AS ExternalUsers
		|		INNER JOIN InitialUsers AS InitialUsers
		|		ON ExternalUsers.Ref = InitialUsers.User
		|			AND (ExternalUsers.IBUserID <> &BlankID)";
	EndIf;
	
	QueryText =
	"SELECT
	|	Users.Ref AS Ref,
	|	Users.IBUserID
	|FROM
	|	Catalog.AccessGroups.Users AS AccessGroupsUsers
	|		INNER JOIN Catalog.Users AS Users
	|		ON (AccessGroupsUsers.Ref = VALUE(Catalog.AccessGroups.Administrators))
	|			AND AccessGroupsUsers.User = Users.Ref
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	UsersToCheck.User,
	|	UsersToCheck.IBUserID
	|FROM
	|	UsersToCheck AS UsersToCheck
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	UsersToCheck.User AS User,
	|	AccessGroupsUsers.Ref.Profile AS Profile
	|INTO UsersProfiles
	|FROM
	|	UsersToCheck AS UsersToCheck
	|		INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		ON UsersToCheck.User = UserGroupCompositions.User
	|			AND (UserGroupCompositions.Used)
	|			AND (&ExcludeExternalUsers)
	|		INNER JOIN Catalog.AccessGroups.Users AS AccessGroupsUsers
	|		ON (UserGroupCompositions.UsersGroup = AccessGroupsUsers.User)
	|			AND (NOT AccessGroupsUsers.Ref.DeletionMark)
	|			AND (NOT AccessGroupsUsers.Ref.Profile.DeletionMark)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	UsersProfiles.User,
	|	Roles.Role AS RoleRef,
	|	Roles.Role.Name AS Role
	|FROM
	|	UsersProfiles AS UsersProfiles
	|		INNER JOIN Catalog.AccessGroupProfiles.Roles AS Roles
	|		ON (Roles.Ref = UsersProfiles.Profile)
	|WHERE
	|	Roles.Role <> UNDEFINED";
	
	Query.Text = Query.Text + "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|" + QueryText;
	
	If Constants.UseExternalUsers.Get() Then
		Query.Text = StrReplace(Query.Text, "&ExcludeExternalUsers", "True");
	Else
		Query.Text = StrReplace(Query.Text, "&ExcludeExternalUsers",
			"VALUETYPE(UsersToCheck.User) = TYPE(Catalog.Users)");
	EndIf;
	
	QueriesResults = Query.ExecuteBatch();
	LastResult = QueriesResults.Count()-1;
	Total = New Structure;
	
	Total.Insert("Administrators", New Map);
	
	For each Row In QueriesResults[LastResult-3].Unload() Do
		Total.Administrators.Insert(Row.Ref, True);
	EndDo;
	
	Total.Insert("IBUsersIDs", QueriesResults[LastResult-2].Unload());
	Total.IBUsersIDs.Indexes.Add("User");
	
	Total.Insert("UsersRoles", QueriesResults[LastResult].Unload());
	Total.UsersRoles.Indexes.Add("User");
	
	RoleIDs = Total.UsersRoles.UnloadColumn("RoleRef");
	RolesMetadata = Catalogs.MetadataObjectIDs.MetadataObjectsByIDs(
		RoleIDs, True);
	
	For Each Row In Total.UsersRoles Do
		RoleMetadata = RolesMetadata.Get(Row.RoleRef);
		If TypeOf(RoleMetadata) = Type("MetadataObject") Then
			Row.Role = RoleMetadata.Name;
		EndIf;
	EndDo;
	
	Return Total;
	
EndFunction

Procedure RegisterUnavailableRole(RoleDetails, User)
	
	// Unavailable roles in profiles.
	Profiles = UserWithRoleProfiles(User, RoleDetails.RoleRef);
	
	For Each Profile In Profiles Do
		WriteLogEvent(
			NStr("ru = 'Управление доступом.Роль не доступна пользователю'; en = 'Access management.Role is unavailable to the user'; pl = 'Kontrola dostępu.Rola niedostępna dla użytkownika';es_ES = 'Gestión de acceso.El rol no está disponible al usuario';es_CO = 'Gestión de acceso.El rol no está disponible al usuario';tr = 'Erişim kontrolü. Rol kullanıcı tarafından kullanılmaz';it = 'Gestione dell''accesso.Il ruolo non è disponibile all''utente';de = 'Zugriffskontrolle. Die Rolle steht dem Benutzer nicht zur Verfügung'",
			     CommonClientServer.DefaultLanguageCode()),
			EventLogLevel.Error,
			Metadata.Catalogs.AccessGroupProfiles,
			Profile,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru= 'При обновлении ролей пользователя ""%1""
				          |роль ""%2""
				          |профиля групп доступа ""%3""
				          |недоступна пользователю.'; 
				          |en = 'While updating the ""%1"" user roles,
				          |the ""%2"" role
				          |of the ""%3"" access group profile
				          |is not available to the user.'; 
				          |pl = 'Podczas aktualizowania ról użytkownika ""%1""
				          | rola ""%2""
				          |profilu grupy dostępu ""%3""
				          |nie jest dostępna dla użytkownika.';
				          |es_ES = 'Al actualizar los roles de usuario ""%1""
				          | el rol ""%2""
				          |del perfil del grupo de acceso ""%3"" 
				          |no está disponible al usuario.';
				          |es_CO = 'Al actualizar los roles de usuario ""%1""
				          | el rol ""%2""
				          |del perfil del grupo de acceso ""%3"" 
				          |no está disponible al usuario.';
				          |tr = 'Erişim grubu profili 
				          |""%1"" rol ""%2"" 
				          |kullanıcı rollerini güncelleştirildiğinde, "
"%3kullanıcı tarafından kullanılamaz.';
				          |it = 'Durante l''aggiornamento dei ruoli utente ""%1"",
				          |il ruolo ""%2""
				          |del profilo del gruppo di accesso ""%3""
				          |non è disponibile per l''utente.';
				          |de = 'Beim Aktualisieren von Benutzerrollen ""%1""
				          |steht die Rolle ""%2""
				          |des Zugriffsgruppenprofils ""%3""
				          |dem Benutzer nicht zur Verfügung.'"),
				String(User),
				RoleDetails.Role,
				String(Profile)),
			EventLogEntryTransactionMode.Transactional);
	EndDo;
	
EndProcedure

Procedure RegisterNotFoundRole(RoleDetails, User)
	
	// New roles not found in the metadata.
	Profiles = UserWithRoleProfiles(User, RoleDetails.RoleRef);
	
	For Each Profile In Profiles Do
		WriteLogEvent(
			NStr("ru = 'Управление доступом.Роль не найдена в метаданных'; en = 'Access management.Role is not found in the metadata'; pl = 'Zarządzanie dostępem. W metadanych nie znaleziono roli';es_ES = 'Gestión de acceso.Rol no encontrado en los metadatos.';es_CO = 'Gestión de acceso.Rol no encontrado en los metadatos.';tr = 'Erişim yönetimi. Meta veride rol bulunmadı.';it = 'Gestione accesso.Ruolo non trovato nei metadati';de = 'Zugriffsverwaltung. Die Rolle wurde in Metadaten nicht gefunden'",
			     CommonClientServer.DefaultLanguageCode()),
			EventLogLevel.Error,
			Metadata.Catalogs.AccessGroupProfiles,
			Profile,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru= 'При обновлении ролей пользователя ""%1""
				          |роль ""%2""
				          |профиля групп доступа ""%3""
				          |не найдена в метаданных.'; 
				          |en = 'While updating roles of the ""%1"" user, the ""%2""
				          |role of the ""%3""
				          |access group profile
				          |was not found in the metadata.'; 
				          |pl = 'Podczas aktualizacji ról użytkownika""%1""
				          |rola ""%2""
				          |profilu grup dostępu""%3""
				          |nie znaleziona w metadanych.';
				          |es_ES = 'Al actualizar los roles de usuario ""%1""
				          | el rol ""%2""
				          |del perfil del grupo de acceso ""%3"" 
				          |no se ha encontrado en metadatos.';
				          |es_CO = 'Al actualizar los roles de usuario ""%1""
				          | el rol ""%2""
				          |del perfil del grupo de acceso ""%3"" 
				          |no se ha encontrado en metadatos.';
				          |tr = 'Erişim grubu profili 
				          |""%1"" rol ""%2"" 
				          |kullanıcı rollerini güncelleştirildiğinde, "
"%3metaverilerde bulunamadı.';
				          |it = 'Durante l''aggiornamento dei ruoli dell''utente ""%1"", il ruolo ""%2""
				          | del profilo del gruppo di accesso ""%3""
				          |non è stato trovato
				          | nei metadati.';
				          |de = 'Bei der Aktualisierung von Benutzerrollen ""%1""
				          |wird die Rolle ""%2""
				          |des Zugriffsgruppenprofils ""%3""
				          |in den Metadaten nicht gefunden.'"),
				String(User),
				RoleDetails.Role,
				String(Profile)),
			EventLogEntryTransactionMode.Transactional);
	EndDo;
	
EndProcedure

Procedure UpdateIBUsersRoles(IBUsersToUpdate, ServiceUserPassword)
	
	StandardSubsystemsServer.CheckApplicationVersionDynamicUpdate();
	
	For Each KeyAndValue In IBUsersToUpdate Do
		RolesForAdding  = KeyAndValue.Value.RolesForAdding;
		RolesForDeletion    = KeyAndValue.Value.RolesForDeletion;
		InfobaseUser     = KeyAndValue.Value.InfobaseUser;
		UserRef = KeyAndValue.Value.UserRef;
		
		HadFullRights = InfobaseUser.Roles.Contains(Metadata.Roles.FullRights);
		
		For each KeyAndValue In RolesForAdding Do
			InfobaseUser.Roles.Add(Metadata.Roles[KeyAndValue.Key]);
		EndDo;
		
		For each KeyAndValue In RolesForDeletion Do
			InfobaseUser.Roles.Delete(Metadata.Roles[KeyAndValue.Key]);
		EndDo;
		
		BeginTransaction();
		Try
			WriteUserOnRolesUpdate(UserRef,
				InfobaseUser, HadFullRights, ServiceUserPassword);
			
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	EndDo;
	
EndProcedure

// For the RegisterUnavailableRole and RegisterNotFoundRole procedures.
Function UserWithRoleProfiles(User, Role)
	
	Query = New Query;
	Query.SetParameter("CurrentUser", User);
	Query.SetParameter("Role", Role);
	
	Query.SetParameter("BlankID",
		New UUID("00000000-0000-0000-0000-000000000000"));
	
	Query.Text =
	"SELECT DISTINCT
	|	Roles.Ref AS Profile
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		INNER JOIN Catalog.AccessGroups.Users AS AccessGroupsUsers
	|		ON (UserGroupCompositions.User = &CurrentUser)
	|			AND UserGroupCompositions.UsersGroup = AccessGroupsUsers.User
	|			AND (UserGroupCompositions.Used)
	|			AND (NOT AccessGroupsUsers.Ref.DeletionMark)
	|		INNER JOIN Catalog.AccessGroupProfiles.Roles AS Roles
	|		ON (Roles.Ref = AccessGroupsUsers.Ref.Profile)
	|			AND (NOT Roles.Ref.DeletionMark)
	|			AND (Roles.Role = &Role)";
	
	Return Query.Execute().Unload().UnloadColumn("Profile");
	
EndFunction

// This method is required by UpdateIBUsersRoles procedure.
Procedure WriteUserOnRolesUpdate(UserRef, InfobaseUser, HadFullRights, ServiceUserPassword)
	
	UsersInternal.WriteInfobaseUser(InfobaseUser, 
		TypeOf(UserRef) = Type("CatalogRef.ExternalUsers"));
	
	If Not Common.DataSeparationEnabled() Then
		Return;
	EndIf;
	
	HasFullRights = InfobaseUser.Roles.Contains(Metadata.Roles.FullRights);
	If HasFullRights = HadFullRights Then
		Return;
	EndIf;
	
	If ServiceUserPassword = Undefined Then
		If Common.SubsystemExists("StandardSubsystems.SaaS") Then
			ModuleSaaS = Common.CommonModule("SaaS");
			SessionWithoutSeparators = ModuleSaaS.SessionWithoutSeparators();
		Else
			SessionWithoutSeparators = True;
		EndIf;
		If SessionWithoutSeparators Then
			Return;
		EndIf;
		
		ErrorText =
			NStr("ru = 'Для изменения административного доступа
			           |требуется пароль пользователя сервиса.
			           |
			           |Операция может быть выполнена только интерактивно.'; 
			           |en = 'To change administration access,
			           |service user password is required.
			           |
			           |The operation can be performed only interactively.'; 
			           |pl = 'Aby zmienić administracyjnego dostępu
			           |wymagane jest hasło użytkownika serwisu.
			           |
			           |Operacja może być wykonana tylko interaktywnie.';
			           |es_ES = 'Para cambiar el acceso administrativo
			           |, se requiere la contraseña del usuario de servicio.
			           |
			           |Operación puede realizarse solo de forma interactiva.';
			           |es_CO = 'Para cambiar el acceso administrativo
			           |, se requiere la contraseña del usuario de servicio.
			           |
			           |Operación puede realizarse solo de forma interactiva.';
			           |tr = 'Yönetici 
			           |erişimini değiştirmek için servis kullanıcı şifresi gereklidir. 
			           |
			           |Operasyon sadece etkileşimli olarak yapılabilir.';
			           |it = 'Per modificare l''accesso di amministrazione,
			           |è richiesta la password dell''utente di servizio.
			           |
			           |L''operazione può essere eseguita solo in modo interattivo.';
			           |de = 'Für die Änderung des Administrator-Zugriffs
			           |ist ein Service-Benutzerpasswort erforderlich.
			           |
			           |Die Operation kann nur interaktiv durchgeführt werden.'");
		Raise ErrorText;
	EndIf;
	
	If Common.SubsystemExists("StandardSubsystems.SaaS.UsersSaaS") Then
		ModuleUsersInternalSaaS = Common.CommonModule("UsersInternalSaaS");
		ModuleUsersInternalSaaS.WriteSaaSUser(UserRef, False, ServiceUserPassword);
	EndIf;
	
EndProcedure

// For the ChangesSelectionQueryText procedure.

Function KeyAndValue(Structure)
	
	For each KeyAndValue In Structure Do
		Return KeyAndValue;
	EndDo;
	
EndFunction

// For the UpdateRecordSet and UpdateNewSetRecordsByVariousNewRecords procedures.

Procedure WriteObjectOrRecordSet(Data, ObjectOrRecordSet)
	
	If Data.IBUpdate Then
		InfobaseUpdate.WriteData(ObjectOrRecordSet);
	Else
		ObjectOrRecordSet.Write();
	EndIf;
	
EndProcedure

// For the UpdateRecordSet and UpdateRecordSets procedures.

Function DimensionParametersGroupProcessed(DimensionName, DimensionValues)
	
	If DimensionName = Undefined Then
		DimensionValues = Undefined;
		
	ElsIf DimensionValues = Undefined Then
		DimensionName = Undefined;
		
	ElsIf TypeOf(DimensionValues) <> Type("Array")
	        AND TypeOf(DimensionValues) <> Type("FixedArray") Then
		
		DimensionValue = DimensionValues;
		DimensionValues = New Array;
		DimensionValues.Add(DimensionValue);
		
	ElsIf DimensionValues.Count() = 0 Then
		Return False;
	EndIf;
	
	Return True;
	
EndFunction

Procedure OrderDimensionsParametersGroups(Data)
	
	If Data.SecondDimensionName = Undefined Then
		Data.SecondDimensionName       = Data.ThirdDimensionName;
		Data.SecondDimensionValues  = Data.ThirdDimensionValues;
		Data.ThirdDimensionName      = Undefined;
		Data.ThirdDimensionValues = Undefined;
	EndIf;
	
	If Data.FirstDimensionName = Undefined Then
		Data.FirstDimensionName       = Data.SecondDimensionName;
		Data.FirstDimensionValues  = Data.SecondDimensionValues;
		Data.SecondDimensionName       = Data.ThirdDimensionName;
		Data.SecondDimensionValues  = Data.ThirdDimensionValues;
		Data.ThirdDimensionName      = Undefined;
		Data.ThirdDimensionValues = Undefined;
	EndIf;
	
	If Data.SecondDimensionValues  <> Undefined
	   AND Data.ThirdDimensionValues <> Undefined
	   AND Data.SecondDimensionValues.Count()
	   > Data.ThirdDimensionValues.Count() Then
		
		DimensionName      = Data.SecondDimensionName;
		DimensionValues = Data.SecondDimensionValues;
		
		Data.SecondDimensionName       = Data.ThirdDimensionName;
		Data.SecondDimensionValues  = Data.ThirdDimensionValues;
		Data.ThirdDimensionName      = DimensionName;
		Data.ThirdDimensionValues = DimensionValues;
	EndIf;
	
	If Data.FirstDimensionValues <> Undefined
	   AND Data.SecondDimensionValues <> Undefined
	   AND Data.FirstDimensionValues.Count()
	   > Data.SecondDimensionValues.Count() Then
		
		DimensionName      = Data.FirstDimensionName;
		DimensionValues = Data.FirstDimensionValues;
		
		Data.FirstDimensionName      = Data.SecondDimensionName;
		Data.FirstDimensionValues = Data.SecondDimensionValues;
		Data.SecondDimensionName      = DimensionName;
		Data.SecondDimensionValues = DimensionValues;
	EndIf;
	
EndProcedure

Function RecordSetFields(RecordSet)
	
	ComparisonFields = "";
	Table = RecordSet.Unload(New Array);
	For each Column In Table.Columns Do
		ComparisonFields = ComparisonFields + "," + Column.Name;
	EndDo;
	ComparisonFields = Mid(ComparisonFields, 2);
	
	Return ComparisonFields;
	
EndFunction

Procedure UpdateNewSetRecordsByAllNewRecords(Val Data, Val Filter, Val FieldsList,
				Val DimensionName, Val DimensionValues, HasChanges)
	
	LockRecordSetArea(Data.RecordSet, Data.FullRegisterName);
	
	Data.RecordSet.Read();
	NewSetRecords = Data.RecordSet.Unload();
	NewSetRecords.Indexes.Add(FieldsList);
	
	For each Value In DimensionValues Do
		Filter[DimensionName] = Value;
		For each FoundRecord In NewSetRecords.FindRows(Filter) Do
			NewSetRecords.Delete(FoundRecord);
		EndDo;
		For each FoundRecord In Data.NewRecords.FindRows(Filter) Do
			FillPropertyValues(NewSetRecords.Add(), FoundRecord);
		EndDo;
	EndDo;
	
	CurrentData = New Structure("RecordSet, ComparisonFields,
		|CheckOnly, AdditionalProperties, IBUpdate");
	FillPropertyValues(CurrentData, Data);
	CurrentData.Insert("NewRecords", NewSetRecords);
	CurrentData.Insert("RecordSetRead", True);
	
	UpdateRecordSet(CurrentData, HasChanges);
	
EndProcedure

Procedure RefreshNewSetRecordsByVariousNewRecords(Val Data, Val Filter, HasChanges)
	
	// Getting a number of records to be read.
	
	If Filter.Count() = 0 Then
		CurrentNewRecords = Data.NewRecords.Copy();
		CountForReading = Data.CountForReading;
	Else
		CurrentNewRecords = Data.NewRecords.Copy(Filter);
		
		FieldName = Data.CountByValues.Columns[0].Name;
		CountRow = Data.CountByValues.Find(Filter[FieldName], FieldName);
		CountForReading = ?(CountRow = Undefined, 0, CountRow.Count);
	EndIf;
	
	NewRecordFilter = New Structure("RowChangeKind, " + Data.ComparisonFields, 1);
	CurrentNewRecords.Indexes.Add("RowChangeKind, " + Data.ComparisonFields);

	RecordsKeys = CurrentNewRecords.Copy(, "RowChangeKind, " + Data.ComparisonFields);
	RecordsKeys.GroupBy("RowChangeKind, " + Data.ComparisonFields);
	RecordsKeys.GroupBy(Data.ComparisonFields, "RowChangeKind");
	
	FilterByRecordKey = New Structure(Data.ComparisonFields);
	
	If UpdateEntireRecordSet(CountForReading, RecordsKeys) Then
		
		LockRecordSetArea(Data.RecordSet, Data.FullRegisterName);
		Data.RecordSet.Read();
		NewSetRecords = Data.RecordSet.Unload();
		NewSetRecords.Indexes.Add(Data.ComparisonFields);
		
		For each Row In RecordsKeys Do
			FillPropertyValues(FilterByRecordKey, Row);
			FoundRows = NewSetRecords.FindRows(FilterByRecordKey);
			If Row.RowChangeKind = -1 Then
				If FoundRows.Count() > 0 Then
					// Deleting an old row.
					NewSetRecords.Delete(FoundRows[0]);
				EndIf;
			Else
				// Adding a new or updating an old row.
				If FoundRows.Count() = 0 Then
					RowToFill = NewSetRecords.Add();
				Else
					RowToFill = FoundRows[0];
				EndIf;
				FillPropertyValues(NewRecordFilter, FilterByRecordKey);
				FoundRecords = CurrentNewRecords.FindRows(NewRecordFilter);
				If FoundRecords.Count() = 1 Then
					NewRecord = FoundRecords[0];
				Else // Error in the NewRecords parameter.
					ExceptionOnRecordSearchError(Data);
				EndIf;
				FillPropertyValues(RowToFill, NewRecord);
			EndIf;
		EndDo;
		// Changing a record set to make it different from the new set records.
		If Data.RecordSet.Count() = NewSetRecords.Count() Then
			Data.RecordSet.Add();
		EndIf;
		
		CurrentData = New Structure("RecordSet, ComparisonFields,
			|CheckOnly, AdditionalProperties, IBUpdate");
		FillPropertyValues(CurrentData, Data);
		CurrentData.Insert("NewRecords", NewSetRecords);
		CurrentData.Insert("RecordSetRead", True);
		
		UpdateRecordSet(CurrentData, HasChanges);
	Else
		// Updating by row.
		SetAdditionalProperties(Data.SetForSingleRecord, Data.AdditionalProperties);
		For each Row In RecordsKeys Do
			Data.SetForSingleRecord.Clear();
			FillPropertyValues(FilterByRecordKey, Row);
			For each KeyAndValue In FilterByRecordKey Do
				SetFilter(
					Data.SetForSingleRecord.Filter[KeyAndValue.Key], KeyAndValue.Value);
			EndDo;
			LockRecordSetArea(Data.SetForSingleRecord, Data.FullRegisterName);
			If Row.RowChangeKind > -1 Then
				// Adding a new row or updating the existing row.
				FillPropertyValues(NewRecordFilter, FilterByRecordKey);
				FoundRecords = CurrentNewRecords.FindRows(NewRecordFilter);
				If FoundRecords.Count() = 1 Then
					NewRecord = FoundRecords[0];
				Else // Error in the NewRecords parameter.
					ExceptionOnRecordSearchError(Data);
				EndIf;
				FillPropertyValues(Data.SetForSingleRecord.Add(), NewRecord);
			EndIf;
			HasChanges = True;
			If Data.CheckOnly Then
				Return;
			EndIf;
			WriteObjectOrRecordSet(Data, Data.SetForSingleRecord);
		EndDo;
	EndIf;
	
EndProcedure

// For the UpdateNewSetRecordsByVariousNewRecords procedure.
Function UpdateEntireRecordSet(CountForReading, RecordsKeys)
	
	If CountForReading > 10000 Then
		Return False; // Record set is too big.
	EndIf;
	
	CountOfItemsToDelete = RecordsKeys.FindRows(
		New Structure("RowChangeKind", -1)).Count();
	
	CountOfItemsToAdd = RecordsKeys.FindRows(
		New Structure("RowChangeKind", 1)).Count();
	
	ForWriteCount = CountForReading - CountOfItemsToDelete
		+ CountOfItemsToAdd;
	
	If ForWriteCount > 10000 Then
		Return False; // Record set is too big.
	EndIf;
	
	ItemsToChangeCount = RecordsKeys.Count()
		- (CountOfItemsToDelete + CountOfItemsToAdd);
	
	NotChangedCount = CountForReading
		- (CountOfItemsToDelete + ItemsToChangeCount);
	
	FullyRewriteCosts =
	//                Operations:   |Read|Delete|Insert|
	      CountOfItemsToDelete   * ( 0.05  +  0.1          )
	    + ItemsToChangeCount  * ( 0.05  +  0.1   +  1   )
	    + CountOfItemsToAdd * (                   1   )
	    + NotChangedCount  * ( 0.05  +  0.1   +  1   );
	
	CostsToRewriteOneRecord =
	//                Operations:   |Delete|Insert|
	      CountOfItemsToDelete   * (   0.5          )
	    + ItemsToChangeCount  * (   0.5  +  1.2  )
	    + CountOfItemsToAdd * (   0.5  +  1.2  );
	
	Return FullyRewriteCosts < CostsToRewriteOneRecord;
	
EndFunction

Procedure ExceptionOnRecordSearchError(Parameters)
	
	For each ChangesRow In Parameters.NewRecords Do
		If ChangesRow.RowChangeKind <>  1
		   AND ChangesRow.RowChangeKind <> -1 Then
			
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Ошибка в процедуре UpdateRecordSets
				           |общего модуля AccessManagementInternal.
				           |
				           |Неверное значение параметра NewRecords - колонка
				           |RowChangeKind содержит недопустимое значение ""%1"".
				           |
				           |Допустимо только 2 значения: ""1"" и ""-1"".'; 
				           |en = 'An error occurred in the UpdateRecordSets procedure
				           |of the AccessManagementInternal common module.
				           |
				           |Incorrect value of the NewRecords parameter – the
				           |RowChangeKind column contains invalid value ""%1"".
				           |
				           |Only 2 values are possible: ""1"" and ""-1"".'; 
				           |pl = 'Błąd w procedurze UpdateRecordSets
				           |wspólnego modułu AccessManagementInternal.
				           |
				           |Nieprawidłowa wartość parametru NewRecords - kolumna
				           |RowChangeKind zawiera nieprawidłową wartość ""%1"".
				           |
				           |Dopuszczalne tylko 2 wartości: ""1"" i ""-1"".';
				           |es_ES = 'Error en el procedimiento UpdateRecordSets procedure 
				           |del módulo común AccessManagementInternal.
				           |
				           |Valor incorrecto del parámetro NewRecords - columna
				           |RowChangeKind contiene valor incorrecto ""%1"".
				           |
				           |Se admiten solo 2 valores: ""1"" y ""-1"".';
				           |es_CO = 'Error en el procedimiento UpdateRecordSets procedure 
				           |del módulo común AccessManagementInternal.
				           |
				           |Valor incorrecto del parámetro NewRecords - columna
				           |RowChangeKind contiene valor incorrecto ""%1"".
				           |
				           |Se admiten solo 2 valores: ""1"" y ""-1"".';
				           |tr = 'ErişimYönetimiServis 
				           |genel modülünün KayıtKümeleriniYenile prosedüründe bir hata oluştu. 
				           |
				           |YeniKayıtlar parametresi 
				           |hatalı değer - SatırDeğişikliğiTürü sütunu geçersiz "
" değerini içerir. %1
				           |Sadece 2 değer mevcuttur: ""1"" ve ""-1"".';
				           |it = 'Si è verificato un errore nella procedura UpdateRecordSets
				           |del modulo comune AccessManagementInternal.
				           |
				           |Il valore errato del parametro NewRecords - la colonna 
				           |RowChangeKind, contiene il valore non valido ""%1"".
				           |
				           |Sono disponibili solo due valori: ""1"" e ""-1"".';
				           |de = 'Fehler in der Prozedur UpdateRecordSets
				           |des allgemeinen Moduls AccessManagementInternal.
				           |
				           |Falscher Wert des Parameters NewRecords - Spalte
				           |RowChangeKind enthält ungültigen Wert ""%1"".
				           |
				           |Nur 2 Werte sind erlaubt: ""1"" und ""-1"".'"),
				String(ChangesRow.RowChangeKind));
			Raise ErrorText;
		EndIf;
	EndDo;
	
	ErrorText =
		NStr("ru = 'Ошибка в процедуре UpdateRecordSets
		           |общего модуля AccessManagementInternal.
		           |
		           |Не удалось найти требуемую в строку
		           |в значении параметра NewRecords.'; 
		           |en = 'An error occurred in the UpdateRecordSets procedure
		           |of the AccessManagementInternal common module.
		           |
		           |Cannot find the required string
		           |in the NewRecords parameter value.'; 
		           |pl = 'Błąd w procedurze UpdateRecordSets
		           | wspólnego modułu AccessManagementInternal.
		           |
		           |Nie udało się znaleźć odpowiednią w wierszu
		           |w wartości parametru NewRecords.';
		           |es_ES = 'Error en el procedimiento UpdateRecordSets 
		           |del módulo común AccessManagementInternal.
		           |
		           |No se ha podido encontrar una línea requerida
		           |en el valor del parámetro NewRecords.';
		           |es_CO = 'Error en el procedimiento UpdateRecordSets 
		           |del módulo común AccessManagementInternal.
		           |
		           |No se ha podido encontrar una línea requerida
		           |en el valor del parámetro NewRecords.';
		           |tr = 'ErişimYönetimiServis 
		           |genel modülünün KayıtKümeleriniYenile prosedüründe 
		           |bir hata oluştu. 
		           |
		           | YeniKayıtlar parametre değerinde gerekli satır bulunamadı.';
		           |it = 'Si è verificato un errore nella procedura UpdateRecordSets
		           |del modulo comune AccessManagementInternal.
		           |
		           |Impossibile trovare la stringa richiesta
		           |nel valore di parametro NewRecords.';
		           |de = 'Fehler in der Prozedur UpdateRecordSets
		           |des allgemeinen Moduls AccessManagementInternal.
		           |
		           |Es war nicht möglich, den gewünschten Wert in der Zeile
		           |im Wert des Parameters NewRecords zu finden.'");
	
	Raise ErrorText;
	
EndProcedure

Procedure LockRecordSetArea(RecordSet, FullRegisterName = Undefined)
	
	If NOT TransactionActive() Then
		Return;
	EndIf;
	
	If FullRegisterName = Undefined Then
		FullRegisterName = Metadata.FindByType(TypeOf(RecordSet)).FullName();
	EndIf;
	
	Lock = New DataLock;
	LockItem = Lock.Add(FullRegisterName);
	For each FilterItem In RecordSet.Filter Do
		If FilterItem.Use Then
			LockItem.SetValue(FilterItem.DataPath, FilterItem.Value);
		EndIf;
	EndDo;
	Lock.Lock();
	
EndProcedure

Procedure SetFilter(FilterItem, FilterValue)
	
	FilterItem.Value = FilterValue;
	FilterItem.Use = True;
	
EndProcedure

Function RecordByMultipleSets(Data, Filter, FieldName, FieldValues)
	
	Query = New Query;
	Query.SetParameter("FieldValues", FieldValues);
	Query.Text =
	"SELECT
	|	COUNT(*) AS Count
	|FROM
	|	&CurrentTable AS CurrentTable
	|WHERE
	|	&FilterCriterion
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	COUNT(*) AS Count
	|FROM
	|	&CurrentTable AS CurrentTable
	|WHERE
	|	CurrentTable.FieldName IN(&FieldValues)
	|	AND &FilterCriterion
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	CurrentTable.FieldName AS FieldName,
	|	COUNT(*) AS Count
	|FROM
	|	&CurrentTable AS CurrentTable
	|WHERE
	|	CurrentTable.FieldName IN(&FieldValues)
	|	AND &FilterCriterion
	|
	|GROUP BY
	|	CurrentTable.FieldName";
	
	FilterCriterion = "True";
	If Data.FixedFilter <> Undefined Then
		For each KeyAndValue In Data.FixedFilter Do
			FilterCriterion = FilterCriterion + "
			|	AND CurrentTable." + KeyAndValue.Key + " = &" + KeyAndValue.Key;
			Query.SetParameter(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	EndIf;
	
	FilterOfItemsToAdd = New Structure;
	FilterOfItemsToAdd.Insert("RowChangeKind", 1);
	FilterOfItemsToRemove = New Structure;
	FilterOfItemsToRemove.Insert("RowChangeKind", -1);
	
	For each KeyAndValue In Filter Do
		FilterCriterion = FilterCriterion + "
		|	AND CurrentTable." + KeyAndValue.Key + " = &" + KeyAndValue.Key;
		Query.SetParameter(KeyAndValue.Key, KeyAndValue.Value);
		FilterOfItemsToAdd.Insert(KeyAndValue.Key, KeyAndValue.Value);
		FilterOfItemsToRemove.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	
	Query.Text = StrReplace(Query.Text, "FieldName", FieldName);
	Query.Text = StrReplace(Query.Text, "&CurrentTable", Data.FullRegisterName);
	Query.Text = StrReplace(Query.Text, "&FilterCriterion", FilterCriterion);
	
	QueriesResults = Query.ExecuteBatch();
	
	// Total number of items without filter.
	CountOfAllItems = QueriesResults[0].Unload()[0].Count;
	Data.Insert("CountForReading", CountOfAllItems);
	
	// Number of filtered items to be updated.
	CountOfItemsToUpdate = QueriesResults[1].Unload()[0].Count;
	
	CountOfItemsToAdd = Data.NewRecords.FindRows(FilterOfItemsToAdd).Count();
	If CountOfItemsToAdd > CountOfItemsToUpdate Then
		CountOfItemsToUpdate = CountOfItemsToAdd;
	EndIf;
	
	CountOfItemsToDelete = Data.NewRecords.FindRows(FilterOfItemsToRemove).Count();
	If CountOfItemsToDelete > CountOfItemsToUpdate Then
		CountOfItemsToUpdate = CountOfItemsToDelete;
	EndIf;
	
	// Number of items to be read by filter values.
	CountByValues = QueriesResults[2].Unload();
	CountByValues.Indexes.Add(FieldName);
	Data.Insert("CountByValues", CountByValues);
	
	Return CountOfAllItems * 0.7 > CountOfItemsToUpdate;
	
EndFunction

Procedure ReadCountForReading(Data)
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	COUNT(*) AS Count
	|FROM
	|	&CurrentTable AS CurrentTable
	|WHERE
	|	&FilterCriterion";
	
	FilterCriterion = "True";
	If Data.FixedFilter <> Undefined Then
		For each KeyAndValue In Data.FixedFilter Do
			FilterCriterion = FilterCriterion + "
			|	AND CurrentTable." + KeyAndValue.Key + " = &" + KeyAndValue.Key;
			Query.SetParameter(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	EndIf;
	
	Query.Text = StrReplace(Query.Text, "&CurrentTable", Data.FullRegisterName);
	Query.Text = StrReplace(Query.Text, "&FilterCriterion", FilterCriterion);
	
	Data.Insert("CountForReading", Query.Execute().Unload()[0].Count);
	
EndProcedure

Procedure SetAdditionalProperties(RecordSet, AdditionalProperties)
	
	If TypeOf(AdditionalProperties) = Type("Structure") Then
		For each KeyAndValue In AdditionalProperties Do
			RecordSet.AdditionalProperties.Insert(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	EndIf;
	
EndProcedure

// For the UpdateInformationRegister procedure.

Function TableColumnValues(Table, ColumnName)
	
	NewTable = Table.Copy(, ColumnName);
	
	NewTable.GroupBy(ColumnName);
	
	Return NewTable.UnloadColumn(ColumnName);
	
EndFunction

// Management of AccessKinds and AccessValues tables in edit forms.

Procedure AddAuxiliaryDataAttributesToForm(Form, TablesStorageAttributeName)
	
	AttributesToAdd = New Array;
	AccessValuesTypesDetails = Metadata.DefinedTypes.AccessValue.Type;
	
	PathToObject = ?(ValueIsFilled(TablesStorageAttributeName), TablesStorageAttributeName + ".", "");
	
	// Adding attributes to the AccessKinds table.
	AttributesToAdd.Add(New FormAttribute(
		"Used", New TypeDescription("Boolean"), PathToObject + "AccessKinds"));
	
	// Adding separate attributes.
	AttributesToAdd.Add(New FormAttribute(
		"CurrentAccessKind", AccessValuesTypesDetails));
	
	AttributesToAdd.Add(New FormAttribute(
		"CurrentTypesOfValuesToSelect", New TypeDescription("ValueList")));
	
	AttributesToAdd.Add(New FormAttribute(
		"CurrentTypeOfValuesToSelect", AccessValuesTypesDetails));
	
	If NOT FormAttributeExists(Form, "UseExternalUsers") Then
		AttributesToAdd.Add(New FormAttribute(
			"UseExternalUsers", New TypeDescription("Boolean")));
	EndIf;
	
	AttributesToAdd.Add(New FormAttribute(
		"TablesStorageAttributeName", New TypeDescription("String")));
	
	AttributesToAdd.Add(New FormAttribute(
		"IsAccessGroupProfile", New TypeDescription("Boolean")));
	
	AttributesToAdd.Add(New FormAttribute(
		"AccessKindUsers", AccessValuesTypesDetails));
	
	AttributesToAdd.Add(New FormAttribute(
		"AccessKindExternalUsers", AccessValuesTypesDetails));
	
	// Adding the AllAccessKinds table.
	AttributesToAdd.Add(New FormAttribute(
		"AllAccessKinds", New TypeDescription("ValueTable")));
	
	AttributesToAdd.Add(New FormAttribute(
		"Ref", AccessValuesTypesDetails, "AllAccessKinds"));
	
	AttributesToAdd.Add(New FormAttribute(
		"Presentation", New TypeDescription("String"), "AllAccessKinds"));
	
	AttributesToAdd.Add(New FormAttribute(
		"Used", New TypeDescription("Boolean"), "AllAccessKinds"));
	
	// Adding the PresentationsAllAllowed table.
	AttributesToAdd.Add(New FormAttribute(
		"PresentationsAllAllowed", New TypeDescription("ValueTable")));
	
	AttributesToAdd.Add(New FormAttribute(
		"Name", New TypeDescription("String"), "PresentationsAllAllowed"));
	
	AttributesToAdd.Add(New FormAttribute(
		"Presentation", New TypeDescription("String"), "PresentationsAllAllowed"));
	
	// Adding the AllTypesOfValuesToSelect table.
	AttributesToAdd.Add(New FormAttribute(
		"AllTypesOfValuesToSelect", New TypeDescription("ValueTable")));
	
	AttributesToAdd.Add(New FormAttribute(
		"AccessKind", AccessValuesTypesDetails, "AllTypesOfValuesToSelect"));
	
	AttributesToAdd.Add(New FormAttribute(
		"ValuesType", AccessValuesTypesDetails, "AllTypesOfValuesToSelect"));
	
	AttributesToAdd.Add(New FormAttribute(
		"TypePresentation", New TypeDescription("String"), "AllTypesOfValuesToSelect"));
	
	AttributesToAdd.Add(New FormAttribute(
		"TableName", New TypeDescription("String"), "AllTypesOfValuesToSelect"));
	
	Form.ChangeAttributes(AttributesToAdd);
	
EndProcedure

Procedure FillTableAllAccessKindsInForm(Form)
	
	For each AccessKindProperties In AccessKindProperties() Do
		Row = Form.AllAccessKinds.Add();
		Row.Ref        = AccessKindProperties.Ref;
		Row.Used  = AccessKindUsed(Row.Ref);
		// Making sure the presentations are unique.
		Presentation = AccessKindProperties.Presentation;
		Filter = New Structure("Presentation", Presentation);
		While Form.AllAccessKinds.FindRows(Filter).Count() > 0 Do
			Filter.Presentation = Filter.Presentation + " ";
		EndDo;
		Row.Presentation = Presentation;
	EndDo;
	
EndProcedure

Procedure FillPresentationTableAllAllowedInForm(Form, ThisProfile)
	
	If ThisProfile Then
		Row = Form.PresentationsAllAllowed.Add();
		Row.Name = "AllDeniedByDefault";
		Row.Presentation = NStr("ru = 'Все запрещены, исключения назначаются в группах доступа'; en = 'All denied, exceptions are set in access groups'; pl = 'Wszystkie zabronione, wyjątki są określane w grupach dostępu';es_ES = 'Todo prohibido, excepciones están asignadas en los grupos de acceso';es_CO = 'Todo prohibido, excepciones están asignadas en los grupos de acceso';tr = 'Hepsi yasak, istisnalar erişim gruplarında atanır';it = 'Tutti rifiutati, le eccezioni sono impostate nei gruppi di accesso';de = 'Alle verboten, Ausnahmen sind in Zugriffsgruppen zugeordnet'");
		
		Row = Form.PresentationsAllAllowed.Add();
		Row.Name = "AllAllowedByDefault";
		Row.Presentation = NStr("ru = 'Все разрешены, исключения назначаются в группах доступа'; en = 'All allowed, exceptions are set in access groups'; pl = 'Wszystkie dozwolone wyjątki są określane w grupach dostępu';es_ES = 'Todo permitido, excepciones están asignadas en los grupos de acceso';es_CO = 'Todo permitido, excepciones están asignadas en los grupos de acceso';tr = 'Hepsine izin verilmiş, istisnalar erişim gruplarında atanır';it = 'Tutti permessi, le eccezioni sono impostate nei gruppi di accesso';de = 'Alle erlaubt, Ausnahmen sind in Zugriffsgruppen zugeordnet'");
		
		Row = Form.PresentationsAllAllowed.Add();
		Row.Name = "AllDenied";
		Row.Presentation = NStr("ru = 'Все запрещены, исключения назначаются в профиле'; en = 'All denied, exceptions are set in profile'; pl = 'Wszystkie zabronione, wyjątki są określane w profilu';es_ES = 'Todo prohibido, excepciones están asignadas en un perfil';es_CO = 'Todo prohibido, excepciones están asignadas en un perfil';tr = 'Hepsi yasak, istisnalar profilde atanır';it = 'Tutti vietati, le eccezioni sono impostate nel profilo';de = 'Alle verboten, Ausnahmen sind in einem Profil zugeordnet'");
		
		Row = Form.PresentationsAllAllowed.Add();
		Row.Name = "AllAllowed";
		Row.Presentation = NStr("ru = 'Все разрешены, исключения назначаются в профиле'; en = 'All allowed, exceptions are set in profile'; pl = 'Wszystkie dozwolone wyjątki są określane w profilu';es_ES = 'Todo permitido, excepciones están asignadas en un perfil';es_CO = 'Todo permitido, excepciones están asignadas en un perfil';tr = 'Hepsine izin verilmiş, istisnalar profilde atanır';it = 'Tutti permessi, le eccezioni sono impostate nel profilo';de = 'Alle erlaubt, Ausnahmen sind in einem Profil zugeordnet'");
	Else
		Row = Form.PresentationsAllAllowed.Add();
		Row.Name = "AllDenied";
		Row.Presentation = NStr("ru = 'Все запрещены'; en = 'All denied'; pl = 'Wszystkie zabronione';es_ES = 'Todo prohibido';es_CO = 'Todo prohibido';tr = 'Hepsi yasak';it = 'Tutti vietati';de = 'Alle verboten'");
		
		Row = Form.PresentationsAllAllowed.Add();
		Row.Name = "AllAllowed";
		Row.Presentation = NStr("ru = 'Все разрешены'; en = 'All allowed'; pl = 'Wszystkie dozwolone';es_ES = 'Todo permitido';es_CO = 'Todo permitido';tr = 'Tüm izin verilenler';it = 'Tutto permesso';de = 'Alle erlaubt'");
	EndIf;
	
	ChoiceList = Form.Items.AccessKindsAllAllowedPresentation.ChoiceList;
	
	For each Row In Form.PresentationsAllAllowed Do
		ChoiceList.Add(Row.Presentation);
	EndDo;
	
EndProcedure

Procedure ApplyTableAccessKindsInForm(Form)
	
	Parameters = AllowedValuesEditFormParameters(Form);
	
	// Appearance of representation of unused access kinds.
	ConditionalAppearanceItem = Form.ConditionalAppearance.Items.Add();
	
	AppearanceColorItem = ConditionalAppearanceItem.Appearance.Items.Find("TextColor");
	AppearanceColorItem.Value = WebColors.Gray;
	AppearanceColorItem.Use = True;
	
	DataSelectionItemsGroup = ConditionalAppearanceItem.Filter.Items.Add(Type("DataCompositionFilterItemGroup"));
	DataSelectionItemsGroup.GroupType = DataCompositionFilterItemsGroupType.AndGroup;
	DataSelectionItemsGroup.Use = True;
	
	DataFilterItem = DataSelectionItemsGroup.Items.Add(Type("DataCompositionFilterItem"));
	DataFilterItem.LeftValue  = New DataCompositionField(Parameters.PathToTables + "AccessKinds.AccessKind");
	DataFilterItem.ComparisonType   = DataCompositionComparisonType.NotEqual;
	DataFilterItem.RightValue = Undefined;
	DataFilterItem.Use  = True;
	
	DataFilterItem = DataSelectionItemsGroup.Items.Add(Type("DataCompositionFilterItem"));
	DataFilterItem.LeftValue  = New DataCompositionField(Parameters.PathToTables + "AccessKinds.Used");
	DataFilterItem.ComparisonType   = DataCompositionComparisonType.Equal;
	DataFilterItem.RightValue = False;
	DataFilterItem.Use  = True;
	
	FieldAppearanceItem = ConditionalAppearanceItem.Fields.Items.Add();
	FieldAppearanceItem.Field = New DataCompositionField("AccessKinds");
	FieldAppearanceItem.Use = True;
	
EndProcedure

Procedure DeleteExcessAccessValues(Form, CurrentObject = Undefined)
	
	Parameters = AllowedValuesEditFormParameters(Form, CurrentObject);
	
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	ByGroupsAndValuesTypes = AccessKindsProperties.ByGroupsAndValuesTypes;
	
	Filter = AccessManagementInternalClientServer.FilterInAllowedValuesEditFormTables(
		Form, "");
	
	Index = Parameters.AccessValues.Count()-1;
	While Index >= 0 Do
		AccessValue = Parameters.AccessValues[Index].AccessValue;
		
		AccessKindProperties = ByGroupsAndValuesTypes.Get(TypeOf(AccessValue));
		If AccessKindProperties <> Undefined Then
			FillPropertyValues(Filter, Parameters.AccessValues[Index]);
			Filter.Insert("AccessKind", AccessKindProperties.Ref);
		EndIf;
		
		If AccessKindProperties = Undefined
		 OR Parameters.AccessValues[Index].AccessKind <> Filter.AccessKind
		 OR Parameters.AccessKinds.FindRows(Filter).Count() = 0 Then
			
			Parameters.AccessValues.Delete(Index);
		EndIf;
		Index = Index - 1;
	EndDo;
	
EndProcedure

Procedure DeleteNonExistentAccessKindsAndValues(Form, CurrentObject = Undefined)
	
	Parameters = AllowedValuesEditFormParameters(Form, CurrentObject);
	
	Index = Parameters.AccessKinds.Count()-1;
	While Index >= 0 Do
		AccessKind = Parameters.AccessKinds[Index].AccessKind;
		If AccessKindProperties(AccessKind) = Undefined Then
			Parameters.AccessKinds.Delete(Index);
		EndIf;
		Index = Index - 1;
	EndDo;
	
	DeleteExcessAccessValues(Form, CurrentObject);
	
EndProcedure

Function AllowedValuesEditFormParameters(Form, CurrentObject = Undefined)
	
	Return AccessManagementInternalClientServer.AllowedValuesEditFormParameters(
		Form, CurrentObject);
	
EndFunction

Function FormAttributeExists(Form, AttributeName)
	
	Structure = New Structure(AttributeName, Null);
	
	FillPropertyValues(Structure, Form);
	
	Return Structure[AttributeName] <> Null;
	
EndFunction

// For the SessionParametersSetting procedure .

Function AllAccessKindsCombinations(UnorderedNamesArray)
	
	// Maximum combination length limit to prevent session parameters and RLS template preprocessor from 
	// overloading.
	MaxCombinationLength = 4;
	
	List = New ValueList;
	If TypeOf(UnorderedNamesArray) = Type("FixedArray") Then
		List.LoadValues(New Array(UnorderedNamesArray));
	Else
		List.LoadValues(UnorderedNamesArray);
	EndIf;
	List.SortByValue();
	NamesArray = List.UnloadValues();
	
	RowTotal = New Array;
	TotalRow = New Array;
	
	// Full list is always supported.
	For each Name In NamesArray Do
		TotalRow.Add(Name);
	EndDo;
	
	RowTotal.Add(TotalRow);
	
	If NamesArray.Count() < 3 Then
		Return RowsGroupsInLine(RowTotal);
	EndIf;
	
	FirstName = NamesArray[0];
	NamesArray.Delete(0);
	
	LastName = NamesArray[NamesArray.Count()-1];
	NamesArray.Delete(NamesArray.Count()-1);
	
	CountOfNamesInCombination = NamesArray.Count();
	
	If CountOfNamesInCombination > 1 Then
		
		If (CountOfNamesInCombination-1) <= MaxCombinationLength Then
			CombinationLength = CountOfNamesInCombination-1;
		Else
			CombinationLength = MaxCombinationLength;
		EndIf;
		
		NamesPositionsInCombination = New Array;
		For Counter = 1 To CombinationLength Do
			NamesPositionsInCombination.Add(Counter);
		EndDo;
		
		While CombinationLength > 0 Do
			While True Do
				// Adding a combination from the current items.
				TotalRow = New Array;
				TotalRow.Add(FirstName);
				For Index = 0 To CombinationLength-1 Do
					TotalRow.Add(NamesArray[NamesPositionsInCombination[Index]-1]);
				EndDo;
				TotalRow.Add(LastName);
				RowTotal.Add(TotalRow);
				// Increasing a position in the combination.
				Index = CombinationLength-1;
				While Index >= 0 Do
					If NamesPositionsInCombination[Index] < CountOfNamesInCombination - (CombinationLength - (Index+1)) Then
						NamesPositionsInCombination[Index] = NamesPositionsInCombination[Index] + 1;
						// Filling senior positions with initial values.
						For SeniorPositionIndex = Index+1 To CombinationLength-1 Do
							NamesPositionsInCombination[SeniorPositionIndex] =
								NamesPositionsInCombination[Index] + SeniorPositionIndex - Index;
						EndDo;
						Break;
					Else
						Index = Index - 1;
					EndIf;
				EndDo;
				If Index < 0 Then
					Break;
				EndIf;
			EndDo;
			CombinationLength = CombinationLength - 1;
			For Index = 0 To CombinationLength - 1 Do
				NamesPositionsInCombination[Index] = Index + 1;
			EndDo;
		EndDo;
	EndIf;
	
	TotalRow = New Array;
	TotalRow.Add(FirstName);
	TotalRow.Add(LastName);
	RowTotal.Add(TotalRow);
	
	Return RowsGroupsInLine(RowTotal);
	
EndFunction

Function RowsGroupsInLine(RowsGroups)
	
	RowTotal = New Array;
	
	For Each TotalRow In RowsGroups Do
		RowTotal.Add(StrConcat(TotalRow, ","));
	EndDo;
	
	Rows = StrConcat(
		RowTotal,
		",
		|,");
	
	Template =
		"%2%1%2
		|";
	
	Return StringFunctionsClientServer.SubstituteParametersToString(Template, Rows, ",");
	
EndFunction

// For the UpdateAccessValuesSets, OnChangeAccessValuesSets procedures.

// Checks whether sets in a tabular section differ from the new sets.
Function AccessValuesSetsOfTabularSectionChanged(ObjectRef, NewSets)
	
	OldSets = Common.ObjectAttributeValue(
		ObjectRef, "AccessValuesSets").Unload();
	
	If OldSets.Count() <> NewSets.Count() Then
		Return True;
	EndIf;
	
	OldSets.Columns.Add("AccessKind", New TypeDescription("String"));
	AccessManagement.AddAccessValuesSets(
		OldSets, AccessManagement.AccessValuesSetsTable(), False, True);
	
	SearchFields = "SetNumber, AccessValue, Clarification, Read, Update";
	
	NewSets.Indexes.Add(SearchFields);
	Filter = New Structure(SearchFields);
	
	For each Row In OldSets Do
		FillPropertyValues(Filter, Row);
		If NewSets.FindRows(Filter).Count() <> 1 Then
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

// This method is required by AllowedDynamicListValues.
Procedure AddQueryToPackage(PackageText, QueryText)
	
	Separator =
	"
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";
	
	PackageText = PackageText + Separator + QueryText;
	
EndProcedure

// This method is required by AllowedDynamicListValues.
Procedure UnionQueryWithQuery(QueryText, QueryTextToAdd)
	
	Combiner =
	"
	|
	|UNION ALL
	|
	|";
	
	QueryText = QueryText + Combiner + QueryTextToAdd;
	
EndProcedure

// Updating access kind properties.

// For the UpdateAccessKindsPropertiesDetails procedure.
// Returns properties of access kinds filled when embedding in the OnFillAccessKinds procedure of 
// the AccessManagementOverridable common module and other handlers with the same name for this 
// event.
// 
//
Function AccessKindsProperties()
	
	// 1. Filling in the data specified upon implementation.
	
	AccessKinds = New ValueTable;
	AccessKinds.Columns.Add("Name",                    New TypeDescription("String"));
	AccessKinds.Columns.Add("Presentation",          New TypeDescription("String"));
	AccessKinds.Columns.Add("ValuesType",            New TypeDescription("Type"));
	AccessKinds.Columns.Add("ValuesGroupsType",       New TypeDescription("Type"));
	AccessKinds.Columns.Add("MultipleValuesGroups", New TypeDescription("Boolean"));
	AccessKinds.Columns.Add("AdditionalTypes",     New TypeDescription("ValueTable"));
	
	SSLSubsystemsIntegration.OnFillAccessKinds(AccessKinds);
	AccessManagementOverridable.OnFillAccessKinds(AccessKinds);
	
	// Checks:
	// - an access value type is not specified for 2 access kinds
	// - access value type Users, UserGroups is used only for Users access kind.
	// the ExternalUsers, ExternalUserGroups access value type is used only for the
	// ExternalUsers access kind.
	// Names of access kinds Object, Condition, RightsSettings, ReadRight, and UpdateRight are not specified.
	// Value group type does not match the value type.
	
	// 2. Preparing various collections of access kind properties used when running the application.
	PropertiesArray         = New Array;
	ByRefs             = New Map;
	ByNames              = New Map;
	ByValuesTypes       = New Map;
	ByGroupsAndValuesTypes = New Map;
	
	AccessValuesWithGroups = New Structure;
	AccessValuesWithGroups.Insert("ByTypes",                        New Map);
	AccessValuesWithGroups.Insert("ByRefsTypes",                  New Map);
	AccessValuesWithGroups.Insert("NamesOfTablesToUpdate",       New Array);
	AccessValuesWithGroups.Insert("ValueGroupTypesForUpdate", New Map);
	AccessValuesWithGroups.Insert("ByTypesForUpdate",           New Map);
	AccessValuesWithGroups.Insert("ByRefTypesForUpdate",     New Map);
	
	Parameters = New Structure;
	Parameters.Insert("TypesOfAccessValuesToDefine",
		AccessManagementInternalCached.TableFieldTypes("DefinedType.AccessValue"));
	
	ErrorTitle =
		NStr("ru = 'Ошибка в процедуре OnFillAccessKinds общего модуля AccessManagementOverridable.'; en = 'An error occurred in the OnFillAccessKinds procedure of the AccessManagementOverridable common module.'; pl = 'Błąd w procedurze OnFillAccessKinds wspólnego modułu AccessManagementOverridable.';es_ES = 'Error en el procedimiento OnFillAccessKinds del módulo común AccessManagementOverridable.';es_CO = 'Error en el procedimiento OnFillAccessKinds del módulo común AccessManagementOverridable.';tr = 'AccessManagementOverridable ortak modülünün OnFillAccessKinds prosedüründe bir hata oluştu.';it = 'Si è verificato un errore nella procedura OnFillAccessKinds del modulo comune AccessManagementOverridable.';de = 'Fehler in der Vorgehensweise OnFillAccessKinds des allgemeinen Moduls AccessManagementOverridable.'")
		+ Chars.LF
		+ Chars.LF;
	
	Parameters.Insert("ErrorTitle", ErrorTitle);
	
	AllAccessKindsNames = New Map;
	AllAccessKindsNames.Insert(Upper("Object"),         True);
	AllAccessKindsNames.Insert(Upper("Condition"),        True);
	AllAccessKindsNames.Insert(Upper("RightsSettings"),  True);
	AllAccessKindsNames.Insert(Upper("ReadRight"),    True);
	AllAccessKindsNames.Insert(Upper("EditRight"), True);
	
	AllValuesTypes      = New Map;
	AllValuesGroupsTypes = New Map;
	
	For each AccessKind In AccessKinds Do
		
		If AllAccessKindsNames[Upper(AccessKind.Name)] <> Undefined Then
			ErrorText = ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Имя вида доступа ""%1"" уже определено.'; en = 'Access kind name %1 is already defined.'; pl = 'Nazwa typu dostępu ""%1"" została już zdefiniowana.';es_ES = 'Nombre del tipo de acceso ""%1"" ya se ha definido.';es_CO = 'Nombre del tipo de acceso ""%1"" ya se ha definido.';tr = '""%1"" Erişim türü adı zaten tanımlanmıştı.';it = 'Nome tipo di accesso %1 già definito.';de = 'Der Name des Zugriffstyps ""%1"" wurde bereits definiert.'"),
				AccessKind.Name);
			Raise ErrorText;
		EndIf;
		
		// Checking for duplicate value types and group types.
		CheckType(AccessKind, AccessKind.ValuesType,      AllValuesTypes,      Parameters);
		CheckType(AccessKind, AccessKind.ValuesGroupsType, AllValuesGroupsTypes, Parameters, True);
		// Checking for intersection of value types and group types.
		CheckType(AccessKind, AccessKind.ValuesType,      AllValuesGroupsTypes, Parameters,       , True);
		CheckType(AccessKind, AccessKind.ValuesGroupsType, AllValuesTypes,      Parameters, True, True);
		
		For each Row In AccessKind.AdditionalTypes Do
			// Checking for duplicate value types and group types.
			CheckType(AccessKind, Row.ValuesType,      AllValuesTypes,      Parameters);
			CheckType(AccessKind, Row.ValuesGroupsType, AllValuesGroupsTypes, Parameters, True);
			// Checking for intersection of value types and group types.
			CheckType(AccessKind, Row.ValuesType,      AllValuesGroupsTypes, Parameters,       , True);
			CheckType(AccessKind, Row.ValuesGroupsType, AllValuesTypes,      Parameters, True, True);
		EndDo;
		
		ValueTypeBlankRef = Common.ObjectManagerByFullName(
			Metadata.FindByType(AccessKind.ValuesType).FullName()).EmptyRef();
		
		Properties = New Structure;
		Properties.Insert("Name",                      AccessKind.Name);
		Properties.Insert("Ref",                   ValueTypeBlankRef);
		Properties.Insert("Presentation",            AccessKind.Presentation);
		Properties.Insert("ValuesType",              AccessKind.ValuesType);
		Properties.Insert("ValuesGroupsType",         AccessKind.ValuesGroupsType);
		Properties.Insert("MultipleValuesGroups",   AccessKind.MultipleValuesGroups);
		Properties.Insert("AdditionalTypes",       New Array);
		Properties.Insert("TypesOfValuesToSelect",   New Array);
		
		PropertiesArray.Add(Properties);
		ByNames.Insert(Properties.Name, Properties);
		ByRefs.Insert(ValueTypeBlankRef, Properties);
		ByValuesTypes.Insert(Properties.ValuesType, Properties);
		ByGroupsAndValuesTypes.Insert(Properties.ValuesType, Properties);
		If Properties.ValuesGroupsType <> Type("Undefined") Then
			ByGroupsAndValuesTypes.Insert(Properties.ValuesGroupsType, Properties);
		EndIf;
		FillAccessValuesWithGroups(Properties, AccessValuesWithGroups, Properties, Parameters);
		
		For each Row In AccessKind.AdditionalTypes Do
			Item = New Structure;
			Item.Insert("ValuesType",            Row.ValuesType);
			Item.Insert("ValuesGroupsType",       Row.ValuesGroupsType);
			Item.Insert("MultipleValuesGroups", Row.MultipleValuesGroups);
			Properties.AdditionalTypes.Add(Item);
			ByValuesTypes.Insert(Row.ValuesType, Properties);
			ByGroupsAndValuesTypes.Insert(Row.ValuesType, Properties);
			If Row.ValuesGroupsType <> Type("Undefined") Then
				ByGroupsAndValuesTypes.Insert(Row.ValuesGroupsType, Properties);
			EndIf;
			FillAccessValuesWithGroups(Row, AccessValuesWithGroups, Properties, Parameters);
		EndDo;
		
	EndDo;
	
	NoGroupsForAccessValue      = New Array;
	WithOneGroupForAccessValue = New Array;
	AccessValuesTypesWithGroups    = New Map;
	
	AccessKindsWithGroups = New Map;
	
	For each KeyAndValue In AccessValuesWithGroups.ByRefsTypes Do
		AccessKindName = KeyAndValue.Value.Name;
		AccessKindsWithGroups.Insert(AccessKindName, True);
		
		BlankRef = MetadataObjectEmptyRef(KeyAndValue.Key);
		AccessValuesTypesWithGroups.Insert(TypeOf(BlankRef), BlankRef);
		
		If NOT KeyAndValue.Value.MultipleValuesGroups
		   AND WithOneGroupForAccessValue.Find(AccessKindName) = Undefined Then
		   
			WithOneGroupForAccessValue.Add(AccessKindName);
		EndIf;
	EndDo;
	
	AccessValuesTypesWithGroups.Insert(Type("CatalogRef.Users"),
		Catalogs.Users.EmptyRef());
	
	AccessValuesTypesWithGroups.Insert(Type("CatalogRef.UserGroups"),
		Catalogs.UserGroups.EmptyRef());
	
	AccessValuesTypesWithGroups.Insert(Type("CatalogRef.ExternalUsers"),
		Catalogs.ExternalUsers.EmptyRef());
	
	AccessValuesTypesWithGroups.Insert(Type("CatalogRef.ExternalUsersGroups"),
		Catalogs.ExternalUsersGroups.EmptyRef());
	
	For each AccessKindProperties In PropertiesArray Do
		If AccessKindsWithGroups.Get(AccessKindProperties.Name) <> Undefined Then
			Continue;
		EndIf;
		If AccessKindProperties.Name = "Users"
		 OR AccessKindProperties.Name = "ExternalUsers" Then
			Continue;
		EndIf;
		NoGroupsForAccessValue.Add(AccessKindProperties.Name);
	EndDo;
	
	AccessKindsProperties = New Structure;
	AccessKindsProperties.Insert("Array",                          PropertiesArray);
	AccessKindsProperties.Insert("ByNames",                        ByNames);
	AccessKindsProperties.Insert("ByRefs",                       ByRefs);
	AccessKindsProperties.Insert("ByValuesTypes",                 ByValuesTypes);
	AccessKindsProperties.Insert("ByGroupsAndValuesTypes",           ByGroupsAndValuesTypes);
	AccessKindsProperties.Insert("AccessValuesWithGroups",        AccessValuesWithGroups);
	AccessKindsProperties.Insert("NoGroupsForAccessValue",      NoGroupsForAccessValue);
	AccessKindsProperties.Insert("WithOneGroupForAccessValue", WithOneGroupForAccessValue);
	AccessKindsProperties.Insert("AccessValuesTypesWithGroups",    AccessValuesTypesWithGroups);
	AccessKindsProperties.Insert("AccessValuesSetsOwner",
		DataStringForHashing(Metadata.DefinedTypes.AccessValuesSetsOwnerObject.Type));
	
	// Checking application version update compatibility.
	If Parameters.TypesOfAccessValuesToDefine.Get(
		TypeOf(ChartsOfCharacteristicTypes.DeleteAccessKinds.EmptyRef())) = Undefined Then
	
		ErrorDescription =
			NStr("ru = 'Тип ChartOfCharacteristicTypesRef.DeleteAccessKinds,
			           |необходимый для перехода на новые версии программы
			           |не указан в определяемом типе ""Значение доступа"".'; 
			           |en = 'The ChartOfCharacteristicTypesRef.DeleteAccessKinds type
			           |required to migrate to new application versions
			           |is not specified in the defined ""Access value"" type.'; 
			           |pl = 'Typ ChartOfCharacteristicTypesRef.DeleteAccessKinds,
			           |niezbędny do przejścia na nową wersję programu
			           |nie określony w określonym typie ""Wartość dostępu"".';
			           |es_ES = 'El tipo ChartOfCharacteristicTypesRef.DeleteAccessKinds
			           |necesario para pasar a nuevas versiones del programa
			           |no se ha indicado en el tipo determinado ""Valor de acceso"".';
			           |es_CO = 'El tipo ChartOfCharacteristicTypesRef.DeleteAccessKinds
			           |necesario para pasar a nuevas versiones del programa
			           |no se ha indicado en el tipo determinado ""Valor de acceso"".';
			           |tr = 'Uygulamanın yeni sürümlerine geçiş için gereken
			           |ChartOfCharacteristicTypesRef.DeleteAccessKinds türü
			           |""Erişim değeri"" türünde belirtilmedi.';
			           |it = 'Il tipo ChartOfCharacteristicTypesRef.DeleteAccessKinds
			           |richiesto per la migrazione alle nuove versioni dell''applicazione
			           |non è indicato nel tipo definito ""Valore di accesso"".';
			           |de = 'Typ ChartOfCharacteristicTypesRef.DeleteAccessKinds,
			           |die für die Umstellung auf neue Versionen des Programms erforderlich sind,
			           |werden im definierten Typ ""Zugriffswert"" nicht angegeben.'");
		
		ErrorText = Parameters.ErrorTitle + ErrorDescription;
		Raise ErrorText;
	EndIf;
	
	CheckSubscriptionTypesUpdateAccessValuesGroups(AccessValuesWithGroups);
	
	Return Common.FixedData(AccessKindsProperties);
	
EndFunction

// For the AccessKindsProperties function.
Procedure FillAccessValuesWithGroups(Row, AccessValuesWithGroups, Properties, Parameters)
	
	If Properties.Name = "Users" Then
		AddToArray(Properties.TypesOfValuesToSelect, Type("CatalogRef.Users"));
		AddToArray(Properties.TypesOfValuesToSelect, Type("CatalogRef.UserGroups"));
		Return;
	EndIf;
	
	If Properties.Name = "ExternalUsers" Then
		AddToArray(Properties.TypesOfValuesToSelect, Type("CatalogRef.ExternalUsers"));
		AddToArray(Properties.TypesOfValuesToSelect, Type("CatalogRef.ExternalUsersGroups"));
		Return;
	EndIf;
	
	RefType = Row.ValuesType;
	
	ValuesTypeMetadata = Metadata.FindByType(Row.ValuesType);
	If Common.IsEnum(ValuesTypeMetadata) Then
		ObjectType = RefType;
	Else
		ObjectType = StandardSubsystemsServer.MetadataObjectOrMetadataObjectRecordSetType(
			ValuesTypeMetadata);
	EndIf;
	
	If Row.ValuesGroupsType = Type("Undefined") Then
		AddSubscriptionTypesUpdateAccessValuesGroups(RefType,
			ObjectType, ValuesTypeMetadata, AccessValuesWithGroups, Properties, Undefined);
		AddToArray(Properties.TypesOfValuesToSelect, Row.ValuesType);
		Return;
	EndIf;
	
	If Row.ValuesGroupsType <> Type("Undefined") Then
		AddToArray(Properties.TypesOfValuesToSelect, Row.ValuesGroupsType);
	EndIf;
	
	AccessValuesWithGroups.ByTypes.Insert(RefType,  Properties);
	AccessValuesWithGroups.ByTypes.Insert(ObjectType, Properties);
	AccessValuesWithGroups.ByRefsTypes.Insert(RefType, Properties);
	
	MetadataOfValuesGroupsType = Metadata.FindByType(Row.ValuesGroupsType);
	
	AddSubscriptionTypesUpdateAccessValuesGroups(RefType,
		ObjectType, ValuesTypeMetadata, AccessValuesWithGroups, Properties, MetadataOfValuesGroupsType);
	
EndProcedure

// For the AccessKindsProperties function and the FillAccessValuesWithGroups procedure.
Procedure AddSubscriptionTypesUpdateAccessValuesGroups(RefType, ObjectType,
			ValuesTypeMetadata, AccessValuesWithGroups, Properties, MetadataOfValuesGroupsType)
	
	ValueTypeBlankRef = PredefinedValue(ValuesTypeMetadata.FullName() + ".EmptyRef");
	
	If MetadataOfValuesGroupsType = Undefined Then
		BlankValuesGroupsTypeRef = ValueTypeBlankRef;
	Else
		BlankValuesGroupsTypeRef = MetadataObjectEmptyRef(MetadataOfValuesGroupsType);
	EndIf;
	
	AccessValuesWithGroups.NamesOfTablesToUpdate.Add(ValuesTypeMetadata.FullName());
	
	AccessValuesWithGroups.ValueGroupTypesForUpdate.Insert(RefType,
		BlankValuesGroupsTypeRef);
	
	AccessValuesWithGroups.ValueGroupTypesForUpdate.Insert(ValueTypeBlankRef,
		BlankValuesGroupsTypeRef);
	
	AccessValuesWithGroups.ByRefTypesForUpdate.Insert(RefType, Properties);
	AccessValuesWithGroups.ByTypesForUpdate.Insert(RefType, Properties);
	AccessValuesWithGroups.ByTypesForUpdate.Insert(ObjectType, Properties);
	
EndProcedure

// For the AccessKindsProperties function.
Procedure CheckSubscriptionTypesUpdateAccessValuesGroups(AccessValuesWithGroups)
	
	CurrentSubscriptionTypes = AccessManagementInternalCached.TableFieldTypes(
		"DefinedType.AccessValueWithAccessValuesGroupsObject");
	
	RequiredSubscriptionTypes = New Map;
	For Each KeyAndValue In AccessValuesWithGroups.ByTypesForUpdate Do
		If AccessValuesWithGroups.ByRefTypesForUpdate.Get(KeyAndValue.Key) <> Undefined
		 Or AccessValuesWithGroups.ByTypes.Get(KeyAndValue.Key) = Undefined Then
			Continue;
		EndIf;
		RequiredSubscriptionTypes.Insert(KeyAndValue.Key, True);
	EndDo;
	
	MissingTypes = New Array;
	
	For Each KeyAndValue In RequiredSubscriptionTypes Do
		If CurrentSubscriptionTypes.Get(KeyAndValue.Key) = Undefined Then
			MissingTypes.Add(KeyAndValue.Key);
		EndIf;
	EndDo;
	
	If MissingTypes.Count() = 0 Then
		Return;
	EndIf;
	
	ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("ru = 'По данным, полученным из процедуры OnFillAccessKinds
		           |общего модуля AccessManagementOverridable, в определяемом типе
		           |""Значение доступа с группами значений доступа объект"" не указаны требуемые типы:
		           |- %1'; 
		           |en = 'According to the data received from the OnFillAccessKinds procedure
		           |of the AccessManagementOverridable common module, in the
		           |""Access value with object access value groups"" defined type, required types are not specified:
		           | - %1'; 
		           |pl = 'Na podstawie danych uzyskanych z procedury OnFillAccessKinds
		           |do wspólnego modułu AccessManagementOverridable, w określonym typie
		           |""Wartość dostępu z grupami wartości dostępu obiekt"" nie są podane wymagane typy:
		           |- %1';
		           |es_ES = 'Por los datos recibidos del procedimiento OnFillAccessKinds
		           |del módulo común AccessManagementOverridable en el tipo predeterminado
		           |""Valor de acceso con grupos de valores de acceso objeto"" no se han indicado tipos requeridos:
		           |- %1';
		           |es_CO = 'Por los datos recibidos del procedimiento OnFillAccessKinds
		           |del módulo común AccessManagementOverridable en el tipo predeterminado
		           |""Valor de acceso con grupos de valores de acceso objeto"" no se han indicado tipos requeridos:
		           |- %1';
		           |tr = 'ErişimKontrolüYenidenBelirlenmiş %1genel modülün ErişimTürleriDoldurulduğunda prosedüründen elde edilen verilere göre, ""Erişim değeri nesne erişim değerlerin grupları ile birlikte"" 
		           | belirlenen türde gereken türler belirtilmedi: 
		           |-
		           |';
		           |it = 'In base ai dati ricevuti dalla procedura OnFillAccessKinds
		           | del modulo comune AccessManagementOverridable, nel tipo definito
		           |""Valore di accesso co gruppo di valori di accesso dell''oggetto"" non sono specificati i tipi richiesti:
		           | -%1';
		           |de = 'Gemäß den Daten aus dem Verfahren OnFillAccessKinds
		           |des allgemeinen Moduls AccessManagementOverridable sind die benötigten Typen im Typ
		           |""Zugriffswert mit Zugriffswertgruppen des Objekts"" nicht angegeben:
		           |- %1'"),
		StrConcat(MissingTypes, "," + Chars.LF + "- "));
	
	Raise ErrorText;
	
EndProcedure

// For the AccessKindsProperties function.
Procedure CheckType(AccessKind, Type, AllTypes, Parameters, CheckGroupsTypes = False, IntersectionCheck = False)
	
	If Type = Type("Undefined") Then
		If CheckGroupsTypes Then
			Return;
		EndIf;
		ErrorText = Parameters.ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Для вида доступа ""%1"" не указан тип значений доступа.'; en = 'Access value type is not specified for the ""%1"" access kind.'; pl = 'Typ wartości dostępu ""%1"" nie jest określony dla typu dostępu.';es_ES = 'Tipo de valores de acceso no está especificado para el tipo de acceso ""%1"".';es_CO = 'Tipo de valores de acceso no está especificado para el tipo de acceso ""%1"".';tr = '""%1"" Erişim türü için erişim değer türü belirtilmemiş.';it = 'La tipologia di accesso ""%1"" non specifica la tipologia di valori di accesso.';de = 'Der Zugriffswerttyp ist für die Zugriffsart ""%1"" nicht angegeben.'"),
			AccessKind.Name);
		Raise ErrorText;
	EndIf;
	
	// Checking whether a reference type is specified.
	If NOT Common.IsReference(Type) Then
		If CheckGroupsTypes Then
			ErrorDescription =
				NStr("ru = 'Тип ""%1"" указан, как тип групп значений, для вида доступа ""%2"".
				           |Однако это не тип ссылки.'; 
				           |en = 'Type ""%1"" is specified as a value group type for access kind ""%2"".
				           |It is not a reference type.'; 
				           |pl = 'Typ ""%1"" jest określony jako typ grup wartości dla typu dostępu ""%2"".
				           |Jednak nie jest to typ linku.';
				           |es_ES = 'El tipo ""%1"" está especificado como el tipo de grupos de valores para el tipo de acceso ""%2"".
				           |Pero no es el tipo de referencia.';
				           |es_CO = 'El tipo ""%1"" está especificado como el tipo de grupos de valores para el tipo de acceso ""%2"".
				           |Pero no es el tipo de referencia.';
				           |tr = '""%1"" türü, ""%2"" türünde erişim türü için değer grubu türü olarak belirtilir.
				           | Ancak referans tipi değil.';
				           |it = 'Il tipo ""%1"" è indicato come tipo di gruppo di valori per il tipo di accesso ""%2"".
				           |Non è un tipo di riferimento.';
				           |de = 'Typ ""%1"" wird als Wertgruppentyp für die Zugriffsart ""%2"" angegeben.
				           |Aber es ist kein Referenztyp.'");
		Else
			ErrorDescription =
				NStr("ru = 'Тип ""%1"" указан, как тип значений, для вида доступа ""%2"".
				           |Однако это не тип ссылки.'; 
				           |en = 'Type ""%1"" is specified as a value type for access kind ""%2"".
				           |It is not a reference type.'; 
				           |pl = 'Typ ""%1"" jest określony jako typ wartości dla typu dostępu ""%2"".
				           |Jednak nie jest to typ linku.';
				           |es_ES = 'El tipo ""%1"" está especificado como el tipo de valores para el tipo de acceso ""%2"".
				           |Pero no es el tipo de referencia.';
				           |es_CO = 'El tipo ""%1"" está especificado como el tipo de valores para el tipo de acceso ""%2"".
				           |Pero no es el tipo de referencia.';
				           |tr = '""%1"" türü, ""%2"" erişim türü için değer türü olarak belirlendi. 
				           |Ancak bu referans türü değil.';
				           |it = 'Il tipo ""%1"" è indicato come un tipo di valore per il tipo di accesso ""%2"".
				           |Non è un tipo di riferimento.';
				           |de = 'Typ ""%1"" wird als Werttyp für die Zugriffsart ""%2"" angegeben.
				           |Aber es ist kein Referenztyp.'");
		EndIf;
		ErrorText = Parameters.ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			ErrorDescription, Type, AccessKind.Name);
		Raise ErrorText;
	EndIf;
	
	// Checking for duplication and intersection of value types and value groups.
	ForSameAccessKindNoError = False;
	
	If CheckGroupsTypes Then
		If IntersectionCheck Then
			ErrorDescription =
				NStr("ru = 'Тип ""%1"" указан, как тип значений, для вида доступа ""%2"".
				           |Для вида доступа ""%3"" его нельзя указать, как тип групп значений.'; 
				           |en = 'Type ""%1"" is specified as a value type for access kind ""%2"".
				           |It cannot be specified as a value group type for access kind ""%3"".'; 
				           |pl = 'Typ ""%1"" jest określony, jako typ wartości dla typu dostępu ""%2"".
				           |Dla rodzaju dostępu ""%3"" nie można go określić, jako typu grupy wartości.';
				           |es_ES = 'El tipo ""%1"" está especificado como el tipo de valores para el tipo de acceso ""%2"".
				           |Para el tipo de acceso ""%3"", no puede especificarse como el tipo de grupos de valores.';
				           |es_CO = 'El tipo ""%1"" está especificado como el tipo de valores para el tipo de acceso ""%2"".
				           |Para el tipo de acceso ""%3"", no puede especificarse como el tipo de grupos de valores.';
				           |tr = '""%2"" türü, "
" erişim türü için değer türü olarak belirlendi. %1 Erişim türü için ""%3"" değerler grup tipi olarak belirtilemez.';
				           |it = 'Il tipo ""%1"" è indicato come tipo di valore per il tipo di accesso ""%2"".
				           |Non può essere indicato come tipo di gruppo di valori per il tipo di accesso ""%3"".';
				           |de = 'Der Typ ""%1"" wird als Werttyp für die Zugriffsart ""%2"" angegeben.
				           |Für die Zugriffsart ""%3"" kann er nicht als Wertgruppentyp angegeben werden.'");
		Else
			ForSameAccessKindNoError = True;
			ErrorDescription =
				NStr("ru = 'Тип групп значений ""%1"" уже указан для вида доступа ""%2"".
				           |Для вида доступа ""%3"" его нельзя указать.'; 
				           |en = 'Value group type ""%1"" is already specified for access kind ""%2"".
				           |It cannot be specified for access kind ""%3"".'; 
				           |pl = 'Dla typu dostępu ""%1"" określono typ grupy wartości ""%2"".
				           |Nie można określić rodzaju dostępu ""%3"".';
				           |es_ES = 'Tipo de grupos de valores ""%1"" está especificado para el tipo de acceso ""%2"".
				           |Para el tipo de acceso ""%3"" no puede especificarse.';
				           |es_CO = 'Tipo de grupos de valores ""%1"" está especificado para el tipo de acceso ""%2"".
				           |Para el tipo de acceso ""%3"" no puede especificarse.';
				           |tr = '""%2"" türü, "
" erişim türü için değer türü olarak belirlendi. %1 Erişim türü için ""%3"" belirtilemez.';
				           |it = 'Il tipo di gruppo di valori ""%1"" è già indicato per il tipo di accesso ""%2"".
				           |Non può essere indicato per il tipo di accesso ""%3"".';
				           |de = 'Für die Zugriffsart ""%2"" ist der Wertegruppentyp ""%1"" angegeben.
				           |Für die Zugriffsart ""%3"" kann sie nicht angegeben werden.'");
		EndIf;
	Else
		If IntersectionCheck Then
			ErrorDescription =
				NStr("ru = 'Тип ""%1"" указан, как тип групп значений, для вида доступа ""%2"".
				           |Для вида доступа ""%3"" его нельзя указать, как тип значений.'; 
				           |en = 'Type ""%1"" is specified as a value group type for access kind ""%2"".
				           |It cannot be specified as a value type for access kind ""%3"".'; 
				           |pl = 'Typ ""%1"" jest określony, jako typ grup wartości dla typu dostępu ""%2"".
				           |Dla rodzaju dostępu ""%3"" nie można go określić, jako typu grup grupy wartości.';
				           |es_ES = 'El tipo ""%1"" está especificado como el tipo de grupos de valores para el tipo de acceso ""%2"".
				           |Para el tipo de acceso ""%3"" no puede especificarse como el tipo de valores.';
				           |es_CO = 'El tipo ""%1"" está especificado como el tipo de grupos de valores para el tipo de acceso ""%2"".
				           |Para el tipo de acceso ""%3"" no puede especificarse como el tipo de valores.';
				           |tr = '""%2"" türü, "
" erişim türü için değer türü olarak belirlendi. %1 Erişim türü için ""%3"" değer tipi olarak belirtilemez.';
				           |it = 'Il tipo 2%1"" è indicato come tipo di gruppo di valore per il tipo di accesso ""%2"".
				           |Non può essere indicato come tipo di valore per il tipo di accesso ""%3"".';
				           |de = 'Der Typ ""%1"" wird als Wertgruppentyp für die Zugriffsart ""%2"" angegeben.
				           |Für die Zugriffsart ""%3"" kann er nicht als Werttyp angegeben werden.'");
		Else
			ErrorDescription =
				NStr("ru = 'Тип значений ""%1"" уже указан для вида доступа ""%2"".
				           |Для вида доступа ""%3"" его нельзя указать.'; 
				           |en = 'Value type ""%1"" is already specified for access kind ""%2"".
				           |It cannot be specified for access kind ""%3"".'; 
				           |pl = 'Dla typu dostępu ""%1"" określony jest typ ""%2"".
				           |Dla rodzaju dostępu ""%3"" nie można go określić.';
				           |es_ES = 'El tipo de valores ""%1"" está especificado para el tipo de acceso ""%2"".
				           |Para el tipo de acceso ""%3"" no puede especificarse.';
				           |es_CO = 'El tipo de valores ""%1"" está especificado para el tipo de acceso ""%2"".
				           |Para el tipo de acceso ""%3"" no puede especificarse.';
				           |tr = '""%2"" türü, "
" erişim türü için değer türü olarak belirlendi. %1 Erişim türü için ""%3"" belirtilemez.';
				           |it = 'Il tipo di valore ""%1"" è già indicato per il tipo di accesso ""%2"".
				           |Non può essere indicato per il tipo di accesso ""%3"".';
				           |de = 'Der Werttyp ""%1"" wird für die Zugriffsart ""%2"" angegeben.
				           |Für die Zugriffsart ""%3"" kann er nicht angegeben werden.'");
		EndIf;
	EndIf;
	
	If AllTypes.Get(Type) <> Undefined Then
		If NOT (ForSameAccessKindNoError AND AccessKind.Name = AllTypes.Get(Type)) Then
			ErrorText = Parameters.ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
				ErrorDescription, Type, AllTypes.Get(Type), AccessKind.Name);
			Raise ErrorText;
		EndIf;
	ElsIf NOT IntersectionCheck Then
		AllTypes.Insert(Type, AccessKind.Name);
	EndIf;
	
	// Checking content of defined types.
	ErrorDescription = "";
	If Parameters.TypesOfAccessValuesToDefine.Get(Type) = Undefined Then
		If CheckGroupsTypes Then
			ErrorDescription =
				NStr("ru = 'Тип групп значений доступа ""%1"" вида доступа ""%2""
				           |не указан в определяемом типе ""Значение доступа"".'; 
				           |en = 'Type of access value groups ""%1"" of access kind ""%2""
				           |is not specified in defined type ""Access value"".'; 
				           |pl = 'Typ grup wartości dostępu""%1""rodzaje dostępu""%2""
				           |nie znajduje się w określonym typie ""Wartość dostępu"".';
				           |es_ES = 'Tipo de grupos de valores de acceso ""%1"" del tipo de acceso ""%2""
				           |no se ha indicado en el tipo determinado ""Valor de acceso"".';
				           |es_CO = 'Tipo de grupos de valores de acceso ""%1"" del tipo de acceso ""%2""
				           |no se ha indicado en el tipo determinado ""Valor de acceso"".';
				           |tr = '""Erişim değeri"" tanımlanmış türünde ""%1"" erişim türü "
" erişim değer grupları türü%2 belirtilmemiş.';
				           |it = 'Tipo di gruppo di valore di accesso ""%1"" del tipo di accesso ""%2""
				           |non indicato nel tipo definito ""Valore di accesso"".';
				           |de = 'Die Art der Zugriffswertgruppen ""%1"" vom Zugriffstyp ""%2""
				           |ist im definierten Typ ""Zugriffswert"" nicht angegeben.'");
		Else
			ErrorDescription =
				NStr("ru = 'Тип значений доступа ""%1"" вида доступа ""%2""
				           |не указан в определяемом типе ""Значение доступа"".'; 
				           |en = 'Access value type ""%1"" of access kind ""%2""
				           |is not specified in defined type ""Access value"".'; 
				           |pl = 'Typ wartości dostępu ""%1"" rodzaje dostępu ""%2""
				           |nie znajduje się w określonym typie ""Wartość dostępu"".';
				           |es_ES = 'Tipo de valores de acceso ""%1"" del tipo de acceso ""%2""
				           |no se ha indicado en el tipo determinado ""Valor de acceso"".';
				           |es_CO = 'Tipo de valores de acceso ""%1"" del tipo de acceso ""%2""
				           |no se ha indicado en el tipo determinado ""Valor de acceso"".';
				           |tr = '""Erişim değeri"" tanımlanmış türünde ""%1"" erişim türü "
" erişim değeri %2 türü belirtilmemiş.';
				           |it = 'Tipo del valore di accesso ""%1"" del tipo di accesso ""%2""
				           |non indicato nel tipo definito ""Valore di accesso"".';
				           |de = 'Die Art der Zugriffswerte ""%1"" von Zugriffstyp ""%2""
				           |ist im definierten Typ ""Zugriffswert"" nicht angegeben.'");
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorDescription) Then
		ErrorText = Parameters.ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			ErrorDescription, Type, AccessKind.Name);
		Raise ErrorText;
	EndIf;
	
EndProcedure

// For the FillAccessValuesWithGroups procedure.
Procedure AddToArray(Array, Value)
	
	If Array.Find(Value) = Undefined Then
		Array.Add(Value);
	EndIf;
	
EndProcedure

// For the UpdateAccessKindsPropertiesDetails procedure.
Function HasChangesOfGroupsTypesAndAccessValues(AccessKindsProperties, Saved)
	
	If NOT TypeOf(Saved) = Type("FixedStructure")
	 OR NOT Saved.Property("ByValuesTypes")
	 OR NOT Saved.Property("AccessValuesTypesWithGroups")
	 OR NOT Saved.Property("AccessValuesWithGroups")
	 OR NOT Saved.Property("AccessValuesSetsOwner")
	 OR NOT TypeOf(Saved.ByValuesTypes)                = Type("FixedMap")
	 OR NOT TypeOf(Saved.AccessValuesTypesWithGroups)   = Type("FixedMap")
	 OR NOT TypeOf(Saved.AccessValuesWithGroups)       = Type("FixedStructure")
	 OR NOT TypeOf(Saved.AccessValuesSetsOwner) = Type("String")
	 OR NOT Saved.AccessValuesWithGroups.Property("NamesOfTablesToUpdate")
	 OR NOT TypeOf(Saved.AccessValuesWithGroups.NamesOfTablesToUpdate) = Type("FixedArray")
	 OR NOT AccessKindsProperties.Property("ByValuesTypes")
	 OR NOT AccessKindsProperties.Property("AccessValuesTypesWithGroups")
	 OR NOT AccessKindsProperties.Property("AccessValuesWithGroups")
	 OR NOT AccessKindsProperties.Property("AccessValuesSetsOwner")
	 OR NOT TypeOf(AccessKindsProperties.ByValuesTypes)                = Type("FixedMap")
	 OR NOT TypeOf(AccessKindsProperties.AccessValuesTypesWithGroups)   = Type("FixedMap")
	 OR NOT TypeOf(AccessKindsProperties.AccessValuesWithGroups)       = Type("FixedStructure")
	 OR NOT TypeOf(AccessKindsProperties.AccessValuesSetsOwner) = Type("String")
	 OR NOT AccessKindsProperties.AccessValuesWithGroups.Property("NamesOfTablesToUpdate")
	 OR NOT TypeOf(AccessKindsProperties.AccessValuesWithGroups.NamesOfTablesToUpdate) = Type("FixedArray") Then
		
		Return True;
	EndIf;
	
	If MapKeysDiffer(AccessKindsProperties.ByValuesTypes, Saved.ByValuesTypes) Then
		Return True;
	EndIf;
	
	If MapKeysDiffer(AccessKindsProperties.AccessValuesTypesWithGroups,
			Saved.AccessValuesTypesWithGroups) Then
		Return True;
	EndIf;
	
	If Not Common.DataMatch(AccessKindsProperties.AccessValuesWithGroups.NamesOfTablesToUpdate,
				Saved.AccessValuesWithGroups.NamesOfTablesToUpdate) Then
		Return True;
	EndIf;
	
	If AccessKindsProperties.AccessValuesSetsOwner
			<> Saved.AccessValuesSetsOwner Then
		Return True;
	EndIf;
	
	Return False;
	
EndFunction

// For the HasChangesOfGroupsTypesAndAccessValues function.
Function MapKeysDiffer(NewValue, Old)
	
	If NewValue.Count() <> Old.Count() Then
		Return True;
	EndIf;
	
	For each KeyAndValue In NewValue Do
		If Old.Get(KeyAndValue.Key) = Undefined Then
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

#Region UniversalRestriction

////////////////////////////////////////////////////////////////////////////////
// Event subscription handlers.

// The CheckAccessBeforeWrite* subscription handler checks access to the old object version, and 
// checks object field changes of the additional tables attached in access restrictions of the list.
// If changes are found, need to update access keys for the lists, which have additional tables 
// attached in access restrictions, is registered.
//
// Parameters:
//  Source        - ConstantManager,
//                    CatalogObject,
//                    DocumentObject,
//                    ChartOfCharacteristicTypesObject,
//                    ChartOfAccountsObject,
//                    ChartOfCalculationTypesObject,
//                    BusinessProcessObject,
//                    TaskObject,
//                    ExchangePlanObject - a data object passed to the BeforeWrite event subscription.
//
//  Cancel - Boolean - a parameter passed to the BeforeWrite event subscription.
//
//  WriteMode     - DocumentWriteMode - a parameter passed to the BeforeWrite event subscription 
//                    when the Source parameter is DocumentObject.
//
//  PostingMode - DocumentPostingMode - a parameter passed to the BeforeWrite event subscription 
//                    when Source is DocumentObject.
//
Procedure CheckAccessBeforeWrite(Source, Cancel, WriteMode = Undefined, PostingMode = Undefined) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessBeforeWriteSource(Source, Cancel, False, False);
	
EndProcedure

// The CheckAccessBeforeWriteRecordSet* subscription handler checks access to the old record set 
// version, and checks changes of record set fields of the additional tables attached in access restrictions of the lists.
// If changes are found, need to update access keys for the lists, which have additional tables 
// attached in access restrictions, is registered.
//
// Parameters:
//  Source - InformationRegisterRecordSet,
//                    AccumulationRegisterRecordSet,
//                    AccountingRegisterRecordSet,
//                    CalculationRegisterRecordSet,
//                    RecalculationRecordSet - a record set passed to the BeforeWrite event 
//                                             subscription.
//
//  Cancel - Boolean - a parameter passed to the BeforeWrite event subscription.
//  Overwrite       - Boolean - a parameter passed to the BeforeWrite event subscription.
//
//  WriteOnly - Boolean - a parameter passed to the BeforeWrite event subscription when the Source 
//                    is CalculationRegisterRecordSet.
//
//  WriteActualActionPeriod - Boolean - a parameter passed to the BeforeWrite event subscription 
//                    when Source is CalculationRegisterRecordSet.
//
//  WriteRecalculations - Boolean - a parameter passed to the BeforeWrite event subscription when 
//                    Source is CalculationRegisterRecordSet.
//
Procedure CheckAccessBeforeWriteRecordsSet(Source, Cancel, Overwrite,
				WriteOnly = Undefined,
				WriteActualActionPeriod = Undefined,
				WriteRecalculations = Undefined) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessBeforeWriteSource(Source, Cancel, True, Overwrite);
	
EndProcedure

// The CheckAccessOnWrite* subscription handler checks whether an access key of the new object 
// version is up-to-date. Updates an obsolete access key and checks the Read and Update rights of 
// the new object version.
//
// Parameters:
//  Source        - ConstantManager,
//                    CatalogObject,
//                    DocumentObject,
//                    ChartOfCharacteristicTypesObject,
//                    ChartOfAccountsObject,
//                    ChartOfCalculationTypesObject,
//                    BusinessProcessObject,
//                    TaskObject,
//                    ExchangePlanObject - a data object passed to the OnWrite event subscription.
//
//  Cancel           - Boolean - a parameter passed to the OnWrite event subscription.
//
Procedure CheckAccessOnWrite(Source, Cancel) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessOnWriteSource(Source, Cancel, False, False);
	
EndProcedure

// The CheckAccessOnWriteRecordSet* subscription handler checks whether access keys of the new 
// record set version are up-to-date. Updates obsolete access keys and checks the Read and Update 
// rights of the new record set version.
//
// Parameters:
//  Source - InformationRegisterRecordSet,
//                    AccumulationRegisterRecordSet,
//                    AccountingRegisterRecordSet,
//                    CalculationRegisterRecordSet,
//                    RecalculationRecordSet - a record set passed to the OnWrite event subscription.
//                                             
//
//  Cancel           - Boolean - a parameter passed to the OnWrite event subscription.
//  Overwrite       - Boolean - the parameter passed to the OnWrite event subscription.
//
//  WriteOnly - Boolean - a parameter passed to the OnWrite event subscription when the Source is 
//                    CalculationRegisterRecordSet.
//
//  WriteActualActionPeriod - Boolean - a parameter passed to the OnWrite event subscription when 
//                    the Source is CalculationRegisterRecordSet.
//
//  WriteRecalculations - Boolean - a parameter passed to the OnWrite event subscription when the 
//                    Source is CalculationRegisterRecordSet.
//
Procedure CheckAccessOnWriteRecordsSet(Source, Cancel, Overwrite,
				WriteOnly = Undefined,
				WriteActualActionPeriod = Undefined,
				WriteRecalculations = Undefined) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessOnWriteSource(Source, Cancel, True, Overwrite);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Universal access restriction.

Function AccessAllowed(DataDetails, Update) Export
	
	If Users.IsFullUser() Then
		Return True;
	EndIf;
	
	MetadataObject = Metadata.FindByType(TypeOf(DataDetails));
	If MetadataObject = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Недопустимое значение параметра %1 в %2.
			           |Ожидалась ссылка или ключ записи.
			           |Передано значение: %3 (тип %4).'; 
			           |en = 'Invalid value of the %1 parameter in %2. 
			           |Reference or key was expected.
			           |Value passed: %3 (type %4).'; 
			           |pl = 'Niepoprawna wartość parametru %1 w %2.
			           |Wymagany link lub klucz zapisu.
			           |Przekazana wartość: %3 (typ %4).';
			           |es_ES = 'Valor incorrecto del parámetro %1 en %2.
			           |Se esperaba un enlace o una clave de registro.
			           |Valor pasado: %3 (tipo %4).';
			           |es_CO = 'Valor incorrecto del parámetro %1 en %2.
			           |Se esperaba un enlace o una clave de registro.
			           |Valor pasado: %3 (tipo %4).';
			           |tr = '%1Parametrenin %2''deki değeri kabul edilemez. 
			           | Kayıt referansı veya anahtarı bekleniyordu. 
			           | Atanan değer: %3 (tür %4).';
			           |it = 'Valore non valido del parametro %1 in %2.
			           |Era previsto il riferimento o la chiave.
			           |Valore trasmesso: %3 (tipo %4).';
			           |de = 'Ungültiger Parameterwert %1 in %2.
			           |Es wurde ein Link oder Datensatz-Schlüssel erwartet.
			           |Übertragener Wert: %3 (Typ%4).'"),
			"DataDetails",
			?(Update, "AccessManagement.EditionAllowed",
				"AccessManagement.ReadingAllowed"),
			String(DataDetails),
			String(TypeOf(DataDetails)));
		Raise ErrorText;
	EndIf;
	
	If Not AccessRight(?(Update, "Update", "Read"), MetadataObject) Then
		Return False;
	EndIf;
	
	If Not LimitAccessAtRecordLevelUniversally() Then
		Return True;
	EndIf;
	
	FullName = MetadataObject.FullName();
	TransactionID = New UUID;
	RestrictionParameters = RestrictionParameters(FullName, TransactionID);
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	UpdateAllowedSetsInSessionParameters();
	
	If RestrictionParameters.RestrictionDisabled Then
		Return True;
	EndIf;
	
	If RestrictionParameters.AccessDenied Then
		Return False;
	EndIf;
	
	Query = New Query;
	SetAllowedSetsInQueryParameters(Query);
	
	Query.Text = ?(Update, RestrictionParameters.ReadEditRightsCheckQueryText,
		RestrictionParameters.ReadRightsCheckQueryText);
	
	If RestrictionParameters.IsReferenceType Then
		ObjectRef = ?(Common.IsReference(TypeOf(DataDetails)),
			DataDetails, DataDetails.Ref);
		
		Query.SetParameter("Object", ObjectRef);
		
		If RestrictionParameters.OwnerField <> Undefined Then
			Query.SetParameter("RightSettingsTableID",
				RestrictionParameters.RightSettingsTableID);
		EndIf;
		
		AccessAllowed = Not Query.Execute().IsEmpty();
	Else
		RecordSet = Common.ObjectManagerByFullName(FullName).CreateRecordSet();
		For Each FilterItem In RecordSet.Filter Do
			FilterItem.Value = DataDetails[FilterItem.Name];
			FilterItem.Use = True;
		EndDo;
		FilterByDimensions = FilterByRecordSetDimensions(RecordSet, Query);
		QueryText =
		"SELECT TOP 1
		|	TRUE AS TrueValue
		|FROM
		|	&CurrentTable AS CurrentTable
		|WHERE
		|	&FilterByDimensions";
		QueryText = StrReplace(QueryText, "&CurrentTable", FullName);
		Query.Text = Query.Text + Common.QueryBatchSeparator() + QueryText;
		Query.Text = StrReplace(Query.Text, "&FilterByDimensions", FilterByDimensions);
		
		QueryResults = Query.ExecuteBatch();
		AccessAllowed = QueryResults[0].IsEmpty() AND Not QueryResults[1].IsEmpty();
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	Return AccessAllowed;
	
EndFunction

// It is required as an initial maximum date when scheduling access update.
Function MaxDate() Export
	
	Return '39991231235959';
	
EndFunction

// For the ImplementationSettings function.
Function XMLFullName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	
	Return Properties.LanguageEnglish + "." + NameContent[1];
	
EndFunction

// For the AddTypesRequiredInDefinedType procedure.
Function RefTypeName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	
	If Not Properties.IsReferenceType Then
		Return "";
	EndIf;
	
	If Upper(Properties.LanguageRussian) = Upper(NameContent[0]) Then
		TypeName = Properties.LanguageRussian + "Ref." + NameContent[1];
	Else
		TypeName = Properties.LanguageEnglish + "Ref." + NameContent[1];
	EndIf;
	
	Return TypeName;
	
EndFunction

// For the ImplementationSettings function.
Function XMLRefTypeName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	
	If Properties.IsReferenceType Then
		Return Properties.LanguageEnglish + "Ref." + NameContent[1];
	EndIf;
	
	Return "";
	
EndFunction

// For the AddTypesRequiredInDefinedType function.
Function ObjectTypeOrRecordSetName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	TypeName = "";
	
	If Properties.IsReferenceType Then
		If Upper(Properties.LanguageRussian) = Upper(NameContent[0]) Then
			TypeName = Properties.LanguageRussian + "Object." + NameContent[1];
		Else
			TypeName = Properties.LanguageEnglish + "Object." + NameContent[1];
		EndIf;
	EndIf;
	
	If StrStartsWith(Properties.CollectionName, "Registers") Then
		If Upper(Properties.LanguageRussian) = Upper(NameContent[0]) Then
			TypeName = Properties.LanguageRussian + "RecordSet." + NameContent[1];
		Else
			TypeName = Properties.LanguageEnglish + "RecordSet." + NameContent[1];
		EndIf;
	EndIf;
	
	Return TypeName;
	
EndFunction

// For the ImplementationSettings function.
Function ObjectTypeOrXMLRecordSetName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	
	If Properties.IsReferenceType Then
		Return Properties.LanguageEnglish + "Object." + NameContent[1];
	EndIf;
	
	If StrStartsWith(Properties.CollectionName, "Registers") Then
		Return Properties.LanguageEnglish + "RecordSet." + NameContent[1];
	EndIf;
	
	Return "";
	
EndFunction

// For the ImplementationSettings function.
Procedure AddRestrictionsInRoles(XMLFullName, FullName, RestrictionsInRoles,
			RestrictionsProperties, KeysRegistersDimensionsTypes, TablesTypesByNames, PredefinedIDs)
	
	Properties = RestrictionsProperties.Get(FullName);
	If Properties <> Undefined AND Properties.AccessDenied Then
		Return;
	EndIf;
	
	RestrictionInRole = New Structure("TemplateForObject, Parameters", True, New Array);
	RestrictionsInRoles.Insert(XMLFullName, RestrictionInRole);
	
	If Properties = Undefined Then
		Return;
	EndIf;
	
	If Properties.OwnerField <> Undefined Then
		RestrictionInRole.Parameters.Add(Properties.OwnerField.Name);
		Return;
	EndIf;
	
	If Properties.BasicFields = Undefined
	 Or Not ValueIsFilled(Properties.BasicFields) Then
		Return;
	EndIf;
	
	RestrictionInRole.TemplateForObject = False;
	
	If ValueIsFilled(Properties.SeparateKeysRegisterName) Then
		FirstParameter = Properties.SeparateKeysRegisterName;
		
		AddDimensionTypes(Properties.SeparateKeysRegisterName,
			Properties.BasicFields, KeysRegistersDimensionsTypes, TablesTypesByNames, FullName);
	Else
		FirstParameter =
			AccessManagementInternalCached.PredefinedMetadataObjectIDDetails(FullName);
		
		AddDimensionTypes("AccessKeysForRegisters",
			Properties.BasicFields, KeysRegistersDimensionsTypes, TablesTypesByNames, FullName);
		
		PredefinedIDs.Insert(FirstParameter, FullName);
	EndIf;
	
	RestrictionInRole.Parameters.Add(FirstParameter);
	
	For Each BasicField In Properties.BasicFields.All Do
		RestrictionInRole.Parameters.Add(BasicField);
	EndDo;
	
EndProcedure

// For the AddRestrictionsInRoles procedure.
Procedure AddDimensionTypes(KeysRegisterName, BasicFields, KeysRegistersDimensionsTypes,
			TablesTypesByNames, InitialRegisterName)
	
	If BasicFields.All.Count() = 0 Then
		Return;
	EndIf;
	
	DimensionsTypes = KeysRegisterDimensionsTypes(KeysRegistersDimensionsTypes, KeysRegisterName);
	
	TypesNames           = DimensionsTypes.TypesNames;
	RegistersFieldsByTypes = DimensionsTypes.RegistersFieldsByTypes;
	
	RegisterFields = New Array;
	DimensionsTypes.RegistersFields.Insert(InitialRegisterName, RegisterFields);
	
	For Each FieldName In BasicFields.All Do
		FieldTypesStorage = BasicFields.AllItemsTypes[BasicFields.All.Find(FieldName)];
		FieldTypes = FieldTypesStorage.Get();
		RegisterFields.Add(New Structure("Field, Type", FieldName, FieldTypes));
		For Each Type In FieldTypes.Types() Do
			RefTypeName = XMLRefTypeName(Metadata.FindByType(Type).FullName(), TablesTypesByNames);
			If TypesNames.Find(RefTypeName) = Undefined Then
				TypesNames.Add(RefTypeName);
			EndIf;
			RegistersFieldsByType = RegistersFieldsByTypes.Get(RefTypeName);
			If RegistersFieldsByType = Undefined Then
				RegistersFieldsByType = New Array;
				RegistersFieldsByTypes.Insert(RefTypeName, RegistersFieldsByType);
			EndIf;
			FullFieldName = InitialRegisterName + "." + FieldName;
			If RegistersFieldsByType.Find(FullFieldName) = Undefined Then
				RegistersFieldsByType.Add(FullFieldName);
			EndIf;
		EndDo;
	EndDo;
	
	// For backwards compatibility of the SLImplementationCheck.epf report.
	If KeysRegisterName <> "AccessKeysForRegisters" Then
		Return;
	EndIf;
	
	XMLRegisterName = "InformationRegister." + KeysRegisterName;
	TypesNames = KeysRegistersDimensionsTypes.Get(XMLRegisterName);
	
	If TypesNames = Undefined Then
		KeysRegistersDimensionsTypes.Insert(XMLRegisterName, DimensionsTypes.TypesNames);
	EndIf;
	
EndProcedure

// For the DeploymentSettings function and AddDimensionTypes procedure.
Function KeysRegisterDimensionsTypes(KeysRegistersDimensionsTypes, KeysRegisterName)
	
	DimensionsTypes = KeysRegistersDimensionsTypes.Get(KeysRegisterName);
	If DimensionsTypes = Undefined Then
		DimensionsTypes = New Structure;
		DimensionsTypes.Insert("TypesNames", New Array);
		DimensionsTypes.Insert("RegistersFields", New Map);
		DimensionsTypes.Insert("RegistersFieldsByTypes", New Map);
		KeysRegistersDimensionsTypes.Insert(KeysRegisterName, DimensionsTypes);
		DimensionsTypes.TypesNames.Add("EnumRef.AdditionalAccessValues");
	EndIf;
	
	Return DimensionsTypes;
	
EndFunction

#Region CheckAccessOnChange

// For the BeforeWrite event subscription handlers.
Procedure CheckAccessBeforeWriteSource(Source, Cancel, IsRecordSet, Overwrite)
	
	If SkipAccessCheck(Cancel, Source) Then
		Return;
	EndIf;
	
	IsFullUser = Users.IsFullUser();
	
	Source.AdditionalProperties.Insert("AccessManagementTransactionID",
		New UUID);
	
	HasOldVersion =  IsRecordSet AND Overwrite
	             Or Not IsRecordSet AND Not Source.IsNew();
	
	If HasOldVersion Then
		RememberDataAffectingDependentAccessKeys(Source, IsRecordSet, Overwrite);
		CheckAccessToSource(Source, True, IsRecordSet, Overwrite, IsFullUser);
		
	ElsIf Not IsRecordSet Then
		SetAllowedAccessKeyForNewObject(Source, IsFullUser);
	EndIf;
	
	If IsRecordSet Then
		WriteAccessKeysOfNewBasicFieldsCombinationsValuesBeforeWrite(Source, IsFullUser);
	EndIf;
	
EndProcedure

// For the OnWrite event subscription handlers.
Procedure CheckAccessOnWriteSource(Source, Cancel, IsRecordSet, Overwrite)
	
	If SkipAccessCheck(Cancel, Source) Then
		Return;
	EndIf;
	
	IsFullUser = Users.IsFullUser();
	
	// Checking access to a new version.
	CheckAccessToSource(Source, False, IsRecordSet, Overwrite, IsFullUser);
	
	ScheduleUpdateOfDependentObsoleteAccessKeys(Source, IsRecordSet);
	
EndProcedure

// For the CheckAccessBeforeWriteSource and CheckAccessOnWriteSource procedures.
Function SkipAccessCheck(Cancel, Source)
	
	If AccessManagementInternalCached.SeparatedDataUnavailable() Then
		Return True;
	EndIf;
	
	If Not LimitAccessAtRecordLevelUniversally() Then
		Return True;
	EndIf;
	
	DisableUpdate = SessionParameters.DIsableAccessKeysUpdate;
	If DisableUpdate.Full Then
		Return True;
	EndIf;
	
	If DisableUpdate.Standard Then
		Cache = AccessManagementInternalCached.ChangedListsCacheOnDisabledAccessKeysUpdate();
		SourceType = TypeOf(Source);
		If Cache.Get(SourceType) <> Undefined Then
			Return True;
		EndIf;
		DisableUpdate = New Structure(DisableUpdate);
		EditedLists = DisableUpdate.EditedLists.Get();
		EditedLists.Insert(SourceType, True);
		DisableUpdate.EditedLists = New ValueStorage(EditedLists);
		
		SetSafeModeDisabled(True);
		SetPrivilegedMode(True);
		SessionParameters.DIsableAccessKeysUpdate = New FixedStructure(DisableUpdate);
		SetPrivilegedMode(True);
		SetSafeModeDisabled(True);
		
		Cache.Insert(SourceType, True);
		Return True;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Source) Then
		Return True;
	EndIf;
	
	If Cancel Then
		Return True;
	EndIf;
	
	Return False;
	
EndFunction

// For the CheckAccessBeforeWriteSource procedure.
Procedure RememberDataAffectingDependentAccessKeys(Source, IsRecordSet, Overwrite)
	
	FullName = Source.Metadata().FullName();
	ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(FullName,
		Source.AdditionalProperties.AccessManagementTransactionID);
	
	If ListPropertiesAsLeadingOne = Undefined
	 Or ListPropertiesAsLeadingOne.ByFieldsValues = Undefined Then
		
		Source.AdditionalProperties.Insert(
			"FieldValueAccessManagementForChangeCheckOnWrite");
		Return;
	EndIf;
	
	Query = New Query;
	
	If IsRecordSet Then
		FilterByDimensions = FilterByRecordSetDimensions(Source, Query);
		Query.Text = StrReplace(ListPropertiesAsLeadingOne.ByFieldsValues.QueryText,
			"&FilterByDimensions", FilterByDimensions);
	Else
		Query.Text = ListPropertiesAsLeadingOne.ByFieldsValues.QueryText;
		Query.SetParameter("ObjectRef", Source.Ref);
	EndIf;
	
	Source.AdditionalProperties.Insert(
		"FieldValueAccessManagementForChangeCheckOnWrite",
		Query.ExecuteBatch());
	
EndProcedure

// For the RememberDataAffectingDependentAccessKeys and CheckAccessToRecordSet procedures.
Function FilterByRecordSetDimensions(RecordSet, Query, NewCombinationsQuery = Undefined)
	
	FilterByDimensions = "";
	
	For Each FilterItem In RecordSet.Filter Do
		If Not FilterItem.Use Then
			Continue;
		EndIf;
		FilterByDimensions = FilterByDimensions + ?(FilterByDimensions = "", "", "
		|	AND ") + "CurrentTable." + FilterItem.Name + " = &FieldValue" + FilterItem.Name;
		
		Query.SetParameter("FieldValue" + FilterItem.Name, FilterItem.Value);
		If NewCombinationsQuery <> Undefined Then
			NewCombinationsQuery.SetParameter("FieldValue" + FilterItem.Name, FilterItem.Value);
		EndIf;
	EndDo;
	
	If FilterByDimensions = "" Then
		FilterByDimensions = "TRUE";
	EndIf;
	
	Return FilterByDimensions;
	
EndFunction

// For the CheckAccessBeforeWriteSource procedure.
Procedure SetAllowedAccessKeyForNewObject(Source, IsFullUser)
	
	If IsFullUser Then
		Return;
	EndIf;
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	NewRef = UsersInternal.ObjectRef(Source);
	AllowedAccessKey = AccessManagementInternalCached.AllowedAccessKey();
	
	RecordSet = InformationRegisters.AccessKeysForObjects.CreateRecordSet();
	RecordSet.Filter.Object.Set(NewRef);
	
	Record = RecordSet.Add();
	Record.Object = NewRef;
	Record.UsersAccessKey        = AllowedAccessKey;
	Record.ExternalUsersAccessKey = AllowedAccessKey;
	
	RecordSet.Write();
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the CheckAccessBeforeWriteSource and CheckAccessOnWriteSource procedures.
Procedure CheckAccessToSource(Source, BeforeWrite, IsRecordSet, Overwrite, IsFullUser)
	
	If BeforeWrite AND IsFullUser Then
		Return;
	EndIf;
	
	FullName = Source.Metadata().FullName();
	TransactionID = Source.AdditionalProperties.AccessManagementTransactionID;
	RestrictionParameters = RectrictionParametersOnAccessCheck(Source, FullName, TransactionID);
	
	If RestrictionParameters.RestrictionDisabled Then
		If Not BeforeWrite
		   AND RestrictionParameters.Property("DataItemWithObsoleteAllowedKeyQueryText") Then
			
			SetSafeModeDisabled(True);
			SetPrivilegedMode(True);
			
			UpdateAccessKeysOfDataItemsOnWrite(Source.Ref,
				RestrictionParameters, TransactionID,,, Source);
			
			SetPrivilegedMode(False);
			SetSafeModeDisabled(False);
		EndIf;
		Return;
	EndIf;
	
	If RestrictionParameters.AccessDenied Then
		If IsFullUser Then
			Return;
		ElsIf RestrictionParameters.ForExternalUsers Then
			ErrorTemplate =
				NStr("ru = 'Внешним пользователям запрещен доступ к данным списка
				           |""%1"".'; 
				           |en = 'External users cannot access data of the
				           |""%1"" list.'; 
				           |pl = 'Zewnętrznym użytkownikom dostępu do danych listy
				           |""%1"".';
				           |es_ES = 'A los usuarios externos les está prohibido el acceso a los datos de la lista
				           |""%1"".';
				           |es_CO = 'A los usuarios externos les está prohibido el acceso a los datos de la lista
				           |""%1"".';
				           |tr = 'Harici kullanıcıların 
				           |""%1"" listenin verilerine erişimleri yasaktır.';
				           |it = 'Agli utenti esterni è vietato l''accesso ai dati dell''elenco
				           |""%1"".';
				           |de = 'Externe Benutzer dürfen nicht auf die Listendaten
				           |""%1"" zugreifen.'");
		Else
			ErrorTemplate =
				NStr("ru = 'Пользователям запрещен доступ к данным списка
				           |""%1"".'; 
				           |en = 'Users cannot access data of the
				           |""%1"" list.'; 
				           |pl = 'Użytkownikom nie wolno uzyskać dostępu do danych listy
				           |""%1"".';
				           |es_ES = 'A los usuarios les está prohibido el acceso a los datos de la lista
				           |""%1"".';
				           |es_CO = 'A los usuarios les está prohibido el acceso a los datos de la lista
				           |""%1"".';
				           |tr = 'Kullanıcıların 
				           |""%1"" listenin verilerine erişimleri yasaktır.';
				           |it = 'Agli utenti è vietato l''accesso ai dati dell''elenco
				           |""%1"".';
				           |de = 'Benutzer dürfen nicht auf die Listendaten
				           |""%1"" zugreifen.'");
		EndIf;
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate,
			Source.Metadata().Presentation());
		Raise ErrorText;
	EndIf;
	
	If IsRecordSet Then
		CheckAccessToRecordSet(Source,
			BeforeWrite, Overwrite, RestrictionParameters, IsFullUser);
	Else
		CheckAccessToObject(Source,
			BeforeWrite, RestrictionParameters, IsFullUser);
	EndIf;
	
EndProcedure

// For the CheckAccessToSource procedure.
Function RectrictionParametersOnAccessCheck(Source, FullName, TransactionID)
	
	Return RestrictionParameters(FullName, TransactionID);
	
EndFunction

// For the CheckAccessToSource procedure.
Procedure CheckAccessToObject(Source, BeforeWrite, RestrictionParameters, IsFullUser)
	
	IsNew = Not Source.AdditionalProperties.Property(
		"FieldValueAccessManagementForChangeCheckOnWrite");
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Not BeforeWrite Then
		If Not IsNew AND Not SourceAccessKeyObsolete(Source.Ref, RestrictionParameters, Source) Then
			Return;
		EndIf;
		UpdateAccessKeysOfDataItemsOnWrite(Source.Ref, RestrictionParameters,
			Source.AdditionalProperties.AccessManagementTransactionID,,, Source);
	EndIf;
	
	If IsFullUser Then
		Return;
	EndIf;
	
	Query = New Query;
	AdditionCheck = Not BeforeWrite AND RestrictionParameters.OwnerField = Undefined;
	
	If AdditionCheck Then
		Query.Text = StrReplace(RestrictionParameters.ReadEditRightsCheckQueryText,
			"AllowedAccessKeys.Update", "AllowedAccessKeys.Insert");
	Else
		Query.Text = RestrictionParameters.ReadEditRightsCheckQueryText;
	EndIf;
	
	UpdateAllowedSetsInSessionParameters();
	
	Query.SetParameter("Object", Source.Ref);
	SetAllowedSetsInQueryParameters(Query);
	
	If RestrictionParameters.OwnerField <> Undefined Then
		Query.SetParameter("RightSettingsTableID",
			RestrictionParameters.RightSettingsTableID);
	EndIf;
	
	If Not AccessCheckQueryResult(Query, Source).IsEmpty() Then
		Return; // Access allowed.
	EndIf;
	
	If AdditionCheck Then
		Query.Text = RestrictionParameters.ReadEditRightsCheckQueryText;
		EditRight = Not Query.Execute().IsEmpty();
	Else
		EditRight = False;
	EndIf;
	
	If RestrictionParameters.RightToWriteRestrictionDisabled Then
		ReadRight = True;
	Else
		Query.Text = RestrictionParameters.ReadRightsCheckQueryText;
		ReadRight = Not Query.Execute().IsEmpty();
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	Data = ?(BeforeWrite, Source.Ref, Source);
	ReportAccessError(Data, BeforeWrite, ReadRight, EditRight, IsNew);
	
EndProcedure

// For the CheckAccessToObject and the CheckAccessToRecordSet procedures.
Function AccessCheckQueryResult(Query, Source)
	
	Return Query.Execute();
	
EndFunction

// For the CheckAccessToSource procedure.
Procedure CheckAccessToRecordSet(Source, BeforeWrite, Overwrite, RestrictionParameters, IsFullUser)
	
	If    BeforeWrite AND (Not Overwrite Or IsFullUser)
	 Or Not BeforeWrite AND Source.Count() = 0
	 Or IsFullUser
	   AND RestrictionParameters.UsesRestrictionByOwner Then
		
		Return;
	EndIf;
	
	Query = New Query;
	If Not BeforeWrite Then
		NewCombinationsQuery = New Query;
	EndIf;
	
	If Overwrite Then
		FilterByDimensions = FilterByRecordSetDimensions(Source, Query, NewCombinationsQuery);
	Else
		FilterByDimensions = "";
		BasicFieldsValuesCombinations = BasicFieldsValuesCombinations(Source,
			FilterByDimensions, RestrictionParameters);
		
		Query.SetParameter("BasicFieldsValuesCombinations", BasicFieldsValuesCombinations);
		NewCombinationsQuery.SetParameter("BasicFieldsValuesCombinations", BasicFieldsValuesCombinations);
	EndIf;
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Not BeforeWrite
	   AND Not RestrictionParameters.UsesRestrictionByOwner Then
		
		UpdateAccessKeysOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
			FilterByDimensions, Source, RestrictionParameters);
	EndIf;
	
	If IsFullUser Then
		Return;
	EndIf;
	
	Query.Text = StrReplace(RestrictionParameters.ReadEditRightsCheckQueryText,
		"&FilterByDimensions", FilterByDimensions);
	
	UpdateAllowedSetsInSessionParameters();
	SetAllowedSetsInQueryParameters(Query);
	
	If AccessCheckQueryResult(Query, Source).IsEmpty() Then
		Return; // Access allowed.
	EndIf;
	
	If RestrictionParameters.RightToWriteRestrictionDisabled Then
		ReadRight = True;
	Else
		Query.Text = StrReplace(RestrictionParameters.ReadRightsCheckQueryText,
			"&FilterByDimensions", FilterByDimensions);
		ReadRight = Query.Execute().IsEmpty();
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	ReportAccessError(Source, BeforeWrite, ReadRight, False, False);
	
EndProcedure

// For the CheckAccessBeforeWriteSource procedure.
Procedure WriteAccessKeysOfNewBasicFieldsCombinationsValuesBeforeWrite(Source, IsFullUser)
	
	If IsFullUser Or Source.Count() = 0 Then
		Return;
	EndIf;
	
	FullName = Source.Metadata().FullName();
	TransactionID = Source.AdditionalProperties.AccessManagementTransactionID;
	RestrictionParameters = RestrictionParameters(FullName, TransactionID);
	
	If RestrictionParameters.RestrictionDisabled
	 Or RestrictionParameters.UsesRestrictionByOwner Then
		Return;
	EndIf;
	
	NewCombinationsQuery = New Query;
	FilterByDimensions = "";
	
	NewCombinationsQuery.SetParameter("BasicFieldsValuesCombinations",
		BasicFieldsValuesCombinations(Source, FilterByDimensions, RestrictionParameters));
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	UpdateAccessKeysOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
			FilterByDimensions, Source, RestrictionParameters);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the CheckAccessToRecordSet and
// WriteAccessKeysOfNewBasicFieldsCombinationsValuesBeforeWrite procedures.
//
Function BasicFieldsValuesCombinations(Source, FilterByDimensions, RestrictionParameters)
	
	Fields = StrConcat(RestrictionParameters.BasicFields.Used, ",");
	BasicFieldsValuesCombinations = Source.Unload(, Fields);
	BasicFieldsValuesCombinations.GroupBy(Fields);
	
	FilterFields = "";
	For Each Field In RestrictionParameters.BasicFields.Used Do
		FilterFields = FilterFields + ?(FilterFields = "", "", ", ") + "CurrentTable." + Field;
	EndDo;
	FilterByDimensions = "(" + FilterFields + ") IN (&BasicFieldsValuesCombinations)";
	
	Return BasicFieldsValuesCombinations;
	
EndFunction

// For the CheckAccessToRecordSet and
// WriteAccessKeysOfNewBasicFieldsCombinationsValuesBeforeWrite procedures.
//
Procedure UpdateAccessKeysOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
			FilterByDimensions, Source, RestrictionParameters)
	
	DataItems = DataItemsOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
		FilterByDimensions, Source, RestrictionParameters);
	
	If DataItems.Count() = 0 Then
		Return;
	EndIf;
	
	UpdateAccessKeysOfDataItemsOnWrite(DataItems, RestrictionParameters,
		Source.AdditionalProperties.AccessManagementTransactionID,,, Source);
	
EndProcedure

// For the UpdateAccessKeysOfNewBasicFieldsCombinationsValues procedure.
Function DataItemsOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
			FilterByDimensions, Source, RestrictionParameters)
	
	NewCombinationsQuery.Text =
		StrReplace(RestrictionParameters.NewCombinationsOfBasicFieldsValuesQueryText,
			"&FilterByDimensions", FilterByDimensions);
	
	NewCombinationsQueryResult = NewCombinationsQuery.Execute();
	If NewCombinationsQueryResult.IsEmpty() Then
		Return New Array;
	EndIf;
	
	DataItems = NewCombinationsQueryResult.Unload();
	DataItems.Columns.Add("CurrentRef", New TypeDescription("Number"));
	Index = 0;
	For Each DataItem In DataItems Do
		DataItem.CurrentRef = Index;
		Index = Index + 1;
	EndDo;
	
	Return DataItems;
	
EndFunction

// For the CheckAccessToObject and the CheckAccessToRecordSet procedures.
Procedure ReportAccessError(Data, BeforeWrite, ReadRight, EditRight, IsNew)
	
	If BeforeWrite Then
		If ReadRight Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Недостаточно прав для изменения существующей версии:
				           |%1'; 
				           |en = 'Insufficient rights to change the current version: 
				           |%1'; 
				           |pl = 'Brak wystarczających uprawnień, aby zmienić istniejącą wersję:
				           |%1';
				           |es_ES = 'Insuficientes derechos para cambiar la versión actual:
				           |%1';
				           |es_CO = 'Insuficientes derechos para cambiar la versión actual:
				           |%1';
				           |tr = 'Mevcut sürümün değişmesi için haklar yetersizdir: 
				           |%1';
				           |it = 'Diritti insufficienti per modificare la versione corrente: 
				           |%1';
				           |de = 'Nicht genügend Rechte, um die bestehende Version zu ändern:
				           |%1'"), DataPresentation(Data));
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Недостаточно прав для чтения существующей версии:
				           |%1'; 
				           |en = 'Insufficient rights to read the current version: 
				           |%1'; 
				           |pl = 'Brak wystarczających uprawnień do odczytu istniejącej wersji:
				           |%1';
				           |es_ES = 'Insuficientes derechos para leer la versión actual:
				           |%1';
				           |es_CO = 'Insuficientes derechos para leer la versión actual:
				           |%1';
				           |tr = 'Mevcut sürümün okunması için haklar yetersizdir: 
				           |%1';
				           |it = 'Diritti insufficienti per leggere la versione corrente: 
				           |%1';
				           |de = 'Nicht genügend Rechte, um die bestehende Version zu lesen:
				           |%1'"), DataPresentation(Data));
		EndIf;
	Else
		If ReadRight AND EditRight Then
			If IsNew Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Недостаточно прав для записи новой версии (нет права добавления):
					           |%1'; 
					           |en = 'Insufficient rights to record a new version (no Insert right):
					           |%1'; 
					           |pl = 'Brak wystarczających uprawnień do zapisu nowej wersji (nie ma prawa dodawania):
					           |%1';
					           |es_ES = 'Insuficientes derechos para guardar la versión actual (no hay derechos de añadir):
					           |%1';
					           |es_CO = 'Insuficientes derechos para guardar la versión actual (no hay derechos de añadir):
					           |%1';
					           |tr = 'Yeni sürümün kaydı için haklar yetersizdir (ilave etme hakkı yok): 
					           |%1';
					           |it = 'Diritti insufficienti per registrare una nuova versione (nessun diritti Inserimento): 
					           |%1';
					           |de = 'Nicht genügend Rechte, um eine neue Version zu schreiben (keine Rechte zum hinzufügen):
					           |%1'"), DataPresentation(Data));
			Else
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Недостаточно прав для записи новой версии (нет права добавления для сделанных изменений):
					           |%1'; 
					           |en = 'Insufficient rights to record a new version (no Insert right for the changes):
					           |%1'; 
					           |pl = 'Brak wystarczających uprawnień do zapisu nowej wersji (nie ma prawa dodawania do dokonanych zmian):
					           |%1';
					           |es_ES = 'Insuficientes derechos para guardar la versión actual (no hay derechos de añadir para los cambios realizados):
					           |%1';
					           |es_CO = 'Insuficientes derechos para guardar la versión actual (no hay derechos de añadir para los cambios realizados):
					           |%1';
					           |tr = 'Yeni sürümün kaydı için haklar yetersizdir (yapılan değişiklikleri ilave etme hakkı yok): 
					           |%1';
					           |it = 'Diritti insufficienti per registrare una nuova versione (nessun diritto Inserire per le modifiche):
					           |%1';
					           |de = 'Nicht genügend Rechte, um eine neue Version zu schreiben (keine Rechte, Änderungen hinzuzufügen):
					           |%1'"), DataPresentation(Data));
			EndIf;
		ElsIf ReadRight Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Недостаточно прав для записи новой версии (ее невозможно будет изменить):
				           |%1'; 
				           |en = 'Insufficient rights to record a new version (you will not be able to change it):
				           |%1'; 
				           |pl = 'Brak wystarczających uprawnień do zapisu nowej wersji (nie można jej zmienić):
				           |%1';
				           |es_ES = 'Insuficientes derechos para guardar la versión actual (no se podrá cambiarla):
				           |%1';
				           |es_CO = 'Insuficientes derechos para guardar la versión actual (no se podrá cambiarla):
				           |%1';
				           |tr = 'Yeni sürümün kaydı için haklar yetersizdir (bu sürüm değiştirilemez): 
				           |%1';
				           |it = 'Diritti insufficienti per registrare una nuova versione (non sarà possibile modificarlo):
				           |%1';
				           |de = 'Nicht genügend Rechte, um eine neue Version zu schreiben (sie kann nicht geändert werden):
				           |%1'"), DataPresentation(Data));
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Недостаточно прав для записи новой версии (ее невозможно будет прочитать):
				           |%1.'; 
				           |en = 'Insufficient rights to record a new version (you will not be able to read it):
				           |%1'; 
				           |pl = 'Brak wystarczających uprawnień do zapisu nowej wersji (nie można jej przeczytać):
				           |%1.';
				           |es_ES = 'Insuficientes derechos para guardar la versión actual (no se podrá leerla):
				           |%1.';
				           |es_CO = 'Insuficientes derechos para guardar la versión actual (no se podrá leerla):
				           |%1.';
				           |tr = 'Yeni sürümün kaydı için haklar yetersizdir (bu sürüm okunamaz): 
				           |%1';
				           |it = 'Diritti insufficienti per registrare una nuova versione (per voi non sarà possibile leggerla):
				           |%1';
				           |de = 'Nicht genügend Rechte, um eine neue Version zu schreiben (sie wird nicht lesbar sein):
				           |%1.'"), DataPresentation(Data));
		EndIf;
	EndIf;
	
	Raise ErrorText;
	
EndProcedure

// For the ReportAccessError procedure.
Function DataPresentation(Data)
	
	If TypeOf(Data) = Type("String") Then
		Return TrimAll(Data);
	EndIf;
	
	If TypeOf(Data) = Type("Structure") Then
		IsRegister = True;
		If TypeOf(Data.Register) = Type("String") Then
			MetadataObject = Metadata.FindByFullName(Data.Register);
		Else
			MetadataObject = Metadata.FindByType(TypeOf(Data.Register));
		EndIf;
	Else
		MetadataObject = Metadata.FindByType(TypeOf(Data));
		IsRegister = Common.IsRegister(MetadataObject);
	EndIf;
	
	If MetadataObject = Undefined Then
		Return "";
	EndIf;
	
	If IsRegister Then
		DataPresentation = MetadataObject.Presentation();
		
		FieldsCount = 0;
		For each FilterItem In Data.Filter Do
			If FilterItem.Use Then
				FieldsCount = FieldsCount + 1;
			EndIf;
		EndDo;
		
		If FieldsCount = 1 Then
			DataPresentation = DataPresentation
				+ " " + NStr("ru = 'с полем'; en = 'with field'; pl = 'z polem';es_ES = 'con el campo';es_CO = 'con el campo';tr = 'alan ile';it = 'con campo';de = 'mit Feld'")  + " " + String(Data.Filter);
			
		ElsIf FieldsCount > 1 Then
			DataPresentation = DataPresentation
				+ " " + NStr("ru = 'с полями'; en = 'with fields'; pl = 'z polami';es_ES = 'con los campos';es_CO = 'con los campos';tr = 'alanlar ile';it = 'con campi';de = 'mit Feldern'") + " " + String(Data.Filter);
		EndIf;
	Else
		DataPresentation = String(Data);
		
		Properties = New Structure("ExtendedObjectPresentation, ObjectPresentation");
		FillPropertyValues(Properties, MetadataObject);
		
		MetadataPresentation = Properties.ExtendedObjectPresentation;
		If Not ValueIsFilled(MetadataPresentation) Then
			MetadataPresentation = Properties.ObjectPresentation;
		EndIf;
		If Not ValueIsFilled(MetadataPresentation) Then
			MetadataPresentation = MetadataObject.Presentation();
		EndIf;
		
		If Not StrEndsWith(DataPresentation, "(" + MetadataPresentation + ")")
		   AND Not StrStartsWith(DataPresentation, MetadataPresentation) Then
			
			DataPresentation = StringFunctionsClientServer.SubstituteParametersToString("%1 (%2)",
				DataPresentation, MetadataPresentation);
		EndIf;
	EndIf;
		
	Return DataPresentation;
	
EndFunction

// For the CheckAccessToObject procedure and the AccessUpdateManualControl form.
Function SourceAccessKeyObsolete(ObjectRef, RestrictionParameters, Source = Undefined) Export
	
	Query = New Query;
	Query.SetParameter("Ref", ObjectRef);
	
	SetDataItemsQueryTextForProcessing(Query, RestrictionParameters);
	
	If RestrictionParameters.ListWithDate Then
		Query.Text = StrReplace(Query.Text,
			"CurrentList.Date BETWEEN &StartDate AND &EndDate", "CurrentList.Ref = &Ref");
	Else
		Query.Text = StrReplace(Query.Text,
			"CurrentList.Ref >= &LastProcessedRef", "CurrentList.Ref = &Ref");
	EndIf;
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Query.Execute().IsEmpty() Then
		Return False;
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	Return True;
	
EndFunction

// For the CheckAccessToObject and CheckAccessToRecordSet procedures, and the AccessUpdateManualControl form.
Procedure UpdateAccessKeysOfDataItemsOnWrite(DataItemsDetails, RestrictionParameters,
			TransactionID, UpdateRightsToKeys = False, HasRightsChanges = False, Source = Undefined) Export
	
	If TypeOf(DataItemsDetails) = Type("ValueTable") Then
		DataItems = DataItemsDetails;
	Else
		DataItems = New ValueTable;
		DataItems.Columns.Add("CurrentRef");
		DataItems.Add().CurrentRef = DataItemsDetails;
	EndIf;
	
	ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(RestrictionParameters.List,
		TransactionID);
	UsersKindPropertyName = ?(RestrictionParameters.ForExternalUsers,
		"ForExternalUsers", "ForUsers");
	
	UpdateParameters = New Structure(RestrictionParameters);
	UpdateParameters.Insert("HasRightsChanges",       HasRightsChanges);
	UpdateParameters.Insert("UpdateRightsToKeys",    UpdateRightsToKeys);
	UpdateParameters.Insert("TransactionID", TransactionID);
	UpdateParameters.Insert("ListID",
		Common.MetadataObjectID(RestrictionParameters.List));
	
	If ListPropertiesAsLeadingOne = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName] = Undefined Then
		
		UpdateParameters.Insert("DependentListsByAccessKeys", New Array);
	Else
		UpdateParameters.Insert("DependentListsByAccessKeys",
			ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName]);
	EndIf;
	
	If RestrictionParameters.RestrictionDisabled
	 Or RestrictionParameters.AccessDenied
	 Or RestrictionParameters.UsesRestrictionByOwner Then
		
		If Not RestrictionParameters.Property("DataItemForKeyClearingQueryText") Then
			UpdateListDataItemsWithObsoleteAllowedKey(DataItems, UpdateParameters);
			
		ElsIf ValueIsFilled(RestrictionParameters.DataItemForKeyClearingQueryText) Then
			ClearAccessKeysOfListDataItems(DataItems, UpdateParameters);
		Else
			Return;
		EndIf;
	Else
		UpdateContext = New Structure;
		UpdateContext.Insert("DataItemsBatch", DataItems);
		UpdateContext.Insert("DataItemsValuesQuery",
			New Query(RestrictionParameters.DataItemValueForAccessKeysQueryText));
		UpdateContext.Insert("KeysValuesQuery",
			New Query(RestrictionParameters.ValueFromAccessKeysForComparisonQueryText));
		
		UpdateAccessKeysOfListDataItemsBatch(UpdateParameters, UpdateContext);
	EndIf;
	
	HasRightsChanges = UpdateParameters.HasRightsChanges;
	
EndProcedure

// For the ScheduleUpdateOfDependentObsoleteAccessKeys procedures.
Procedure ScheduleUpdateOfObsoleteSourceAccessKeys(Source, ListsForUpdate = Undefined)
	
	TransactionID = Source.AdditionalProperties.AccessManagementTransactionID;
	If ListsForUpdate = Undefined Then
		ListsForUpdate = New Map;
		Properties = New Structure("ForUsers, ForExternalUsers", True, False);
		ListsForUpdate.Insert(Source.Metadata().FullName(), Properties);
	EndIf;
	
	ScheduleUpdateOfObsoleteAccessKeys(ListsForUpdate, TransactionID);
	
EndProcedure

// For the AccessValuesGroups information register.
Procedure ScheduleUpdateOfDependentListsByValuesWithGroups(ValuesTypesWithChanges) Export
	
	If Not LimitAccessAtRecordLevelUniversally() Then
		Return;
	EndIf;
	
	TransactionID = New UUID;
	
	ListsForUpdate = New Map;
	For Each AccessValueTypeDetails In ValuesTypesWithChanges Do
		FullLeadingListName = Metadata.FindByType(AccessValueTypeDetails.Key).FullName();
		ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(FullLeadingListName, TransactionID);
		If ListPropertiesAsLeadingOne = Undefined
		 Or ListPropertiesAsLeadingOne.ByValuesWithGroups = Undefined Then
			Continue;
		EndIf;
		AddListsForUsersKindUpdate(ListsForUpdate,
			ListPropertiesAsLeadingOne.ByValuesWithGroups, "ForUsers");
		
		AddListsForUsersKindUpdate(ListsForUpdate,
			ListPropertiesAsLeadingOne.ByValuesWithGroups, "ForExternalUsers");
	EndDo;
	
	ScheduleUpdateOfObsoleteAccessKeys(ListsForUpdate, TransactionID);
	
EndProcedure

// For the ScheduleUpdateOfDependentListsByValuesWithGroups procedure.
Procedure AddListsForUsersKindUpdate(ListsForUpdate, ByValuesWithGroups, UsersKindName)
	
	FullNames = ByValuesWithGroups[UsersKindName];
	If FullNames = Undefined Then
		Return;
	EndIf;
	
	For Each FullName In FullNames Do
		ListForUpdate = ListsForUpdate.Get(FullName);
		If ListForUpdate = Undefined Then
			ListForUpdate = New Structure("ForUsers, ForExternalUsers", False, False);
			ListsForUpdate.Insert(FullName, ListForUpdate);
		EndIf;
		ListForUpdate[UsersKindName] = True;
	EndDo;
	
EndProcedure

// For the ScheduleUpdateOfObsoleteSourceAccessKeys, WriteObjectsAccessKeys,
// ScheduleUpdateOfDependentListsByValuesWithGroups procedures.
//
Procedure ScheduleUpdateOfObsoleteAccessKeys(ListsForUpdate, TransactionID)
	
	If ListsForUpdate.Count() = 0 Then
		Return;
	EndIf;
	
	RecordSet = ServiceRecordSet(InformationRegisters.DataAccessKeysUpdate);
	
	Context = New Structure;
	Context.Insert("TransactionID", TransactionID);
	Context.Insert("RecordSet",            RecordSet);
	Context.Insert("UniqueKey",        New UUID);
	Context.Insert("CurrentDate",             CurrentSessionDate());
	Context.Insert("MaxDate",        MaxDate());
	Context.Insert("List",                  Undefined);
	Context.Insert("FullName",               Undefined);
	
	For Each ListDetails In ListsForUpdate Do
		Context.FullName = ListDetails.Key;
		Context.List = Common.MetadataObjectID(Context.FullName);
		
		If ListDetails.Value.ForUsers Then
			ScheduleUpdateOfObsoleteAccessKeysForUsersKind(Context, False)
		EndIf;
		
		If ListDetails.Value.ForExternalUsers Then
			ScheduleUpdateOfObsoleteAccessKeysForUsersKind(Context, True)
		EndIf;
	EndDo;
	
	If RecordSet.Count() = 0 Then
		Return;
	EndIf;
	
	RecordSet.Write(False);
	
	SetAccessUpdate(True);
	
EndProcedure

// For the ScheduleUpdateOfObsoleteAccessKeys procedure.
Procedure ScheduleUpdateOfObsoleteAccessKeysForUsersKind(Context, ForExternalUsers)
	
	RestrictionParameters = RestrictionParameters(Context.FullName,
		Context.TransactionID, ForExternalUsers);
	
	If RestrictionParameters.RestrictionDisabled
	 Or RestrictionParameters.AccessDenied
	 Or RestrictionParameters.UsesRestrictionByOwner Then
		Return;
	EndIf;
	
	NewRecord = Context.RecordSet.Add();
	NewRecord.UniqueKey                   = Context.UniqueKey;
	NewRecord.List                             = Context.List;
	NewRecord.ForExternalUsers            = ForExternalUsers;
	NewRecord.LatestUpdatedItemDate = Context.MaxDate;
	NewRecord.RegisterRecordChangeDate        = Context.CurrentDate;
	
EndProcedure

// For the CheckAccessOnWriteSource procedure.
Procedure ScheduleUpdateOfDependentObsoleteAccessKeys(Source, IsRecordSet)
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	FullName = Source.Metadata().FullName();
	ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(FullName,
		Source.AdditionalProperties.AccessManagementTransactionID);
	
	If ListPropertiesAsLeadingOne = Undefined
	 Or ListPropertiesAsLeadingOne.ByFieldsValues = Undefined
	 Or Not Source.AdditionalProperties.Property("FieldValueAccessManagementForChangeCheckOnWrite") Then
		Return;
	EndIf;
	
	QueryResults = Source.AdditionalProperties.FieldValueAccessManagementForChangeCheckOnWrite;
	If QueryResults = Undefined Then
		Return;
	EndIf;
	
	ListsForUpdate = New Map;
	ByFieldsValues = ListPropertiesAsLeadingOne.ByFieldsValues;
	
	If IsRecordSet Then
		If ValueIsFilled(ByFieldsValues.RegisterFields.Fields)
		   AND TableChanged(QueryResults[0], Source, ByFieldsValues.RegisterFields) Then
			
			AddListsToUpdate(ListsForUpdate, ByFieldsValues.RegisterFields.DependentLists);
		EndIf;
	Else
		If ValueIsFilled(ByFieldsValues.HeaderFields) Then
			PreviousValues = QueryResults[0].Unload()[0];
			For Each FieldDetails In ByFieldsValues.HeaderFields Do
				If Source[FieldDetails.Key] <> PreviousValues[FieldDetails.Key] Then
					AddListsToUpdate(ListsForUpdate, FieldDetails.Value);
				EndIf;
			EndDo;
			Index = 1;
		Else
			Index = 0;
		EndIf;
		For Each TabularSectionDetails In ByFieldsValues.TabularSections Do
			If TableChanged(QueryResults[Index], Source[TabularSectionDetails.Name],
					TabularSectionDetails) Then
				
				AddListsToUpdate(ListsForUpdate,
					TabularSectionDetails.DependentLists);
			EndIf;
			Index = Index + 1;
		EndDo;
	EndIf;
	
	ScheduleUpdateOfObsoleteSourceAccessKeys(Source, ListsForUpdate);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the ScheduleUpdateOfDependentObsoleteAccessKeys procedure.
Function TableChanged(QueryResult, Source, FieldsDetails)
	
	MaxCombinations = MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes();
	Selection = QueryResult.Select();
	
	If Selection.Count() >= MaxCombinations Then
		Return True;
	EndIf;
	
	Fields = StrConcat(FieldsDetails.Fields, ", ");
	
	NewCombinations = Source.Unload(, Fields);
	NewCombinations.GroupBy(Fields);
	
	If NewCombinations.Count() >= MaxCombinations Then
		Return True;
	EndIf;
	
	NewCombinations.Columns.Add("ChangeKind", New TypeDescription("Number"));
	NewCombinations.FillValues(1, "ChangeKind");
	While Selection.Next() Do
		NewRow = NewCombinations.Add();
		FillPropertyValues(NewRow, Selection);
		NewRow.ChangeKind = -1;
	EndDo;
	NewCombinations.GroupBy(Fields, "ChangeKind");
	
	Filter = New Structure("ChangeKind", 0);
	Return NewCombinations.Count() <> NewCombinations.FindRows(Filter).Count();
	
EndFunction

// For the AddAccessKeysUpdateContentToList procedure.
Procedure AddListsToUpdate(ListsForUpdate, DependentLists)
	
	For Each DependentListDetails In DependentLists Do
		Properties = ListsForUpdate.Get(DependentListDetails.Key);
		If Properties = Undefined Then
			Properties = New Structure("ForUsers, ForExternalUsers", False, False);
			ListsForUpdate.Insert(DependentListDetails.Key, Properties);
		EndIf;
		If DependentListDetails.Value.ForUsers Then
			Properties.ForUsers = True;
		EndIf;
		If DependentListDetails.Value.ForExternalUsers Then
			Properties.ForExternalUsers = True;
		EndIf;
	EndDo;
	
EndProcedure

// For call and manager module of the AccessGroups catalog.
Procedure ScheduleAccessUpdateOnChangeAccessGroupMembers(AccessGroup, ChangedMembersTypes) Export
	
	If Not ChangedMembersTypes.Users
	   AND Not ChangedMembersTypes.ExternalUsers Then
		Return;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("AccessGroup", AccessGroup);
	Query.Text =
	"SELECT
	|	AccessGroupsTables.Table AS Table
	|FROM
	|	InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|WHERE
	|	AccessGroupsTables.AccessGroup = &AccessGroup";
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	Tables = Query.Execute().Unload();
	
	ScheduleAccessKeysUsersUpdate(Tables,
		ChangedMembersTypes.Users,
		ChangedMembersTypes.ExternalUsers,
		True);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the AfterAddChangeUserOrGroup, AfterUserGroupsUpdate procedures.
Procedure ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers(ChangedMembers)
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	ForUsers        = False;
	ForExternalUsers = False;
	
	For Each Member In ChangedMembers Do
		If TypeOf(Member) = Type("CatalogRef.Users")
		 Or TypeOf(Member) = Type("CatalogRef.UserGroups") Then
			
			ForUsers = True;
		
		ElsIf TypeOf(Member) = Type("CatalogRef.ExternalUsers")
		      Or TypeOf(Member) = Type("CatalogRef.ExternalUsersGroups") Then
			
			ForExternalUsers = True;
		EndIf;
	EndDo;
	
	Query = New Query;
	Query.SetParameter("ChangedMembers", ChangedMembers);
	Query.Text =
	"SELECT DISTINCT
	|	AccessGroupsTables.Table AS Table
	|FROM
	|	InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|		INNER JOIN Catalog.AccessGroups.Users AS AccessGroupsMembers
	|		ON AccessGroupsTables.AccessGroup = AccessGroupsMembers.Ref
	|			AND (AccessGroupsMembers.User IN (&ChangedMembers))";
	
	Tables = Query.Execute().Unload();
	ScheduleAccessKeysUsersUpdate(Tables,
		ForUsers, ForExternalUsers, True);
	
	ScheduleAccessGroupsSetsUpdate(ForUsers, ForExternalUsers);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For calling the AccessGroupsTables register from manager module.
Procedure ScheduleAccessUpdateOnChangeAccessGroupsTables(Tables) Export
	
	ScheduleAccessKeysUsersUpdate(Tables);
	
EndProcedure

// For calling the AccessGroupsValues register from the manager module.
Procedure ScheduleAccessUpdateOnChangeAllowedValues(AccessGroupsAndValuesTypes) Export
	
	ClearAccessGroupsValuesCacheToCalculateRights();
	
	Query = New Query;
	Query.SetParameter("AccessGroupsAndValuesTypes", AccessGroupsAndValuesTypes);
	Query.Text =
	"SELECT
	|	AccessGroupsAndValuesTypes.AccessGroup AS AccessGroup,
	|	AccessGroupsAndValuesTypes.AccessValuesType AS AccessValuesType
	|INTO AccessGroupsAndValuesTypes
	|FROM
	|	&AccessGroupsAndValuesTypes AS AccessGroupsAndValuesTypes
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	AccessGroupsTables.Table AS Table,
	|	VALUETYPE(AccessGroupsAndValuesTypes.AccessValuesType) AS AccessValuesType
	|FROM
	|	InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|		INNER JOIN AccessGroupsAndValuesTypes AS AccessGroupsAndValuesTypes
	|		ON AccessGroupsTables.AccessGroup = AccessGroupsAndValuesTypes.AccessGroup
	|TOTALS BY
	|	Table";
	
	TablesAndAccessValuesTypes = Query.Execute().Unload(QueryResultIteration.ByGroups);
	
	ScheduleAccessKeysUsersUpdate(TablesAndAccessValuesTypes.Rows);
	
EndProcedure

// For the ScheduleAccessUpdateOnChangeAllowedValues and
// ScheduleAccessUpdate procedures, and calling from the AccessUpdateManualControl form module.
//
Procedure ClearAccessGroupsValuesCacheToCalculateRights() Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	VersionParameterName = "StandardSubsystems.AccessManagement.AccessGroupsValuesVersion";
	StandardSubsystemsServer.SetExtensionParameter(VersionParameterName, New UUID, True);
	
	ParameterName = "StandardSubsystems.AccessManagement.AccessGroupsValues";
	StandardSubsystemsServer.SetExtensionParameter(ParameterName, Undefined, True);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the ScheduleAccessUpdateOnChangeAccessGroupMembers,
// ScheduleAccessUpdateAfterUserGroupsUpdate,
// ScheduleAccessUpdateOnChangeAccessGroupsTables, and
// ScheduleAccessUpdateOnChangeAllowedValues procedures.
//
Procedure ScheduleAccessKeysUsersUpdate(ListsDetails, ForUsers = True,
				ForExternalUsers = True, OnChangeAccessGroupMembers = False)
	
	If ListsDetails.Count() = 0 Then
		Return;
	EndIf;
	
	RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeysUpdate);
	
	Context = New Structure;
	Context.Insert("OnChangeAccessGroupMembers", OnChangeAccessGroupMembers);
	Context.Insert("TransactionID",             New UUID);
	Context.Insert("RecordSet",                        RecordSet);
	Context.Insert("UniqueKey",                    New UUID);
	Context.Insert("CurrentDate",                         CurrentSessionDate());
	Context.Insert("List",                              Undefined);
	Context.Insert("FullName",                           Undefined);
	Context.Insert("AccessValuesTypes",                 Undefined);
	
	If TypeOf(ListsDetails) = Type("FixedArray") Then
		ListsIDsByFullNames = Common.MetadataObjectIDs(ListsDetails);
	Else
		FullNames = ListsDetails.UnloadColumn("Table");
		ListsMetadataObjects = Catalogs.MetadataObjectIDs.MetadataObjectsByIDs(
			FullNames, True);
	EndIf;
	
	For Each ListDetails In ListsDetails Do
		If ListsIDsByFullNames <> Undefined Then
			Context.FullName = ListDetails;
			Context.List = ListsIDsByFullNames.Get(Context.FullName);
		Else
			MetadataObject = ListsMetadataObjects.Get(ListDetails.Table);
			Context.FullName = ?(TypeOf(MetadataObject) = Type("MetadataObject"), MetadataObject.FullName(), "");
			Context.List    = ListDetails.Table;
			If TypeOf(ListDetails) = Type("ValueTreeRow") Then
				Context.AccessValuesTypes = ListDetails.Rows;
			EndIf;
		EndIf;
		If ForUsers Then
			ScheduleAccessKeysUsersUpdateForUsersKind(Context, False)
		EndIf;
		If ForExternalUsers Then
			ScheduleAccessKeysUsersUpdateForUsersKind(Context, True)
		EndIf;
	EndDo;
	
	If RecordSet.Count() = 0 Then
		Return;
	EndIf;
	
	RecordSet.Write(False);
	
	SetAccessUpdate(True);
	
EndProcedure

// For the ScheduleAccessKeysUsersUpdate procedure.
Procedure ScheduleAccessKeysUsersUpdateForUsersKind(Context, ForExternalUsers)
	
	If ValueIsFilled(Context.FullName) Then
		ActiveParameters = ActiveAccessRestrictionParameters(Context.TransactionID, Undefined);
		If ForExternalUsers Then
			AdditionalContext = ActiveParameters.AdditionalContext.ForExternalUsers;
		Else
			AdditionalContext = ActiveParameters.AdditionalContext.ForUsers;
		EndIf;
		RestrictionProperties = AdditionalContext.ListRestrictionsProperties.Get(Context.FullName);
		
		If AdditionalContext.ListsWithDisabledRestriction.Get(Context.FullName) <> Undefined
		 Or RestrictionProperties = Undefined
		 Or RestrictionProperties.AccessDenied
		 Or RestrictionProperties.OwnerField <> Undefined
		 Or Context.OnChangeAccessGroupMembers
		   AND Not RestrictionProperties.CalculateUserRights Then
			
			Return;
		EndIf;
		
		If RestrictionProperties <> Undefined
		   AND Context.AccessValuesTypes <> Undefined
		   AND Not Context.OnChangeAccessGroupMembers Then
			
			NoUsedTypesAmongChangedAccessValuesTypes = True;
			UsedAccessValuesTypes = RestrictionProperties.UsedAccessValuesTypes.Get();
			For Each Row In Context.AccessValuesTypes Do
				If UsedAccessValuesTypes.Find(Row.AccessValuesType) <> Undefined Then
					NoUsedTypesAmongChangedAccessValuesTypes = False;
					Break;
				EndIf;
			EndDo;
			If NoUsedTypesAmongChangedAccessValuesTypes Then
				Return;
			EndIf;
		EndIf;
	EndIf;
	
	NewRecord = Context.RecordSet.Add();
	NewRecord.UniqueKey            = Context.UniqueKey;
	NewRecord.List                      = Context.List;
	NewRecord.ForExternalUsers     = ForExternalUsers;
	NewRecord.RegisterRecordChangeDate = Context.CurrentDate;
	
EndProcedure

// For the ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers procedure, and the AccessGroups 
// catalog object and manager modules.
//
Procedure ScheduleAccessGroupsSetsUpdate(Val ForUsers = True, Val ForExternalUsers = True) Export
	
	If Not ForUsers AND Not ForExternalUsers Then
		Return;
	EndIf;
	
	RecordSet = ServiceRecordSet(InformationRegisters.DataAccessKeysUpdate);
	
	UniqueKey = New UUID;
	List = Common.MetadataObjectID("Catalog.AccessGroupsSets");
	CurrentDate = CurrentSessionDate();
	MaxDate = MaxDate();
	
	// Update only by changes (not a full update).
	LastUpdatedItem = New ValueStorage(Catalogs.AccessGroupsSets.EmptyRef());
	
	If ForUsers Then
		NewRecord = RecordSet.Add();
		NewRecord.UniqueKey                   = UniqueKey;
		NewRecord.List                             = List;
		NewRecord.ForExternalUsers            = False;
		NewRecord.LatestUpdatedItemDate = MaxDate;
		NewRecord.LastUpdatedItem        = LastUpdatedItem;
		NewRecord.RegisterRecordChangeDate        = CurrentDate;
	EndIf;
	
	If ForExternalUsers Then
		NewRecord = RecordSet.Add();
		NewRecord.UniqueKey                   = UniqueKey;
		NewRecord.List                             = List;
		NewRecord.ForExternalUsers            = True;
		NewRecord.LatestUpdatedItemDate = MaxDate;
		NewRecord.LastUpdatedItem        = LastUpdatedItem;
		NewRecord.RegisterRecordChangeDate        = CurrentDate;
	EndIf;
	
	RecordSet.Write(False);
	
EndProcedure

#EndRegion

#Region AccessUpdate

// For internal use only.
Procedure AfterChangeRightsSettingsInForm() Export
	
	If Not LimitAccessAtRecordLevelUniversally() Then
		Return;
	EndIf;
	
	StartAccessUpdateAtRecordLevel();
	
EndProcedure

// Starts an access update background job instead of a scheduled job.
//
// Parameters:
//  IsManualStart - Boolean - if True is passed, the name will begin with "Manual run", otherwise, 
//                              the name will begin with "Autorun."
//
// Returns:
//  Structure - with the following properties:
//   * Running - Boolean - if the update is already running.
//
//   * BackgroundJobID - Undefined - if the update is not running or running not in a background job.
//                                      
//                                  - UUID - a background job ID.
//
//   * SessionProperties - Undefined - if a background job never started or was just added to the queue.
//                    - Structure - with session properties if the update is already running.
//                        * ComputerName - String - the InfobaseSession object property of the same name.
//                        * SessionNumber   - Number - the InfobaseSession object property of the same name.
//                        * SessionStart  - String - the InfobaseSession object property of the same name.
//
//   * WarningText - Undefined - if a background job never started or a new background job was started.
//                         - String - a description showing that access update is already started.
//
Function StartAccessUpdateAtRecordLevel(IsManualRun = False) Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Not LimitAccessAtRecordLevelUniversally(True) Then
		ErrorText =
			NStr("ru = 'Невозможно запустить обновление доступа на уровне записей, так как
			           |константа LimitAccessAtRecordLevelUniversally выключена.'; 
			           |en = 'Cannot start access update at the record level as
			           |the LimitAccessAtRecordLevelUniversally constant is disabled.'; 
			           |pl = 'Nie można uruchomić aktualizację dostępu na poziomie rekordu, ponieważ
			           |stała LimitAccessAtRecordLevelUniversally jest wyłączona.';
			           |es_ES = 'Imposible lanzar la actualización de acceso en nivel de registros, porque
			           |el constante LimitAccessAtRecordLevelUniversally no está desactivado.';
			           |es_CO = 'Imposible lanzar la actualización de acceso en nivel de registros, porque
			           |el constante LimitAccessAtRecordLevelUniversally no está desactivado.';
			           |tr = 'ErişimiKayıtlarSeviyesindeÜniversalOlarakKısıtla sabiti devre dışı bırakıldığı için 
			           |erişim kayıtlar seviyesinde güncellenemez.';
			           |it = 'Impossibile avviare l''aggiornamento dell''accesso a livello di registrazione, poiché 
			           |la costante LimitAccessAtRecordLevelUniversally è disattivata.';
			           |de = 'Es ist nicht möglich, die Aktualisierung des Zugriffs auf die Aufzeichnungsebene zu starten, da die Konstante
			           |LimitAccessAtRecordLevelUniversally deaktiviert ist.'");
		Raise ErrorText;
	EndIf;
	
	If TransactionActive() Then
		ErrorText =
			NStr("ru = 'Невозможно запустить обновление доступа на уровне записей в открытой транзакции.'; en = 'Cannot start access update at the record level in an open transaction.'; pl = 'Nie można uruchomić aktualizację dostępu na poziomie rekordu w otwartej transakcji.';es_ES = 'Imposible lanzar la actualización de acceso en nivel de registros en transacción abierta.';es_CO = 'Imposible lanzar la actualización de acceso en nivel de registros en transacción abierta.';tr = 'Açık bir işlemde kayıt düzeyinde erişim güncelleştirmesi başlatılamıyor.';it = 'Impossibile avviare l''aggiornamento dell''accesso a livello di registrazione in una transazione aperta.';de = 'Es ist nicht möglich, die Aktualisierung des Zugriffs auf die Aufzeichnungsebene in der offenen Transaktion zu starten.'");
		Raise ErrorText;
	EndIf;
	
	If Not IsManualRun AND Not AccessUpdateScheduled() Then
		Return Undefined;
	EndIf;
	
	LastAccessUpdate = LastAccessUpdate();
	
	Result = New Structure("AlreadyRunning, BackgroundJobID, SessionProperties, WarningText", True);
	Performer = AccessUpdateAssignee(LastAccessUpdate);
	
	If Performer = Undefined Then
		Result.AlreadyRunning = False;
		If Common.FileInfobase() Then
			StandardSubsystemsServer.CheckApplicationVersionDynamicUpdate();
		EndIf;
		BackgroundJob = ConfigurationExtensions.ExecuteBackgroundJobWithDatabaseExtensions(
			Metadata.ScheduledJobs.AccessUpdateAtRecordLevel.MethodName,,,
			?(IsManualRun, NStr("ru = 'Запуск вручную'; en = 'Manual start'; pl = 'Uruchomienie ręczne';es_ES = 'Lanzar manualmente';es_CO = 'Lanzar manualmente';tr = 'Manuel başlatma';it = 'Avvio manuale';de = 'Manueller Start'"), NStr("ru = 'Автозапуск'; en = 'Autostart'; pl = 'Autostart';es_ES = 'Lanzamiento automático';es_CO = 'Lanzamiento automático';tr = 'Otomatik başlatma';it = 'Avvio automatico';de = 'Autostart'")) + ": "
				+ Metadata.ScheduledJobs.AccessUpdateAtRecordLevel.Synonym);
			
		Result.BackgroundJobID = BackgroundJob.UUID;
		
	ElsIf TypeOf(Performer) = Type("BackgroundJob")
	        AND Performer.UUID <> LastAccessUpdate.BackgroundJobID Then
		
		Result.WarningText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не удалось начать обновление доступа, так как оно уже запущено %3 в %4'; en = 'Cannot start access update as it has already been started on %3 at %4'; pl = 'Nie udało się rozpocząć aktualizację dostępu, ponieważ ona działa już %3 w %4';es_ES = 'No se ha podido empezar la actualización de acceso porque ya está lanzado %3 en %4';es_CO = 'No se ha podido empezar la actualización de acceso porque ya está lanzado %3 en %4';tr = 'Erişim güncellemesi %3''de %4 başlatıldığı için güncelleme başlatılamadı';it = 'Non è possibile avviare l''aggiornamento accesso dato che è già stato avviato il %3 alle %4';de = 'Es war nicht möglich, mit der Aktualisierung des Zugriffs zu beginnen, da er bereits gestartet wurde %3 in %4'"),
			Format(Performer.Begin, "DLF=D"),
			Format(Performer.Begin, "DLF=T"));
	Else
		SessionProperties = New Structure("ComputerName, SessionNumber, SessionStarted");
		If TypeOf(Performer) = Type("BackgroundJob") Then
			FillPropertyValues(SessionProperties, LastAccessUpdate);
		Else
			FillPropertyValues(SessionProperties, Performer);
		EndIf;
		Result.SessionProperties = SessionProperties;
		Result.WarningText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Обновление доступа уже выполняется
			           |(компьютер: %1, сеанс: %2, начат: %3 в %4)'; 
			           |en = 'Access update is already running
			           |(computer: %1, session: %2, started: %3 at %4)'; 
			           |pl = 'Aktualizacja dostępu jest już uruchomiona
			           |(komputer:%1, sesja: %2, rozpoczęto: %3 w %4)';
			           |es_ES = 'La actualización de acceso ya se está procesando
			           |(ordenador: %1, sesión: %2, empezado: %3 a %4)';
			           |es_CO = 'La actualización de acceso ya se está procesando
			           |(ordenador: %1, sesión: %2, empezado: %3 a %4)';
			           |tr = 'Erişim zaten güncelleniyor 
			           | (bilgisayar:%1, oturum:%2, başlatma: %3''de %4)';
			           |it = 'L''aggiornamento dell''accesso è già in corso
			           |(computer: %1, sessione: %2, cominciato:%3 alle %4)';
			           |de = 'Zugriffsaktualisierung läuft bereits
			           |(Computer: %1, Sitzung: %2, gestartet: %3 in %4)'"),
			SessionProperties.ComputerName,
			SessionProperties.SessionNumber,
			Format(SessionProperties.SessionStarted, "DLF=D"),
			Format(SessionProperties.SessionStarted, "DLF=T"));
	EndIf;
	
	If TypeOf(Performer) = Type("BackgroundJob") Then
		Result.BackgroundJobID = Performer.UUID;
	EndIf;
	
	Return Result;
	
EndFunction

// Cancel access update that is running in the background job.
Procedure CancelAccessUpdateAtRecordLevel() Export
	
	Performer = AccessUpdateAssignee(LastAccessUpdate());
	
	If TypeOf(Performer) = Type("InfoBaseSession") Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Невозможно отменить полное обновление доступа
			           |(компьютер: %1, сеанс: %2, начат: %3 в %4)'; 
			           |en = 'Cannot cancel full access update
			           |(computer: %1, session: %2, started: %3 at %4)'; 
			           |pl = 'Nie można cofnąć pełnej aktualizacji dostępu
			           |(komputer: %1, sesja: %2, rozpoczęto: %3 w %4)';
			           |es_ES = 'Es imposible cancelar la actualización completa del acceso
			           |(ordenador: %1, sesión: %2, empezado: %3 a %4)';
			           |es_CO = 'Es imposible cancelar la actualización completa del acceso
			           |(ordenador: %1, sesión: %2, empezado: %3 a %4)';
			           |tr = 'Tam erişim güncellemesi iptal edilemez 
			           | (bilgisayar: %1, oturum: %2, başlatma: %3''de %4)';
			           |it = 'Impossibile annullare il pieno aggiornamento dell''accesso
			           |(computer: %1, sessione: %2, cominciato:%3 alle %4)';
			           |de = 'Aktualisierung mit vollem Zugriff kann nicht abgebrochen werden
			           |(Computer: %1, Sitzung: %2, gestartet: %3 in %4)'"),
			Performer.ComputerName,
			Performer.SessionNumber,
			Format(Performer.SessionStarted, "DLF=D"),
			Format(Performer.SessionStarted, "DLF=T"));
		Raise ErrorText;
		
	ElsIf TypeOf(Performer) = Type("BackgroundJob") Then
		Performer.Cancel();
	EndIf;
	
	Filter = New Structure;
	Filter.Insert("State", BackgroundJobState.Active);
	Filter.Insert("MethodName", Metadata.ScheduledJobs.AccessUpdateAtRecordLevel.MethodName);
	MainJobs = BackgroundJobs.GetBackgroundJobs(Filter);
	
	For Each MainJob In MainJobs Do
		MainJob.Cancel();
	EndDo;
	
	Filter.MethodName = AccessUpdateInBackgroundMethodName();
	AdditionalJobs = BackgroundJobs.GetBackgroundJobs(Filter);
	
	For Each AdditionalJob In AdditionalJobs Do
		AdditionalJob.Cancel();
	EndDo;
	
EndProcedure

// AccessUpdateAtRecordLevel scheduled job handler.
Procedure AccessUpdateAtRecordLevel(UpdateAll = False) Export
	
	Common.OnStartExecuteScheduledJob(
		Metadata.ScheduledJobs.AccessUpdateAtRecordLevel);
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	CurrentSession = GetCurrentInfoBaseSession();
	
	If CurrentSession.ApplicationName <> "BackgroundJob" Then
		If UpdateAll Then
			BackgroundJobID = ArbitrarySessionID();
		Else
			ErrorText = NStr("ru = 'Обновление доступа может выполняться порциями только в фоновом задании.'; en = 'Access can be updated in batches only in a background job.'; pl = 'Aktualizacja dostępu może być wykonywana porcjami tylko w tle zadania.';es_ES = 'La actualización de acceso puede realizarse gradualmente solo en la tarea de fondo.';es_CO = 'La actualización de acceso puede realizarse gradualmente solo en la tarea de fondo.';tr = 'Erişim güncellemesi partiler halinde sadece arkaplan görevinde yapılabilir.';it = 'L''accesso può essere aggiornato per lotti solo in un processo in background.';de = 'Der Zugriff kann nur in Chargen im Hintergrundjob aktualisiert werden.'");
			Raise ErrorText;
		EndIf;
	Else
		BackgroundJobID = CurrentSession.GetBackgroundJob().UUID;
	EndIf;
	
	DataLock = New DataLock;
	DataLock.Add("Constant.LastAccessUpdate");
	
	BeginTransaction();
	Try
		DataLock.Lock();
		ConstantValue = Constants.LastAccessUpdate.Get();
		LastAccessUpdate = LastAccessUpdate(ConstantValue);
		
		Performer = AccessUpdateAssignee(LastAccessUpdate, BackgroundJobID);
		
		If Performer = Undefined Then
			LastAccessUpdate.RunDateAtServer = CurrentDateAtServer();
			LastAccessUpdate.SessionNumber          = CurrentSession.SessionNumber;
			LastAccessUpdate.SessionStarted         = CurrentSession.SessionStarted;
			LastAccessUpdate.ComputerName        = CurrentSession.ComputerName;
			LastAccessUpdate.BackgroundJobID = BackgroundJobID;
			
			Constants.LastAccessUpdate.Set(
				New ValueStorage(LastAccessUpdate));
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If Performer <> Undefined Then
		If Not UpdateAll Then
			Return;
		EndIf;
		
		If TypeOf(Performer) = Type("BackgroundJob")
		   AND Performer.UUID <> LastAccessUpdate.BackgroundJobID Then
			
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Не удалось начать обновление доступа, так как оно уже запущено %3 в %4'; en = 'Cannot start access update as it has already been started on %3 at %4'; pl = 'Nie udało się rozpocząć aktualizację dostępu, ponieważ ona działa już %3 w %4';es_ES = 'No se ha podido empezar la actualización de acceso porque ya está lanzado %3 en %4';es_CO = 'No se ha podido empezar la actualización de acceso porque ya está lanzado %3 en %4';tr = 'Erişim güncellemesi %3''de %4 başlatıldığı için güncelleme başlatılamadı';it = 'Non è possibile avviare l''aggiornamento accesso dato che è già stato avviato il %3 alle %4';de = 'Es war nicht möglich, mit der Aktualisierung des Zugriffs zu beginnen, da er bereits gestartet wurde %3 in %4'"),
				Format(Performer.Begin, "DLF=D"),
				Format(Performer.Begin, "DLF=T"));
		Else
			SessionProperties = ?(TypeOf(Performer) = Type("BackgroundJob"),
				LastAccessUpdate, Performer);
			
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Не удалось начать обновление доступа, так как оно уже выполняется
				           |(компьютер: %1, сеанс: %2, начат: %3 в %4)'; 
				           |en = 'Cannot start access update as it is already running
				           |(computer: %1, session: %2, started: %3 at %4)'; 
				           |pl = 'Nie udało się rozpocząć aktualizację dostępu, ponieważ ona już działa
				           |(komputer: %1, sesja: %2, rozpoczęto: %3 w %4)';
				           |es_ES = 'No se ha podido empezar la actualización de acceso porque se está actualizando
				           |(ordenador: %1, sesión: %2, empezado: %3 a %4)';
				           |es_CO = 'No se ha podido empezar la actualización de acceso porque se está actualizando
				           |(ordenador: %1, sesión: %2, empezado: %3 a %4)';
				           |tr = 'Erişim güncellemesi zaten yapıldığı için başlatılamadı 
				           | (bilgisayar: %1, oturum: %2, başlatma: %3''de %4)';
				           |it = 'Non è stato possibile iniziare l''aggiornamento dell''accesso poiché è già in corso
				           |(computer: %1, sessione: %2, cominciato:%3 alle %4)';
				           |de = 'Fehler beim Starten der Zugriffsaktualisierung, da diese bereits ausgeführt wird
				           |(Computer: %1, Sitzung: %2, gestartet: %3 in %4)'"),
				SessionProperties.ComputerName,
				SessionProperties.SessionNumber,
				Format(SessionProperties.SessionStarted, "DLF=D"),
				Format(SessionProperties.SessionStarted, "DLF=T"));
		EndIf;
		Raise ErrorText;
	EndIf;
	
	LastAccessUpdate.CompletionErrorText = "";
	LastAccessUpdate.BackgroundJobID =
		New UUID("00000000-0000-0000-0000-000000000000");
	
	Try
		If DataBaseConfigurationChangedDynamically() Then
			StandardSubsystemsServer.RequireRestartDueToApplicationVersionDynamicUpdate();
		EndIf;
		If LimitAccessAtRecordLevelUniversally() Then
			CheckUpdateActiveAccessRestrictionParameters(LastAccessUpdate);
			ExecuteAccessUpdate(LastAccessUpdate.CompletionErrorText, UpdateAll);
		Else
			SetAccessUpdate(False);
		EndIf;
	Except
		ErrorInformation = ErrorInfo();
		If UpdateAll Then
			AddCompletionErrorText(LastAccessUpdate.CompletionErrorText,
				DetailErrorDescription(ErrorInformation));
		Else
			RegisterAccessUpdateError(ErrorInformation,
				LastAccessUpdate.CompletionErrorText);
		EndIf;
	EndTry;
	
	LastAccessUpdate.EndDateAtServer = CurrentDateAtServer();
	
	LastAccessUpdate.LastRunSeconds =
		LastAccessUpdate.EndDateAtServer - LastAccessUpdate.RunDateAtServer;
	
	Constants.LastAccessUpdate.Set(New ValueStorage(LastAccessUpdate));
	
	If UpdateAll AND ValueIsFilled(LastAccessUpdate.CompletionErrorText) Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не удалось выполнить обновление доступа по причине:
			           |%1'; 
			           |en = 'Cannot update access due to:
			           |%1'; 
			           |pl = 'Nie można zaktualizować dostępu z powodu:
			           |%1';
			           |es_ES = 'No se ha podido actualizar el acceso a causa de:
			           |%1';
			           |es_CO = 'No se ha podido actualizar el acceso a causa de:
			           |%1';
			           |tr = 'Erişim güncellemesi 
			           |%1 nedeniyle yürütülemedi.';
			           |it = 'Non è possibile aggiornare l''accesso a causa di:
			           |%1';
			           |de = 'Konnte den Zugriff aus dem Grund nicht aktualisieren:
			           |%1'"),
			LastAccessUpdate.CompletionErrorText);
		Raise ErrorText;
	EndIf;
	
EndProcedure

// For the StartAccessUpdateAtRecordLevel function.
Function AccessUpdateScheduled()
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS DataAccessKeysUpdate
	|
	|UNION ALL
	|
	|SELECT TOP 1
	|	TRUE
	|FROM
	|	InformationRegister.UsersAccessKeysUpdate AS UsersAccessKeysUpdate";
	
	Return Not Query.Execute().IsEmpty();
	
EndFunction

// For the StartAccessUpdateAtRecordLevel function, the AccessUpdateAtRecordLevel and 
// CancelAccessUpdateAtRecordLevel procedures, and the AccessUpdateAtRecordLevel form.
// 
//
Function LastAccessUpdate(CurrentValue = Undefined) Export
	
	If CurrentValue = Undefined Then
		Query = New Query;
		Query.Text =
		"SELECT
		|	LastAccessUpdate.Value AS Value
		|FROM
		|	Constant.LastAccessUpdate AS LastAccessUpdate";
		
		Selection = Query.Execute().Select();
		CurrentValue = ?(Selection.Next(), Selection.Value, Undefined);
	EndIf;
	
	Properties = New Structure;
	Properties.Insert("RunDateAtServer",      '00010101');
	Properties.Insert("EndDateAtServer",   '00010101');
	Properties.Insert("LastRunSeconds", 0);
	Properties.Insert("CompletionErrorText",     "");
	Properties.Insert("SessionNumber",               0);
	Properties.Insert("SessionStarted",              '00010101');
	Properties.Insert("ComputerName",             "");
	Properties.Insert("BackgroundJobID",
		New UUID("00000000-0000-0000-0000-000000000000"));
	
	If TypeOf(CurrentValue) <> Type("ValueStorage") Then
		Return Properties;
	EndIf;
	
	CurrentProperties = CurrentValue.Get();
	
	If TypeOf(CurrentProperties) <> Type("Structure") Then
		Return Properties;
	EndIf;
	
	FillPropertyValues(Properties, CurrentProperties);
	
	Return Properties;
	
EndFunction

// For the StartAccessUpdateAtRecordLevel function, the AccessUpdateAtRecordLevel and 
// CancelAccessUpdateAtRecordLevel procedures, and the AccessUpdateAtRecordLevel form.
// 
//
Function AccessUpdateAssignee(LastAccessUpdate, IDOfJobToExclude = Undefined) Export
	
	If ValueIsFilled(LastAccessUpdate.BackgroundJobID) Then
		If LastAccessUpdate.BackgroundJobID = ArbitrarySessionID() Then
			Sessions = GetInfoBaseSessions();
			For Each Session In Sessions Do
				If Session.SessionNumber  = LastAccessUpdate.SessionNumber
				   AND Session.SessionStarted = LastAccessUpdate.SessionStarted Then
					Return Session;
				EndIf;
			EndDo;
		Else
			ActiveBackgroundJob = BackgroundJobs.FindByUUID(
				LastAccessUpdate.BackgroundJobID);
		
			If ActiveBackgroundJob <> Undefined
			  AND ActiveBackgroundJob.State = BackgroundJobState.Active Then
				Return ActiveBackgroundJob;
			EndIf;
		EndIf;
	EndIf;
	
	Filter = New Structure("State, MethodName", BackgroundJobState.Active,
		Metadata.ScheduledJobs.AccessUpdateAtRecordLevel.MethodName);
	
	FoundJobs = BackgroundJobs.GetBackgroundJobs(Filter);
	For Each FoundJob In FoundJobs Do
		If FoundJob.UUID <> IDOfJobToExclude Then
			Return FoundJob;
		EndIf;
	EndDo;
	
	Return Undefined;
	
EndFunction

// For the AccessUpdateAtRecordLevel and AccessUpdateAssignee procedures.
Function ArbitrarySessionID()
	
	Return New UUID("ba4730f7-0493-402d-b5d3-8052c80fb125");
	
EndFunction

// For the AccessUpdateAtRecordLevel procedure.
Procedure CheckUpdateActiveAccessRestrictionParameters(LastAccessUpdate)
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	ExtensionsVersionUpdateDate = Catalogs.ExtensionsVersions.LastExtensionsVersion().UpdateDate;
	
	AllApplicationParametersUpdateDate =
		InformationRegisters.ApplicationParameters.AllApplicationParametersUpdateDate();
	
	LastFillingDateOfAllExtensionsParameters =
		InformationRegisters.ExtensionVersionParameters.LastFillingDateOfAllExtensionsParameters();
	
	ActiveAccessRestrictionParameters(Undefined, Undefined);
	AccessRestrictionParametersCreationDate = SessionParameters.AccessRestrictionParameters.CreationDate;
	
	ParameterName = "StandardSubsystems.AccessManagement.AccessRestrictionParametersCheckDate";
	AccessRestrictionParametersCheckDate = StandardSubsystemsServer.ExtensionParameter(ParameterName, True);
	If TypeOf(AccessRestrictionParametersCheckDate) <> Type("Date") Then
		AccessRestrictionParametersCheckDate = '00010101';
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	If AccessRestrictionParametersCheckDate > AccessRestrictionParametersCreationDate Then
		AccessRestrictionParametersRelevanceDate = AccessRestrictionParametersCheckDate;
	Else
		AccessRestrictionParametersRelevanceDate = AccessRestrictionParametersCreationDate;
	EndIf;
	
	If ExtensionsVersionUpdateDate                         > AccessRestrictionParametersRelevanceDate
	 Or AllApplicationParametersUpdateDate            > AccessRestrictionParametersRelevanceDate
	 Or LastFillingDateOfAllExtensionsParameters > AccessRestrictionParametersRelevanceDate Then
		
		ActiveAccessRestrictionParameters(Undefined, Undefined, False, True);
	EndIf;
	
EndProcedure

// Updates access keys to data based on information register records
// DataAccessKeysUpdate and user access keys based on records of the UsersAccessKeysUpdate 
// information register.
//
// Data batch for each table is updated starting from the most recent data.
// The procedure must be called again until the data processor is completed, while the scheduled job 
// is stopped.
//
// The procedure is designed to function in a single copy without parallel operation (call from the 
// AccessUpdateAtRecordLevel scheduled job procedure).
// Parallel operation is ensured by the procedure itself by running up to two background jobs for 
// each list, but not more than the AccessUpdateThreadsCount constant value.
//
Procedure ExecuteAccessUpdate(CompletionErrorText, UpdateAll)
	
	AccessGroupsSetsCatalogID =
		Common.MetadataObjectID("Catalog.AccessGroupsSets");
	
	ActiveBackgroundJobs = Undefined;
	If Not Common.FileInfobase() Then
		ThreadsCount = Constants.AccessUpdateThreadsCount.Get();
		If ThreadsCount < 1 Then
			ThreadsCount = 1;
		EndIf;
		If ThreadsCount > 1 Then
			ActiveBackgroundJobs = New Structure;
			ActiveBackgroundJobs.Insert("Content", New Array);
			For Counter = 1 To ThreadsCount Do
				JobDetails = New Structure("IsDataAccessKeysUpdate, Job,
				|ListID, ForExternalUsers, ResultAddress,
				|StartBatchUpdate, AccessGroupsSetsCatalogID");
				JobDetails.AccessGroupsSetsCatalogID
					= AccessGroupsSetsCatalogID;
				ActiveBackgroundJobs.Content.Add(JobDetails);
			EndDo;
			ActiveBackgroundJobs.Insert("HasStartedJobsForPass", False);
			ActiveBackgroundJobs.Insert("CompletionErrorText", "");
			ActiveBackgroundJobs.Insert("AdditionalFreeJobsCount", 0);
			ActiveBackgroundJobs.Insert("AdditionalJobsCountForMain", 0);
			ActiveBackgroundJobs.Insert("ByBatches", New Array);
			ActiveBackgroundJobs.Insert("BatchIndex", 0);
			ActiveBackgroundJobs.Insert("FreeJobsCount",
				ActiveBackgroundJobs.Content.Count());
		EndIf;
	EndIf;
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	Lists.List AS List,
	|	Lists.ForExternalUsers AS ForExternalUsers,
	|	MAX(Lists.LatestUpdatedItemDate) AS LastDate,
	|	MAX(Lists.RegisterRecordChangeDate) AS ChangeDate
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS Lists
	|
	|GROUP BY
	|	Lists.List,
	|	Lists.ForExternalUsers
	|
	|ORDER BY
	|	MAX(Lists.LatestUpdatedItemDate) DESC
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	Lists.List AS List,
	|	Lists.ForExternalUsers AS ForExternalUsers,
	|	MIN(Lists.RegisterRecordChangeDate) AS ChangeDate
	|FROM
	|	InformationRegister.UsersAccessKeysUpdate AS Lists
	|
	|GROUP BY
	|	Lists.List,
	|	Lists.ForExternalUsers
	|
	|ORDER BY
	|	MAX(Lists.RegisterRecordChangeDate) DESC";
	
	ExecutionEnd = CurrentUniversalDate()
		+ MaxCountOfMinutesToPerformBackgroundAccessUpdateJob() * 60;
	
	While True Do
		If Not UpdateAll AND CurrentUniversalDate() > ExecutionEnd Then
			Break;
		EndIf;
		ProcessingCompleted = True;
		
		QueryResults = Query.ExecuteBatch();
		If QueryResults[0].IsEmpty()
		   AND QueryResults[1].IsEmpty() Then
			
			DataLockWaitingError = False;
			Try
				DisableScheduledJobIfNoNewJobs(True, DataLockWaitingError);
			Except
				If Not DataLockWaitingError Then
					Raise;
				EndIf;
			EndTry;
			Break;
		EndIf;
		
		MaxDate = MaxDate();
		CommonUpdateParameters = New Structure("IsDataAccessKeysUpdate,
		|ListID, ForExternalUsers, StartDate, EndDate,
		|InitialUpdate, StartBatchUpdate, AccessGroupsSetsCatalogID");
		CommonUpdateParameters.AccessGroupsSetsCatalogID
			= AccessGroupsSetsCatalogID;
		
		FirstIndex = 0;
		DataAccessKeysUpdate = AccessKeysToDataUpdateTable(QueryResults[0],
			MaxDate, CommonUpdateParameters, ActiveBackgroundJobs = Undefined);
		
		Filter = New Structure("LastDate", MaxDate);
		InitialUpdate = DataAccessKeysUpdate.FindRows(Filter).Count() <> 0;
		
		SecondIndex = 0;
		UsersAccessKeysUpdate = QueryResults[1].Unload();
		
		If ActiveBackgroundJobs <> Undefined Then
			ActiveBackgroundJobs.HasStartedJobsForPass = False;
			FillAdditionalJobsCount(ActiveBackgroundJobs,
				DataAccessKeysUpdate, UsersAccessKeysUpdate);
		EndIf;
		
		While True Do
			If CurrentUniversalDate() > ExecutionEnd
			 Or FirstIndex >= DataAccessKeysUpdate.Count()
			   AND SecondIndex >= UsersAccessKeysUpdate.Count() Then
				Break;
			EndIf;
			If FirstIndex < DataAccessKeysUpdate.Count() Then
				Row = DataAccessKeysUpdate[FirstIndex];
				FirstIndex = FirstIndex + 1;
				If InitialUpdate AND Row.LastDate <> MaxDate Then
					Continue;
				EndIf;
				CommonUpdateParameters.IsDataAccessKeysUpdate = True;
				CommonUpdateParameters.ListID     = Row.List;
				CommonUpdateParameters.ForExternalUsers = Row.ForExternalUsers;
				CommonUpdateParameters.InitialUpdate     = InitialUpdate;
				StartListAccessUpdate(ActiveBackgroundJobs, CommonUpdateParameters, ProcessingCompleted);
			EndIf;
			If SecondIndex < UsersAccessKeysUpdate.Count() Then
				Row = UsersAccessKeysUpdate[SecondIndex];
				SecondIndex = SecondIndex + 1;
				CommonUpdateParameters.IsDataAccessKeysUpdate = False;
				CommonUpdateParameters.ListID     = Row.List;
				CommonUpdateParameters.ForExternalUsers = Row.ForExternalUsers;
				CommonUpdateParameters.InitialUpdate     = InitialUpdate;
				StartListAccessUpdate(ActiveBackgroundJobs, CommonUpdateParameters, ProcessingCompleted);
			EndIf;
		EndDo;
		
		If ActiveBackgroundJobs <> Undefined Then
			StartUpdateOfListAccessItemsBatches(ActiveBackgroundJobs, ProcessingCompleted);
			If ActiveBackgroundJobs.HasStartedJobsForPass Then
				Continue;
			EndIf;
		EndIf;
		
		If Not ProcessingCompleted
		 Or DataAccessKeysUpdate.Count() > 0
		 Or UsersAccessKeysUpdate.Count() > 0
		 Or ActiveBackgroundJobs <> Undefined
		   AND ActiveBackgroundJobs.ByBatches.Count() > 0 Then
			
			If ActiveBackgroundJobs <> Undefined Then
				WaitBackgroundJobCompletion(ActiveBackgroundJobs, ProcessingCompleted);
				If ValueIsFilled(ActiveBackgroundJobs.CompletionErrorText) Then
					Break;
				EndIf;
			EndIf;
			Continue;
		EndIf;
		
		CompleteAccessUpdate(ActiveBackgroundJobs, ProcessingCompleted);
		If ActiveBackgroundJobs <> Undefined
		   AND ValueIsFilled(ActiveBackgroundJobs.CompletionErrorText) Then
			Break;
		EndIf;
		If ProcessingCompleted Then
			Break;
		EndIf;
	EndDo;
	
	CompleteAccessUpdate(ActiveBackgroundJobs, ProcessingCompleted);
	
	If ActiveBackgroundJobs <> Undefined Then
		CompletionErrorText = ActiveBackgroundJobs.CompletionErrorText;
	EndIf;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Procedure FillAdditionalJobsCount(ActiveBackgroundJobs,
				DataAccessKeysUpdate, UsersAccessKeysUpdate)
	
	MainJobsCount = DataAccessKeysUpdate.Count()
		+ UsersAccessKeysUpdate.Count();
	
	AdditionalJobsCount = ActiveBackgroundJobs.Content.Count() - MainJobsCount;
	AdditionalJobsCount = ?(AdditionalJobsCount < 0, 0, AdditionalJobsCount);
	ActiveBackgroundJobs.AdditionalFreeJobsCount = AdditionalJobsCount;
	
	If MainJobsCount = 0 Then
		ActiveBackgroundJobs.AdditionalJobsCountForMain = 0;
	Else
		CountForMain = Int(AdditionalJobsCount / MainJobsCount);
		ActiveBackgroundJobs.AdditionalJobsCountForMain = ?(CountForMain > 0,
			CountForMain, ?(AdditionalJobsCount > 0, 1, 0));
	EndIf;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Procedure StartUpdateOfListAccessItemsBatches(ActiveBackgroundJobs, ProcessingCompleted)
	
	HasBatchesToRun = True;
	
	FreeReserveJobsCount = 0;
	For Each JobsDetails In ActiveBackgroundJobs.ByBatches Do
		If JobsDetails.BatchesSet.Count() < 3 Then
			FreeReserveJobsCount = FreeReserveJobsCount + 1;
		EndIf;
	EndDo;
	
	While HasBatchesToRun
	   AND ActiveBackgroundJobs.FreeJobsCount > FreeReserveJobsCount Do
		
		HasBatchesToRun = False;
		If ActiveBackgroundJobs.BatchIndex > ActiveBackgroundJobs.ByBatches.Count() - 1 Then
			 ActiveBackgroundJobs.BatchIndex = 0;
		EndIf;
		If ActiveBackgroundJobs.ByBatches.Count() = 0 Then
			Break;
		EndIf;
		JobsDetails = ActiveBackgroundJobs.ByBatches[ActiveBackgroundJobs.BatchIndex];
		ActiveBackgroundJobs.BatchIndex = ActiveBackgroundJobs.BatchIndex + 1;
		
		If JobsDetails.BatchesSet.Count() = 0 Then
			Continue;
		EndIf;
		JobRun = New Structure("BatchFromSet, Result", JobsDetails.BatchesSet[0]);
		CommonUpdateParameters = New Structure(JobsDetails.CommonUpdateParameters);
		CommonUpdateParameters.Insert("InitialUpdate",    False);
		CommonUpdateParameters.Insert("StartBatchUpdate", JobRun);
		If CommonUpdateParameters.IsDataAccessKeysUpdate Then
			If JobRun.BatchFromSet.DataItems = Undefined Then
				JobRun.Result = New Structure("NewLastUpdatedItem");
				If JobRun.BatchFromSet.Property("LastPortionItem") Then
					JobRun.Result.NewLastUpdatedItem = JobRun.BatchFromSet.LastPortionItem;
				EndIf;
			EndIf;
		Else
			If JobRun.BatchFromSet.AccessKeys = Undefined Then
				JobRun.Result = New Structure("NewLastUpdatedAccessKey");
				If JobRun.BatchFromSet.Property("LastAccessKeyInPortion") Then
					JobRun.Result.NewLastUpdatedAccessKey = JobRun.BatchFromSet.LastAccessKeyInPortion;
				EndIf;
			EndIf;
		EndIf;
		If JobRun.Result = Undefined Then
			If Not ListAccessUpdateStartedInBackground(ActiveBackgroundJobs, CommonUpdateParameters, False) Then
				Break;
			EndIf;
		EndIf;
		JobsDetails.JobRuns.Add(JobRun);
		JobsDetails.BatchesSet.Delete(0);
		If JobsDetails.BatchesSet.Count() > 0 Then
			HasBatchesToRun = True;
		EndIf;
	EndDo;
	
	For Each JobDetails In ActiveBackgroundJobs.Content Do
		ProcessCompletedBackgroundJob(JobDetails, ProcessingCompleted, ActiveBackgroundJobs);
	EndDo;
	CheckCompleteUpdateByBatches(ActiveBackgroundJobs);
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Procedure CompleteAccessUpdate(ActiveBackgroundJobs, ProcessingCompleted)
	
	If ActiveBackgroundJobs <> Undefined Then
		CompleteBackgroundJobs(ActiveBackgroundJobs, ProcessingCompleted);
		CheckCompleteUpdateByBatches(ActiveBackgroundJobs);
	EndIf;
	
	If ProcessingCompleted Then
		UpdateRightsToAllowedAccessKey();
		
		DataLockWaitingError = False;
		Try
			DisableScheduledJobIfNoNewJobs(ProcessingCompleted, DataLockWaitingError);
		Except
			If Not DataLockWaitingError Then
				Raise;
			EndIf;
		EndTry;
	EndIf;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Function AccessKeysToDataUpdateTable(QueryResult, MaxDate, CommonUpdateParameters, UpdateInThisSession)
	
	DataExported = QueryResult.Unload();
	If DataExported.Count() = 0 Then
		Return DataExported;
	EndIf;
	
	DataExported.Columns.Add("DependencyLevel", New TypeDescription("Number"));
	
	LastDate = DataExported[0].LastDate;
	MaxDate = MaxDate();
	
	If UpdateInThisSession Then
		ListsIDs = New Array;
		If CommonUpdateParameters.Property("Cache") Then
			Cache = CommonUpdateParameters.Cache;
		Else
			Cache = New Structure;
			CommonUpdateParameters.Insert("Cache", Cache);
		EndIf;
		If Not Cache.Property("MetadataObjectsByIDs") Then
			Cache.Insert("MetadataObjectsByIDs", New Map);
		EndIf;
	EndIf;
	
	ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined);
	For Each Row In DataExported Do
		If Not ValueIsFilled(Row.LastDate) Then
			Row.LastDate = MaxDate - 1;
		EndIf;
		If UpdateInThisSession
		   AND Cache.MetadataObjectsByIDs.Get(Row.List) = Undefined Then
			
			ListsIDs.Add(Row.List);
		EndIf;
		DependencyLevels = ActiveParameters.DependencyLevels.Get(Row.List);
		If DependencyLevels = Undefined Then
			Continue;
		EndIf;
		Row.DependencyLevel = ?(Row.ForExternalUsers,
			DependencyLevels.ForExternalUsers, DependencyLevels.ForUsers);
	EndDo;
	DataExported.Sort("DependencyLevel Asc, LastDate Desc, ChangeDate Desc");
	
	If UpdateInThisSession AND ListsIDs.Count() > 0 Then
		MetadataObjectsByIDs =
			Catalogs.MetadataObjectIDs.MetadataObjectsByIDs(ListsIDs, True);
		For Each KeyAndValue In MetadataObjectsByIDs Do
			Cache.MetadataObjectsByIDs.Insert(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	EndIf;
	
	If LastDate = MaxDate Then
		// Update start.
		CommonUpdateParameters.StartDate = BegOfDay(CurrentSessionDate()) - 7 * (60 * 60 * 24); // 7 Days.
	Else
		// Continue update.
		ThisYear = Year(CurrentSessionDate()) - Year(LastDate) = 0;
		MonthOffset = Month(CurrentSessionDate()) - Month(LastDate);
		
		If ThisYear AND MonthOffset = 0 Then
			StartDate = BegOfMonth(LastDate);
			
		ElsIf ThisYear AND MonthOffset < 3 Then 
			StartDate = BegOfQuarter(LastDate);
		Else
			StartDate = BegOfYear(LastDate);
		EndIf;
		
		CommonUpdateParameters.StartDate = StartDate;
	EndIf;
	CommonUpdateParameters.EndDate = LastDate;
	
	Index = DataExported.Count() - 1;
	While Index >= 0 Do
		If CommonUpdateParameters.StartDate > DataExported[Index].LastDate Then
			DataExported.Delete(Index);
		EndIf;
		Index = Index - 1;
	EndDo;
	
	Return DataExported;
	
EndFunction

// For the ExecuteAccessUpdate procedure.
Procedure DisableScheduledJobIfNoNewJobs(ProcessingCompleted, DataLockWaitingError)
	
	Query = New Query;
	Query.SetParameter("UnavailableListsForDataAccessKeyUpdate",       New Array);
	Query.SetParameter("UnavailableListsForUserAccessKeyUpdate", New Array);
	Query.Text =
	"SELECT DISTINCT
	|	DataAccessKeysUpdate.List AS List
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS DataAccessKeysUpdate
	|WHERE
	|	NOT DataAccessKeysUpdate.List IN (&UnavailableListsForDataAccessKeyUpdate)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	UsersAccessKeysUpdate.List AS List
	|FROM
	|	InformationRegister.UsersAccessKeysUpdate AS UsersAccessKeysUpdate
	|WHERE
	|	NOT UsersAccessKeysUpdate.List IN (&UnavailableListsForUserAccessKeyUpdate)";
	QueryResults = Query.ExecuteBatch();
	
	If Not QueryResults[0].IsEmpty() Then
		SetUnavailableLists(QueryResults[0],
			Query.Parameters.UnavailableListsForDataAccessKeyUpdate);
	EndIf;
	
	If Not QueryResults[1].IsEmpty() Then
		SetUnavailableLists(QueryResults[1],
			Query.Parameters.UnavailableListsForDataAccessKeyUpdate);
	EndIf;
	
	If Query.Parameters.UnavailableListsForDataAccessKeyUpdate.Count() > 0
	 Or Query.Parameters.UnavailableListsForUserAccessKeyUpdate.Count() > 0 Then
		
		QueryResults = Query.ExecuteBatch();
	EndIf;
	
	If QueryResults[0].IsEmpty()
	   AND QueryResults[1].IsEmpty() Then
		
		Lock = New DataLock;
		Lock.Add("InformationRegister.DataAccessKeysUpdate");
		Lock.Add("InformationRegister.UsersAccessKeysUpdate");
		BeginTransaction();
		Try
			DataLockWaitingError = True;
			Lock.Lock();
			DataLockWaitingError = False;
			
			QueryResults = Query.ExecuteBatch();
			
			If QueryResults[0].IsEmpty()
			   AND QueryResults[1].IsEmpty() Then
				
				SetAccessUpdate(False);
			Else
				ProcessingCompleted = False;
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			ProcessingCompleted = False;
			Raise;
		EndTry;
	Else
		ProcessingCompleted = False;
	EndIf;
	
EndProcedure

// For the DisableScheduledJobIfNoNewJobs procedure.
Procedure SetUnavailableLists(QueryResult, UnavailableLists)
	
	MetadataObjectsByIDs =
		Catalogs.MetadataObjectIDs.MetadataObjectsByIDs(
			QueryResult.Unload().UnloadColumn("List"), True);
	
	For Each KeyAndValue In MetadataObjectsByIDs Do
		If KeyAndValue.Value = Undefined Then
			UnavailableLists.Add(KeyAndValue.Key);
		EndIf;
	EndDo;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Procedure StartListAccessUpdate(ActiveBackgroundJobs, CommonUpdateParameters, ProcessingCompleted)
	
	If ActiveBackgroundJobs = Undefined Then
		ExecuteUpdateListAccess(CommonUpdateParameters, ProcessingCompleted);
	Else
		While Not ListAccessUpdateStartedInBackground(ActiveBackgroundJobs,
					CommonUpdateParameters, ProcessingCompleted) Do
			
			WaitBackgroundJobCompletion(ActiveBackgroundJobs, ProcessingCompleted);
		EndDo;
	EndIf;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Function ListAccessUpdateStartedInBackground(ActiveBackgroundJobs, CommonUpdateParameters, ProcessingCompleted)
	
	AlreadyStarted = False;
	For Each JobDetails In ActiveBackgroundJobs.Content Do
		ProcessCompletedBackgroundJob(JobDetails, ProcessingCompleted, ActiveBackgroundJobs);
		If JobDetails.Job = Undefined
		 Or JobDetails.StartBatchUpdate <> Undefined
		 Or CommonUpdateParameters.StartBatchUpdate <> Undefined Then
			Continue;
		EndIf;
		If JobDetails.IsDataAccessKeysUpdate = CommonUpdateParameters.IsDataAccessKeysUpdate
		   AND JobDetails.ForExternalUsers           = CommonUpdateParameters.ForExternalUsers
		   AND JobDetails.ListID               = CommonUpdateParameters.ListID Then
			// Has not ended since the last pass.
			AlreadyStarted = True;
		EndIf;
	EndDo;
	
	If AlreadyStarted Then
		Return True;
	EndIf;
	
	If ValueIsFilled(ActiveBackgroundJobs.CompletionErrorText) Then
		Return True;
	EndIf;
	
	For Each JobDetails In ActiveBackgroundJobs.Content Do
		If JobDetails.Job <> Undefined Then
			Continue;
		EndIf;
		
		FillPropertyValues(JobDetails, CommonUpdateParameters);
		
		If Not CheckPrepareBatchUpdateRun(JobDetails,
					CommonUpdateParameters, ActiveBackgroundJobs) Then
			Return True;
		EndIf;
		
		If ValueIsFilled(JobDetails.ResultAddress) Then
			PutToTempStorage(Undefined, JobDetails.ResultAddress);
		Else
			JobDetails.ResultAddress = PutToTempStorage(Undefined);
		EndIf;
		JobParameters = New Array;
		JobParameters.Add(CommonUpdateParameters);
		JobParameters.Add(JobDetails.ResultAddress);
		JobDetails.Job = BackgroundJobs.Execute(AccessUpdateInBackgroundMethodName(), JobParameters);
		
		ActiveBackgroundJobs.FreeJobsCount = ActiveBackgroundJobs.FreeJobsCount - 1;
		ActiveBackgroundJobs.HasStartedJobsForPass = True;
		Return True;
	EndDo;
	
	Return False;
	
EndFunction

// For the ListAccessUpdateStartedInBackground function.
Function CheckPrepareBatchUpdateRun(JobDetails, CommonUpdateParameters, ActiveBackgroundJobs)
	
	If CommonUpdateParameters.StartBatchUpdate <> Undefined Then
		CommonUpdateParameters.Delete("StartBatchUpdate");
		CommonUpdateParameters.Insert("BatchFromSet",
			JobDetails.StartBatchUpdate.BatchFromSet);
		Return True;
	EndIf;
	JobDetails.StartBatchUpdate = Undefined;
	
	JobsDetails = BatchUpdateJobsDetails(ActiveBackgroundJobs, CommonUpdateParameters);
	
	If Not CommonUpdateParameters.InitialUpdate
	   AND ActiveBackgroundJobs.AdditionalFreeJobsCount > 0
	   AND (JobsDetails = Undefined Or JobsDetails.BatchesSet.Count() < 4) Then
		
		AdditionalJobsCount = ActiveBackgroundJobs.AdditionalJobsCountForMain;
		If ActiveBackgroundJobs.AdditionalFreeJobsCount < AdditionalJobsCount Then
			AdditionalJobsCount = ActiveBackgroundJobs.AdditionalFreeJobsCount;
		EndIf;
		
		CommonUpdateParameters.Insert("GetPortions", (AdditionalJobsCount + 2) * 2);
		ActiveBackgroundJobs.AdditionalFreeJobsCount =
			ActiveBackgroundJobs.AdditionalFreeJobsCount - AdditionalJobsCount;
		
		If JobsDetails <> Undefined Then
			BatchesSet = JobsDetails.BatchesSet;
			
			LastBatch = Undefined;
			If BatchesSet.Count() > 0 Then
				LastBatch = BatchesSet[BatchesSet.Count() - 1];
			ElsIf JobsDetails.JobRuns.Count() > 0 Then
				LastBatch = JobsDetails.JobRuns[JobsDetails.JobRuns.Count() - 1].BatchFromSet;
			EndIf;
			If LastBatch <> Undefined Then
				If CommonUpdateParameters.IsDataAccessKeysUpdate Then
					If LastBatch.DataItems = Undefined
					 Or LastBatch.LastPortionItem = Undefined
					 Or CommonUpdateParameters.StartDate > LastBatch.LatestChunkItemDate Then
						Return False;
					EndIf;
					CommonUpdateParameters.Insert("LastPortionItem", LastBatch.LastPortionItem);
				Else
					If LastBatch.AccessKeys = Undefined
					 Or LastBatch.LastAccessKeyInPortion = Undefined Then
						Return False;
					EndIf;
					CommonUpdateParameters.Insert("LastAccessKeyInPortion", LastBatch.LastAccessKeyInPortion);
				EndIf;
			EndIf;
		EndIf;
		
		Return True;
	EndIf;
	
	Return JobsDetails = Undefined;
	
EndFunction

// For the StartedListAccessUpdateInBackground function and the AccessUpdateAtRecordLevel form.
Function AccessUpdateInBackgroundMethodName()
	
	Return "AccessManagementInternal.UpdateListAccessInBackground";
	
EndFunction

// For the ExecuteAccessUpdate and StartListAccessUpdate procedures.
Procedure WaitBackgroundJobCompletion(ActiveBackgroundJobs, ProcessingCompleted)
	
	For Each JobDetails In ActiveBackgroundJobs.Content Do
		If TypeOf(JobDetails.Job) <> Type("BackgroundJob") Then
			Continue;
		EndIf;
		UpdateBackgroundJobProperties(JobDetails, ActiveBackgroundJobs.CompletionErrorText, ProcessingCompleted);
		If JobDetails.Job.State <> BackgroundJobState.Active Then
			Continue;
		EndIf;
		Try
			JobDetails.Job.WaitForCompletion(0.2);
		Except
			// Waiting ended before completing the job.
		EndTry;
		Break;
	EndDo;
	
	For Each JobDetails In ActiveBackgroundJobs.Content Do
		ProcessCompletedBackgroundJob(JobDetails, ProcessingCompleted, ActiveBackgroundJobs);
	EndDo;
	CheckCompleteUpdateByBatches(ActiveBackgroundJobs);
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Procedure CompleteBackgroundJobs(ActiveBackgroundJobs, ProcessingCompleted)
	
	For Each JobDetails In ActiveBackgroundJobs.Content Do
		If TypeOf(JobDetails.Job) <> Type("BackgroundJob") Then
			Continue;
		EndIf;
		UpdateBackgroundJobProperties(JobDetails, ActiveBackgroundJobs.CompletionErrorText, ProcessingCompleted);
		If JobDetails.Job.State = BackgroundJobState.Active Then
			Try
				JobDetails.Job.WaitForCompletion();
			Except
				RegisterAccessUpdateError(ErrorInfo(),
					ActiveBackgroundJobs.CompletionErrorText, JobDetails);
				Continue;
			EndTry;
		EndIf;
		ProcessCompletedBackgroundJob(JobDetails, ProcessingCompleted, ActiveBackgroundJobs);
	EndDo;
	
EndProcedure

// For the ListAccessUpdateStartedInBackground function and the CompleteBackgroundJobs procedure.
Procedure ProcessCompletedBackgroundJob(JobDetails, ProcessingCompleted, ActiveBackgroundJobs, Cancel = False)
	
	If TypeOf(JobDetails.Job) <> Type("BackgroundJob") Then
		Return;
	EndIf;
	
	UpdateBackgroundJobProperties(JobDetails, ActiveBackgroundJobs.CompletionErrorText, ProcessingCompleted);
	Job = JobDetails.Job;
	
	If Job.State = BackgroundJobState.Active Then
		If Cancel Then
			ProcessingCompleted = False;
			Try
				Job.Cancel();
			Except
				ErrorInformation = ErrorInfo();
				RegisterAccessUpdateError(ErrorInformation,
					ActiveBackgroundJobs.CompletionErrorText, JobDetails);
			EndTry;
		Else
			Return;
		EndIf;
	EndIf;
	
	ActiveBackgroundJobs.FreeJobsCount = ActiveBackgroundJobs.FreeJobsCount + 1;
	JobDetails.Job = Undefined;
	
	If Job.State = BackgroundJobState.Completed AND Not Cancel Then
		Result = GetFromTempStorage(JobDetails.ResultAddress);
		
		If TypeOf(Result) <> Type("Structure") Then
			ProcessingCompleted = False;
		
		ElsIf ValueIsFilled(Result.CompletionErrorText) Then
			AddCompletionErrorText(ActiveBackgroundJobs.CompletionErrorText,
				Result.CompletionErrorText);
			
		ElsIf Result.Property("BatchesSet") Then
			AddUpdateByBatches(JobDetails,
				Result.BatchesSet, ActiveBackgroundJobs, ProcessingCompleted);
			
		ElsIf JobDetails.StartBatchUpdate <> Undefined Then
			JobDetails.StartBatchUpdate.Result = Result;
		EndIf;
	EndIf;
	
	JobDetails.StartBatchUpdate = Undefined;
	CheckCompleteUpdateByBatches(ActiveBackgroundJobs);
	
	If Job.State = BackgroundJobState.Completed Then
		Return;
	EndIf;
	
	ProcessingCompleted = False;
	
	If Job.State = BackgroundJobState.Failed Then
		RegisterAccessUpdateError(Job.ErrorInfo,
			ActiveBackgroundJobs.CompletionErrorText, JobDetails);
	EndIf;
	
EndProcedure

// For the ProcessCompletedBackgroundJob procedure.
Procedure AddUpdateByBatches(JobDetails, BatchesSet, ActiveBackgroundJobs, ProcessingCompleted)
	
	CommonUpdateParameters = New Structure("ListID, ForExternalUsers,
		|IsDataAccessKeysUpdate, AccessGroupsSetsCatalogID");
	FillPropertyValues(CommonUpdateParameters, JobDetails);
	
	JobsDetails = BatchUpdateJobsDetails(ActiveBackgroundJobs, CommonUpdateParameters);
	
	If BatchesSet = Undefined Then
		If JobsDetails = Undefined Then
			Return;
		EndIf;
		Index = ActiveBackgroundJobs.ByBatches.Find(JobsDetails);
		ActiveBackgroundJobs.ByBatches.Delete(Index);
		For Each JobRun In JobsDetails.JobRuns Do
			For Each JobDetails In ActiveBackgroundJobs.Content Do
				If JobDetails.StartBatchUpdate = JobRun Then
					ProcessCompletedBackgroundJob(JobDetails,
						ProcessingCompleted, ActiveBackgroundJobs, True);
				EndIf;
			EndDo;
		EndDo;
		Return;
	EndIf;
	
	If JobsDetails = Undefined Then
		JobsDetails = New Structure;
		JobsDetails.Insert("CommonUpdateParameters", New FixedStructure(CommonUpdateParameters));
		JobsDetails.Insert("JobRuns", New Array);
		JobsDetails.Insert("BatchesSet", BatchesSet);
		ActiveBackgroundJobs.ByBatches.Add(JobsDetails);
	Else
		For Each BatchFromSet In BatchesSet Do
			JobsDetails.BatchesSet.Add(BatchFromSet);
		EndDo;
	EndIf;
	
EndProcedure

Function BatchUpdateJobsDetails(ActiveBackgroundJobs, CommonUpdateParameters)
	
	For Each JobsDetails In ActiveBackgroundJobs.ByBatches Do
		CommonParameters = JobsDetails.CommonUpdateParameters;
		
		If CommonUpdateParameters.IsDataAccessKeysUpdate = CommonParameters.IsDataAccessKeysUpdate
		   AND CommonUpdateParameters.ForExternalUsers           = CommonParameters.ForExternalUsers
		   AND CommonUpdateParameters.ListID               = CommonParameters.ListID Then
			
			Return JobsDetails;
		EndIf;
	EndDo;
	
	Return Undefined;
	
EndFunction

// For the ProcessCompletedBackgroundJob procedure.
Procedure CheckCompleteUpdateByBatches(ActiveBackgroundJobs)
	
	Index = ActiveBackgroundJobs.ByBatches.Count();
	While Index > 0 Do
		Index = Index - 1;
		JobsDetails = ActiveBackgroundJobs.ByBatches[Index];
		
		CompletedJobRuns = New Array;
		For Each JobRun In JobsDetails.JobRuns Do
			If JobRun.Result = Undefined Then
				Break;
			EndIf;
			CompletedJobRuns.Add(JobRun);
			LastCompletedJobRun = JobRun;
		EndDo;
		If CompletedJobRuns.Count() > 0 Then
			If JobsDetails.CommonUpdateParameters.IsDataAccessKeysUpdate Then
				UpdateListDataAccessKeysCompletion(JobsDetails.CommonUpdateParameters,
					LastCompletedJobRun.Result.NewLastUpdatedItem);
			Else
				UpdateListUsersAccessKeysCompletion(JobsDetails.CommonUpdateParameters,
					LastCompletedJobRun.Result.NewLastUpdatedAccessKey);
			EndIf;
			For Counter = 1 To CompletedJobRuns.Count() Do
				JobsDetails.JobRuns.Delete(0);
			EndDo;
		EndIf;
		
		HasError = False;
		For Each JobRun In JobsDetails.JobRuns Do
			If JobRun.Result <> Undefined Then
				Continue;
			EndIf;
			BatchUpdateInProgress = False;
			For Each JobDetails In ActiveBackgroundJobs.Content Do
				If JobDetails.StartBatchUpdate = JobRun Then
					BatchUpdateInProgress = True;
					Break;
				EndIf;
			EndDo;
			If Not BatchUpdateInProgress Then
				HasError = True;
				Break;
			EndIf;
		EndDo;
		
		If HasError
		 Or JobsDetails.JobRuns.Count() = 0
		   AND JobsDetails.BatchesSet.Count() = 0 Then
			
			ActiveBackgroundJobs.ByBatches.Delete(Index);
		EndIf;
	EndDo;
	
EndProcedure

// For the CompleteBackgroundJobs and ProcessCompletedBackgroundJob procedures.
Procedure UpdateBackgroundJobProperties(JobDetails, CompletionErrorText, ProcessingCompleted)
	
	Job = BackgroundJobs.FindByUUID(
		JobDetails.Job.UUID);
	
	If Job = Undefined Then
		RegisterAccessUpdateError(
			NStr("ru = 'Не удалось найти запущенное фоновое задание.'; en = 'Cannot find the started background job.'; pl = 'Nie udało się znaleźć rozpoczętego zadania wykonywanego w tle.';es_ES = 'No se ha podido encontrar una tarea de fondo lanzada.';es_CO = 'No se ha podido encontrar una tarea de fondo lanzada.';tr = 'Başlatılan arkaplan görevi bulunamadı.';it = 'Non è stato possibile trovare il task in background avviato.';de = 'Es konnte kein laufender Hintergrundjob gefunden werden.'"),
			CompletionErrorText,
			JobDetails);
		
		ProcessingCompleted = False;
		Return;
	EndIf;
	JobDetails.Job = Job;
	
EndProcedure

// For the ListAccessUpdateStartedInBackground function.
Procedure UpdateListAccessInBackground(CommonUpdateParameters, ResultAddress) Export
	
	Result = New Structure;
	Result.Insert("ProcessingCompleted", True);
	Result.Insert("CompletionErrorText", "");
	
	Try
		ExecuteUpdateListAccess(CommonUpdateParameters, Result.ProcessingCompleted);
	Except
		RegisterAccessUpdateError(ErrorInfo(),
			Result.CompletionErrorText, CommonUpdateParameters);
		
		Result.ProcessingCompleted = False;
	EndTry;
	
	If CommonUpdateParameters.Property("BatchesSet") Then
		Result.Insert("BatchesSet", CommonUpdateParameters.BatchesSet);
	EndIf;
	If CommonUpdateParameters.Property("NewLastUpdatedItem") Then
		Result.Insert("NewLastUpdatedItem",
			CommonUpdateParameters.NewLastUpdatedItem);
	EndIf;
	If CommonUpdateParameters.Property("NewLastUpdatedAccessKey") Then
		Result.Insert("NewLastUpdatedAccessKey",
			CommonUpdateParameters.NewLastUpdatedAccessKey);
	EndIf;
	
	PutToTempStorage(Result, ResultAddress);
	
EndProcedure

// For procedures AccessUpdateAtRecordLevel, CompleteBackgroundJobs,
// ProcessCompletedBackgroundJob and ExecuteListAccessUpdateInBackground procedures.
//
Procedure RegisterAccessUpdateError(ErrorInformation, CompletionErrorText, JobDetails = Undefined)
	
	AddCompletionErrorText(CompletionErrorText, DetailErrorDescription(ErrorInformation));
	
	If JobDetails = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не удалось выполнить обновление доступа по причине:
			           |%1'; 
			           |en = 'Cannot update access due to:
			           |%1'; 
			           |pl = 'Nie można zaktualizować dostępu z powodu:
			           |%1';
			           |es_ES = 'No se ha podido actualizar el acceso a causa de:
			           |%1';
			           |es_CO = 'No se ha podido actualizar el acceso a causa de:
			           |%1';
			           |tr = 'Erişim güncellemesi 
			           |%1 nedeniyle yürütülemedi.';
			           |it = 'Non è possibile aggiornare l''accesso a causa di:
			           |%1';
			           |de = 'Konnte den Zugriff aus dem Grund nicht aktualisieren:
			           |%1'"),
			DetailErrorDescription(ErrorInformation));
			
	ElsIf JobDetails.IsDataAccessKeysUpdate Then
		
		If JobDetails.ForExternalUsers Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Не удалось обновить порцию ключей доступа к данным списка
				           |""%1"" (для внешних пользователей)
				           |по причине:
				           |%2'; 
				           |en = 'Cannot update keys of access to the
				           |""%1"" list data (for external users)
				           |due to: 
				           |%2'; 
				           |pl = 'Nie można zaktualizować kluczy dostępu do danych listy
				           |""%1"" (dla użytkowników zewnętrznych)
				           |z powodu: 
				           |%2';
				           |es_ES = 'No se ha podido actualizar unas claves de acceso a los datos de la lista
				           |""%1"" (para los usuarios externos)
				           |a causa de:
				           |%2';
				           |es_CO = 'No se ha podido actualizar unas claves de acceso a los datos de la lista
				           |""%1"" (para los usuarios externos)
				           |a causa de:
				           |%2';
				           |tr = '""%1"" listesinin verilerine (harici kullanıcılar için)
				           |erişim anahtarları güncellenemedi.
				           |Nedeni: 
				           |%2';
				           |it = 'Impossibile aggiornare le chiavi di accesso ai dati dell''elenco 
				           |""%1"" (per utenti esterni)
				           |a causa di: 
				           |%2';
				           |de = 'Ein Teil der Listendatenzugriffsschlüssel
				           |""%1"" (für externe Benutzer)
				           |konnte aus diesem Grund nicht aktualisiert werden:
				           |%2'"),
				String(JobDetails.ListID),
				DetailErrorDescription(ErrorInformation));
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Не удалось обновить порцию ключей доступа к данным списка
				           |""%1"" (для пользователей)
				           |по причине:
				           |%2'; 
				           |en = 'Cannot update keys of access to the
				           |""%1"" list data (for users)
				           |due to: 
				           |%2'; 
				           |pl = 'Nie można zaktualizować kluczy dostępu do danych listy
				           |""%1"" (dla użytkowników)
				           |z powodu: 
				           |%2';
				           |es_ES = 'No se ha podido actualizar unas claves de acceso a los datos de la lista
				           |""%1"" (para los usuarios)
				           |a causa de:
				           |%2';
				           |es_CO = 'No se ha podido actualizar unas claves de acceso a los datos de la lista
				           |""%1"" (para los usuarios)
				           |a causa de:
				           |%2';
				           |tr = '""%1"" listesinin verilerine (kullanıcılar için)
				           |erişim anahtarları güncellenemedi.
				           |Nedeni: 
				           |%2';
				           |it = 'Impossibile aggiornare le chiavi di accesso ai dati dell''elenco 
				           |""%1"" (per utenti)
				           |a causa di: 
				           |%2';
				           |de = 'Ein Teil der Listendatenzugriffsschlüssel
				           |""%1"" (für Benutzer)
				           |konnte aus diesem Grund nicht aktualisiert werden:
				           |%2'"),
				String(JobDetails.ListID),
				DetailErrorDescription(ErrorInformation));
		EndIf;
		
	Else // UsersAccessKeysUpdate.
		
		If JobDetails.ForExternalUsers Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Не удалось обновить порцию ключей доступа внешних пользователей
				           |для списка ""%1""
				           |по причине:
				           |%2'; 
				           |en = 'Cannot update access keys of external users
				           |for the ""%1"" list
				           |due to:
				           |%2'; 
				           |pl = 'Nie można zaktualizować kluczy dostępu użytkowników zewnętrznych
				           |dla ""%1"" listy
				           |do:
				           |%2';
				           |es_ES = 'No se ha podido actualizar las claves de acceso de usuarios externos
				           |para la lista ""%1""
				           |a causa de:
				           |%2';
				           |es_CO = 'No se ha podido actualizar las claves de acceso de usuarios externos
				           |para la lista ""%1""
				           |a causa de:
				           |%2';
				           |tr = '""%1"" listesi için
				           |harici kullanıcıların erişim anahtarları güncellenemedi.
				           |Nedeni: 
				           |%2';
				           |it = 'Impossibile aggiornare le chiavi di accesso per gli utenti esterni
				           |dell''elenco ""%1""
				           |a causa di:
				           |%2';
				           |de = 'Ein Teil der externen Benutzerzugriffsschlüssel
				           |für die Liste ""%1""
				           |konnte aus diesem Grund nicht aktualisiert werden:
				           |%2'"),
				String(JobDetails.ListID),
				DetailErrorDescription(ErrorInformation));
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Не удалось обновить порцию ключей доступа пользователей
				           |для списка ""%1""
				           |по причине:
				           |%2'; 
				           |en = 'Cannot update access keys of users
				           |for the ""%1"" list
				           |due to:
				           |%2'; 
				           |pl = 'Nie można zaktualizować kluczy dostępu użytkowników
				           |dla ""%1"" listy
				           |do:
				           |%2';
				           |es_ES = 'No se ha podido actualizar unas claves de acceso de usuarios
				           |para la lista ""%1""
				           |a causa de:
				           |%2';
				           |es_CO = 'No se ha podido actualizar unas claves de acceso de usuarios
				           |para la lista ""%1""
				           |a causa de:
				           |%2';
				           |tr = '""%1"" listesi için
				           |kullanıcıların erişim anahtarları güncellenemedi.
				           |Nedeni: 
				           |%2';
				           |it = 'Impossibile aggiornare le chiavi di accesso degli utenti
				           |ell''elenco ""%1""
				           |a causa di:
				           |%2';
				           |de = 'Ein Teil der Benutzerzugriffsschlüssel
				           |für die Liste ""%1""
				           |konnte aus diesem Grund nicht aktualisiert werden:
				           |%2'"),
				String(JobDetails.ListID),
				DetailErrorDescription(ErrorInformation));
		EndIf;
	EndIf;
	
	WriteLogEvent(
		NStr("ru = 'Управление доступом.Обновление доступа на уровне записей'; en = 'Access management.Access update at record level'; pl = 'Kontrola dostępu.Aktualizacja dostępu na poziomie zapisów';es_ES = 'Gestión de acceso.Actualización de acceso en nivel de registros';es_CO = 'Gestión de acceso.Actualización de acceso en nivel de registros';tr = 'Erişim kontrolü. Kayıt seviyesinde erişim güncelleme';it = 'Gestione accesso.Aggiornamento accesso a livello di registrazione';de = 'Zugangskontrolle. Aktualisieren des Zugriffs auf Aufzeichnungsebene'",
			CommonClientServer.DefaultLanguageCode()),
		EventLogLevel.Error, , , ErrorText);
	
EndProcedure

// For the RegisterAccessUpdateError and ProcessCompletedBackgroundJob procedures.
Procedure AddCompletionErrorText(CompletionErrorText, ErrorText)
	
	If ValueIsFilled(CompletionErrorText) Then
		If StrFind(CompletionErrorText, ErrorText) > 0 Then
			Return;
		EndIf;
		CompletionErrorText = CompletionErrorText + Chars.LF + Chars.LF;
	EndIf;
	
	CompletionErrorText = CompletionErrorText + ErrorText;
	
EndProcedure

// For the ListAccessUpdateStartedInBackground function.
Procedure ExecuteUpdateListAccess(CommonUpdateParameters, ProcessingCompleted)
	
	If CommonUpdateParameters.Property("Cache")
	   AND CommonUpdateParameters.Cache.Property("MetadataObjectsByIDs") Then
		
		MetadataObject = CommonUpdateParameters.Cache.MetadataObjectsByIDs.Get(
			CommonUpdateParameters.ListID);
	Else
		MetadataObject = Catalogs.MetadataObjectIDs.MetadataObjectByID(
			CommonUpdateParameters.ListID, True);
	EndIf;
	
	If MetadataObject = Undefined Then
		// If a configuration extension is disabled, the update is unavailable, but you cannot clear a 
		// registration to update.
		Return;
	EndIf;
	
	If Not CommonUpdateParameters.Property("GetPortions") Then
		CommonUpdateParameters.Insert("GetPortions", 0);
	EndIf;
	
	If CommonUpdateParameters.IsDataAccessKeysUpdate Then
		UpdateListDataAccessKeys(MetadataObject, CommonUpdateParameters, ProcessingCompleted);
	Else
		UpdateListUsersAccessKeys(MetadataObject, CommonUpdateParameters, ProcessingCompleted);
	EndIf;
	
EndProcedure

// For the ExecuteListAccessUpdate procedures.
Procedure UpdateListDataAccessKeys(MetadataObject, CommonUpdateParameters, ProcessingCompleted)
	
	If TypeOf(MetadataObject) <> Type("MetadataObject") Then
		// Clearing records of non-existent metadata objects.
		BlankSet = ServiceRecordSet(InformationRegisters.DataAccessKeysUpdate);
		BlankSet.Filter.List.Set(CommonUpdateParameters.ListID);
		BlankSet.Write();
		Return;
	EndIf;
	
	UpdateParameters = New Structure;
	UpdateParameters.Insert("List",                  MetadataObject.FullName());
	UpdateParameters.Insert("ListID",     CommonUpdateParameters.ListID);
	UpdateParameters.Insert("ForExternalUsers", CommonUpdateParameters.ForExternalUsers);
	
	If CommonUpdateParameters.Property("BatchFromSet") Then
		UpdateAccessKeysToListDataItems(UpdateParameters,
			CommonUpdateParameters.BatchFromSet.DataItems.Get());
		
		CommonUpdateParameters.Insert("NewLastUpdatedItem",
			UpdateParameters.NewLastUpdatedItem);
		Return;
	EndIf;
	
	UpdateParameters.Insert("StartDate",          CommonUpdateParameters.StartDate);
	UpdateParameters.Insert("EndDate",       CommonUpdateParameters.EndDate);
	UpdateParameters.Insert("InitialUpdate", CommonUpdateParameters.InitialUpdate);
	UpdateParameters.Insert("GetPortions",      CommonUpdateParameters.GetPortions);
	
	Query = New Query;
	Query.SetParameter("List",                  UpdateParameters.ListID);
	Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
	Query.Text =
	"SELECT TOP 1000
	|	UniqueKeys.UniqueKey AS UniqueKey,
	|	UniqueKeys.LatestUpdatedItemDate AS LatestUpdatedItemDate,
	|	UniqueKeys.LastUpdatedItem AS LastUpdatedItem
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS UniqueKeys
	|WHERE
	|	UniqueKeys.List = &List
	|	AND UniqueKeys.ForExternalUsers = &ForExternalUsers";
	DataExported = Query.Execute().Unload();
	
	If DataExported.Count() = 0 Then
		If UpdateParameters.GetPortions > 0
		   AND CommonUpdateParameters.Property("LastPortionItem") Then
			
			CommonUpdateParameters.Insert("BatchesSet", Undefined);
		EndIf;
		Return;
	EndIf;
	
	LastUpdatedItem = New Structure("Date, DataKey", MaxDate());
	
	If DataExported.Count() = 1
	   AND Not ValueIsFilled(DataExported[0].UniqueKey) Then
		
		SavedDate = DataExported[0].LatestUpdatedItemDate;
		If TypeOf(SavedDate) = Type("Date") Then
			LastUpdatedItem.Date = SavedDate;
		EndIf;
		LastUpdatedItem.DataKey = DataExported[0].LastUpdatedItem.Get();
	Else
		If UpdateParameters.GetPortions > 0
		   AND CommonUpdateParameters.Property("LastPortionItem") Then
			
			CommonUpdateParameters.Insert("BatchesSet", Undefined);
			ProcessingCompleted = False;
			Return;
		EndIf;
		
		KeysUpdateSchedule = ServiceRecordSet(InformationRegisters.DataAccessKeysUpdate);
		KeysUpdateSchedule.Filter.List.Set(UpdateParameters.ListID);
		KeysUpdateSchedule.Filter.ForExternalUsers.Set(UpdateParameters.ForExternalUsers);
		KeysUpdateSchedule.Filter.UniqueKey.Set(
			New UUID("00000000-0000-0000-0000-000000000000"));
		
		Lock = New DataLock;
		LockItem = Lock.Add("InformationRegister.DataAccessKeysUpdate");
		LockItem.SetValue("List", UpdateParameters.ListID);
		LockItem.SetValue("ForExternalUsers", UpdateParameters.ForExternalUsers);
		LockItem.SetValue("UniqueKey",
			New UUID("00000000-0000-0000-0000-000000000000"));
		
		For Each Row In DataExported Do
			If Not ValueIsFilled(Row.UniqueKey) Then
				Continue;
			EndIf;
			LockItem = Lock.Add("InformationRegister.DataAccessKeysUpdate");
			LockItem.SetValue("List", UpdateParameters.ListID);
			LockItem.SetValue("ForExternalUsers", UpdateParameters.ForExternalUsers);
			LockItem.SetValue("UniqueKey", Row.UniqueKey);
			Break;
		EndDo;
		
		Query.Text = StrReplace(Query.Text, "SELECT TOP 1000", "SELECT TOP 1");
		JobsDeleted = False;
		
		If UpdateParameters.List = "Catalog.AccessGroupsSets" Then
			LastUpdatedItem.DataKey = Catalogs.AccessGroupsSets.EmptyRef();
			For Each Row In DataExported Do
				DataKey = Row.LastUpdatedItem.Get();
				If DataKey = Undefined Then
					LastUpdatedItem.DataKey = Undefined;
					Break;
				EndIf;
			EndDo;
		EndIf;
		
		BeginTransaction();
		Try
			Lock.Lock();
			If Query.Execute().IsEmpty() Then
				JobsDeleted = True;
			Else
				Record = KeysUpdateSchedule.Add();
				Record.List                  = UpdateParameters.ListID;
				Record.ForExternalUsers = UpdateParameters.ForExternalUsers;
				Record.LatestUpdatedItemDate = LastUpdatedItem.Date;
				Record.LastUpdatedItem = New ValueStorage(LastUpdatedItem.DataKey);
				Record.RegisterRecordChangeDate = CurrentSessionDate();
				KeysUpdateSchedule.Write();
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If JobsDeleted Then
			If UpdateParameters.GetPortions > 0
			   AND CommonUpdateParameters.Property("LastPortionItem") Then
				
				CommonUpdateParameters.Insert("BatchesSet", Undefined);
			EndIf;
			Return;
		EndIf;
		
		KeysUpdateSchedule.Clear();
		For Each Row In DataExported Do
			If Not ValueIsFilled(Row.UniqueKey) Then
				Continue;
			EndIf;
			KeysUpdateSchedule.Filter.UniqueKey.Set(Row.UniqueKey);
			KeysUpdateSchedule.Write();
		EndDo;
		If DataExported.Count() = 1000 Then
			ProcessingCompleted = False;
		EndIf;
	EndIf;
	
	If UpdateParameters.GetPortions > 0
	   AND CommonUpdateParameters.Property("LastPortionItem") Then
		
		UpdateParameters.Insert("LastPortionItem");
		LastUpdatedItem = New Structure("Date, DataKey", MaxDate());
		FillPropertyValues(LastUpdatedItem,  CommonUpdateParameters.LastPortionItem);
	EndIf;
	
	If ValueIsFilled(LastUpdatedItem.Date)
	   AND CommonUpdateParameters.StartDate > LastUpdatedItem.Date Then
		
		ProcessingCompleted = False;
		Return;
	EndIf;
	
	UpdateParameters.Insert("LastUpdatedItem", LastUpdatedItem);
	UpdateParameters.Insert("NewLastUpdatedItem", Undefined);
	
	UpdateAccessKeysToListDataItems(UpdateParameters);
	
	If UpdateParameters.Property("BatchesSet") Then
		CommonUpdateParameters.Insert("BatchesSet", UpdateParameters.BatchesSet);
		ProcessingCompleted = False;
		Return;
	EndIf;
	
	UpdateListDataAccessKeysCompletion(CommonUpdateParameters,
		UpdateParameters.NewLastUpdatedItem, ProcessingCompleted);
	
EndProcedure

// For the UpdateListDataAccessKeys and CheckCompleteUpdateByBatches procedures.
Procedure UpdateListDataAccessKeysCompletion(CommonUpdateParameters, LastUpdatedItem, ProcessingCompleted = True)
	
	If LastUpdatedItem = Undefined
	   AND CommonUpdateParameters.ListID
	       = CommonUpdateParameters.AccessGroupsSetsCatalogID Then
		
		UpdateGroupsSetsNonuseDate(CommonUpdateParameters);
		DeleteObsoleteGroupSets(CommonUpdateParameters);
	EndIf;
	
	KeysUpdateSchedule = ServiceRecordSet(InformationRegisters.DataAccessKeysUpdate);
	KeysUpdateSchedule.Filter.List.Set(CommonUpdateParameters.ListID);
	KeysUpdateSchedule.Filter.ForExternalUsers.Set(CommonUpdateParameters.ForExternalUsers);
	KeysUpdateSchedule.Filter.UniqueKey.Set(
		New UUID("00000000-0000-0000-0000-000000000000"));
	
	Lock = New DataLock;
	LockItem = Lock.Add("InformationRegister.DataAccessKeysUpdate");
	LockItem.SetValue("List", CommonUpdateParameters.ListID);
	LockItem.SetValue("ForExternalUsers", CommonUpdateParameters.ForExternalUsers);
	LockItem.SetValue("UniqueKey", New UUID("00000000-0000-0000-0000-000000000000"));
	
	BeginTransaction();
	Try
		Lock.Lock();
		KeysUpdateSchedule.Read();
		If KeysUpdateSchedule.Count() > 0 Then
			If LastUpdatedItem = Undefined Then
				KeysUpdateSchedule.Clear();
			Else
				Record = KeysUpdateSchedule[0];
				Record.RegisterRecordChangeDate = CurrentSessionDate();
				If LastUpdatedItem.Property("Date") Then
					Record.LatestUpdatedItemDate = LastUpdatedItem.Date;
					Record.LastUpdatedItem = New ValueStorage(Undefined);
				Else
					Record.LatestUpdatedItemDate = '00010101';
					Record.LastUpdatedItem = New ValueStorage(LastUpdatedItem.DataKey);
				EndIf;
				ProcessingCompleted = False;
			EndIf;
			KeysUpdateSchedule.Write();
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure


// For the UpdateListDataAccessKeys procedure.
Procedure UpdateAccessKeysToListDataItems(UpdateParameters, DataItems = Undefined)
	
	If UpdateParameters.List = "Catalog.AccessGroupsSets" Then
		UpdateAccessGroupsSets(UpdateParameters, DataItems);
		Return;
	EndIf;
	
	TransactionID = New UUID;
	ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(UpdateParameters.List, TransactionID);
	RestrictionParameters = RestrictionParameters(UpdateParameters.List,
		TransactionID, UpdateParameters.ForExternalUsers);
	
	RestrictionParameters = New Structure(RestrictionParameters);
	For Each KeyAndValue In UpdateParameters Do
		RestrictionParameters.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	UpdateParameters = RestrictionParameters;
	UpdateParameters.Insert("TransactionID", TransactionID);
	
	UsersKindPropertyName = ?(UpdateParameters.ForExternalUsers,
		"ForExternalUsers", "ForUsers");
	
	If ListPropertiesAsLeadingOne = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName] = Undefined Then
		
		UpdateParameters.Insert("DependentListsByAccessKeys", New Array);
	Else
		UpdateParameters.Insert("DependentListsByAccessKeys",
			ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName]);
	EndIf;
	
	If DataItems = Undefined Then
		Query = New Query;
		SetDataKey = Undefined;
		SetLastUpdatedItemParameters(Query, UpdateParameters, SetDataKey);
		SetDataItemsQueryTextForProcessing(Query, UpdateParameters);
		
		BatchOfSetItems = 1000;
		BatchSize = DataItemsBatchSize();
		If UpdateParameters.InitialUpdate Then
			BatchSize = Int(BatchSize / 100);
			
		ElsIf UpdateParameters.GetPortions > 0
			    AND (    BatchSize < UpdateParameters.GetPortions * BatchOfSetItems
			       Or UpdateParameters.Property("LastPortionItem")) Then
			
			BatchSize = UpdateParameters.GetPortions * BatchOfSetItems;
		EndIf;
		BatchSize = ?(BatchSize < 25, 25, ?(BatchSize > 10000, 10000, BatchSize));
		Query.Text = StrReplace(Query.Text, BatchSizeMarker(), Format(BatchSize, "NG="));
		
		DataItems = Query.Execute().Unload();
		
		ResultBlank = False;
		If DataItems.Count() = 0 Then
			ResultBlank = True;
		EndIf;
		
		If ResultBlank Then
			FillLastItemOnComplete(UpdateParameters, Query);
			Return;
		EndIf;
		
		If UpdateParameters.GetPortions > 0
		   AND (    UpdateParameters.Property("LastPortionItem")
		      Or DataItems.Count() > BatchOfSetItems * 2) Then
			
			FillItemsBatches(UpdateParameters, DataItems, BatchOfSetItems, BatchSize);
			Return;
		EndIf;
	EndIf;
	
	If UpdateParameters.RestrictionDisabled
	 Or UpdateParameters.AccessDenied
	 Or UpdateParameters.UsesRestrictionByOwner Then
		
		If Not UpdateParameters.Property("DataItemForKeyClearingQueryText") Then
			UpdateListDataItemsWithObsoleteAllowedKey(DataItems, UpdateParameters);
			
		ElsIf ValueIsFilled(UpdateParameters.DataItemForKeyClearingQueryText) Then
			ClearAccessKeysOfListDataItems(DataItems, UpdateParameters);
		Else
			Return;
		EndIf;
	Else
		UpdateListDataItemsWithObsoleteKeys(DataItems, UpdateParameters);
	EndIf;
	
	If BatchSize <> Undefined AND DataItems.Count() < BatchSize Then
		If UpdateParameters.ListWithDate Then
			FillLastItemOnComplete(UpdateParameters, Query);
		EndIf;
		Return;
	EndIf;
	
	UpdateParameters.Insert("NewLastUpdatedItem",
		LastDataItem(DataItems, UpdateParameters));
	
EndProcedure

// For the UpdateAccessKeysToListDataItems procedure.
Function LastDataItem(DataItems, UpdateParameters, DataKey = Undefined)
	
	DataItem = New Structure;
	If UpdateParameters.ListWithDate Then
		DataItem.Insert("Date");
		
	ElsIf UpdateParameters.IsReferenceType Then
		DataItem.Insert("DataKey");
	Else
		DataItem.Insert("DataKey", DataKey(UpdateParameters));
	EndIf;
	
	LastDataItem = DataItems[DataItems.Count() - 1];
	
	If UpdateParameters.ListWithDate Then
		DataItem.Date = LastDataItem.Date;
		DataKey = DataItem.Date;
		
	ElsIf UpdateParameters.IsReferenceType Then
		DataItem.DataKey = LastDataItem.CurrentRef;
		DataKey = DataItem.DataKey;
	Else
		FillPropertyValues(DataItem.DataKey, LastDataItem);
		DataKey = DataItem.DataKey;
	EndIf;
	
	Return DataItem;
	
EndFunction

// For the UpdateAccessKeysToListDataItems procedure.
Procedure SetLastUpdatedItemParameters(Query, UpdateParameters, SetDataKey)
	
	If UpdateParameters.ListWithDate Then
		Query.SetParameter("StartDate",    UpdateParameters.StartDate);
		Query.SetParameter("EndDate", UpdateParameters.LastUpdatedItem.Date);
		SetDataKey = UpdateParameters.LastUpdatedItem.Date;
		Return;
	EndIf;
	
	DataKey = UpdateParameters.LastUpdatedItem.DataKey;
	
	If UpdateParameters.IsReferenceType Then
		SetDataKey = ?(Common.IsReference(TypeOf(DataKey)), DataKey, Undefined);
		Query.SetParameter("LastProcessedRef", SetDataKey);
		Return;
	EndIf;
	
	Query.SetParameter("RegisterID", UpdateParameters.ListID);
	
	SetDataKey = DataKey(UpdateParameters, DataKey);
	For Each KeyAndValue In SetDataKey Do
		Query.SetParameter(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	
EndProcedure

// For the UpdateAccessKeysToListDataItems and SetLastUpdatedItemParameters procedures, and the 
// RemainingRegisterItemsCountQueryText function.
//
Function DataKey(UpdateParameters, InitialDataKey = Undefined)
	
	FieldsCount = UpdateParameters.BasicFields.Used.Count();
	If FieldsCount = 0 Or UpdateParameters.UsesRestrictionByOwner Then
		FieldsCount = UpdateParameters.BasicFields.MaxCount;
	EndIf;
	
	If TypeOf(InitialDataKey) = Type("Structure")
	   AND InitialDataKey.Count() = FieldsCount Then
		
		FieldsValues = InitialDataKey;
	Else
		FieldsValues = New Structure;
	EndIf;
	
	NewDataKey = New Structure;
	For Number = 1 To FieldsCount Do
		FieldName = "Field" + Number;
		If FieldsValues.Property(FieldName) Then
			NewDataKey.Insert(FieldName, FieldsValues[FieldName]);
		Else
			NewDataKey.Insert(FieldName, Undefined);
		EndIf;
	EndDo;
	
	Return NewDataKey;
	
EndFunction

// For the UpdateAccessKeysToListDataItems procedure and the SourceAccessKeyOutdated function.
Procedure SetDataItemsQueryTextForProcessing(Query, RestrictionParameters);
	
	If RestrictionParameters.RestrictionDisabled
	 Or RestrictionParameters.AccessDenied
	 Or RestrictionParameters.UsesRestrictionByOwner Then
		
		If Not RestrictionParameters.Property("DataItemForKeyClearingQueryText") Then
			Query.SetParameter("AllowedAccessKey", AccessManagementInternalCached.AllowedAccessKey());
			Query.Text = RestrictionParameters.DataItemWithObsoleteAllowedKeyQueryText;
			
		ElsIf ValueIsFilled(RestrictionParameters.DataItemForKeyClearingQueryText) Then
			Query.Text = RestrictionParameters.DataItemForKeyClearingQueryText;
		Else
			Return;
		EndIf;
	Else
		Query.Text = RestrictionParameters.DataItemWithObsoleteKeysQueryText;
	EndIf;
	
EndProcedure

// For the UpdateAccessKeysToListDataItems and UpdateAccessGroupsSets procedures.
Procedure FillLastItemOnComplete(UpdateParameters, Query)
	
	If UpdateParameters.ListWithDate Then
		Query.Text = UpdateParameters.NextDataItemDateQueryText;
		QueryResult = Query.Execute();
		If Not QueryResult.IsEmpty() Then
			UpdateParameters.Insert("NewLastUpdatedItem",
				LastDataItem(QueryResult.Unload(), UpdateParameters));
		EndIf;
	EndIf;
	If Not UpdateParameters.Property("LastPortionItem") Then
		Return;
	EndIf;
	UpdateParameters.Insert("BatchesSet", New Array);
	BatchFromSet = New Structure("DataItems", Undefined);
	UpdateParameters.BatchesSet.Add(BatchFromSet);
	If ValueIsFilled(UpdateParameters.NewLastUpdatedItem) Then
		BatchFromSet.Insert("LastPortionItem",
			UpdateParameters.NewLastUpdatedItem);
		BatchFromSet.Insert("LatestChunkItemDate",
			BatchFromSet.LastPortionItem.Date);
	Else
		BatchFromSet.Insert("LatestChunkItemDate", '00010101');
	EndIf;
	
EndProcedure

// For the UpdateAccessKeysToListDataItems and UpdateAccessGroupsSets procedures.
Procedure FillItemsBatches(UpdateParameters, DataItems, BatchOfSetItems, BatchSize)
	
	BatchesSet = New Array;
	UpdateParameters.Insert("BatchesSet", BatchesSet);
	Index = 0;
	For Each DataItem In DataItems Do
		If Index / BatchOfSetItems = Int(Index / BatchOfSetItems) Then
			BatchFromSet = New Array;
			BatchesSet.Add(BatchFromSet);
		EndIf;
		BatchFromSet.Add(DataItem);
		Index = Index + 1;
	EndDo;
	
	MaxDate = MaxDate();
	For Index = 0 To BatchesSet.Count() - 1 Do
		BatchDataItems = DataItems.Copy(BatchesSet[Index]);
		BatchFromSet = New Structure;
		BatchesSet[Index] = BatchFromSet;
		BatchFromSet.Insert("DataItems", New ValueStorage(BatchDataItems));
		If UpdateParameters.ListWithDate Then
			BatchFromSet.Insert("LatestChunkItemDate",
				BatchDataItems[BatchDataItems.Count()-1].Date);
		Else
			BatchFromSet.Insert("LatestChunkItemDate", MaxDate);
		EndIf;
		BatchFromSet.Insert("LastPortionItem",
			LastDataItem(BatchDataItems, UpdateParameters));
	EndDo;
	
	If DataItems.Count() < BatchSize Then
		BatchFromSet.LastPortionItem = Undefined;
	EndIf;
	
EndProcedure


// For the UpdateListDataAccessKeys procedure.
Procedure UpdateAccessGroupsSets(UpdateParameters, DataItems)
	
	BlankAccessGroupsSet = Catalogs.AccessGroupsSets.EmptyRef();
	
	UpdateParameters.Insert("ListWithDate", False);
	UpdateParameters.Insert("IsReferenceType", True);
	UpdateParameters.Insert("BlankAccessGroupsSet", BlankAccessGroupsSet);
	
	If DataItems = Undefined Then
		If UpdateParameters.InitialUpdate Then
			UpdateSetsOfOneUserInCatalog(UpdateParameters);
			UpdateAccessGroupsSetsInCatalog(UpdateParameters);
			UpdateUserGroupsSetsInCatalog(UpdateParameters);
		EndIf;
		Query = New Query;
		Query.Text =
		"SELECT
		|	COUNT(AccessKeys.Ref) AS Count
		|FROM
		|	Catalog.AccessKeys AS AccessKeys";
		Selection = Query.Execute().Select();
		If Selection.Next() AND Selection.Count > 100 Then
			BatchOfSetItems = Int(10000 / Selection.Count);
		Else
			BatchOfSetItems = 100;
		EndIf;
		If BatchOfSetItems < 5 Then
			BatchOfSetItems = 5;
		EndIf;
		
		Query = New Query;
		Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
		If UpdateParameters.LastUpdatedItem.DataKey = BlankAccessGroupsSet Then
			
			Query.Text =
			"SELECT TOP " + BatchSizeMarker() + "
			|	GroupsSets.GroupSet AS CurrentRef
			|FROM
			|	(SELECT TOP " + BatchSizeMarker() + "
			|		AccessGroupsSets.NewAccessGroupSet AS GroupSet
			|	FROM
			|		Catalog.AccessGroupsSets AS AccessGroupsSets
			|	WHERE
			|		AccessGroupsSets.ForExternalUsers = &ForExternalUsers
			|		AND AccessGroupsSets.NewAccessGroupSet <> VALUE(Catalog.AccessGroupsSets.EmptyRef)
			|	
			|	UNION ALL
			|	
			|	SELECT TOP " + BatchSizeMarker() + "
			|		AccessGroupsSets.NewUserGroupSet
			|	FROM
			|		Catalog.AccessGroupsSets AS AccessGroupsSets
			|	WHERE
			|		AccessGroupsSets.ForExternalUsers = &ForExternalUsers
			|		AND AccessGroupsSets.NewUserGroupSet <> VALUE(Catalog.AccessGroupsSets.EmptyRef)) AS GroupsSets
			|
			|ORDER BY
			|	GroupsSets.GroupSet";
		Else
			Query.SetParameter("LastProcessedRef",
				UpdateParameters.LastUpdatedItem.DataKey);
			
			Query.Text =
			"SELECT TOP " + BatchSizeMarker() + "
			|	CurrentList.Ref AS CurrentRef
			|FROM
			|	Catalog.AccessGroupsSets AS CurrentList
			|WHERE
			|	CurrentList.ForExternalUsers = &ForExternalUsers
			|	AND CurrentList.SetItemsType IN (VALUE(Catalog.AccessGroups.EmptyRef), VALUE(Catalog.UserGroups.EmptyRef))
			|	AND CurrentList.Ref > &LastProcessedRef
			|
			|ORDER BY
			|	CurrentList.Ref";
			
			If UpdateParameters.ForExternalUsers Then
				Query.Text = StrReplace(Query.Text,
					"Catalog.UserGroups", "Catalog.ExternalUsersGroups");
			EndIf;
		EndIf;
		
		BatchSize = BatchOfSetItems;
		
		If UpdateParameters.InitialUpdate Then
			BatchSize = 1;
			
		ElsIf UpdateParameters.GetPortions > 0
			    AND (    BatchSize < UpdateParameters.GetPortions * BatchOfSetItems
			       Or UpdateParameters.Property("LastPortionItem")) Then
			
			BatchSize = UpdateParameters.GetPortions * BatchOfSetItems;
		EndIf;
		Query.Text = StrReplace(Query.Text, BatchSizeMarker(), Format(BatchSize, "NG="));
		
		DataItems = Query.Execute().Unload();
		If UpdateParameters.LastUpdatedItem.DataKey = Undefined Then
			DataItems.Insert(0).CurrentRef = BlankAccessGroupsSet;
		EndIf;
		
		ResultBlank = False;
		If DataItems.Count() = 0 Then
			ResultBlank = True;
		EndIf;
		
		If ResultBlank Then
			FillLastItemOnComplete(UpdateParameters, Undefined);
			Return;
		EndIf;
		
		If UpdateParameters.GetPortions > 0
		   AND (    UpdateParameters.Property("LastPortionItem")
		      Or DataItems.Count() > BatchOfSetItems * 2) Then
			
			FillItemsBatches(UpdateParameters, DataItems, BatchOfSetItems, BatchSize);
			Return;
		EndIf;
	EndIf;
	
	GroupsSets = DataItems.UnloadColumn("CurrentRef");
	
	UpdateGroupsSetsAccessKeys(UpdateParameters,
		GroupsSets, "AccessGroupSetsAccessKeys", "IsAccessGroupsRights", "AccessGroupsSet");
	
	If Not UpdateParameters.ForExternalUsers Then
		UpdateGroupsSetsAccessKeys(UpdateParameters,
			GroupsSets, "UsersAccessKeys", "IsUsersRights", "User");
	Else
		UpdateGroupsSetsAccessKeys(UpdateParameters,
			GroupsSets, "ExternalUsersAccessKeys", "IsExternalUsersRights", "ExternalUser");
	EndIf;
	
	UpdateAllowedSetsAfterNewSetsAccessKeysUpdate(UpdateParameters, GroupsSets);
	
	If BatchSize <> Undefined AND DataItems.Count() < BatchSize Then
		Return;
	EndIf;
	
	If BatchSize <> Undefined
	   AND UpdateParameters.LastUpdatedItem.DataKey = BlankAccessGroupsSet Then
		
		LastDataItem = New Structure("DataKey", BlankAccessGroupsSet);
	Else
		LastDataItem = LastDataItem(DataItems, UpdateParameters);
	EndIf;
	UpdateParameters.Insert("NewLastUpdatedItem", LastDataItem);
	
EndProcedure

// For the UpdateAccessGroupsSets procedure.
Procedure UpdateSetsOfOneUserInCatalog(UpdateParameters)
	
	Query = New Query;
	Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
	Query.Text =
	"SELECT
	|	AccessGroupsSets.Ref AS Ref
	|FROM
	|	Catalog.AccessGroupsSets AS AccessGroupsSets
	|WHERE
	|	AccessGroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND AccessGroupsSets.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|	AND AccessGroupsSets.User IN
	|			(SELECT DISTINCT
	|				AccessGroupsSets.User AS User
	|			FROM
	|				Catalog.AccessGroupsSets AS AccessGroupsSets
	|			WHERE
	|				AccessGroupsSets.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|			GROUP BY
	|				AccessGroupsSets.User
	|			HAVING
	|				COUNT(AccessGroupsSets.User) > 1)";
	
	If UpdateParameters.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.Users", "Catalog.ExternalUsers");
	EndIf;
	
	Selection = Query.Execute().Select();
	While Selection.Next() Do
		Object = ServiceItem(Undefined, Selection.Ref);
		Object.SetItemsType = Undefined;
	EndDo;
	
	Query = New Query;
	Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
	Query.SetParameter("EmptyUniqueID",
		New UUID("00000000-0000-0000-0000-000000000000"));
	
	Query.Text =
	"SELECT
	|	UserGroupCompositions.User AS User,
	|	UserGroupCompositions.User.Description AS Description,
	|	UserGroupCompositions.Used AS Used,
	|	AccessGroupsSets.NotUsedSince AS NotUsedSince
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		LEFT JOIN Catalog.AccessGroupsSets AS AccessGroupsSets
	|		ON (AccessGroupsSets.User = UserGroupCompositions.User)
	|			AND (AccessGroupsSets.ForExternalUsers = &ForExternalUsers)
	|			AND (AccessGroupsSets.SetItemsType = VALUE(Catalog.Users.EmptyRef))
	|			AND (NOT FALSE IN
	|					(SELECT TOP 1
	|						FALSE
	|					FROM
	|						Catalog.AccessGroupsSets.Folders AS SetGroups
	|					WHERE
	|						SetGroups.Ref = AccessGroupsSets.Ref))
	|WHERE
	|	VALUETYPE(UserGroupCompositions.UsersGroup) = TYPE(Catalog.Users)
	|	AND CASE
	|			WHEN UserGroupCompositions.Used
	|					AND CAST(UserGroupCompositions.User AS Catalog.Users).IBUserID <> &EmptyUniqueID
	|				THEN AccessGroupsSets.User IS NULL
	|						OR AccessGroupsSets.NotUsedSince <> DATETIME(1, 1, 1)
	|			ELSE AccessGroupsSets.NotUsedSince = DATETIME(1, 1, 1)
	|		END";
	
	If UpdateParameters.ForExternalUsers Then
		SetItemsType = Catalogs.ExternalUsers.EmptyRef();
		ItemPresentation = NStr("ru = 'Внешний пользователь'; en = 'External user'; pl = 'Użytkownik zewnętrzny';es_ES = 'Usuario externo';es_CO = 'Usuario externo';tr = 'Harici kullanıcı';it = 'Utente esterno';de = 'Externer Benutzer'", CommonClientServer.DefaultLanguageCode());
		Query.Text = StrReplace(Query.Text, "Catalog.Users", "Catalog.ExternalUsers");
	Else
		SetItemsType = Catalogs.Users.EmptyRef();
		ItemPresentation = NStr("ru = 'Пользователь'; en = 'User'; pl = 'Użytkownik';es_ES = 'Usuario';es_CO = 'Usuario';tr = 'Kullanıcı';it = 'Utente';de = 'Benutzer'", CommonClientServer.DefaultLanguageCode());
	EndIf;
	
	Selection = Query.Execute().Select();
	While Selection.Next() Do
		SetRef = Catalogs.AccessGroupsSets.GetRef(Selection.User.UUID());
		Object = ServiceItem(Undefined, SetRef);
		If Object = Undefined Then
			Object = ServiceItem(Catalogs.AccessGroupsSets);
			Object.SetNewObjectRef(SetRef);
		Else
			Object.Folders.Clear();
		EndIf;
		If Selection.Used Then
			Object.NotUsedSince = '00010101';
		ElsIf Not ValueIsFilled(Selection.NotUsedSince) Then
			Object.NotUsedSince = CurrentSessionDate();
		EndIf;
		Object.ForExternalUsers = UpdateParameters.ForExternalUsers;
		Object.SetItemsType = SetItemsType;
		Object.User = Selection.User;
		Object.Description = Selection.Description + " (" + ItemPresentation + ")";
		Object.Write();
	EndDo;
	
	Query = New Query;
	Query.SetParameter("DateOfBecomingObsolete", DateOfBecomingObsolete());
	Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
	Query.Text =
	"SELECT
	|	AccessGroupsSets.Ref AS Ref
	|FROM
	|	Catalog.AccessGroupsSets AS AccessGroupsSets
	|WHERE
	|	AccessGroupsSets.SetItemsType = UNDEFINED
	|
	|UNION ALL
	|
	|SELECT
	|	AccessGroupsSets.Ref
	|FROM
	|	Catalog.AccessGroupsSets AS AccessGroupsSets
	|WHERE
	|	AccessGroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND AccessGroupsSets.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|	AND (CAST(AccessGroupsSets.User AS Catalog.Users).Ref IS NULL
	|			OR AccessGroupsSets.NotUsedSince <> DATETIME(1, 1, 1)
	|				AND AccessGroupsSets.NotUsedSince < &DateOfBecomingObsolete)";
	
	If UpdateParameters.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.Users", "Catalog.ExternalUsers");
	EndIf;
	
	If Query.Execute().IsEmpty() Then
		Return;
	EndIf;
	
	AccessGroupsSetsAccessKeysRecordSet = ServiceRecordSet(
		InformationRegisters.AccessGroupSetsAccessKeys);
	
	UsersAccessKeysRecordSet = ServiceRecordSet(
		InformationRegisters.UsersAccessKeys);
	
	ExternalUsersAccessKeysRecordSet = ServiceRecordSet(
		InformationRegisters.ExternalUsersAccessKeys);
	
	Lock = New DataLock;
	Lock.Add("Catalog.AccessGroupsSets");
	Lock.Add("InformationRegister.AccessGroupSetsAccessKeys");
	Lock.Add("InformationRegister.UsersAccessKeys");
	Lock.Add("InformationRegister.ExternalUsersAccessKeys");
	
	BeginTransaction();
	Try
		Lock.Lock();
		Selection = Query.Execute().Select();
		While Selection.Next() Do
			AccessGroupsSetsAccessKeysRecordSet.Filter.AccessGroupsSet.Set(Selection.Ref);
			AccessGroupsSetsAccessKeysRecordSet.Write();
			UsersAccessKeysRecordSet.Filter.User.Set(Selection.Ref);
			UsersAccessKeysRecordSet.Write();
			ExternalUsersAccessKeysRecordSet.Filter.ExternalUser.Set(Selection.Ref);
			ExternalUsersAccessKeysRecordSet.Write();
			Object = ServiceItem(Undefined, Selection.Ref);
			Object.Delete();
		EndDo;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateSetsOfOneUserInCatalog procedure.
Function DateOfBecomingObsolete()
	
	Return CurrentSessionDate() - 172800; // 2 * 24 * 60 * 60 = 2 days.
	
EndFunction

// For the UpdateAccessGroupsSets procedure.
Procedure UpdateAccessGroupsSetsInCatalog(UpdateParameters)
	
	If Not UpdateParameters.ForExternalUsers Then
		GroupsQueryText =
		"SELECT
		|	AccessGroups.Ref AS Ref
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile <> VALUE(Catalog.AccessGroupProfiles.Administrator)
		|	AND NOT AccessGroups.DeletionMark
		|	AND NOT AccessGroups.Profile.DeletionMark
		|	AND TRUE IN
		|			(SELECT TOP 1
		|				TRUE
		|			FROM
		|				Catalog.AccessGroups.Users AS AccessGroupsUsers
		|			WHERE
		|				AccessGroupsUsers.Ref = AccessGroups.Ref)
		|	AND CASE
		|			WHEN TRUE IN
		|					(SELECT TOP 1
		|						TRUE
		|					FROM
		|						Catalog.AccessGroupProfiles.Purpose AS Purpose
		|					WHERE
		|						Purpose.Ref = AccessGroups.Profile
		|						AND VALUETYPE(Purpose.UsersType) = TYPE(Catalog.Users))
		|				THEN TRUE
		|			WHEN NOT FALSE IN
		|						(SELECT TOP 1
		|							FALSE
		|						FROM
		|							Catalog.AccessGroupProfiles.Purpose AS Purpose
		|						WHERE
		|							Purpose.Ref = AccessGroups.Profile)
		|				THEN TRUE
		|			ELSE FALSE
		|		END
		|
		|ORDER BY
		|	Ref";
	Else
		GroupsQueryText =
		"SELECT
		|	AccessGroups.Ref AS Ref
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile <> VALUE(Catalog.AccessGroupProfiles.Administrator)
		|	AND NOT AccessGroups.DeletionMark
		|	AND NOT AccessGroups.Profile.DeletionMark
		|	AND TRUE IN
		|			(SELECT TOP 1
		|				TRUE
		|			FROM
		|				Catalog.AccessGroups.Users AS AccessGroupsUsers
		|			WHERE
		|				AccessGroupsUsers.Ref = AccessGroups.Ref)
		|	AND TRUE IN
		|			(SELECT TOP 1
		|				TRUE
		|			FROM
		|				Catalog.AccessGroupProfiles.Purpose AS Purpose
		|			WHERE
		|				Purpose.Ref = AccessGroups.Profile
		|				AND Purpose.UsersType <> UNDEFINED
		|				AND VALUETYPE(Purpose.UsersType) <> TYPE(Catalog.Users))
		|
		|ORDER BY
		|	Ref";
	EndIf;
	
	NewGroupsSetsQueryText =
	"SELECT
	|	UserAccessGroups.User AS User,
	|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
	|INTO NewGroupsSets
	|FROM
	|	(SELECT DISTINCT
	|		UserGroupCompositions.User AS User,
	|		AccessGroupsUsers.Ref AS AccessGroup
	|	FROM
	|		Catalog.AccessGroups.Users AS AccessGroupsUsers
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = AccessGroupsUsers.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (CAST(UserGroupCompositions.User AS Catalog.Users).IBUserID <> &EmptyUniqueID)
	|				AND (UserGroupCompositions.Used)) AS UserAccessGroups
	|		INNER JOIN GroupsNumbers AS GroupsNumbers
	|		ON UserAccessGroups.AccessGroup = GroupsNumbers.Group
	|
	|GROUP BY
	|	UserAccessGroups.User
	|
	|INDEX BY
	|	UserAccessGroups.User";
	
	UpdateGroupsSetsInCatalog(UpdateParameters, GroupsQueryText, NewGroupsSetsQueryText,
		"AccessGroupsSet", "AccessGroups", NStr("ru = 'Группы доступа'; en = 'Access groups'; pl = 'Grupy dostępu';es_ES = 'Grupos de acceso';es_CO = 'Grupos de acceso';tr = 'Erişim grupları';it = 'Gruppi di accesso';de = 'Zugriffsgruppen'", CommonClientServer.DefaultLanguageCode()));
	
EndProcedure

// For the UpdateAccessGroupsSets procedure.
Procedure UpdateUserGroupsSetsInCatalog(UpdateParameters)
	
	GroupsQueryText =
	"SELECT DISTINCT
	|	UserGroupCompositions.UsersGroup AS Ref
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|WHERE
	|	UserGroupCompositions.Used
	|	AND VALUETYPE(UserGroupCompositions.UsersGroup) = TYPE(Catalog.UserGroups)
	|
	|ORDER BY
	|	UserGroupCompositions.UsersGroup";
	
	If UpdateParameters.ForExternalUsers Then
		GroupsQueryText = StrReplace(GroupsQueryText,
			"Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	
	NewGroupsSetsQueryText =
	"SELECT
	|	UserGroupCompositions.User AS User,
	|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
	|INTO NewGroupsSets
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		INNER JOIN GroupsNumbers AS GroupsNumbers
	|		ON UserGroupCompositions.UsersGroup = GroupsNumbers.Group
	|			AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|			AND (CAST(UserGroupCompositions.User AS Catalog.Users).IBUserID <> &EmptyUniqueID)
	|			AND (UserGroupCompositions.Used)
	|
	|GROUP BY
	|	UserGroupCompositions.User
	|
	|INDEX BY
	|	UserGroupCompositions.User";
	
	If UpdateParameters.ForExternalUsers Then
		GroupsCatalogName = "ExternalUsersGroups";
		ItemPresentation = NStr("ru = 'Группы внешних пользователей'; en = 'External user groups'; pl = 'Zewnętrzna grupa użytkowników';es_ES = 'Grupos de usuario externo';es_CO = 'Grupos de usuario externo';tr = 'Harici kullanıcı grupları';it = 'Gruppi di utenti esterni';de = 'Gruppen externer Benutzer'",
			CommonClientServer.DefaultLanguageCode());
	Else
		GroupsCatalogName = "UserGroups";
		ItemPresentation = NStr("ru = 'Группы пользователей'; en = 'User groups'; pl = 'Grupy użytkowników';es_ES = 'Grupos de usuario';es_CO = 'Grupos de usuario';tr = 'Kullanıcı grupları';it = 'Gruppi utente';de = 'Benutzergruppen'",
			CommonClientServer.DefaultLanguageCode());
	EndIf;
	
	UpdateGroupsSetsInCatalog(UpdateParameters, GroupsQueryText, NewGroupsSetsQueryText,
		"UserGroupSet", GroupsCatalogName, ItemPresentation);
	
EndProcedure

// This is required by UpdateAccessGroupsSetsInCatalog and UpdateUsersGroupsSetsInCatalog procedures.
Procedure UpdateGroupsSetsInCatalog(UpdateParameters, GroupsQueryText, NewGroupsSetsQueryText,
			SetFieldName, GroupsCatalogName, ItemPresentation)
	
	Query = New Query;
	Query.Text = GroupsQueryText;
	GroupsNumbers = Query.Execute().Unload();
	
	NumberPartsNames = New Array;
	FillGroupsNumbers(GroupsNumbers, NumberPartsNames);
	
	Query = New Query;
	Query.SetParameter("GroupsNumbers", GroupsNumbers);
	Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
	Query.SetParameter("EmptyUniqueID",
		New UUID("00000000-0000-0000-0000-000000000000"));
	
	Query.Text =
	"SELECT
	|	GroupsNumbers.Ref AS Group,
	|	GroupsNumbers.NumberPart1 AS NumberPart1
	|INTO GroupsNumbers
	|FROM
	|	&GroupsNumbers AS GroupsNumbers
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	UNDEFINED AS User,
	|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
	|INTO NewGroupsSets
	|FROM
	|	GroupsNumbers AS GroupsNumbers
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	GroupsSets.Ref AS SingleUserSet,
	|	GroupsSets.User AS User,
	|	ISNULL(SUM(GroupsNumbers.NumberPart1), -1) AS NumberPart1
	|INTO OldGroupSets
	|FROM
	|	Catalog.AccessGroupsSets AS GroupsSets
	|		LEFT JOIN Catalog.AccessGroupsSets.Folders AS SetGroups
	|		ON (SetGroups.Ref = GroupsSets.AllowedAccessGroupsSet)
	|		LEFT JOIN GroupsNumbers AS GroupsNumbers
	|		ON (SetGroups.Group = GroupsNumbers.Group)
	|WHERE
	|	GroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND GroupsSets.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|	AND GroupsSets.NotUsedSince = DATETIME(1, 1, 1)
	|	AND GroupsSets.NewAccessGroupSet = VALUE(Catalog.AccessGroupsSets.EmptyRef)
	|
	|GROUP BY
	|	GroupsSets.Ref,
	|	GroupsSets.User
	|
	|UNION ALL
	|
	|SELECT
	|	GroupsSets.Ref,
	|	GroupsSets.User,
	|	ISNULL(SUM(GroupsNumbers.NumberPart1), -1)
	|FROM
	|	Catalog.AccessGroupsSets AS GroupsSets
	|		LEFT JOIN Catalog.AccessGroupsSets.Folders AS SetGroups
	|		ON (SetGroups.Ref = GroupsSets.NewAccessGroupSet)
	|		LEFT JOIN GroupsNumbers AS GroupsNumbers
	|		ON (SetGroups.Group = GroupsNumbers.Group)
	|WHERE
	|	GroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND GroupsSets.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|	AND GroupsSets.NotUsedSince = DATETIME(1, 1, 1)
	|	AND GroupsSets.NewAccessGroupSet <> VALUE(Catalog.AccessGroupsSets.EmptyRef)
	|
	|GROUP BY
	|	GroupsSets.Ref,
	|	GroupsSets.User
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	OldSets.SingleUserSet AS SingleUserSet,
	|	NewSets.NumberPart1 AS NumberPart1
	|INTO GroupSetsForUpdate
	|FROM
	|	OldGroupSets AS OldSets
	|		LEFT JOIN NewGroupsSets AS NewSets
	|		ON (NewSets.User = OldSets.User)
	|WHERE
	|	OldSets.NumberPart1 <> NewSets.NumberPart1
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	GroupsSets.Ref AS GroupSet,
	|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
	|INTO ExistingGroupSets
	|FROM
	|	Catalog.AccessGroupsSets AS GroupsSets
	|		INNER JOIN Catalog.AccessGroupsSets.Folders AS SetGroups
	|		ON (GroupsSets.ForExternalUsers = &ForExternalUsers)
	|			AND (GroupsSets.SetItemsType = VALUE(Catalog.AccessGroups.EmptyRef))
	|			AND (SetGroups.Ref = GroupsSets.Ref)
	|		LEFT JOIN GroupsNumbers AS GroupsNumbers
	|		ON (SetGroups.Group = GroupsNumbers.Group)
	|
	|GROUP BY
	|	GroupsSets.Ref
	|
	|HAVING
	|	NOT SUM(GroupsNumbers.NumberPart1) IS NULL
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	NewSets.SingleUserSet AS SingleUserSet,
	|	ISNULL(ExistingSets.GroupSet, VALUE(Catalog.AccessGroupsSets.EmptyRef)) AS GroupSet,
	|	TRUE IN
	|		(SELECT TOP 1
	|			TRUE
	|		FROM
	|			Catalog.AccessGroupsSets AS AllSets
	|		WHERE
	|			AllSets.ForExternalUsers = &ForExternalUsers
	|			AND AllSets.NewAccessGroupSet = ExistingSets.GroupSet) AS NewGroupSet,
	|	NewSets.NumberPart1 AS NumberPart1
	|FROM
	|	GroupSetsForUpdate AS NewSets
	|		LEFT JOIN ExistingGroupSets AS ExistingSets
	|		ON (ExistingSets.NumberPart1 = NewSets.NumberPart1)
	|
	|ORDER BY
	|	SingleUserSet,
	|	GroupSet";
	
	Query.Text = StrReplace(Query.Text,
		"SELECT
		|	UNDEFINED AS User,
		|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
		|INTO NewGroupsSets
		|FROM
		|	GroupsNumbers AS GroupsNumbers",
		NewGroupsSetsQueryText);
	
	If UpdateParameters.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.Users", "Catalog.ExternalUsers");
	EndIf;
	
	Query.Text = StrReplace(Query.Text, "VALUE(Catalog.AccessGroups.EmptyRef)",
		"VALUE(Catalog." + GroupsCatalogName + ".EmptyRef)");
	
	Query.Text = StrReplace(Query.Text, "NewAccessGroupSet",       "New"       + SetFieldName);
	Query.Text = StrReplace(Query.Text, "AllowedAccessGroupsSet", "Allowed" + SetFieldName);
	
	Query.Text = StrReplace(Query.Text,
		"	GroupsNumbers.NumberPart1 AS NumberPart1",
		"	GroupsNumbers." + StrConcat(NumberPartsNames, ",
		|	GroupsNumbers."));
	
	Query.Text = StrReplace(Query.Text,
		"	ISNULL(SUM(GroupsNumbers.NumberPart1), -1)
		|",
		"	ISNULL(SUM(GroupsNumbers." + StrConcat(NumberPartsNames, "), -1),
		|	ISNULL(SUM(GroupsNumbers.") + "), -1)
		|");
	
	Query.Text = StrReplace(Query.Text,
		"	NewSets.NumberPart1 AS NumberPart1",
		"	NewSets." + StrConcat(NumberPartsNames, ",
		|	NewSets."));
	
	Query.Text = StrReplace(Query.Text,
		"	NOT SUM(GroupsNumbers.NumberPart1) IS NULL",
		"	NOT SUM(GroupsNumbers." + StrConcat(NumberPartsNames, ") IS NULL
		|	AND NOT SUM(GroupsNumbers.") + ") IS NULL");
	
	FilterCriterion = "";
	ConnectionCondition = "";
	OldOnesSumFields = "";
	NewOnesSumFields = "";
	For Each NumberPartName In NumberPartsNames Do
		FilterCriterion = FilterCriterion + ?(FilterCriterion = "", "","
		|			OR ") + "OldSets." + NumberPartName + " <> NewSets." + NumberPartName;
		ConnectionCondition = ConnectionCondition + ?(ConnectionCondition = "", "", "
		|			AND ") + "(ExistingSets." + NumberPartName + " = NewSets." + NumberPartName + ")";
		OldOnesSumFields = OldOnesSumFields + ?(OldOnesSumFields = "", "", ",
		|	") + "ISNULL(SUM(GroupsNumbers." + NumberPartName + "), -1) AS " + NumberPartName;
		NewOnesSumFields = NewOnesSumFields + ?(NewOnesSumFields = "", "", ",
		|	") + "SUM(GroupsNumbers." + NumberPartName + ") AS " + NumberPartName;
	EndDo;
	
	Query.Text = StrReplace(Query.Text,
		"OldSets.NumberPart1 <> NewSets.NumberPart1", "(" + FilterCriterion + ")");
	Query.Text = StrReplace(Query.Text,
		"(ExistingSets.NumberPart1 = NewSets.NumberPart1)", ConnectionCondition);
	
	Query.Text = StrReplace(Query.Text,
		"ISNULL(SUM(GroupsNumbers.NumberPart1), -1) AS NumberPart1", OldOnesSumFields);
	Query.Text = StrReplace(Query.Text,
		"SUM(GroupsNumbers.NumberPart1) AS NumberPart1", NewOnesSumFields);
	
	DataExported = Query.Execute().Unload();
	NewGroupsSets = DataExported.Copy(New Array);
	Filter = New Structure(StrConcat(NumberPartsNames, ", "));
	
	For Each Row In DataExported Do
		If Not ValueIsFilled(Row.GroupSet) Then
			FillPropertyValues(Filter, Row);
			FoundRows = NewGroupsSets.FindRows(Filter);
			If FoundRows.Count() = 0 Then
				Row.GroupSet = NewGroupsSet(GroupsNumbers,
					NumberPartsNames,
					Filter,
					UpdateParameters.ForExternalUsers,
					Catalogs[GroupsCatalogName].EmptyRef(),
					ItemPresentation);
				FoundRow = NewGroupsSets.Add();
				FillPropertyValues(FoundRow, Filter);
				FoundRow.GroupSet = Row.GroupSet;
				Row.NewGroupSet = True;
			Else
				Row.GroupSet = FoundRows[0].GroupSet;
			EndIf;
		EndIf;
		Object = ServiceItem(Undefined, Row.SingleUserSet);
		If Row.NewGroupSet Then
			Object["New" + SetFieldName] = Row.GroupSet;
		Else
			Object["Allowed" + SetFieldName] = Row.GroupSet;
			Object["New" + SetFieldName] = UpdateParameters.BlankAccessGroupsSet;
		EndIf;
		Object.Write();
	EndDo;
	
EndProcedure

// For the UpdateGroupsSetsInCatalog procedure.
Procedure FillGroupsNumbers(GroupsNumbers, NumberPartsNames)
	
	GroupsCount = GroupsNumbers.Count();
	NumberPartsCount = Int(GroupsCount / 64) + 1;
	NumberTypesDetails = New TypeDescription("Number",,,
		New NumberQualifiers(31, 0, AllowedSign.Nonnegative));
	
	For Counter = 1 To NumberPartsCount Do
		NumberPartName = "NumberPart" + Format(Counter, "NGS=");
		NumberPartsNames.Add(NumberPartName);
		GroupsNumbers.Columns.Add(NumberPartName, NumberTypesDetails);
	EndDo;
	
	CurrentNumberPart = 1;
	CurrentNumberPartName = NumberPartsNames[0];
	CurrentGroupNumber = 1;
	MaxGroupNumberInNumberPart = 9223372036854775808; // 2^63.
	For Each Row In GroupsNumbers Do
		Row[CurrentNumberPartName] = CurrentGroupNumber;
		CurrentGroupNumber = CurrentGroupNumber * 2;
		If CurrentGroupNumber > MaxGroupNumberInNumberPart Then
			CurrentGroupNumber = 1;
			CurrentNumberPartName = NumberPartsNames[CurrentNumberPart];
			CurrentNumberPart = CurrentNumberPart + 1;
		EndIf;
	EndDo;
	
EndProcedure

// For the UpdateGroupsSetsInCatalog procedure.
Function NewGroupsSet(GroupsNumbers, NumberPartsNames, NumberParts, ForExternalUsers,
			SetItemsType, GroupsItemsPresentation)
	
	NewRef = Catalogs.AccessGroupsSets.GetRef();
	Object = ServiceItem(Catalogs.AccessGroupsSets);
	Object.SetNewObjectRef(NewRef);
	Object.ForExternalUsers = ForExternalUsers;
	Object.SetItemsType = SetItemsType;
	Object.Description = String(NewRef.UUID()) + " (" + GroupsItemsPresentation + ")";
	
	SetGroups = SetGroupsByNumbers(GroupsNumbers, NumberPartsNames, NumberParts);
	For Each SetGroup In SetGroups Do
		Object.Folders.Add().Folder = SetGroup;
	EndDo;
	
	Object.Write();
	
	Return Object.Ref;
	
EndFunction

// For the NewGroupsSet function.
Function SetGroupsByNumbers(GroupsNumbers, NumberPartsNames, NumberParts)
	
	SetGroups = New Array;
	CurrentNumberPart = 1;
	GroupIndex = 0;
	Divisor = 4294967296; // 2^32.
	
	For Each NumberPartName In NumberPartsNames Do
		NumberPart = NumberParts[NumberPartName];
		For NumberPartBlockNumber = 1 To 2 Do
			Integer = Int(NumberPart / Divisor);
			NumberPartBlock = NumberPart - Integer * Divisor;
			NumberPart = Integer;
			For BitNumber = 0 To 31 Do
				If CheckBit(NumberPartBlock, BitNumber) Then
					SetGroups.Add(GroupsNumbers[GroupIndex + BitNumber].Ref);
				EndIf;
			EndDo;
			GroupIndex = GroupIndex + 32;
		EndDo;
	EndDo;
	
	Return SetGroups;
	
EndFunction

// For the UpdateAccessGroupsSets procedure.
Procedure UpdateGroupsSetsAccessKeys(UpdateParameters, GroupsSets, RightsRegisterName,
				RightsFilterFieldName, GroupsSetFieldName)
	
	BatchForLockSelectionQueryText =
	"SELECT TOP 1000
	|	AllRows.AccessGroupsSet AS AccessGroupsSet,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind,
	|	AllRows.AccessKey AS AccessKey
	|FROM
	|	(SELECT
	|		GroupsInSets.Ref AS AccessGroupsSet,
	|		AccessGroupsAccessKeys.AccessKey AS AccessKey,
	|		MAX(AccessGroupsAccessKeys.Update) AS Update,
	|		MAX(AccessGroupsAccessKeys.Insert) AS Insert,
	|		1 AS RowChangeKind
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|			INNER JOIN Catalog.AccessGroupsSets.Folders AS GroupsInSets
	|			ON (GroupsInSets.Group = AccessGroupsAccessKeys.AccessGroup)
	|				AND (AccessGroupsAccessKeys.IsAccessGroupsRights)
	|				AND (&AccessGroupSetFilterCriterion1)
	|	
	|	GROUP BY
	|		AccessGroupsAccessKeys.AccessKey,
	|		GroupsInSets.Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		&AllowedEmptySet,
	|		AccessGroupsAccessKeys.AccessKey,
	|		AccessGroupsAccessKeys.Update,
	|		AccessGroupsAccessKeys.Insert,
	|		1
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|	WHERE
	|		AccessGroupsAccessKeys.AccessGroup = VALUE(Catalog.AccessGroups.EmptyRef)
	|		AND AccessGroupsAccessKeys.IsAccessGroupsRights
	|		AND &AccessGroupSetFilterCriterion2
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.AccessGroupsSet,
	|		OldData.AccessKey,
	|		OldData.Update,
	|		OldData.Insert,
	|		-1
	|	FROM
	|		InformationRegister.AccessGroupSetsAccessKeys AS OldData
	|	WHERE
	|		&GroupRightsFilterCriterion
	|		AND &AccessGroupSetFilterCriterion3) AS AllRows
	|
	|GROUP BY
	|	AllRows.AccessGroupsSet,
	|	AllRows.AccessKey,
	|	AllRows.Update,
	|	AllRows.Insert
	|
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0
	|
	|ORDER BY
	|	AccessGroupsSet,
	|	RowChangeKind,
	|	AccessKey";
	
	BatchForUpdateSelectionQueryText =
	"SELECT TOP 1000
	|	AllRows.AccessGroupsSet AS AccessGroupsSet,
	|	AllRows.AccessKey AS AccessKey,
	|	AllRows.Update AS Update,
	|	AllRows.Insert AS Insert,
	|	TRUE AS AreGroupSetRights,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind
	|FROM
	|	(SELECT
	|		GroupsInSets.Ref AS AccessGroupsSet,
	|		AccessGroupsAccessKeys.AccessKey AS AccessKey,
	|		MAX(AccessGroupsAccessKeys.Update) AS Update,
	|		MAX(AccessGroupsAccessKeys.Insert) AS Insert,
	|		1 AS RowChangeKind
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|			INNER JOIN Catalog.AccessGroupsSets.Folders AS GroupsInSets
	|			ON (GroupsInSets.Group = AccessGroupsAccessKeys.AccessGroup)
	|				AND (AccessGroupsAccessKeys.IsAccessGroupsRights)
	|				AND (&AccessGroupSetFilterCriterion1)
	|				AND (&AccessKeyFilterCriterion1)
	|	
	|	GROUP BY
	|		AccessGroupsAccessKeys.AccessKey,
	|		GroupsInSets.Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		&AllowedEmptySet,
	|		AccessGroupsAccessKeys.AccessKey,
	|		AccessGroupsAccessKeys.Update,
	|		AccessGroupsAccessKeys.Insert,
	|		1
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|	WHERE
	|		AccessGroupsAccessKeys.AccessGroup = VALUE(Catalog.AccessGroups.EmptyRef)
	|		AND AccessGroupsAccessKeys.IsAccessGroupsRights
	|		AND &AccessGroupSetFilterCriterion2
	|		AND &AccessKeyFilterCriterion2
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.AccessGroupsSet,
	|		OldData.AccessKey,
	|		OldData.Update,
	|		OldData.Insert,
	|		-1
	|	FROM
	|		InformationRegister.AccessGroupSetsAccessKeys AS OldData
	|	WHERE
	|		&GroupRightsFilterCriterion
	|		AND &AccessGroupSetFilterCriterion3
	|		AND &AccessKeyFilterCriterion3) AS AllRows
	|
	|GROUP BY
	|	AllRows.AccessGroupsSet,
	|	AllRows.AccessKey,
	|	AllRows.Update,
	|	AllRows.Insert
	|
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0
	|
	|ORDER BY
	|	RowChangeKind";
	
	BatchForLockSelectionQueryText = StrReplace(BatchForLockSelectionQueryText,
		"IsAccessGroupsRights", RightsFilterFieldName);
	
	BatchForUpdateSelectionQueryText = StrReplace(BatchForUpdateSelectionQueryText,
		"AccessGroupsSet", GroupsSetFieldName);
	
	BatchForLockSelectionQueryText = StrReplace(BatchForLockSelectionQueryText,
		"AccessGroupsSet", GroupsSetFieldName);
	
	BatchForUpdateSelectionQueryText = StrReplace(BatchForUpdateSelectionQueryText,
		"IsAccessGroupsRights", RightsFilterFieldName);
	
	BatchForLockSelectionQueryText = StrReplace(BatchForLockSelectionQueryText,
		"InformationRegister.AccessGroupSetsAccessKeys", "InformationRegister." + RightsRegisterName);
	
	BatchForUpdateSelectionQueryText = StrReplace(BatchForUpdateSelectionQueryText,
		"InformationRegister.AccessGroupSetsAccessKeys", "InformationRegister." + RightsRegisterName);
	
	BatchForLockSelectionQueryText = StrReplace(BatchForLockSelectionQueryText,
		"&GroupRightsFilterCriterion", ?(RightsFilterFieldName = "IsAccessGroupsRights", "TRUE", "OldData.AreGroupSetRights"));
	
	BatchForUpdateSelectionQueryText = StrReplace(BatchForUpdateSelectionQueryText,
		"&GroupRightsFilterCriterion", ?(RightsFilterFieldName = "IsAccessGroupsRights", "TRUE", "OldData.AreGroupSetRights"));
	
	While True Do
		Query = New Query;
		Query.Text = BatchForLockSelectionQueryText;
		
		Query.SetParameter("AllowedEmptySet",
			AccessManagementInternalCached.AllowedBlankAccessGroupsSet());
		
		SetFilterCriterionInQuery(Query, GroupsSets, "GroupsSets",
			"&AccessGroupSetFilterCriterion1:GroupsInSets.Ref
			|&AccessGroupSetFilterCriterion2:&AllowedEmptySet
			|&AccessGroupSetFilterCriterion3:OldData." + GroupsSetFieldName);
		
		DataExported = Query.Execute().Unload();
		If DataExported.Count() = 0 Then
			Break;
		EndIf;
		
		Lock = New DataLock;
		For Each Row In DataExported Do
			LockItem = Lock.Add("InformationRegister." + RightsRegisterName);
			LockItem.SetValue(GroupsSetFieldName, Row[GroupsSetFieldName]);
			LockItem.SetValue("AccessKey",      Row.AccessKey);
		EndDo;
		
		DataExported.GroupBy("AccessKey");
		AccessKeys = DataExported.UnloadColumn("AccessKey");
		
		Query = New Query;
		Query.Text = BatchForUpdateSelectionQueryText;
		
		Query.SetParameter("AllowedEmptySet",
			AccessManagementInternalCached.AllowedBlankAccessGroupsSet());
		
		SetFilterCriterionInQuery(Query, GroupsSets, "GroupsSets",
			"&AccessGroupSetFilterCriterion1:GroupsInSets.Ref
			|&AccessGroupSetFilterCriterion2:&AllowedEmptySet
			|&AccessGroupSetFilterCriterion3:OldData." + GroupsSetFieldName);
		
		SetFilterCriterionInQuery(Query, AccessKeys, "AccessKeys",
			"&AccessKeyFilterCriterion1:AccessGroupsAccessKeys.AccessKey
			|&AccessKeyFilterCriterion2:AccessGroupsAccessKeys.AccessKey
			|&AccessKeyFilterCriterion3:OldData.AccessKey");
		
		RecordSet = ServiceRecordSet(InformationRegisters[RightsRegisterName]);
		
		BeginTransaction();
		Try
			Lock.Lock();
			Selection = Query.Execute().Select();
			
			DeletionCompleted = False;
			While Selection.Next() Do
				RecordSet.Filter[GroupsSetFieldName].Set(Selection[GroupsSetFieldName]);
				RecordSet.Filter.AccessKey.Set(Selection.AccessKey);
				If Not DeletionCompleted AND Selection.RowChangeKind = 1 Then
					DeletionCompleted = True;
					OneRecord = RecordSet.Add();
				EndIf;
				If DeletionCompleted Then
					FillPropertyValues(OneRecord, Selection);
				EndIf;
				RecordSet.Write();
			EndDo;
			
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	EndDo;
	
EndProcedure

// For the UpdateAccessGroupsSets procedure.
Procedure UpdateAllowedSetsAfterNewSetsAccessKeysUpdate(UpdateParameters, AccessGroupsSets)
	
	Query = New Query;
	Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	Catalog.AccessGroupsSets AS AccessGroupsSets
	|WHERE
	|	AccessGroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND (AccessGroupsSets.NewAccessGroupSet <> VALUE(Catalog.AccessGroupsSets.EmptyRef)
	|			OR AccessGroupsSets.NewUserGroupSet <> VALUE(Catalog.AccessGroupsSets.EmptyRef))";
	
	If Query.Execute().IsEmpty() Then
		Return;
	EndIf;
	
	Query.SetParameter("AccessGroupsSets", AccessGroupsSets);
	Query.Text =
	"SELECT
	|	AccessGroupsSets.Ref AS Ref,
	|	AccessGroupsSets.NewAccessGroupSet <> VALUE(Catalog.AccessGroupsSets.EmptyRef)
	|		AND AccessGroupsSets.NewAccessGroupSet IN (&AccessGroupsSets) AS UpdateAllowedAccessGroupSet,
	|	AccessGroupsSets.NewUserGroupSet <> VALUE(Catalog.AccessGroupsSets.EmptyRef)
	|		AND AccessGroupsSets.NewUserGroupSet IN (&AccessGroupsSets) AS UpdateAllowedUserGroupSet
	|FROM
	|	Catalog.AccessGroupsSets AS AccessGroupsSets
	|WHERE
	|	AccessGroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND (AccessGroupsSets.NewAccessGroupSet <> VALUE(Catalog.AccessGroupsSets.EmptyRef)
	|				AND AccessGroupsSets.NewAccessGroupSet IN (&AccessGroupsSets)
	|			OR AccessGroupsSets.NewUserGroupSet <> VALUE(Catalog.AccessGroupsSets.EmptyRef)
	|				AND AccessGroupsSets.NewUserGroupSet IN (&AccessGroupsSets))";
	
	Lock = New DataLock;
	Lock.Add("Catalog.AccessGroupsSets");
	
	BeginTransaction();
	Try
		Lock.Lock();
		Selection = Query.Execute().Select();
		While Selection.Next() Do
			Object = ServiceItem(Undefined, Selection.Ref);
			If Selection.UpdateAllowedAccessGroupSet Then
				Object.AllowedAccessGroupsSet = Object.NewAccessGroupSet;
				Object.NewAccessGroupSet = UpdateParameters.BlankAccessGroupsSet;
			EndIf;
			If Selection.UpdateAllowedUserGroupSet Then
				Object.AllowedUserGroupsSet = Object.NewUserGroupSet;
				Object.NewUserGroupSet = UpdateParameters.BlankAccessGroupsSet;
			EndIf;
			Object.Write();
		EndDo;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateAccessGroupsSets procedure.
Procedure UpdateGroupsSetsNonuseDate(CommonUpdateParameters)
	
	Query = New Query;
	Query.SetParameter("ForExternalUsers", CommonUpdateParameters.ForExternalUsers);
	Query.SetParameter("AllowedEmptySet",
		AccessManagementInternalCached.AllowedBlankAccessGroupsSet());
	
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	Catalog.AccessGroupsSets AS AccessGroupsSets
	|		LEFT JOIN Catalog.AccessGroupsSets AS SetsWithSingleUser
	|		ON (SetsWithSingleUser.ForExternalUsers = &ForExternalUsers)
	|			AND (SetsWithSingleUser.AllowedAccessGroupsSet = AccessGroupsSets.Ref
	|				OR SetsWithSingleUser.NewAccessGroupSet = AccessGroupsSets.Ref)
	|WHERE
	|	AccessGroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND AccessGroupsSets.SetItemsType = VALUE(Catalog.AccessGroups.EmptyRef)
	|	AND AccessGroupsSets.Ref <> &AllowedEmptySet
	|	AND (AccessGroupsSets.NotUsedSince = DATETIME(1, 1, 1)
	|				AND SetsWithSingleUser.Ref IS NULL
	|			OR AccessGroupsSets.NotUsedSince <> DATETIME(1, 1, 1)
	|				AND NOT SetsWithSingleUser.Ref IS NULL)
	|
	|UNION ALL
	|
	|SELECT TOP 1
	|	TRUE
	|FROM
	|	Catalog.AccessGroupsSets AS UserGroupSets
	|		LEFT JOIN Catalog.AccessGroupsSets AS SetsWithSingleUser
	|		ON (SetsWithSingleUser.ForExternalUsers = &ForExternalUsers)
	|			AND (SetsWithSingleUser.AllowedUserGroupsSet = UserGroupSets.Ref
	|				OR SetsWithSingleUser.NewUserGroupSet = UserGroupSets.Ref)
	|WHERE
	|	UserGroupSets.ForExternalUsers = &ForExternalUsers
	|	AND UserGroupSets.SetItemsType = VALUE(Catalog.UserGroups.EmptyRef)
	|	AND (UserGroupSets.NotUsedSince = DATETIME(1, 1, 1)
	|				AND SetsWithSingleUser.Ref IS NULL
	|			OR UserGroupSets.NotUsedSince <> DATETIME(1, 1, 1)
	|				AND NOT SetsWithSingleUser.Ref IS NULL)";
	
	If CommonUpdateParameters.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	
	If Query.Execute().IsEmpty() Then
		Return;
	EndIf;
	
	Query.Text =
	"SELECT DISTINCT
	|	AccessGroupsSets.Ref AS Ref,
	|	NOT SetsWithSingleUser.Ref IS NULL AS Used
	|FROM
	|	Catalog.AccessGroupsSets AS AccessGroupsSets
	|		LEFT JOIN Catalog.AccessGroupsSets AS SetsWithSingleUser
	|		ON (SetsWithSingleUser.ForExternalUsers = &ForExternalUsers)
	|			AND (SetsWithSingleUser.AllowedAccessGroupsSet = AccessGroupsSets.Ref
	|				OR SetsWithSingleUser.NewAccessGroupSet = AccessGroupsSets.Ref)
	|WHERE
	|	AccessGroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND AccessGroupsSets.SetItemsType = VALUE(Catalog.AccessGroups.EmptyRef)
	|	AND AccessGroupsSets.Ref <> &AllowedEmptySet
	|	AND (AccessGroupsSets.NotUsedSince = DATETIME(1, 1, 1)
	|				AND SetsWithSingleUser.Ref IS NULL
	|			OR AccessGroupsSets.NotUsedSince <> DATETIME(1, 1, 1)
	|				AND NOT SetsWithSingleUser.Ref IS NULL)
	|
	|UNION ALL
	|
	|SELECT DISTINCT
	|	UserGroupSets.Ref,
	|	NOT SetsWithSingleUser.Ref IS NULL
	|FROM
	|	Catalog.AccessGroupsSets AS UserGroupSets
	|		LEFT JOIN Catalog.AccessGroupsSets AS SetsWithSingleUser
	|		ON (SetsWithSingleUser.ForExternalUsers = &ForExternalUsers)
	|			AND (SetsWithSingleUser.AllowedUserGroupsSet = UserGroupSets.Ref
	|				OR SetsWithSingleUser.NewUserGroupSet = UserGroupSets.Ref)
	|WHERE
	|	UserGroupSets.ForExternalUsers = &ForExternalUsers
	|	AND UserGroupSets.SetItemsType = VALUE(Catalog.UserGroups.EmptyRef)
	|	AND (UserGroupSets.NotUsedSince = DATETIME(1, 1, 1)
	|				AND SetsWithSingleUser.Ref IS NULL
	|			OR UserGroupSets.NotUsedSince <> DATETIME(1, 1, 1)
	|				AND NOT SetsWithSingleUser.Ref IS NULL)";
	
	If CommonUpdateParameters.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	
	Lock = New DataLock;
	Lock.Add("Catalog.AccessGroupsSets");
	
	BeginTransaction();
	Try
		Lock.Lock();
		Selection = Query.Execute().Select();
		While Selection.Next() Do
			Object = ServiceItem(Undefined, Selection.Ref);
			If Selection.Used Then
				Object.NotUsedSince = '00010101';
			Else
				Object.NotUsedSince = CurrentSessionDate();
			EndIf;
			Object.Write();
		EndDo;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateAccessGroupsSets procedure.
Procedure DeleteObsoleteGroupSets(CommonUpdateParameters)
	
	Query = New Query;
	Query.SetParameter("DateOfBecomingObsolete", DateOfBecomingObsolete());
	Query.SetParameter("ForExternalUsers", CommonUpdateParameters.ForExternalUsers);
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	Catalog.AccessGroupsSets AS AccessGroupsSets
	|WHERE
	|	AccessGroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND AccessGroupsSets.SetItemsType IN (VALUE(Catalog.AccessGroups.EmptyRef), VALUE(Catalog.UserGroups.EmptyRef))
	|	AND AccessGroupsSets.NotUsedSince <> DATETIME(1, 1, 1)
	|	AND AccessGroupsSets.NotUsedSince < &DateOfBecomingObsolete";
	
	If CommonUpdateParameters.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	
	If Query.Execute().IsEmpty() Then
		Return;
	EndIf;
	
	Query.Text =
	"SELECT
	|	AccessGroupsSets.Ref AS Ref
	|FROM
	|	Catalog.AccessGroupsSets AS AccessGroupsSets
	|WHERE
	|	AccessGroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND AccessGroupsSets.SetItemsType IN (VALUE(Catalog.AccessGroups.EmptyRef), VALUE(Catalog.UserGroups.EmptyRef))
	|	AND AccessGroupsSets.NotUsedSince <> DATETIME(1, 1, 1)
	|	AND AccessGroupsSets.NotUsedSince < &DateOfBecomingObsolete";
	
	If CommonUpdateParameters.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	
	AccessGroupsSetsAccessKeysRecordSet = ServiceRecordSet(
		InformationRegisters.AccessGroupSetsAccessKeys);
	
	UsersAccessKeysRecordSet = ServiceRecordSet(
		InformationRegisters.UsersAccessKeys);
	
	ExternalUsersAccessKeysRecordSet = ServiceRecordSet(
		InformationRegisters.ExternalUsersAccessKeys);
	
	Lock = New DataLock;
	Lock.Add("Catalog.AccessGroupsSets");
	Lock.Add("InformationRegister.AccessGroupSetsAccessKeys");
	Lock.Add("InformationRegister.UsersAccessKeys");
	Lock.Add("InformationRegister.ExternalUsersAccessKeys");
	
	BeginTransaction();
	Try
		Lock.Lock();
		Selection = Query.Execute().Select();
		While Selection.Next() Do
			AccessGroupsSetsAccessKeysRecordSet.Filter.AccessGroupsSet.Set(Selection.Ref);
			AccessGroupsSetsAccessKeysRecordSet.Write();
			UsersAccessKeysRecordSet.Filter.User.Set(Selection.Ref);
			UsersAccessKeysRecordSet.Write();
			ExternalUsersAccessKeysRecordSet.Filter.ExternalUser.Set(Selection.Ref);
			ExternalUsersAccessKeysRecordSet.Write();
			Object = ServiceItem(Undefined, Selection.Ref);
			Object.Delete();
		EndDo;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure


// For the UpdateAccessKeysOfListDataItems and the UpdateAccessKeysOfDataItemsOnWrite procedures.
Procedure UpdateListDataItemsWithObsoleteAllowedKey(DataItems, UpdateParameters)
	
	If Not UpdateParameters.IsReferenceType Then
		Return;
	EndIf;
	
	Context = New Structure;
	Context.Insert("ObjectsRefs", DataItems.UnloadColumn("CurrentRef"));
	Context.Insert("ObjectsAccessKeysDetails", DataItems);
	
	AllowedAccessKey = AccessManagementInternalCached.AllowedAccessKey();
	
	DataItems.Columns.Add("KeyProperties", New TypeDescription("Structure"));
	DataItems.FillValues(New Structure("AccessKey", AllowedAccessKey), "KeyProperties");
	
	WriteObjectsAccessKeys(UpdateParameters, Context);
	
	If UpdateParameters.Property("UpdateRightsToKeys")
	   AND UpdateParameters.UpdateRightsToKeys Then
		
		UpdateRightsToAllowedAccessKey(UpdateParameters.HasRightsChanges);
	EndIf;
	
EndProcedure

// For the UpdateListDataItemsWithObsoleteAllowedKey procedure.
Procedure UpdateRightsToAllowedAccessKey(HasChanges = False)
	
	UpdateAccessGroupsOfAllowedAccessKey( , HasChanges);
	
EndProcedure

// For the UpdateRightsToAllowedAccessKey procedure.
Procedure UpdateAccessGroupsOfAllowedAccessKey(AccessGroups = Undefined, HasChanges = False) Export
	
	SetPrivilegedMode(True);
	AllowedAccessKey = AccessManagementInternalCached.AllowedAccessKey();
	AllowedBlankSet = AccessManagementInternalCached.AllowedBlankAccessGroupsSet();
	
	Lock = New DataLock;
	
	// Access group update in the AccessGroupsAccessKeys register.
	GroupsQuery = New Query;
	GroupsQuery.SetParameter("AccessKey", AllowedAccessKey);
	GroupsQuery.Text = SelectionQueryTextOfAllowedKeyAccessGroupsDifferences();
	SetFilterCriterionInQuery(GroupsQuery, AccessGroups, "AccessGroups",
		"&AccessGroupFilterCriterion1:AccessGroups.Ref
		|&AccessGroupFilterCriterion2:OldData.AccessGroup");
	
	GroupsLockItem = Lock.Add("InformationRegister.AccessGroupsAccessKeys");
	GroupsLockItem.SetValue("AccessKey", AllowedAccessKey);
	GroupsRecordSet = ServiceRecordSet(InformationRegisters.AccessGroupsAccessKeys);
	GroupsRecordSet.Filter.AccessKey.Set(AllowedAccessKey);
	
	// Updating access group sets in the AccessGroupsSetsAccessKeys register.
	RightsRequestForAccessGroups = New Query;
	RightsRequestForAccessGroups.SetParameter("AccessKey", AllowedAccessKey);
	RightsRequestForAccessGroups.SetParameter("AllowedEmptySet", AllowedBlankSet);
	RightsRequestForAccessGroups.Text = DifferencesSelectionOfDerivedRightsQueryTextForAccessGroups();
	
	LockItem = Lock.Add("InformationRegister.AccessGroupSetsAccessKeys");
	LockItem.SetValue("AccessKey", AllowedAccessKey);
	RightsForAccessGroups = ServiceRecordSet(InformationRegisters.AccessGroupSetsAccessKeys);
	RightsForAccessGroups.Filter.AccessKey.Set(AllowedAccessKey);
	
	// Updating access group sets in the UsersAccessKeys register.
	RightsRequestForUsers = New Query;
	RightsRequestForUsers.SetParameter("AccessKey", AllowedAccessKey);
	RightsRequestForUsers.SetParameter("AllowedEmptySet", AllowedBlankSet);
	RightsRequestForUsers.Text = StrReplace(DifferencesSelectionOfDerivedRightsQueryTextForUsers(),
		"OldData.AreGroupSetRights", "True");
	
	LockItem = Lock.Add("InformationRegister.UsersAccessKeys");
	LockItem.SetValue("AccessKey", AllowedAccessKey);
	RightsForUsers = ServiceRecordSet(InformationRegisters.UsersAccessKeys);
	RightsForUsers.Filter.AccessKey.Set(AllowedAccessKey);
	
	// Updating access group sets in the ExternalUsersAccessKeys register.
	RightsRequestForExternalUsers = New Query;
	RightsRequestForExternalUsers.SetParameter("AccessKey", AllowedAccessKey);
	RightsRequestForExternalUsers.SetParameter("AllowedEmptySet", AllowedBlankSet);
	RightsRequestForExternalUsers.Text = StrReplace(DifferencesSelectionOfDerivedRightsQueryTextForExternalUsers(),
		"OldData.AreGroupSetRights", "True");
	
	LockItem = Lock.Add("InformationRegister.ExternalUsersAccessKeys");
	LockItem.SetValue("AccessKey", AllowedAccessKey);
	RightsForExternalUsers = ServiceRecordSet(InformationRegisters.ExternalUsersAccessKeys);
	RightsForExternalUsers.Filter.AccessKey.Set(AllowedAccessKey);
	
	BeginTransaction();
	Try
		Lock.Lock();
		
		GroupsRequestResult = GroupsQuery.Execute();
		UpdateDerivedRightsToAccessKey(GroupsRequestResult,
			GroupsRecordSet, "AccessGroup", AllowedAccessKey, HasChanges);
		
		RightsRequestForAccessGroupsResult = RightsRequestForAccessGroups.Execute();
		UpdateDerivedRightsToAccessKey(RightsRequestForAccessGroupsResult,
			RightsForAccessGroups, "AccessGroupsSet", AllowedAccessKey, HasChanges);
		
		RightsRequestForUsersResult = RightsRequestForUsers.Execute();
		UpdateDerivedRightsToAccessKey(RightsRequestForUsersResult,
			RightsForUsers, "User", AllowedAccessKey, HasChanges);
		
		RightsRequestForExternalUsersResult = RightsRequestForExternalUsers.Execute();
		UpdateDerivedRightsToAccessKey(RightsRequestForExternalUsersResult,
			RightsForExternalUsers, "ExternalUser", AllowedAccessKey, HasChanges);
		
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateAllowedAccessKeyGroups procedure.
Function SelectionQueryTextOfAllowedKeyAccessGroupsDifferences()
	
	Return
	"SELECT
	|	AllRows.AccessGroup AS AccessGroup,
	|	AllRows.Update AS Update,
	|	AllRows.Insert AS Insert,
	|	AllRows.IsAccessGroupsRights AS IsAccessGroupsRights,
	|	AllRows.IsUsersRights AS IsUsersRights,
	|	AllRows.IsExternalUsersRights AS IsExternalUsersRights,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind
	|FROM
	|	(SELECT
	|		AccessGroups.Ref AS AccessGroup,
	|		TRUE AS Update,
	|		TRUE AS Insert,
	|		TRUE AS IsAccessGroupsRights,
	|		CASE
	|			WHEN TRUE IN
	|					(SELECT TOP 1
	|						TRUE
	|					FROM
	|						Catalog.AccessGroupProfiles.Purpose AS Purpose
	|					WHERE
	|						Purpose.Ref = AccessGroups.Profile
	|						AND VALUETYPE(Purpose.UsersType) = TYPE(Catalog.Users))
	|				THEN TRUE
	|			WHEN NOT FALSE IN
	|						(SELECT TOP 1
	|							FALSE
	|						FROM
	|							Catalog.AccessGroupProfiles.Purpose AS Purpose
	|						WHERE
	|							Purpose.Ref = AccessGroups.Profile)
	|				THEN TRUE
	|			ELSE FALSE
	|		END AS IsUsersRights,
	|		CASE
	|			WHEN TRUE IN
	|					(SELECT TOP 1
	|						TRUE
	|					FROM
	|						Catalog.AccessGroupProfiles.Purpose AS Purpose
	|					WHERE
	|						Purpose.Ref = AccessGroups.Profile
	|						AND Purpose.UsersType <> UNDEFINED
	|						AND VALUETYPE(Purpose.UsersType) <> TYPE(Catalog.Users))
	|				THEN TRUE
	|			ELSE FALSE
	|		END AS IsExternalUsersRights,
	|		1 AS RowChangeKind
	|	FROM
	|		Catalog.AccessGroups AS AccessGroups
	|			INNER JOIN Catalog.AccessGroupProfiles AS AccessGroupProfiles
	|			ON AccessGroups.Profile = AccessGroupProfiles.Ref
	|				AND (AccessGroups.Profile <> VALUE(Catalog.AccessGroupProfiles.Administrator))
	|				AND (NOT AccessGroups.DeletionMark)
	|				AND (NOT AccessGroupProfiles.DeletionMark)
	|				AND (&AccessGroupFilterCriterion1)
	|				AND (TRUE IN
	|					(SELECT TOP 1
	|						TRUE AS TrueValue
	|					FROM
	|						Catalog.AccessGroups.Users AS AccessGroupsMembers
	|					WHERE
	|						AccessGroupsMembers.Ref = AccessGroups.Ref))
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.AccessGroup,
	|		OldData.Update,
	|		OldData.Insert,
	|		OldData.IsAccessGroupsRights,
	|		OldData.IsUsersRights,
	|		OldData.IsExternalUsersRights,
	|		-1
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS OldData
	|	WHERE
	|		OldData.AccessKey = &AccessKey
	|		AND &AccessGroupFilterCriterion2) AS AllRows
	|
	|GROUP BY
	|	AllRows.AccessGroup,
	|	AllRows.Update,
	|	AllRows.Insert,
	|	AllRows.IsAccessGroupsRights,
	|	AllRows.IsUsersRights,
	|	AllRows.IsExternalUsersRights
	|
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0
	|
	|ORDER BY
	|	RowChangeKind";
	
EndFunction

// For the UpdateAccessKeysOfListDataItems and UpdateAccessKeysOfDataItemsOnWrite procedures.
Procedure ClearAccessKeysOfListDataItems(DataItems, UpdateParameters)
	
	If UpdateParameters.IsReferenceType Then
		SetOfOneRecord = ServiceRecordSet(InformationRegisters.AccessKeysForObjects);
		Lock = New DataLock;
		LockItem = Lock.Add("InformationRegister.AccessKeysForObjects");
		For Each Row In DataItems Do
			LockItem.SetValue("Object", Row.CurrentRef);
			SetOfOneRecord.Filter.Object.Set(Row.CurrentRef);
			LockSet = False;
			BeginTransaction();
			Try
				Lock.Lock();
				LockSet = True;
				If UpdateParameters.DoNotWriteAccessKeysForUsersAndExternalUsers Then
					SetOfOneRecord.Clear();
					SetOfOneRecord.Write();
				Else
					SetOfOneRecord.Read();
					If SetOfOneRecord.Count() > 0 Then
						If UpdateParameters.ForExternalUsers Then
							SetOfOneRecord[0].ExternalUsersAccessKey = Undefined;
						Else
							SetOfOneRecord[0].UsersAccessKey = Undefined;
						EndIf;
						If Not ValueIsFilled(SetOfOneRecord[0].ExternalUsersAccessKey)
						   AND Not ValueIsFilled(SetOfOneRecord[0].UsersAccessKey) Then
							SetOfOneRecord.Clear();
						EndIf;
						SetOfOneRecord.Write();
					EndIf;
				EndIf;
				CommitTransaction();
			Except
				RollbackTransaction();
				If LockSet Then
					Raise;
				EndIf;
			EndTry;
		EndDo;
		
		Return;
	EndIf;
	
	Lock = New DataLock;
	If ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
		RegisterName = UpdateParameters.SeparateKeysRegisterName;
	Else
		RegisterName = "AccessKeysForRegisters";
	EndIf;
	LockItem = Lock.Add("InformationRegister." + RegisterName);
	If Not ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
		LockItem.SetValue("Register", UpdateParameters.ListID);
	EndIf;
	SetOfOneRecord = ServiceRecordSet(InformationRegisters[RegisterName]);
	
	For Each Row In DataItems Do
		LockItem.SetValue("ForExternalUsers", Row.ForExternalUsers);
		For Each Column In DataItems.Columns Do
			DimensionName = Column.Name;
			LockItem.SetValue(DimensionName, Row[DimensionName]);
			SetOfOneRecord.Filter[DimensionName].Set(Row[DimensionName]);
		EndDo;
		LockSet = False;
		BeginTransaction();
		Try
			Lock.Lock();
			LockSet = True;
			SetOfOneRecord.Write();
			CommitTransaction();
		Except
			RollbackTransaction();
			If LockSet Then
				Raise;
			EndIf;
		EndTry;
	EndDo;
	
EndProcedure

// For the UpdateAccessKeysToListDataItems procedure.
Procedure UpdateListDataItemsWithObsoleteKeys(DataItems, UpdateParameters)
	
	DataItemsValuesQuery = New Query;
	DataItemsValuesQuery.Text = UpdateParameters.DataItemValueForAccessKeysQueryText;
	
	KeysValuesQuery = New Query;
	KeysValuesQuery.Text = UpdateParameters.ValueFromAccessKeysForComparisonQueryText;
	
	Context = New Structure;
	Context.Insert("DataItemsValuesQuery", DataItemsValuesQuery);
	Context.Insert("KeysValuesQuery", KeysValuesQuery);
	
	BatchSize = 100; // Import N data items, 100 at a time.
	
	Index = 0;
	While Index < DataItems.Count() Do
		
		DataItemsBatch = DataItems.Copy(New Array);
		If Not UpdateParameters.IsReferenceType Then
			DataItemsBatch.Columns.Add("CurrentRef", New TypeDescription("Number"));
			DeletedDataItemsBatch = New Array;
		EndIf;
		
		While Index < DataItems.Count()
		   AND DataItemsBatch.Count() < BatchSize Do
			
			DataItem = DataItems[Index];
			Index = Index + 1;
			
			If Not UpdateParameters.IsReferenceType
			   AND IncorrectCombinationOfBasicFieldsValues(DataItem, UpdateParameters) Then
				
				DeletedDataItemsBatch.Add(DataItem);
				Continue;
			EndIf;
			
			NewRow = DataItemsBatch.Add();
			FillPropertyValues(NewRow, DataItem);
			If Not UpdateParameters.IsReferenceType Then
				NewRow.CurrentRef = DataItemsBatch.IndexOf(NewRow) + 1;
			EndIf;
		EndDo;
		
		If Not UpdateParameters.IsReferenceType
		   AND DeletedDataItemsBatch.Count() > 0 Then
			
			DeleteIncorrectBasicFieldsValuesCombinations(DeletedDataItemsBatch, UpdateParameters);
		EndIf;
		
		Context.Insert("DataItemsBatch", DataItemsBatch);
		UpdateAccessKeysOfListDataItemsBatch(UpdateParameters, Context);
	EndDo;
	
EndProcedure

// For the UpdateListDataItemsWithObsoleteKeys function.
Function IncorrectCombinationOfBasicFieldsValues(DataItem, UpdateParameters)
	
	Number = 1;
	For Each FieldTypesStorage In UpdateParameters.BasicFields.UsedItemsTypes Do
		FieldTypes = FieldTypesStorage.Get();
		
		If Not FieldTypes.ContainsType(TypeOf(DataItem["Field" + Number]))
		   AND DataItem["Field" + Number] <> Undefined Then
			
			Return True;
		EndIf;
		
		Number = Number + 1;
	EndDo;
	
	Return False;
	
EndFunction

// For the UpdateListDataItemsWithObsoleteKeys and UpdateAccessKeysOfDataItemsOnWrite function.
Procedure UpdateAccessKeysOfListDataItemsBatch(UpdateParameters, Context)
	
	IsReferenceType       = UpdateParameters.IsReferenceType;
	ListID   = UpdateParameters.ListID;
	DataItemsBatch = Context.DataItemsBatch;
	
	If IsReferenceType Then
		Context.Insert("ObjectsRefs", DataItemsBatch.UnloadColumn("CurrentRef"));
		Context.DataItemsValuesQuery.SetParameter("ObjectsRefs", Context.ObjectsRefs);
	Else
		Context.DataItemsValuesQuery.SetParameter("RegisterID", ListID);
		Context.DataItemsValuesQuery.SetParameter("BasicFieldsValues",  DataItemsBatch);
	EndIf;
	ItemsValuesQueryResults = Context.DataItemsValuesQuery.ExecuteBatch();
	
	StringAccessKeysData = New Map;
	KeyTables = UpdateParameters.KeyTables;
	
	TablesRowsValues = New Map;
	ObjectsRowsValuesKeys = ObjectsRowsValuesKeys(ItemsValuesQueryResults,
		?(IsReferenceType, 0, 1), KeyTables, TablesRowsValues);
	
	RequiredAccessKeys         = New Array;
	RequiredAccessKeysHash    = New Array;
	ObjectsAccessKeysDetails = New Array;
	For Each DataItem In DataItemsBatch Do
		ValuesKeysDetails = ObjectsRowsValuesKeys.Get(DataItem.CurrentRef);
		StringForHash = StringForAccessKeyHash(ValuesKeysDetails, KeyTables);
		Properties = StringAccessKeysData.Get(StringForHash);
		If Properties = Undefined Then
			Properties = New Structure("TablesValues, StringForHash, Hash, AccessKey, TablesColumnsValues");
			StringAccessKeysData.Insert(StringForHash, Properties);
			TablesValues = New Array;
			For Each TableName In KeyTables Do
				ValuesKey = ValuesKeysDetails.ValuesKeys[KeyTables.Find(TableName)];
				RowsValues = TablesRowsValues.Get(TableName).Get(ValuesKey);
				If RowsValues = Undefined Then
					RowsValues = New Array;
				EndIf;
				TablesValues.Add(New Structure("TableName, Table", TableName, RowsValues));
			EndDo;
			Properties.TablesValues = TablesValues;
			Properties.StringForHash = StringForHash;
			Properties.TablesColumnsValues = ValuesKeysDetails.TablesColumnsValues;
			Hashing = New DataHashing(HashFunction.CRC32);
			Hashing.Append(StringForHash);
			Properties.Hash = Hashing.HashSum;
			RequiredAccessKeys.Add(Properties);
			RequiredAccessKeysHash.Add(Properties.Hash);
		EndIf;
		ObjectsAccessKeysDetails.Add(
			New Structure("CurrentRef, KeyProperties", DataItem.CurrentRef, Properties));
	EndDo;
	Context.Insert("ObjectsAccessKeysDetails", ObjectsAccessKeysDetails);
	
	// Receiving data of existing access keys by hash of required access keys.
	Context.KeysValuesQuery.SetParameter("Hashes",   RequiredAccessKeysHash);
	Context.KeysValuesQuery.SetParameter("List", UpdateParameters.ListID);
	KeysValuesQueryResults = Context.KeysValuesQuery.ExecuteBatch();
	
	KeyTablesRowsValues = New Map;
	HasHeader = StrStartsWith(KeyTables[0], "Header");
	KeysRowsValuesKeys = ObjectsRowsValuesKeys(KeysValuesQueryResults,
		?(HasHeader, 0, 1), KeyTables, KeyTablesRowsValues);
	
	For Each AccessKeyDetails In KeysRowsValuesKeys Do
		StringForHash = StringForAccessKeyHash(AccessKeyDetails.Value, KeyTables);
		Properties = StringAccessKeysData.Get(StringForHash);
		If Properties <> Undefined AND Properties.AccessKey = Undefined Then
			Properties.AccessKey = AccessKeyDetails.Key;
		EndIf;
	EndDo;
	
	UpdateParameters.Insert("AllowedAccessKeysValuesTypes",
		AccessManagementInternalCached.AllowedAccessKeysValuesTypes());
	
	NewAccessKeys = New Array;
	Try
		// Creating missing access keys.
		For Each KeyDetails In RequiredAccessKeys Do
			If KeyDetails.AccessKey <> Undefined Then
				Continue;
			EndIf;
			CheckAccessKeyValueType(KeyDetails, UpdateParameters);
			NewAccessKey = NewAccessKey(KeyDetails, UpdateParameters);
			NewAccessKeys.Add(NewAccessKey);
			KeyDetails.AccessKey = NewAccessKey;
		EndDo;
	Except
		If Not TransactionActive() Then
			PlanningParameters = AccessUpdatePlanningParameters();
			PlanningParameters.DataAccessKeys = False;
			ScheduleAccessUpdate(UpdateParameters.List, PlanningParameters);
		EndIf;
		Raise;
	EndTry;
	
	If UpdateParameters.Property("UpdateRightsToKeys")
	   AND UpdateParameters.UpdateRightsToKeys Then
		
		AllBatchAccessKeys = New Array;
		For Each KeyDetails In RequiredAccessKeys Do
			AllBatchAccessKeys.Add(KeyDetails.AccessKey);
		EndDo;
		UpdateRightsToAccessKeys(AllBatchAccessKeys, UpdateParameters,
			NewAccessKeys.Count() > 0);
		
	ElsIf NewAccessKeys.Count() > 0 Then
		UpdateRightsToAccessKeys(NewAccessKeys, UpdateParameters, True);
	EndIf;
	
	// Updating access keys of data items.
	If IsReferenceType Then
		WriteObjectsAccessKeys(UpdateParameters, Context);
	Else
		WriteRegistersAccessKeys(UpdateParameters, Context);
	EndIf;
	
EndProcedure

// For the UpdateAccessKeysOfListDataItemsBatch procedure.
Procedure UpdateRightsToAccessKeys(AccessKeys, UpdateParameters, NewKeys = False)
	
	If Not UpdateParameters.Property("Cache") Then
		UpdateParameters.Insert("Cache", New Structure);
	EndIf;
	
	Try
		UpdateRightsOfListAccessKeysBatch(UpdateParameters, AccessKeys);
	Except
		If NewKeys AND Not TransactionActive() Then
			PlanningParameters = AccessUpdatePlanningParameters();
			PlanningParameters.DataAccessKeys = False;
			ScheduleAccessUpdate(UpdateParameters.List, PlanningParameters);
		EndIf;
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateAccessKeysOfListDataItemsBatch procedure.
Function StringForAccessKeyHash(ValuesKeysDetails, KeyTables)
	
	If ValuesKeysDetails = Undefined Then
		ValuesKeysDetails = New Structure(
			"ValuesKeys, TablesNames, TablesColumnsValues",
			New Array, New Array, New Array);
	EndIf;
	
	ValuesKeys = ValuesKeysDetails.ValuesKeys;
	TablesNames   = ValuesKeysDetails.TablesNames;
	
	If TablesNames.Count() <> KeyTables.Count() Then
		// The access key uses tabular sections and some blank ones.
		For Index = 0 To KeyTables.Count() - 1 Do
			
			If Index >= TablesNames.Count()
			 Or TablesNames[Index] <> KeyTables[Index] Then
				
				TablesNames.Insert(Index, KeyTables[Index]);
				ValuesKeys.Insert(Index, "6ab8db6a-4878-483a-b9d5-ef905ff1537e");
			EndIf;
		EndDo;
	EndIf;
	
	Return StrConcat(ValuesKeys);
	
EndFunction

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Procedure WriteObjectsAccessKeys(UpdateParameters, Context)
	
	If UpdateParameters.WriteAccessKeysForUsersAndExternalUsers Then
		CurrentKeysQuery = New Query;
		CurrentKeysQuery.Text =
		"SELECT
		|	AccessKeysForObjects.Object AS Object,
		|	AccessKeysForObjects.UsersAccessKey AS UsersAccessKey,
		|	AccessKeysForObjects.ExternalUsersAccessKey AS ExternalUsersAccessKey
		|FROM
		|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|WHERE
		|	AccessKeysForObjects.Object IN (&ObjectsRefs)";
		CurrentKeysQuery.SetParameter("ObjectsRefs", Context.ObjectsRefs);
	EndIf;
	
	If UpdateParameters.ForExternalUsers Then
		KeyToSaveAttributeName = "UsersAccessKey";
		KeyToUpdateAttributeName = "ExternalUsersAccessKey";
	Else
		KeyToSaveAttributeName = "ExternalUsersAccessKey";
		KeyToUpdateAttributeName = "UsersAccessKey";
	EndIf;
	
	SetOfOneRecord = ServiceRecordSet(InformationRegisters.AccessKeysForObjects);
	Record = SetOfOneRecord.Add();
	Lock = New DataLock;
	ObjectType = Metadata.InformationRegisters.AccessKeysForObjects.Dimensions.Object.Type;
	If Not ObjectType.ContainsType(TypeOf(Context.ObjectsAccessKeysDetails[0].CurrentRef)) Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Невозможно обновить ключ доступа объекта ""%1"" типа ""%2"",
			           |так как этот тип не указан в определяемом типе AccessKeysValuesOwner.'; 
			           |en = 'Cannot update access key of the ""%1"" object of the ""%2"" type
			           |as this type is not specified in the AccessKeysValuesOwner defined type.'; 
			           |pl = 'Nie można zaktualizować klucza dostępu ""%1"" obiektu typu ""%2"", ponieważ ten typ
			           |nie jest określony w AccessKeysValuesOwner defined type.';
			           |es_ES = 'Es imposible actualizar una clave de acceso del objeto ""%1"" del tipo ""%2"",
			           |porque este tipo no se ha indicado en el tipo determinado AccessKeysValuesOwner.';
			           |es_CO = 'Es imposible actualizar una clave de acceso del objeto ""%1"" del tipo ""%2"",
			           |porque este tipo no se ha indicado en el tipo determinado AccessKeysValuesOwner.';
			           |tr = '""%1"" tür ""%2"" nesnenin erişim anahtarı güncellenemiyor, çünkü bu tür ErişimAnahtarıDeğerlerininSahibi 
			           |belirlenmiş türünde belirtilmedi.';
			           |it = 'Impossibile aggiornare la chiave di accesso dell''oggetto ""%1"" del tipo ""%2""
			           |poiché questo tipo non è indicato nel tipo definito AccessKeysValuesOwner.';
			           |de = 'Es ist nicht möglich, den Zugriffsschlüssel des Objekts ""%1"" des Typs ""%2"" zu aktualisieren,
			           |da dieser Typ im definierten Typ AccessKeysValuesOwner nicht angegeben ist.'"),
			String(Context.ObjectsAccessKeysDetails[0].CurrentRef),
			String(TypeOf(Context.ObjectsAccessKeysDetails[0].CurrentRef)),
			UpdateParameters.List);
		Raise ErrorText;
	EndIf;
	For Each ObjectAccessKeyDetails In Context.ObjectsAccessKeysDetails Do
		LockItem = Lock.Add("InformationRegister.AccessKeysForObjects");
		LockItem.SetValue("Object", ObjectAccessKeyDetails.CurrentRef);
	EndDo;
	
	ListsForUpdate = New Map;
	For Each DependentList In UpdateParameters.DependentListsByAccessKeys Do
		Properties = New Structure("ForUsers, ForExternalUsers", False, False);
		If UpdateParameters.ForExternalUsers Then
			Properties.ForExternalUsers = True;
		Else
			Properties.ForUsers = True;
		EndIf;
		ListsForUpdate.Insert(DependentList, Properties);
	EndDo;
	
	BeginTransaction();
	Try
		Lock.Lock();
		If UpdateParameters.WriteAccessKeysForUsersAndExternalUsers Then
			CurrentKeys = CurrentKeysQuery.Execute().Unload();
		EndIf;
		For Each ObjectAccessKeyDetails In Context.ObjectsAccessKeysDetails Do
			SetOfOneRecord.Filter.Object.Set(ObjectAccessKeyDetails.CurrentRef);
			Record.Object = ObjectAccessKeyDetails.CurrentRef;
			Record[KeyToUpdateAttributeName] = ObjectAccessKeyDetails.KeyProperties.AccessKey;
			
			If UpdateParameters.WriteAccessKeysForUsersAndExternalUsers Then
				Row = CurrentKeys.Find(ObjectAccessKeyDetails.CurrentRef, "Object");
				If Row <> Undefined Then
					Record[KeyToSaveAttributeName] = Row[KeyToSaveAttributeName];
				EndIf;
			EndIf;
			SetOfOneRecord.Write();
		EndDo;
		ScheduleUpdateOfObsoleteAccessKeys(ListsForUpdate,
			UpdateParameters.TransactionID);
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Procedure WriteRegistersAccessKeys(UpdateParameters, Context)
	
	If Not ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
		KeysRegisterName = "AccessKeysForRegisters";
	Else
		KeysRegisterName = UpdateParameters.SeparateKeysRegisterName;
	EndIf;
	SetOfOneRecord = ServiceRecordSet(InformationRegisters[KeysRegisterName]);
	Record = SetOfOneRecord.Add();
	
	BlankBasicFieldsValues = AccessManagementInternalCached.BlankBasicFieldsValues(
		UpdateParameters.BasicFields.MaxCount);
	
	Lock = New DataLock;
	For Each ObjectAccessKeyDetails In Context.ObjectsAccessKeysDetails Do
		LockItem = Lock.Add("InformationRegister." + KeysRegisterName);
		If Not ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
			LockItem.SetValue("Register", UpdateParameters.ListID);
		EndIf;
		LockItem.SetValue("ForExternalUsers", UpdateParameters.ForExternalUsers);
		DataItem = Context.DataItemsBatch.Find(ObjectAccessKeyDetails.CurrentRef, "CurrentRef");
		For FieldNumber = 1 To UpdateParameters.BasicFields.Used.Count() Do
			FieldName = "Field" + FieldNumber;
			LockItem.SetValue(FieldName, DataItem[FieldName]);
		EndDo;
	EndDo;
	
	BeginTransaction();
	Try
		Lock.Lock();
		For Each ObjectAccessKeyDetails In Context.ObjectsAccessKeysDetails Do
			If Not ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
				SetOfOneRecord.Filter.Register.Set(UpdateParameters.ListID);
				Record.Register = UpdateParameters.ListID;
			EndIf;
			SetOfOneRecord.Filter.ForExternalUsers.Set(UpdateParameters.ForExternalUsers);
			Record.ForExternalUsers = UpdateParameters.ForExternalUsers;
			
			DataItem = Context.DataItemsBatch.Find(ObjectAccessKeyDetails.CurrentRef, "CurrentRef");
			FillPropertyValues(Record, BlankBasicFieldsValues);
			For FieldNumber = 1 To UpdateParameters.BasicFields.Used.Count() Do
				FieldName = "Field" + FieldNumber;
				If DataItem[FieldName] = Undefined Then
					SetOfOneRecord.Filter[FieldName].Value = Undefined;
					SetOfOneRecord.Filter[FieldName].Use = True;
				Else
					SetOfOneRecord.Filter[FieldName].Set(DataItem[FieldName]);
				EndIf;
				Record[FieldName] = DataItem[FieldName];
			EndDo;
			
			Record.AccessKey = ObjectAccessKeyDetails.KeyProperties.AccessKey;
			SetOfOneRecord.Write();
		EndDo;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateListDataItemsWithObsoleteKeys function.
Procedure DeleteIncorrectBasicFieldsValuesCombinations(DataItemsBatch, UpdateParameters)
	
	If Not ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
		KeysRegisterName = "AccessKeysForRegisters";
	Else
		KeysRegisterName = UpdateParameters.SeparateKeysRegisterName;
	EndIf;
	SetOfOneRecord = ServiceRecordSet(InformationRegisters[KeysRegisterName]);
	
	Lock = New DataLock;
	For Each DataItem In DataItemsBatch Do
		LockItem = Lock.Add("InformationRegister." + KeysRegisterName);
		If Not ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
			LockItem.SetValue("Register", UpdateParameters.ListID);
		EndIf;
		LockItem.SetValue("ForExternalUsers", UpdateParameters.ForExternalUsers);
		For FieldNumber = 1 To UpdateParameters.BasicFields.Used.Count() Do
			FieldName = "Field" + FieldNumber;
			LockItem.SetValue(FieldName, DataItem[FieldName]);
		EndDo;
	EndDo;
	
	BeginTransaction();
	Try
		Lock.Lock();
		For Each DataItem In DataItemsBatch Do
			If Not ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
				SetOfOneRecord.Filter.Register.Set(UpdateParameters.ListID);
			EndIf;
			For FieldNumber = 1 To UpdateParameters.BasicFields.Used.Count() Do
				FieldName = "Field" + FieldNumber;
				SetOfOneRecord.Filter[FieldName].Set(DataItem[FieldName]);
			EndDo;
			SetOfOneRecord.Write();
		EndDo;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Function ObjectsRowsValuesKeys(QueryResults, Index, KeyTables, TablesRowsValues)
	
	ObjectsRowsValuesKeys = New Map;
	
	For Each AccessKeyTableName In KeyTables Do
		TableRowsValues = TablesRowsValues.Get(AccessKeyTableName);
		If TableRowsValues = Undefined Then
			TableRowsValues = New Map;
			TablesRowsValues.Insert(AccessKeyTableName, TableRowsValues);
		EndIf;
		Tree = QueryResults[Index].Unload(QueryResultIteration.ByGroups);
		Index = Index + 1;
		For Each Row In Tree.Rows Do
			TableColumnsValues = New Array;
			For Each Column In Tree.Columns Do
				If StrStartsWith(Column.Name, "Value") Then
					TableColumnsValues.Add(Row.Rows.UnloadColumn(Column.Name));
				EndIf;
			EndDo;
			RowsValuesKey = DataStringForHashing(TableColumnsValues);
			If TableRowsValues.Get(RowsValuesKey) = Undefined Then
				TableRowsValues.Insert(RowsValuesKey, Row.Rows);
			EndIf;
			ValuesKeysDetails = ObjectsRowsValuesKeys.Get(Row.CurrentRef);
			If ValuesKeysDetails = Undefined Then
				ValuesKeysDetails = New Structure(
					"ValuesKeys, TablesNames, TablesColumnsValues",
					New Array, New Array, New Array);
				ObjectsRowsValuesKeys.Insert(Row.CurrentRef, ValuesKeysDetails);
			EndIf;
			ValuesKeysDetails.TablesNames.Add(AccessKeyTableName);
			ValuesKeysDetails.ValuesKeys.Add(RowsValuesKey);
			ValuesKeysDetails.TablesColumnsValues.Add(TableColumnsValues);
		EndDo;
	EndDo;
	
	Return ObjectsRowsValuesKeys;
	
EndFunction

// For the ObjectsRowsValuesKeys function and other.
Function DataStringForHashing(Data)
	
	// Returns a data string for further hashing, for example, string description of references stored 
	// in the database, considering types by internal IDs, which ensures that the hash sum remains 
	// unchanged upon changing names of tables and attributes, and ensures that the data hash 
	// corresponds to the data stored in the database.
	// 
	//
	// This allows you to avoid excessive mass recreation of access keys with subsequent recalculation 
	// of users and access groups for the recreated access keys.
	
	Return ValueToStringInternal(Data);
	
EndFunction

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Procedure CheckAccessKeyValueType(KeyDetails, UpdateParameters)
	
	AllowedAccessKeysValuesTypes = UpdateParameters.AllowedAccessKeysValuesTypes;
	TablesColumnsValues = KeyDetails.TablesColumnsValues;
	
	For Each TableColumnsValues In TablesColumnsValues Do
		For Each TableColumnValues In TableColumnsValues Do
			For Each Value In TableColumnValues Do
				If Not AllowedAccessKeysValuesTypes.ContainsType(TypeOf(Value)) Then
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Невозможно сохранить значение ""%1"" типа ""%2""
						           |при обновлении ключей доступа списка ""%3"",
						           |так как этот тип не указан в определяемом типе AccessValue.'; 
						           |en = 'Cannot save the ""%1"" value of the ""%2"" type
						           |while updating access keys of the ""%3"" list
						           |as this type is not specified in the AccessValue defined type.'; 
						           |pl = 'Nie można zapisać wartość ""%1"" jak ""%2""
						           |w przypadku aktualizacji kluczy dostępu listy""%3"",
						           |ponieważ ten typ nie znajduje się w określonym typie AccessValue.';
						           |es_ES = 'Es imposible guardar un valor ""%1"" del tipo ""%2"",
						           |al actualizar las claves de acceso de la lista ""%3"",
						           |porque este tipo no está indicado en el tipo determinado AccessValue.';
						           |es_CO = 'Es imposible guardar un valor ""%1"" del tipo ""%2"",
						           |al actualizar las claves de acceso de la lista ""%3"",
						           |porque este tipo no está indicado en el tipo determinado AccessValue.';
						           |tr = 'Bu tür belirtilen ErişimDeğeri türünde listelenmediğinden "
" liste erişim anahtarlarını güncelleştirdiğinizde %3 ""%1"" türü ""%2"" değeri 
						           |kaydedilemiyor.';
						           |it = 'Impossibile salvare il valore ""%1"" del tipo ""%2""
						           |durante l''aggiornamento delle chiavi di accesso dell''elenco ""%3""
						           |poiché questo tipo non è indicato nel tipo definito AccessValue.';
						           |de = 'Es ist nicht möglich, den Wert von ""%1"" des Typs ""%2""
						           |bei der Aktualisierung der Zugriffsschlüssel der Liste ""%3"" zu speichern,
						           |da dieser Typ im definierten Typ AccessValue nicht angegeben ist.'"),
						String(Value),
						String(TypeOf(Value)),
						UpdateParameters.List);
					Raise ErrorText;
				EndIf;
			EndDo;
		EndDo;
	EndDo;
	
EndProcedure

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Function NewAccessKey(KeyDetails, UpdateParameters)
	
	NewRef = Catalogs.AccessKeys.GetRef();
	NewKey = ServiceItem(Catalogs.AccessKeys);
	
	NewKey.SetNewObjectRef(NewRef);
	NewKey.Description            = String(NewRef.UUID());
	NewKey.List                  = UpdateParameters.ListID;
	NewKey.FieldsComposition             = UpdateParameters.FieldsComposition;
	NewKey.ForExternalUsers = UpdateParameters.ForExternalUsers;
	NewKey.Hash                     = KeyDetails.Hash;
	
	For Each TableValues In KeyDetails.TablesValues Do
		If StrStartsWith(TableValues.TableName, "Header") Then
			If StrEndsWith(TableValues.TableName, "0") Then
				FillPropertyValues(NewKey, TableValues.Table[0],, "Parent");
			Else
				RowNumber = Number(Right(TableValues.TableName, 1));
				NewKey.Header.Add();
				FillPropertyValues(NewKey.Header[RowNumber - 1], TableValues.Table[0]);
			EndIf;
		Else
			For Each Row In TableValues.Table Do
				FillPropertyValues(NewKey[TableValues.TableName].Add(), Row);
			EndDo;
		EndIf;
	EndDo;
	
	NewKey.Write();
	
	Return NewKey.Ref;
	
EndFunction

// For the ExecuteListAccessUpdate procedures.
Procedure UpdateListUsersAccessKeys(MetadataObject, CommonUpdateParameters, ProcessingCompleted)
	
	If TypeOf(MetadataObject) <> Type("MetadataObject") Then
		// Clearing records of non-existent metadata objects.
		BlankSet = ServiceRecordSet(InformationRegisters.UsersAccessKeysUpdate);
		BlankSet.Filter.List.Set(CommonUpdateParameters.ListID);
		BlankSet.Write();
		Return;
	EndIf;
	
	If Not CommonUpdateParameters.Property("Cache") Then
		CommonUpdateParameters.Insert("Cache", New Structure);
	EndIf;
	
	UpdateParameters = New Structure;
	UpdateParameters.Insert("List",                  MetadataObject.FullName());
	UpdateParameters.Insert("ListID",     CommonUpdateParameters.ListID);
	UpdateParameters.Insert("ForExternalUsers", CommonUpdateParameters.ForExternalUsers);
	UpdateParameters.Insert("Cache",                     CommonUpdateParameters.Cache);
	
	If CommonUpdateParameters.Property("BatchFromSet") Then
		UpdateRightsToListAccessKeys(UpdateParameters,
			CommonUpdateParameters.BatchFromSet.AccessKeys.Get());
		
		CommonUpdateParameters.Insert("NewLastUpdatedAccessKey",
			UpdateParameters.NewLastUpdatedAccessKey);
		Return;
	EndIf;
	
	UpdateParameters.Insert("InitialUpdate", CommonUpdateParameters.InitialUpdate);
	UpdateParameters.Insert("GetPortions",      CommonUpdateParameters.GetPortions);
	
	Query = New Query;
	Query.SetParameter("List",                  UpdateParameters.ListID);
	Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
	Query.Text =
	"SELECT TOP 1000
	|	UniqueKeys.UniqueKey AS UniqueKey,
	|	UniqueKeys.LastUpdatedAccessKey AS LastUpdatedAccessKey
	|FROM
	|	InformationRegister.UsersAccessKeysUpdate AS UniqueKeys
	|WHERE
	|	UniqueKeys.List = &List
	|	AND UniqueKeys.ForExternalUsers = &ForExternalUsers";
	DataExported = Query.Execute().Unload();
	
	If DataExported.Count() = 0 Then
		If UpdateParameters.GetPortions > 0
		   AND CommonUpdateParameters.Property("LastAccessKeyInPortion") Then
			
			CommonUpdateParameters.Insert("BatchesSet", Undefined);
		EndIf;
		Return;
	EndIf;
	
	MaxDate = MaxDate();
	
	If DataExported.Count() = 1
	   AND Not ValueIsFilled(DataExported[0].UniqueKey) Then
		
		LastUpdatedAccessKey = DataExported[0].LastUpdatedAccessKey.Get();
	Else
		LastUpdatedAccessKey = Undefined;
		
		If UpdateParameters.GetPortions > 0
		   AND CommonUpdateParameters.Property("LastAccessKeyInPortion") Then
			
			CommonUpdateParameters.Insert("BatchesSet", Undefined);
			ProcessingCompleted = False;
			Return;
		EndIf;
		
		KeysUpdateSchedule = ServiceRecordSet(InformationRegisters.UsersAccessKeysUpdate);
		KeysUpdateSchedule.Filter.List.Set(UpdateParameters.ListID);
		KeysUpdateSchedule.Filter.ForExternalUsers.Set(UpdateParameters.ForExternalUsers);
		KeysUpdateSchedule.Filter.UniqueKey.Set(
			New UUID("00000000-0000-0000-0000-000000000000"));
		
		Lock = New DataLock;
		LockItem = Lock.Add("InformationRegister.UsersAccessKeysUpdate");
		LockItem.SetValue("List", UpdateParameters.ListID);
		LockItem.SetValue("ForExternalUsers", UpdateParameters.ForExternalUsers);
		LockItem.SetValue("UniqueKey",
			New UUID("00000000-0000-0000-0000-000000000000"));
		
		For Each Row In DataExported Do
			If Not ValueIsFilled(Row.UniqueKey) Then
				Continue;
			EndIf;
			LockItem = Lock.Add("InformationRegister.UsersAccessKeysUpdate");
			LockItem.SetValue("List", UpdateParameters.ListID);
			LockItem.SetValue("ForExternalUsers", UpdateParameters.ForExternalUsers);
			LockItem.SetValue("UniqueKey", Row.UniqueKey);
			Break;
		EndDo;
		
		Query.Text = StrReplace(Query.Text, "SELECT TOP 1000", "SELECT TOP 1");
		JobsDeleted = False;
		
		BeginTransaction();
		Try
			Lock.Lock();
			If Query.Execute().IsEmpty() Then
				JobsDeleted = True;
			Else
				Record = KeysUpdateSchedule.Add();
				Record.List                      = UpdateParameters.ListID;
				Record.ForExternalUsers     = UpdateParameters.ForExternalUsers;
				Record.RegisterRecordChangeDate = CurrentSessionDate();
				KeysUpdateSchedule.Write();
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If JobsDeleted Then
			If UpdateParameters.GetPortions > 0
			   AND CommonUpdateParameters.Property("LastAccessKeyInPortion") Then
				
				CommonUpdateParameters.Insert("BatchesSet", Undefined);
			EndIf;
			Return;
		EndIf;
		
		KeysUpdateSchedule.Clear();
		For Each Row In DataExported Do
			If Not ValueIsFilled(Row.UniqueKey) Then
				Continue;
			EndIf;
			KeysUpdateSchedule.Filter.UniqueKey.Set(Row.UniqueKey);
			KeysUpdateSchedule.Write();
		EndDo;
		If DataExported.Count() = 1000 Then
			ProcessingCompleted = False;
		EndIf;
	EndIf;
	
	If UpdateParameters.GetPortions > 0
	   AND CommonUpdateParameters.Property("LastAccessKeyInPortion") Then
		
		UpdateParameters.Insert("LastAccessKeyInPortion");
		LastUpdatedAccessKey = CommonUpdateParameters.LastAccessKeyInPortion;
	EndIf;
	
	UpdateParameters.Insert("LastUpdatedAccessKey", LastUpdatedAccessKey);
	UpdateParameters.Insert("NewLastUpdatedAccessKey", Undefined);
	
	UpdateRightsToListAccessKeys(UpdateParameters);
	
	If UpdateParameters.Property("BatchesSet") Then
		CommonUpdateParameters.Insert("BatchesSet", UpdateParameters.BatchesSet);
		ProcessingCompleted = False;
		Return;
	EndIf;
	
	UpdateListUsersAccessKeysCompletion(CommonUpdateParameters,
		UpdateParameters.NewLastUpdatedAccessKey, ProcessingCompleted);
	
EndProcedure

// For the UpdateListUsersAccessKeys and CheckCompleteUpdateByBatches procedures.
Procedure UpdateListUsersAccessKeysCompletion(CommonUpdateParameters, LastUpdatedAccessKey, ProcessingCompleted = True)
	
	KeysUpdateSchedule = ServiceRecordSet(InformationRegisters.UsersAccessKeysUpdate);
	KeysUpdateSchedule.Filter.List.Set(CommonUpdateParameters.ListID);
	KeysUpdateSchedule.Filter.ForExternalUsers.Set(CommonUpdateParameters.ForExternalUsers);
	KeysUpdateSchedule.Filter.UniqueKey.Set(
		New UUID("00000000-0000-0000-0000-000000000000"));
	
	Lock = New DataLock;
	LockItem = Lock.Add("InformationRegister.UsersAccessKeysUpdate");
	LockItem.SetValue("List", CommonUpdateParameters.ListID);
	LockItem.SetValue("ForExternalUsers", CommonUpdateParameters.ForExternalUsers);
	LockItem.SetValue("UniqueKey", New UUID("00000000-0000-0000-0000-000000000000"));
	
	BeginTransaction();
	Try
		Lock.Lock();
		KeysUpdateSchedule.Read();
		If KeysUpdateSchedule.Count() > 0 Then
			If LastUpdatedAccessKey = Undefined Then
				KeysUpdateSchedule.Clear();
			Else
				Record = KeysUpdateSchedule[0];
				Record.RegisterRecordChangeDate     = CurrentSessionDate();
				Record.LastUpdatedAccessKey = New ValueStorage(LastUpdatedAccessKey);
				ProcessingCompleted = False;
			EndIf;
			KeysUpdateSchedule.Write();
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateListDataAccessKeys procedure.
Procedure UpdateRightsToListAccessKeys(UpdateParameters, AccessKeys = Undefined)
	
	TransactionID = New UUID;
	ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(UpdateParameters.List, TransactionID);
	RestrictionParameters = RestrictionParameters(UpdateParameters.List,
		TransactionID, UpdateParameters.ForExternalUsers);
	
	RestrictionParameters = New Structure(RestrictionParameters);
	For Each KeyAndValue In UpdateParameters Do
		RestrictionParameters.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	UpdateParameters = RestrictionParameters;
	UpdateParameters.Insert("TransactionID", TransactionID);
	
	UsersKindPropertyName = ?(UpdateParameters.ForExternalUsers,
		"ForExternalUsers", "ForUsers");
	
	If ListPropertiesAsLeadingOne = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName] = Undefined Then
		
		UpdateParameters.Insert("DependentListsByAccessKeys", New Array);
	Else
		UpdateParameters.Insert("DependentListsByAccessKeys",
			ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName]);
	EndIf;
	
	If UpdateParameters.RestrictionDisabled
	 Or UpdateParameters.AccessDenied
	 Or UpdateParameters.UsesRestrictionByOwner Then
		
		DeleteListAccessKeysBatch(UpdateParameters);
		Return;
	EndIf;
	
	UpdateRightsOfListAccessKeysBatch(UpdateParameters, AccessKeys);
	
EndProcedure

// For the UpdateRightsToListAccessKeys and UpdateRightsToAccessKeys procedures.
Procedure UpdateRightsOfListAccessKeysBatch(UpdateParameters, AccessKeys)
	
	Query = New Query;
	Query.SetParameter("List", UpdateParameters.ListID);
	
	If AccessKeys = Undefined Then
		If Common.IsReference(TypeOf(UpdateParameters.LastUpdatedAccessKey)) Then
			Query.SetParameter("LastAccessKey", UpdateParameters.LastUpdatedAccessKey);
		Else
			Query.SetParameter("LastAccessKey", Undefined);
		EndIf;
		
		SetKeysBatch = 200;
		BatchSize = AccessKeysBatchSize();
		If UpdateParameters.InitialUpdate Then
			BatchSize = Int(BatchSize / 100);
			
		ElsIf UpdateParameters.GetPortions > 0
			    AND (    BatchSize < UpdateParameters.GetPortions * SetKeysBatch
			       Or UpdateParameters.Property("LastAccessKeyInPortion")) Then
			
			BatchSize = UpdateParameters.GetPortions * SetKeysBatch;
		EndIf;
		BatchSize = ?(BatchSize < 25, 25, ?(BatchSize > 10000, 10000, BatchSize));
		
		If UpdateParameters.GetPortions > 0 Then
			Query.Text = StrSplit(UpdateParameters.ValueFromAccessKeysForRightsCalculationQueryText, ";", False)[0];
			Query.Text = TrimAll(StrReplace(Query.Text, "INTO KeysBatch" + Chars.LF, ""));
			Query.Text = StrReplace(Query.Text, "INDEX", "ORDER");
		Else
			Query.Text = UpdateParameters.ValueFromAccessKeysForRightsCalculationQueryText;
		EndIf;
		
		Query.Text = StrReplace(Query.Text, BatchSizeMarker(), Format(BatchSize, "NG="));
		
		If UpdateParameters.GetPortions > 0 Then
			QueryResult = Query.Execute();
			If QueryResult.IsEmpty() Then
				If Not UpdateParameters.Property("LastAccessKeyInPortion") Then
					Return;
				EndIf;
				UpdateParameters.Insert("BatchesSet", New Array);
				BatchFromSet = New Structure("AccessKeys", Undefined);
				UpdateParameters.BatchesSet.Add(BatchFromSet);
				Return;
			EndIf;
			AccessKeys = QueryResult.Unload().UnloadColumn("Ref");
			
			If UpdateParameters.Property("LastAccessKeyInPortion")
			 Or AccessKeys.Count() > SetKeysBatch * 2 Then
				
				BatchesSet = New Array;
				UpdateParameters.Insert("BatchesSet", BatchesSet);
				Index = 0;
				For Each AccessKey In AccessKeys Do
					If Index / SetKeysBatch = Int(Index / SetKeysBatch) Then
						BatchFromSet = New Array;
						BatchesSet.Add(BatchFromSet);
					EndIf;
					BatchFromSet.Add(AccessKey);
					Index = Index + 1;
				EndDo;
				For Index = 0 To BatchesSet.Count() - 1 Do
					BatchAccessKeys = BatchesSet[Index];
					BatchFromSet = New Structure;
					BatchesSet[Index] = BatchFromSet;
					BatchFromSet.Insert("AccessKeys", New ValueStorage(BatchAccessKeys));
					BatchFromSet.Insert("LastAccessKeyInPortion",
						BatchAccessKeys[BatchAccessKeys.Count()-1]);
				EndDo;
				If AccessKeys.Count() < BatchSize Then
					BatchFromSet.LastAccessKeyInPortion = Undefined;
				EndIf;
				Return;
			EndIf;
		EndIf;
	EndIf;
	
	If AccessKeys <> Undefined Then
		Query.Text = UpdateParameters.ValueFromAccessKeysForRightsCalculationQueryText;
		Query.SetParameter("AccessKeys", AccessKeys);
		Query.Text = StrReplace(UpdateParameters.ValueFromAccessKeysForRightsCalculationQueryText,
			"AND AccessKeys.Ref > &LastAccessKey",
			"AND AccessKeys.Ref IN (&AccessKeys)");
	EndIf;
	
	Query.SetParameter("RightSettingsTableID", UpdateParameters.RightSettingsTableID);
	Query.SetParameter("EmptyUniqueID",
		New UUID("00000000-0000-0000-0000-000000000000"));
	
	QueryResults = Query.ExecuteBatch();
	If QueryResults[1].IsEmpty() Then
		Return;
	EndIf;
	
	UpdateParameters.Insert("UserType", ?(UpdateParameters.ForExternalUsers,
		Type("CatalogRef.ExternalUsers"), Type("CatalogRef.Users")));
	
	UpdateParameters.Insert("UserGroupType", ?(UpdateParameters.ForExternalUsers,
		Type("CatalogRef.ExternalUsersGroups"), Type("CatalogRef.UserGroups")));
	
	UpdateParameters.Insert("AccessGroupType",    Type("CatalogRef.AccessGroups"));
	UpdateParameters.Insert("BlankAccessGroup", Catalogs.AccessGroups.EmptyRef());
	
	KeysTablesValues = New Map;
	TableNumber = 0;
	For Each KeyTable In UpdateParameters.KeyTables Do
		TableNumber = TableNumber + 1;
		KeysTablesValues.Insert(KeyTable,
			QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups));
	EndDo;
	FillRightsToLeadingAccessKeysAndLeadingLists(QueryResults, TableNumber, UpdateParameters);
	FillRightsByRightsSettingsOwners(QueryResults, TableNumber, UpdateParameters);
	
	FillListAccessGroupsRightsAndMembers(UpdateParameters);
	FillAccessGroupsValuesToCalculateRights(UpdateParameters);
	
	FirstTableValues = KeysTablesValues.Get(UpdateParameters.KeyTables[0]);
	LastKeyIndex = FirstTableValues.Rows.Count() - 1;
	
	For KeyIndex = 0 To LastKeyIndex Do
		KeyTablesValues = New Structure;
		For Each KeyTable In UpdateParameters.KeyTables Do
			TableValues = KeysTablesValues.Get(KeyTable).Rows[KeyIndex].Rows;
			If StrStartsWith(KeyTable, "Header") Then
				TableValues = TableValues[0];
			EndIf;
			KeyTablesValues.Insert(KeyTable, TableValues);
		EndDo;
		AccessKey = FirstTableValues.Rows[KeyIndex].Ref;
		RightsToKey = RightsToListAccessKey(UpdateParameters, KeyTablesValues, AccessKey);
		UpdateRightsToListAccessKey(UpdateParameters, AccessKey, RightsToKey);
	EndDo;
	
	If BatchSize <> Undefined AND FirstTableValues.Rows.Count() < BatchSize Then
		Return;
	EndIf;
	
	LastAccessKey = FirstTableValues.Rows[LastKeyIndex].Ref;
	
	UpdateParameters.Insert("NewLastUpdatedAccessKey", LastAccessKey);
	
EndProcedure

// For the UpdateRightsToListAccessKeys procedure.
Procedure DeleteListAccessKeysBatch(UpdateParameters)
	
	Query = New Query;
	Query.SetParameter("List",                  UpdateParameters.ListID);
	Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
	
	Query.Text =
	"SELECT TOP 1000
	|	AccessKeys.Ref AS Ref,
	|	TRUE IN
	|		(SELECT TOP 1
	|			TRUE
	|		FROM
	|			InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|		WHERE
	|			AccessGroupsAccessKeys.AccessKey = AccessKeys.Ref) AS ClearAccessGroupAccessKeys,
	|	TRUE IN
	|		(SELECT TOP 1
	|			TRUE
	|		FROM
	|			InformationRegister.AccessGroupSetsAccessKeys AS AccessGroupSetsAccessKeys
	|		WHERE
	|			AccessGroupSetsAccessKeys.AccessKey = AccessKeys.Ref) AS ClearAccessGroupSetAccessKeys,
	|	TRUE IN
	|		(SELECT TOP 1
	|			TRUE
	|		FROM
	|			InformationRegister.UsersAccessKeys AS UsersAccessKeys
	|		WHERE
	|			UsersAccessKeys.AccessKey = AccessKeys.Ref) AS ClearUserAccessKeys,
	|	TRUE IN
	|		(SELECT TOP 1
	|			TRUE
	|		FROM
	|			InformationRegister.ExternalUsersAccessKeys AS ExternalUsersAccessKeys
	|		WHERE
	|			ExternalUsersAccessKeys.AccessKey = AccessKeys.Ref) AS ClearExternalUserAccessKeys
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|WHERE
	|	AccessKeys.List = &List
	|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
	|
	|ORDER BY
	|	AccessKeys.DeletionMark DESC,
	|	AccessKeys.Ref";
	
	QueryResult = Query.Execute();
	
	If QueryResult.IsEmpty() Then
		Return;
	EndIf;
	
	DataExported = QueryResult.Unload();
	
	Context = New Structure;
	Context.Insert("AccessGroupsAccessKeys",
		ServiceRecordSet(InformationRegisters.AccessGroupsAccessKeys));
	Context.Insert("AccessGroupSetsAccessKeys",
		ServiceRecordSet(InformationRegisters.AccessGroupSetsAccessKeys));
	Context.Insert("UsersAccessKeys",
		ServiceRecordSet(InformationRegisters.UsersAccessKeys));
	Context.Insert("ExternalUsersAccessKeys",
		ServiceRecordSet(InformationRegisters.ExternalUsersAccessKeys));
	
	AllDeleted = True;
	KeysBatch = New Array;
	For Each Row In DataExported Do
		If KeysBatch.Count() < 50 Then
			KeysBatch.Add(Row);
			Continue;
		EndIf;
		DeleteCurrentListAccessKeysBatch(Context, KeysBatch, AllDeleted);
		KeysBatch = New Array;
	EndDo;
	
	If KeysBatch.Count() > 0 Then
		DeleteCurrentListAccessKeysBatch(Context, KeysBatch, AllDeleted);
	EndIf;
	
	If Not AllDeleted Or DataExported.Count() = 1000 Then
		UpdateParameters.Insert("NewLastUpdatedAccessKey", Undefined);
	EndIf;
	
EndProcedure

// For the DeleteListAccessKeysBatch procedure.
Procedure DeleteCurrentListAccessKeysBatch(Context, KeysBatch, AllDeleted)
	
	Lock = New DataLock;
	For Each KeyDetails In KeysBatch Do
		LockItem = Lock.Add("Catalog.AccessKeys");
		LockItem.SetValue("Ref", KeyDetails.Ref);
		If KeyDetails.ClearAccessGroupAccessKeys Then
			LockItem = Lock.Add("InformationRegister.AccessGroupsAccessKeys");
			LockItem.SetValue("AccessKey", KeyDetails.Ref);
		EndIf;
		If KeyDetails.ClearAccessGroupSetAccessKeys Then
			LockItem = Lock.Add("InformationRegister.AccessGroupSetsAccessKeys");
			LockItem.SetValue("AccessKey", KeyDetails.Ref);
		EndIf;
		If KeyDetails.ClearUserAccessKeys Then
			LockItem = Lock.Add("InformationRegister.UsersAccessKeys");
			LockItem.SetValue("AccessKey", KeyDetails.Ref);
		EndIf;
		If KeyDetails.ClearExternalUserAccessKeys Then
			LockItem = Lock.Add("InformationRegister.ExternalUsersAccessKeys");
			LockItem.SetValue("AccessKey", KeyDetails.Ref);
		EndIf;
	EndDo;
	
	LockSet = False;
	BeginTransaction();
	Try
		Lock.Lock();
		LockSet = True;
		For Each KeyDetails In KeysBatch Do
			AccessKeyObject = KeyDetails.Ref.GetObject();
			If AccessKeyObject <> Undefined Then
				InfobaseUpdate.DeleteData(AccessKeyObject, False, False);
			EndIf;
			If KeyDetails.ClearAccessGroupAccessKeys Then
				Context.AccessGroupsAccessKeys.Filter.AccessKey.Set(KeyDetails.Ref);
				Context.AccessGroupsAccessKeys.Write();
			EndIf;
			If KeyDetails.ClearAccessGroupSetAccessKeys Then
				Context.AccessGroupSetsAccessKeys.Filter.AccessKey.Set(KeyDetails.Ref);
				Context.AccessGroupSetsAccessKeys.Write();
			EndIf;
			If KeyDetails.ClearUserAccessKeys Then
				Context.UsersAccessKeys.Filter.AccessKey.Set(KeyDetails.Ref);
				Context.UsersAccessKeys.Write();
			EndIf;
			If KeyDetails.ClearExternalUserAccessKeys Then
				Context.ExternalUsersAccessKeys.Filter.AccessKey.Set(KeyDetails.Ref);
				Context.ExternalUsersAccessKeys.Write();
			EndIf;
		EndDo;
		CommitTransaction();
	Except
		RollbackTransaction();
		If LockSet Then
			Raise;
		Else
			AllDeleted = False;
		EndIf;
	EndTry;
	
EndProcedure

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillListAccessGroupsRightsAndMembers(UpdateParameters)
	
	Query = New Query;
	Query.SetParameter("Table", UpdateParameters.ListID);
	Query.Text =
	"SELECT
	|	Profiles.Ref AS Profile,
	|	MAX(CASE
	|			WHEN ProfilesPurpose.UsersType IS NULL
	|				THEN TRUE
	|			ELSE VALUETYPE(ProfilesPurpose.UsersType) = TYPE(Catalog.Users)
	|		END) AS ForUsers,
	|	MAX(CASE
	|			WHEN ProfilesPurpose.UsersType IS NULL
	|				THEN FALSE
	|			ELSE ProfilesPurpose.UsersType <> UNDEFINED
	|					AND VALUETYPE(ProfilesPurpose.UsersType) <> TYPE(Catalog.Users)
	|		END) AS ForExternalUsers
	|INTO ProfilesPurpose
	|FROM
	|	Catalog.AccessGroupProfiles AS Profiles
	|		LEFT JOIN Catalog.AccessGroupProfiles.Purpose AS ProfilesPurpose
	|		ON (ProfilesPurpose.Ref = Profiles.Ref)
	|
	|GROUP BY
	|	Profiles.Ref
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	AccessGroupsTables.AccessGroup AS AccessGroup,
	|	AccessGroupsTables.Update AS Update,
	|	AccessGroupsTables.Insert AS Insert,
	|	AccessGroupsTables.ReadWithoutRestriction AS ReadWithoutRestriction,
	|	AccessGroupsTables.UpdateWithoutRestriction AS UpdateWithoutRestriction,
	|	AccessGroupsTables.InsertWithoutRestriction AS InsertWithoutRestriction
	|FROM
	|	InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|		INNER JOIN Catalog.AccessGroups AS AccessGroups
	|		ON (AccessGroupsTables.Table = &Table)
	|			AND (AccessGroups.Ref = AccessGroupsTables.AccessGroup)
	|		INNER JOIN ProfilesPurpose AS ProfilesPurpose
	|		ON (ProfilesPurpose.Profile = AccessGroups.Profile)
	|			AND (ProfilesPurpose.ForUsers)";
	
	MembersQueryText =
	"SELECT DISTINCT
	|	AccessGroups.Ref AS Ref
	|INTO AccessGroups
	|FROM
	|	(SELECT
	|		AccessGroupsTables.AccessGroup AS Ref
	|	FROM
	|		InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|			INNER JOIN Catalog.AccessGroups AS AccessGroups
	|			ON (AccessGroupsTables.Table = &Table)
	|				AND (AccessGroups.Ref = AccessGroupsTables.AccessGroup)
	|			INNER JOIN ProfilesPurpose AS ProfilesPurpose
	|			ON (ProfilesPurpose.Profile = AccessGroups.Profile)
	|				AND (ProfilesPurpose.ForUsers)
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		AccessGroups.Ref
	|	FROM
	|		Catalog.AccessGroups AS AccessGroups
	|			INNER JOIN ProfilesPurpose AS ProfilesPurpose
	|			ON (ProfilesPurpose.Profile = AccessGroups.Profile)
	|				AND (ProfilesPurpose.ForUsers)
	|				AND (AccessGroups.Ref IN (&AdditionalAccessGroups))) AS AccessGroups
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	UserGroups.Ref AS Ref
	|INTO UserGroups
	|FROM
	|	(SELECT DISTINCT
	|		AccessGroupUsers.User AS Ref
	|	FROM
	|		Catalog.AccessGroups.Users AS AccessGroupUsers
	|			INNER JOIN AccessGroups AS AccessGroups
	|			ON (AccessGroups.Ref = AccessGroupUsers.Ref)
	|	WHERE
	|		VALUETYPE(AccessGroupUsers.User) = TYPE(Catalog.UserGroups)
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		UserGroups.Ref
	|	FROM
	|		Catalog.UserGroups AS UserGroups
	|	WHERE
	|		UserGroups.Ref IN(&AdditionalUserGroups)) AS UserGroups
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	UserGroupCompositions.UsersGroup AS UsersGroup,
	|	UserGroupCompositions.User AS User
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		INNER JOIN UserGroups AS UserGroups
	|		ON (UserGroups.Ref = UserGroupCompositions.UsersGroup)
	|			AND (UserGroupCompositions.Used)
	|		INNER JOIN Catalog.Users AS Users
	|		ON (Users.Ref = UserGroupCompositions.User)
	|			AND (Users.IBUserID <> &EmptyUniqueID)
	|TOTALS BY
	|	UsersGroup
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	AccessGroupUsers.Ref AS AccessGroup,
	|	AccessGroupUsers.User AS Member
	|FROM
	|	Catalog.AccessGroups.Users AS AccessGroupUsers
	|		INNER JOIN AccessGroups AS AccessGroups
	|		ON (AccessGroups.Ref = AccessGroupUsers.Ref)
	|			AND (TRUE IN
	|				(SELECT TOP 1
	|					TRUE
	|				FROM
	|					InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|						INNER JOIN Catalog.Users AS Users
	|						ON
	|							UserGroupCompositions.UsersGroup = AccessGroupUsers.User
	|								AND UserGroupCompositions.Used
	|								AND Users.Ref = UserGroupCompositions.User
	|								AND Users.IBUserID <> &EmptyUniqueID))
	|TOTALS BY
	|	AccessGroup";
	
	If UpdateParameters.CalculateUserRights Then
		If UpdateParameters.ForExternalUsers Then
			MembersQueryText = StrReplace(MembersQueryText,
				"Catalog.Users", "Catalog.ExternalUsers");
			MembersQueryText = StrReplace(MembersQueryText,
				"Catalog.UserGroups", "Catalog.ExternalUsersGroups");
		EndIf;
		
		Query.Text = Query.Text + Common.QueryBatchSeparator() + MembersQueryText;
		Query.SetParameter("EmptyUniqueID",
			New UUID("00000000-0000-0000-0000-000000000000"));
		
		AdditionalAccessGroups       = New Array;
		AdditionalUserGroups = New Array;
		Query.SetParameter("AdditionalAccessGroups",       AdditionalAccessGroups);
		Query.SetParameter("AdditionalUserGroups", AdditionalUserGroups);
		
		AddedAccessGroups          = New Map;
		AddedUserGroups    = New Map;
		AccessGroupType       = UpdateParameters.AccessGroupType;
		UserGroupType = UpdateParameters.UserGroupType;
		
		For Each KeyAndValue In UpdateParameters.RightsToLeadingAccessKeys Do
			For Each RightsDetails In KeyAndValue.Value Do
				If TypeOf(RightsDetails.Key) = AccessGroupType Then
					If AddedAccessGroups.Get(RightsDetails.Key) <> Undefined Then
						AddedAccessGroups.Insert(RightsDetails.Key, True);
						AdditionalAccessGroups.Add(RightsDetails.Key);
					EndIf;
				ElsIf TypeOf(RightsDetails.Key) = UserGroupType Then
					If AddedUserGroups.Get(RightsDetails.Key) <> Undefined Then
						AddedUserGroups.Insert(RightsDetails.Key, True);
						AdditionalUserGroups.Add(RightsDetails.Key);
					EndIf;
				EndIf;
			EndDo;
		EndDo;
		For Each KeyAndValue In UpdateParameters.RightsByRightsSettingsOwners Do
			For Each RightsDetails In KeyAndValue.Value Do
				If TypeOf(RightsDetails.Key) = UserGroupType Then
					If AddedUserGroups.Get(RightsDetails.Key) <> Undefined Then
						AddedUserGroups.Insert(RightsDetails.Key, True);
						AdditionalUserGroups.Add(RightsDetails.Key);
					EndIf;
				EndIf;
			EndDo;
		EndDo;
	EndIf;
	
	If UpdateParameters.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text,
			"ProfilesPurpose.ForUsers", "ProfilesPurpose.ForExternalUsers");
	EndIf;
	
	QueryResults = Query.ExecuteBatch();
	
	Selection = QueryResults[1].Select();
	ListAccessGroupsRights = New Map;
	
	While Selection.Next() Do
		AccessGroupRights = New Structure;
		AccessGroupRights.Insert("Update",                Selection.Update);
		AccessGroupRights.Insert("Insert",               Selection.Insert);
		AccessGroupRights.Insert("ReadWithoutRestriction",     Selection.ReadWithoutRestriction);
		AccessGroupRights.Insert("UpdateWithoutRestriction",  Selection.UpdateWithoutRestriction);
		AccessGroupRights.Insert("InsertWithoutRestriction", Selection.InsertWithoutRestriction);
		ListAccessGroupsRights.Insert(Selection.AccessGroup, AccessGroupRights);
	EndDo;
	UpdateParameters.Insert("ListAccessGroupsRights", ListAccessGroupsRights);
	
	UserGroupsUsers = New Map;
	
	If UpdateParameters.CalculateUserRights Then
		Tree = QueryResults[4].Unload(QueryResultIteration.ByGroups);
		For Each Row In Tree.Rows Do
			UserGroupUsers = New Map;
			For Each Substring In Row.Rows Do
				UserGroupUsers.Insert(Substring.User, True);
			EndDo;
			UserGroupsUsers.Insert(Row.UsersGroup, UserGroupUsers);
		EndDo;
	EndIf;
	UpdateParameters.Insert("UserGroupsUsers", UserGroupsUsers);
	
	AccessGroupsMembers           = New Map;
	AccessGroupsUserGroups = New Map;
	UserGroupType = UpdateParameters.UserGroupType;
	
	If UpdateParameters.CalculateUserRights Then
		Tree = QueryResults[5].Unload(QueryResultIteration.ByGroups);
		For Each Row In Tree.Rows Do
			AccessGroupMembers = New Map;
			AccessGroupUserGroups = New Map;
			For Each Substring In Row.Rows Do
				AccessGroupMembers.Insert(Substring.Member, True);
				If TypeOf(Substring.Member) = UserGroupType Then
					GroupUsers = UserGroupsUsers.Get(Substring.Member);
					If GroupUsers <> Undefined Then
						AccessGroupUserGroups.Insert(Substring.Member, GroupUsers);
					EndIf;
				EndIf;
			EndDo;
			If AccessGroupMembers.Count() > 0 Then
				AccessGroupsMembers.Insert(Row.AccessGroup, AccessGroupMembers);
			EndIf;
			If AccessGroupUserGroups.Count() > 0 Then
				AccessGroupsUserGroups.Insert(Row.AccessGroup, AccessGroupUserGroups);
			EndIf;
		EndDo;
	EndIf;
	UpdateParameters.Insert("AccessGroupsMembers",           AccessGroupsMembers);
	UpdateParameters.Insert("AccessGroupsUserGroups", AccessGroupsUserGroups);
	
EndProcedure

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillAccessGroupsValuesToCalculateRights(UpdateParameters)
	
	If Not UpdateParameters.Cache.Property("AccessGroupsValuesVersion") Then
		UpdateParameters.Cache.Insert("AccessGroupsValuesVersion", New UUID);
	EndIf;
	
	VersionParameterName = "StandardSubsystems.AccessManagement.AccessGroupsValuesVersion";
	AccessGroupsValuesVersion = StandardSubsystemsServer.ExtensionParameter(VersionParameterName, True);
	
	If UpdateParameters.Cache.AccessGroupsValuesVersion = AccessGroupsValuesVersion Then
		UpdateParameters.Insert("AccessGroupsValues", UpdateParameters.Cache.AccessGroupsValues);
		Return;
	EndIf;
	
	ParameterName = "StandardSubsystems.AccessManagement.AccessGroupsValues";
	AccessGroupsValues = StandardSubsystemsServer.ExtensionParameter(ParameterName, True);
	
	If AccessGroupsValuesVersion <> Undefined AND AccessGroupsValues <> Undefined Then
		UpdateParameters.Cache.Insert("AccessGroupsValuesVersion", AccessGroupsValuesVersion);
		UpdateParameters.Cache.Insert("AccessGroupsValues", AccessGroupsValues);
		UpdateParameters.Insert("AccessGroupsValues", AccessGroupsValues);
		Return;
	EndIf;
	
	AccessGroupsValuesVersion = New UUID;
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	DefaultAccessGroupsValues.AccessGroup AS AccessGroup,
	|	VALUETYPE(DefaultAccessGroupsValues.AccessValuesType) AS AccessValuesType,
	|	DefaultAccessGroupsValues.AllAllowed AS AllAllowed
	|FROM
	|	InformationRegister.DefaultAccessGroupsValues AS DefaultAccessGroupsValues
	|WHERE
	|	NOT DefaultAccessGroupsValues.NoSettings
	|TOTALS BY
	|	AccessGroup
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	AccessGroupsValues.AccessGroup AS AccessGroup,
	|	VALUETYPE(AccessGroupsValues.AccessValue) AS AccessValuesType,
	|	AccessGroupsValues.AccessValue AS AccessValue
	|FROM
	|	InformationRegister.AccessGroupsValues AS AccessGroupsValues
	|TOTALS BY
	|	AccessGroup,
	|	AccessValuesType";
	QueryResults = Query.ExecuteBatch();
	
	AccessGroupsValues = New Map;
	
	Tree = QueryResults[0].Unload(QueryResultIteration.ByGroups);
	For Each Row In Tree.Rows Do
		AccessGroupValues = New Map;
		For Each Substring In Row.Rows Do
			ValuesOfOneType = New Structure;
			ValuesOfOneType.Insert("AllAllowed", Substring.AllAllowed);
			ValuesOfOneType.Insert("Values",     New Map);
			AccessGroupValues.Insert(Substring.AccessValuesType, ValuesOfOneType);
		EndDo;
		AccessGroupsValues.Insert(Row.AccessGroup, AccessGroupValues);
	EndDo;
	
	Tree = QueryResults[1].Unload(QueryResultIteration.ByGroups);
	For Each Row In Tree.Rows Do
		AccessGroupValues = AccessGroupsValues.Get(Row.AccessGroup);
		If AccessGroupValues = Undefined Then
			Continue;
		EndIf;
		For Each Substring In Row.Rows Do
			ValuesOfOneType = AccessGroupValues.Get(Substring.AccessValuesType);
			If ValuesOfOneType = Undefined Then
				Continue;
			EndIf;
			Values = ValuesOfOneType.Values;
			For Each ValueDetails In Substring.Rows Do
				Values.Insert(ValueDetails.AccessValue, True);
			EndDo;
		EndDo;
	EndDo;
	
	StandardSubsystemsServer.SetExtensionParameter(ParameterName, AccessGroupsValues, True);
	StandardSubsystemsServer.SetExtensionParameter(VersionParameterName, AccessGroupsValuesVersion, True);
	
	UpdateParameters.Cache.Insert("AccessGroupsValuesVersion", AccessGroupsValuesVersion);
	UpdateParameters.Cache.Insert("AccessGroupsValues", AccessGroupsValues);
	UpdateParameters.Insert("AccessGroupsValues", AccessGroupsValues);
	
EndProcedure

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillRightsToLeadingAccessKeysAndLeadingLists(QueryResults, TableNumber, UpdateParameters)
	
	RightsToLeadingAccessKeysLists = New Map;
	RightsToLeadingAccessKeys = New Map;
	If UpdateParameters.HasMasterAccessKeys Then
		ActiveParameters = ActiveAccessRestrictionParameters(UpdateParameters.TransactionID, Undefined);
		If UpdateParameters.ForExternalUsers Then
			AdditionalContext = ActiveParameters.AdditionalContext.ForExternalUsers;
		Else
			AdditionalContext = ActiveParameters.AdditionalContext.ForUsers;
		EndIf;
		TableNumber = TableNumber + 1;
		RightsToLists = New Map;
		Tree = QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups);
		ListsIDs = Tree.Rows.UnloadColumn("List");
		If UpdateParameters.Cache.Property("MetadataObjectsByIDs") Then
			MetadataObjectsByIDs = UpdateParameters.Cache.MetadataObjectsByIDs;
			NotFoundListsIDs = New Array;
			For Each ListID In ListsIDs Do
				If MetadataObjectsByIDs.Get(ListID) = Undefined Then
					NotFoundListsIDs.Add(ListID);
				EndIf;
			EndDo;
			Result = Catalogs.MetadataObjectIDs.MetadataObjectsByIDs(
				NotFoundListsIDs, True);
			For Each KeyAndValue In Result Do
				MetadataObjectsByIDs.Insert(KeyAndValue.Key, KeyAndValue.Value);
			EndDo;
		Else
			MetadataObjectsByIDs =
				Catalogs.MetadataObjectIDs.MetadataObjectsByIDs(
					ListsIDs, True);
		EndIf;
		For Each Row In Tree.Rows Do
			MetadataObject = MetadataObjectsByIDs.Get(Row.List);
			If TypeOf(MetadataObject) <> Type("MetadataObject") Then
				Continue;
			EndIf;
			FullName = MetadataObject.FullName();
			ByAccessGroups = New Map;
			For Each Substring In Row.Rows Do
				ByAccessGroups.Insert(Substring.AccessGroup, Substring.Update);
			EndDo;
			RightsToList = New Structure;
			RightsToList.Insert("RightToWriteRestrictionDisabled",
				AdditionalContext.ListsWithReadRestrictionDisabled.Get(FullName) <> Undefined);
			RightsToList.Insert("RestrictionDisabled",
				AdditionalContext.ListsWithDisabledRestriction.Get(FullName) <> Undefined);
			RightsToList.Insert("ByAccessGroups", New FixedMap(ByAccessGroups));
			RightsToLists.Insert(Row.List, New FixedStructure(RightsToList));
		EndDo;
		TableNumber = TableNumber + 1;
		Table = QueryResults[TableNumber].Unload();
		For Each Row In Table Do
			RightsToLeadingAccessKeysLists.Insert(Row.AccessKey,
				RightsToLists.Get(Row.List));
		EndDo;
		TableNumber = TableNumber + 1;
		Tree = QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups);
		For Each Row In Tree.Rows Do
			RightsToLeadingKey = New Map;
			For Each Substring In Row.Rows Do
				RightsToLeadingKey.Insert(Substring.RightsOwner, Substring.Update);
			EndDo;
			RightsToLeadingAccessKeys.Insert(Row.AccessKey,
				New FixedMap(RightsToLeadingKey));
		EndDo;
	EndIf;
	UpdateParameters.Insert("RightsToLeadingAccessKeysLists",
		New FixedMap(RightsToLeadingAccessKeysLists));
	UpdateParameters.Insert("RightsToLeadingAccessKeys",
		New FixedMap(RightsToLeadingAccessKeys));
	
	RightsToLeadingLists = New Map;
	If UpdateParameters.HasHeadRightsLists Then
		TableNumber = TableNumber + 1;
		Tree = QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups);
		AddRightsByTypes = Tree.Columns.Find("ValueType") <> Undefined;
		For Each Row In Tree.Rows Do
			RightsToLeadingList = New Map;
			For Each Substring In Row.Rows Do
				RightsToLeadingList.Insert(Substring.RightsOwner, Substring.Update);
				If AddRightsByTypes Then
					ListValueType = Substring.ValueType;
				EndIf;
			EndDo;
			RightsToLeadingLists.Insert(Row.List,
				New FixedMap(RightsToLeadingList));
			If AddRightsByTypes Then
				RightsToLeadingLists.Insert(ListValueType,
					New FixedMap(RightsToLeadingList));
			EndIf;
		EndDo;
	EndIf;
	UpdateParameters.Insert("RightsToLeadingLists",
		New FixedMap(RightsToLeadingLists));
	
EndProcedure

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillRightsByRightsSettingsOwners(QueryResults, TableNumber, UpdateParameters)
	
	RightsByRightsSettingsOwners = New Map;
	If UpdateParameters.HasRightsSettingsOwners Then
		TableNumber = TableNumber + 3;
		Tree = QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups);
		For Each Row In Tree.Rows Do
			RightsByRightsSettingsOwner = New Map;
			For Each Substring In Row.Rows Do
				RightsByRightsSettingsOwner.Insert(Substring.RightsOwner, Substring.Update);
			EndDo;
			RightsByRightsSettingsOwners.Insert(Row.RightsSettingsOwner,
				New FixedMap(RightsByRightsSettingsOwner));
		EndDo;
	EndIf;
	UpdateParameters.Insert("RightsByRightsSettingsOwners",
		New FixedMap(RightsByRightsSettingsOwners));
	
EndProcedure

// For the UpdateRightsToListAccessKeys procedure.
Function RightsToListAccessKey(UpdateParameters, KeyTablesValues, AccessKey)
	
	RightsToKey = New Structure("ForGroups, ForUsers", New Map, New Map);
	
	If UpdateParameters.RestrictionDisabled Then
		If Not UpdateParameters.HasDependantListsWithoutAccessKeysRecords Then
			Return RightsToKey;
		ElsIf UpdateParameters.EditionAllowedForAllUsers Then
			RightsToKey.ForGroups.Insert(UpdateParameters.BlankAccessGroup,
				New Structure("Update, Insert", True, True));
			Return RightsToKey;
		EndIf;
	EndIf;
	
	WithoutWriteReadRight = UpdateParameters.RightToWriteRestrictionDisabled
		AND Not UpdateParameters.HasDependantListsWithoutAccessKeysRecords;
	
	Context = New Structure;
	Context.Insert("KeyTablesValues",               KeyTablesValues);
	Context.Insert("WithoutWriteReadRight",              WithoutWriteReadRight);
	Context.Insert("KeyTablesAttributes",              UpdateParameters.KeyTablesAttributes);
	Context.Insert("AccessGroupsMembers",             UpdateParameters.AccessGroupsMembers);
	Context.Insert("AccessGroupsUserGroups",   UpdateParameters.AccessGroupsUserGroups);
	Context.Insert("UserGroupsUsers",    UpdateParameters.UserGroupsUsers);
	Context.Insert("RightsToLeadingAccessKeysLists", UpdateParameters.RightsToLeadingAccessKeysLists);
	Context.Insert("RightsToLeadingAccessKeys",        UpdateParameters.RightsToLeadingAccessKeys);
	Context.Insert("RightsToLeadingLists",              UpdateParameters.RightsToLeadingLists);
	Context.Insert("RightsByRightsSettingsOwners",     UpdateParameters.RightsByRightsSettingsOwners);
	Context.Insert("CalculateUserRights",    UpdateParameters.CalculateUserRights);
	Context.Insert("AccessGroupType",                  UpdateParameters.AccessGroupType);
	Context.Insert("BlankAccessGroup",               UpdateParameters.BlankAccessGroup);
	Context.Insert("UserType",                   UpdateParameters.UserType);
	Context.Insert("UserGroupType",            UpdateParameters.UserGroupType);
	Context.Insert("RightsSettingsOwnersTypes",        UpdateParameters.RightsSettingsOwnersTypes);
	
	ReadAllowedForAllAccessGroups = True;
	ChangeAddAllowedForAllAccessGroups = True;
	
	For Each RightsDetails In UpdateParameters.ListAccessGroupsRights Do
		AccessGroup      = RightsDetails.Key;
		AccessGroupRights = RightsDetails.Value;
		
		Context.Insert("AccessGroup", AccessGroup);
		Context.Insert("AccessGroupValues",
			UpdateParameters.AccessGroupsValues.Get(AccessGroup));
		
		If UpdateParameters.RightToWriteRestrictionDisabled
		 Or AccessGroupRights.ReadWithoutRestriction Then
			
			ReadRight = "True";
		Else
			ReadRight = CalculatedConditionForRows(Context,
				UpdateParameters.ReadRightCalculationStructure);
		EndIf;
		
		If ReadRight <> "True" Then
			ReadAllowedForAllAccessGroups = False;
			ChangeAddAllowedForAllAccessGroups = False;
		EndIf;
		
		If ReadRight = "False"
		 Or TypeOf(ReadRight) = Type("Map")
		   AND ReadRight.Count() = 0 Then
			
			Continue;
		EndIf;
		
		If UpdateParameters.RestrictionDisabled
		 Or AccessGroupRights.UpdateWithoutRestriction
		   AND AccessGroupRights.InsertWithoutRestriction Then
			
			UpdateRight = "True";
			
		ElsIf Not AccessGroupRights.Update Then
			UpdateRight = "False";
			
		ElsIf UpdateParameters.HasLimitChanges Then
			UpdateRight = CalculatedConditionForRows(Context,
				UpdateParameters.EditRightCalculationStructure);
			
		ElsIf UpdateParameters.RightToWriteRestrictionDisabled
		      Or AccessGroupRights.ReadWithoutRestriction Then
			
			UpdateRight = CalculatedConditionForRows(Context,
				UpdateParameters.ReadRightCalculationStructure);
		Else
			UpdateRight = "True";
		EndIf;
		
		InsertRight = ?(AccessGroupRights.Insert, UpdateRight, "False");
		
		If AccessGroupRights.UpdateWithoutRestriction Then
			UpdateRight = "True";
		EndIf;
		
		If UpdateRight <> "True" Or InsertRight <> "True" Then
			ChangeAddAllowedForAllAccessGroups = False;
		EndIf;
		
		If Context.CalculateUserRights Then
			AddUsersRightsToAccessKey(RightsToKey,
				ReadRight, UpdateRight, InsertRight, Context);
		
		ElsIf Not WithoutWriteReadRight Or UpdateRight = "True" Or InsertRight = "True" Then
			RightsToKey.ForGroups.Insert(AccessGroup, New Structure("Update, Insert",
				UpdateRight = "True", InsertRight = "True"));
		EndIf;
	EndDo;
	
	If Not ReadAllowedForAllAccessGroups
	 Or UpdateParameters.HasDependantListsWithoutAccessKeysRecords
	   AND Not UpdateParameters.ReadingAllowedForAllUsers Then
		
		Return RightsToKey;
	EndIf;
	
	If ChangeAddAllowedForAllAccessGroups
	   AND ( Not UpdateParameters.HasDependantListsWithoutAccessKeysRecords
	      Or UpdateParameters.EditionAllowedForAllUsers) Then
		
		RightsToKey = New Structure("ForGroups, ForUsers", New Map, New Map);
		RightsToKey.ForGroups.Insert(UpdateParameters.BlankAccessGroup,
			New Structure("Update, Insert", True, True));
		
	Else // ReadAllowedForAllAccessGroups.
		CurrentRightsToKey = RightsToKey;
		RightsToKey = New Structure("ForGroups, ForUsers", New Map, New Map);
		If Not WithoutWriteReadRight Then
			RightsToKey.ForGroups.Insert(UpdateParameters.BlankAccessGroup,
				New Structure("Update, Insert", False, False));
		EndIf;
		For Each KeyAndValue In CurrentRightsToKey.ForGroups Do
			If KeyAndValue.Value.Update Then
				RightsToKey.ForGroups.Insert(KeyAndValue.Key, KeyAndValue.Value);
			EndIf;
		EndDo;
		For Each KeyAndValue In CurrentRightsToKey.ForUsers Do
			If KeyAndValue.Value.Update Then
				RightsToKey.ForUsers.Insert(KeyAndValue.Key, KeyAndValue.Value);
			EndIf;
		EndDo;
	EndIf;
	
	Return RightsToKey;
	
EndFunction

// For the RightsToListAccessKey procedure.
Procedure AddUsersRightsToAccessKey(RightsToKey, ReadRight, UpdateRight, InsertRight, Context)
	
	If TypeOf(UpdateRight) = Type("Map") AND UpdateRight.Count() = 0 Then
		UpdateRight  = "False";
		InsertRight = "False";
		
	ElsIf TypeOf(InsertRight) = Type("Map") AND InsertRight.Count() = 0 Then
		InsertRight = "False";
	EndIf;
	
	Rights = New Structure("Update, Insert", UpdateRight = "True", InsertRight = "True");
	
	If TypeOf(ReadRight) <> Type("Map") Then
		If Not Context.WithoutWriteReadRight Or Rights.Update Or Rights.Insert Then
			RightsToKey.ForGroups.Insert(Context.AccessGroup,
				New Structure("Update, Insert", Rights.Update, Rights.Insert));
		EndIf;
	Else
		AddRightsToAccessKeyToUsers(RightsToKey.ForUsers,
			ReadRight, Rights.Update, Rights.Insert, Context.WithoutWriteReadRight);
	EndIf;
	
	If TypeOf(UpdateRight)  <> Type("Map")
	   AND TypeOf(InsertRight) <> Type("Map") Then
		Return;
	EndIf;
	
	Right = ?(TypeOf(UpdateRight) = Type("Map"), UpdateRight, InsertRight);
	AddRightsToAccessKeyToUsers(RightsToKey.ForUsers,
		Right, True, InsertRight <> "False", Context.WithoutWriteReadRight);
	
EndProcedure

// For the AddUsersRightsToAccessKey procedure.
Procedure AddRightsToAccessKeyToUsers(RightsToAccessKeyForUsers,
				UsersContent, Update, Insert, WithoutWriteReadRight)
	
	If Update AND Insert Then
		For Each KeyAndValue In UsersContent Do
			RightsToAccessKeyForUsers.Insert(KeyAndValue.Key,
				New Structure("Update, Insert", True, True));
		EndDo;
		
	ElsIf Not Update AND Not Insert Then
		If Not WithoutWriteReadRight Then
			For Each KeyAndValue In UsersContent Do
				Rights = RightsToAccessKeyForUsers.Get(KeyAndValue.Key);
				If Rights = Undefined Then
					Rights = New Structure("Update, Insert", False, False);
					RightsToAccessKeyForUsers.Insert(KeyAndValue.Key, Rights);
				EndIf;
			EndDo;
		EndIf;
	Else
		For Each KeyAndValue In UsersContent Do
			Rights = RightsToAccessKeyForUsers.Get(KeyAndValue.Key);
			If Rights = Undefined Then
				Rights = New Structure("Update, Insert", Update, Insert);
			Else
				Rights.Update  = Rights.Update  Or Update;
				Rights.Insert = Rights.Insert Or Insert;
			EndIf;
			RightsToAccessKeyForUsers.Insert(KeyAndValue.Key, Rights);
		EndDo;
	EndIf;
	
EndProcedure

// For the RightsToListAccessKey and CalculatedCondition functions.
Function CalculatedConditionForRows(Context, Condition, AttributesNode = Undefined, ForAnyRow = True)
	
	If AttributesNode = Undefined Then
		Context.Insert("RequiredKeyTablesDetails", New Array);
		If Condition.Node = "ForAllRows" Or Condition.Node = "ForAtLeastOneRow" Then
			Return CalculatedCondition(Context, Condition);
		EndIf;
		AttributesNode = Condition;
	EndIf;
	
	If Not ValueIsFilled(AttributesNode.RequiredKeyTabularSectionsAttributes) Then
		Context.Insert("CurrentKeyTableRows", Context.KeyTablesValues);
		Return CalculatedCondition(Context, Condition);
	EndIf;
	TablesAttributes    = AttributesNode.RequiredKeyTabularSectionsAttributes;
	TablesValues     = CurrentKeyTablesValues(Context, TablesAttributes);
	TablesRowsIndexes = New Map;
	
	Context.RequiredKeyTablesDetails.Add(
		New Structure("TablesAttributes, TablesValues, TablesRowsIndexes",
			TablesAttributes, TablesValues, TablesRowsIndexes));
	
	Context.Insert("CurrentKeyTableRows", New Structure);
	For Each ValuesDetails In Context.KeyTablesValues Do
		If StrStartsWith(ValuesDetails.Key, "Header") Then
			Context.CurrentKeyTableRows.Insert(ValuesDetails.Key, ValuesDetails.Value);
		EndIf;
	EndDo;
	
	Result = "Undefined";
	
	While True Do
		IndexChanged = False;
		For Each TableDetails In TablesAttributes Do
			KeyTableName = TableDetails.Key;
			RowIndex = TablesRowsIndexes.Get(KeyTableName);
			TableValues = TablesValues[KeyTableName];
			If RowIndex = Undefined Then
				RowIndex = 0;
			Else
				If RowIndex >= TableValues.Count() - 1 Then
					Continue;
				EndIf;
				RowIndex = RowIndex + 1;
			EndIf;
			IndexChanged = True;
			TablesRowsIndexes.Insert(KeyTableName, RowIndex);
			Context.CurrentKeyTableRows.Insert(KeyTableName, TableValues[RowIndex]);
		EndDo;
		If Not IndexChanged Then
			Break;
		EndIf; 
		CurrentResult = CalculatedCondition(Context, Condition);
		If TypeOf(CurrentResult) <> Type("Map") Then
			If ForAnyRow Then
				If CurrentResult = "True" Then
					Result = "True";
					Break;
				ElsIf CurrentResult = "False" Then
					If Result = "Undefined" Then
						Result = "False";
					EndIf;
				EndIf;
			Else
				If CurrentResult = "False" Then
					Result = "False";
					Break;
				ElsIf CurrentResult = "True" Then
					If Result = "Undefined" Then
						Result = "True";
					EndIf;
				EndIf;
			EndIf;
		Else
			If Not ForAnyRow AND CurrentResult.Count() = 0 Then
				Result = "False";
				Break;
			EndIf;
			If TypeOf(Result) = Type("String") Then
				Result = CurrentResult;
			Else
				AddCurrentResult(Result, CurrentResult, ForAnyRow, Context);
			EndIf;
		EndIf;
	EndDo;
	
	If Result = "Undefined" Then
		Result = "False";
	EndIf;
	
	Context.RequiredKeyTablesDetails.Delete(
		Context.RequiredKeyTablesDetails.Count() - 1);
	
	Return Result;
	
EndFunction

// For the CalculatedConditionForRows function.
Procedure AddCurrentResult(Result, CurrentResult, ForAnyRow, Context)
	
	If ForAnyRow Then
		For Each KeyAndValue In CurrentResult Do
			Result.Insert(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	Else
		If Result.Count() > CurrentResult.Count() Then
			SmallerResult = CurrentResult;
			BiggerResult = Result;
		Else
			SmallerResult = Result;
			BiggerResult = CurrentResult;
		EndIf;
		Result = New Map;
		UserGroupType = Undefined;
		
		For Each KeyAndValue In SmallerResult Do
			Member = KeyAndValue.Key;
			If BiggerResult.Get(Member) <> Undefined Then
				Result.Insert(Member, True);
			Else
				If UserGroupType = Undefined Then
					UserGroupType = Context.UserGroupType;
					UserGroupsUsers = Context.UserGroupsUsers;
					BiggerResultGroupsUsers = GroupsUsers(BiggerResult, Context);
				EndIf;
				If TypeOf(Member) = UserGroupType Then
					GroupUsers = UserGroupsUsers.Get(Member);
					If GroupUsers = Undefined Then
						Continue;
					EndIf;
					For Each UserDetails In GroupUsers Do
						If BiggerResultGroupsUsers.Get(UserDetails.Key) <> Undefined Then
							Result.Insert(UserDetails.Key, True);
						EndIf;
					EndDo;
				ElsIf BiggerResultGroupsUsers.Get(Member) <> Undefined Then
					Result.Insert(Member, True);
				EndIf;
			EndIf;
		EndDo;
	EndIf;
	
EndProcedure

// For the AddCurrentResult and SetReverseResult procedures.
Function GroupsUsers(UsersAndGroups, Context)
	
	GroupsUsers = New Map;
	
	UserGroupType = Context.UserGroupType;
	UserGroupsUsers = Context.UserGroupsUsers;
	
	For Each KeyAndValue In UsersAndGroups Do
		If TypeOf(KeyAndValue.Key) = UserGroupType Then
			GroupUsers = UserGroupsUsers.Get(KeyAndValue.Key);
			If GroupUsers <> Undefined Then
				For Each UserDetails In GroupUsers Do
					GroupsUsers.Insert(UserDetails.Key, True);
				EndDo;
			EndIf;
		EndIf;
	EndDo;
	
	Return GroupsUsers;
	
EndFunction

// For the CalculatedCondition function.
Procedure SetReverseResult(Result, Context)
	
	ExceptionsList = Result;
	Result = New Map;
	
	CurrentAccessGroupMembers = Context.AccessGroupsMembers.Get(Context.AccessGroup);
	If CurrentAccessGroupMembers = Undefined Then
		Return;
	EndIf;
	
	UserGroupsUsers = Context.UserGroupsUsers;
	UserGroupType         = Context.UserGroupType;
	UserType                = Context.UserType;
	
	UsersOfGroupsToExclude = GroupsUsers(ExceptionsList, Context);
	
	For Each KeyAndValue In CurrentAccessGroupMembers Do
		Member = KeyAndValue.Key;
		If ExceptionsList.Get(Member) <> Undefined Then
			Continue;
		EndIf;
		If TypeOf(Member) = UserType Then
			If ExceptionsList.Get(Member) = Undefined
			   AND UsersOfGroupsToExclude.Get(Member) = Undefined Then
				
				Result.Insert(Member, True);
			EndIf;
		ElsIf TypeOf(Member) = UserGroupType Then
			GroupUsers = UserGroupsUsers.Get(Member);
			If GroupUsers = Undefined Then
				Continue;
			EndIf;
			AllGroupWithoutExceptions = True;
			For Each UserDetails In GroupUsers Do
				If ExceptionsList.Get(UserDetails.Key) <> Undefined
				 Or UsersOfGroupsToExclude.Get(UserDetails.Key) <> Undefined Then
					
					AllGroupWithoutExceptions = False;
					Break;
				EndIf;
			EndDo;
			If AllGroupWithoutExceptions Then
				Result.Insert(Member, True);
			Else
				For Each UserDetails In GroupUsers Do
					If ExceptionsList.Get(UserDetails.Key) = Undefined
					   AND UsersOfGroupsToExclude.Get(UserDetails.Key) = Undefined Then
						
						Result.Insert(UserDetails.Key, True);
					EndIf;
				EndDo;
			EndIf;
		EndIf;
	EndDo;
	
EndProcedure

// For the CalculatedConditionForRows function.
Function CurrentKeyTablesValues(Context, RequiredKeyTabularSectionsAttributes)
	
	CurrentKeyTablesValues = New Structure;
	For Each TablesDetails In RequiredKeyTabularSectionsAttributes Do
		KeyTableName = TablesDetails.Key;
		Attributes       = TablesDetails.Value;
		KeyTableValues = Context.KeyTablesValues[KeyTableName];
		Filter = New Structure;
		For Each CurrentDetails In Context.RequiredKeyTablesDetails Do
			TableAttributes    = CurrentDetails.TablesAttributes.Get(KeyTableName);
			TableValues     = CurrentDetails.TablesValues[KeyTableName];
			TableRowIndex = CurrentDetails.TablesRowsIndexes.Get(KeyTableName);
			TableRow = TableValues[TableRowIndex];
			For Each AttributeName In TableAttributes Do
				Filter.Insert(AttributeName, TableRow[AttributeName]);
			EndDo;
		EndDo;
		TableAttributesTotal = Context.KeyTablesAttributes.Get(KeyTableName).Count();
		If TableAttributesTotal = Attributes.Count() AND Not ValueIsFilled(Filter) Then
			CurrentKeyTablesValues.Insert(KeyTableName, KeyTableValues);
			Continue;
		EndIf;
		Rows = KeyTableValues;
		If ValueIsFilled(Filter) Then
			Rows = Rows.FindRows(Filter);
		EndIf;
		TableValues = New ValueTable;
		For Each AttributeName In Attributes Do
			TableValues.Columns.Add(AttributeName);
		EndDo;
		For Each Row In Rows Do
			FillPropertyValues(TableValues.Add(), Row);
		EndDo;
		If Attributes.Count() < TableAttributesTotal Then
			AttributesAsString = StrConcat(Attributes, ", ");
			TableValues.GroupBy(AttributesAsString);
		EndIf;
		CurrentKeyTablesValues.Insert(KeyTableName, TableValues);
	EndDo;
	
	Return CurrentKeyTablesValues;
	
EndFunction

// For the CalculatedConditionForRows function.
Function CalculatedCondition(Context, Condition)
	
	// Checked types are already considered.
	
	If Condition.Node = "Field" Then
		Value = Context.CurrentKeyTableRows[Condition.Table][Condition.Attribute];
		Result = ?(Value = Enums.AdditionalAccessValues.True
			Or Value = Null AND Condition.Property("CheckHasNull"), "True", "False");
		
	ElsIf Condition.Node = "Constant" Then
		Result = ?(Condition.Value = True, "True", "False");
		
	ElsIf Upper( Condition.Node ) = Upper( "AND" ) Then // PATCHED:
		
		Result = "Undefined";
		For Each Argument In Condition.Arguments Do
			CurrentResult = CalculatedCondition(Context, Argument);
			If CurrentResult = "False" Then
				Result = "False";
				Break;
			EndIf;
			If CurrentResult = "True" Then
				If Result = "Undefined" Then
					Result = "True";
				EndIf;
			ElsIf TypeOf(CurrentResult) = Type("Map") Then
				If CurrentResult.Count() = 0 Then
					Result = "False";
					Break;
				EndIf;
				If TypeOf(Result) = Type("String") Then
					Result = CurrentResult;
				Else
					AddCurrentResult(Result, CurrentResult, False, Context);
				EndIf;
			EndIf;
		EndDo;
		If Result = "Undefined" Then
			Result = "False";
		EndIf;
		
	ElsIf Condition.Node = "Or" Then
		
		Result = "Undefined";
		For Each Argument In Condition.Arguments Do
			CurrentResult = CalculatedCondition(Context, Argument);
			If CurrentResult = "True" Then
				Result = "True";
				Break;
			EndIf;
			If CurrentResult = "False" Then
				If Result = "Undefined" Then
					Result = "False";
				EndIf;
			ElsIf TypeOf(CurrentResult) = Type("Map") Then
				If CurrentResult.Count() = 0 Then
					If Result = "Undefined" Then
						Result = "False";
					EndIf;
				ElsIf TypeOf(Result) = Type("String") Then
					Result = CurrentResult;
				Else
					AddCurrentResult(Result, CurrentResult, True, Context);
				EndIf;
			EndIf;
		EndDo;
		If Result = "Undefined" Then
			Result = "False";
		EndIf;
		
	ElsIf Condition.Node = "Not" Then
		Result = CalculatedCondition(Context, Condition.Argument);
		If Result = "True" Then
			Result = "False";
		ElsIf Result = "False" Then
			Result = "True";
		ElsIf TypeOf(Result) = Type("Map") Then
			If Result.Count() = 0 Then
				Result = "True";
			Else
				SetReverseResult(Result, Context);
			EndIf;
		EndIf;
		
	ElsIf Condition.Node = "ForAllRows"
	      Or Condition.Node = "ForAtLeastOneRow" Then
		
		Result = CalculatedConditionForRows(Context,
			Condition.Argument, Condition, Condition.Node = "ForAtLeastOneRow");
		
	ElsIf Condition.Node = "Case" Then
		Result = Undefined;
		For Each When In Condition.When Do
			If CalculatedCondition(Context, When.Condition) = "True" Then
				Result = CalculatedCondition(Context, When.Value);
				Break;
			EndIf;
		EndDo;
		If Result = Undefined Then
			Result = CalculatedCondition(Context, Condition.Else);
		EndIf;
		
	ElsIf Condition.Node = "ValueAllowed"
	      Or Condition.Node = "IsAuthorizedUser"
	      Or Condition.Node = "ObjectReadingAllowed"
	      Or Condition.Node = "ObjectUpdateAllowed"
	      Or Condition.Node = "ListReadingAllowed"
	      Or Condition.Node = "ListUpdateAllowed" Then
		
		Value = Context.CurrentKeyTableRows[Condition.Field.Table][Condition.Field.Attribute];
		If Value = Null Then
			Value = Enums.AdditionalAccessValues.Null;
		EndIf;
		
		If Value = Enums.AdditionalAccessValues.AllowedType Then
			CurrentResult = "True";
			
		ElsIf Value = Enums.AdditionalAccessValues.ProhibitedType Then
			CurrentResult = "False";
		Else
			CurrentResult = Undefined;
			For Each ComparisonClarification In Condition.ComparisonClarifications Do
				If ComparisonClarification.Key = "Null"
				 Or ComparisonClarification.Key = "Undefined" Then
					If Value = Enums.AdditionalAccessValues[ComparisonClarification.Key] Then
						CurrentResult = ComparisonClarification.Value;
						Break;
					EndIf;
				ElsIf ComparisonClarification.Key = "EmptyRef" Then
					If Value = Enums.AdditionalAccessValues.EmptyRefAnyType
					 Or Value.IsEmpty() Then
						CurrentResult = ComparisonClarification.Value;
						Break;
					EndIf;
				ElsIf ComparisonClarification.Key = TypeOf(Value) Then
					CurrentResult = ComparisonClarification.Value;
					Break;
				EndIf;
			EndDo;
		EndIf;
		
		If CurrentResult <> Undefined Then
			Result = CurrentResult;
			
		ElsIf Condition.Node = "ValueAllowed" Then
			If Value = Enums.AdditionalAccessValues.Null
			 Or Value = Enums.AdditionalAccessValues.Undefined
			 Or Context.AccessGroupValues = Undefined Then
				Result = "False";
			Else
				ValueType = TypeOf(Value);
				ValuesOfOneType = Context.AccessGroupValues.Get(ValueType);
				If ValuesOfOneType = Undefined Then
					If Condition.ComparisonClarifications.Get("Disabled") = "False" Then
						Result = "False";
					Else
						Result = "True";
					EndIf;
				Else
					ValueSpecified = ValuesOfOneType.Values.Get(Value) <> Undefined;
					Result = "False";
					If    ValueSpecified AND Not ValuesOfOneType.AllAllowed
					 Or Not ValueSpecified AND    ValuesOfOneType.AllAllowed Then
						Result = "True";
						
					ElsIf ValueType = Context.UserType Then
						FillResultForUser(Result, Value, Context);
						
					ElsIf ValueType = Context.UserGroupType Then
						FillResultForUserGroup(Result, Value, Context);
					EndIf;
				EndIf;
			EndIf;
			
		ElsIf Condition.Node = "IsAuthorizedUser" Then
			If TypeOf(Value) = Context.UserType Then
				FillResultForUser(Result, Value, Context);
			Else
				Result = "False";
			EndIf;
			
		ElsIf TypeOf(Value) = Type("CatalogRef.AccessKeys") Then
			RightsToList = Context.RightsToLeadingAccessKeysLists.Get(Value);
			If RightsToList = Undefined Then
				Result = "False";
			Else
				UpdateRight = RightsToList.ByAccessGroups.Get(Context.AccessGroup);
				If Condition.Node =    "ObjectReadingAllowed" AND UpdateRight = Undefined
				 Or Condition.Node = "ObjectUpdateAllowed" AND UpdateRight <> True Then
					Result = "False";
				
				ElsIf Condition.Node =    "ObjectReadingAllowed" AND RightsToList.RightToWriteRestrictionDisabled
					  Or Condition.Node = "ObjectUpdateAllowed" AND RightsToList.RestrictionDisabled Then
					
					Result = "True";
				Else
					RightsToLeadingAccessKey = Context.RightsToLeadingAccessKeys.Get(Value);
					If RightsToLeadingAccessKey = Undefined Then
						Result = "False";
						
					ElsIf Context.CalculateUserRights Then
						If Condition.Node = "ObjectReadingAllowed" Then
							Result = New Map;
							For Each KeyAndValue In RightsToLeadingAccessKey Do
								If TypeOf(KeyAndValue.Key) <> Context.AccessGroupType Then
									Result.Insert(KeyAndValue.Key, True);
									
								ElsIf KeyAndValue.Key = Context.AccessGroup
								      Or KeyAndValue.Key = Context.BlankAccessGroup Then
									
									Result.Insert(Context.AccessGroup, True);
								EndIf;
							EndDo;
							
						ElsIf Condition.Node = "ObjectUpdateAllowed" Then
							Result = New Map;
							For Each KeyAndValue In RightsToLeadingAccessKey Do
								If Not KeyAndValue.Value Then
									Continue;
								EndIf;
								If TypeOf(KeyAndValue.Key) <> Context.AccessGroupType Then
									Result.Insert(KeyAndValue.Key, True);
									
								ElsIf KeyAndValue.Key = Context.AccessGroup
								      Or KeyAndValue.Key = Context.BlankAccessGroup Then
									
									Result.Insert(Context.AccessGroup, True);
								EndIf;
							EndDo;
						Else
							Result = "False";
						EndIf;
					Else
						UpdateRight = RightsToLeadingAccessKey.Get(Context.AccessGroup);
						If Condition.Node =    "ObjectReadingAllowed" AND UpdateRight <> Undefined
						 Or Condition.Node = "ObjectUpdateAllowed" AND UpdateRight = True Then
							Result = "True";
						Else
							Result = "False";
						EndIf;
					EndIf;
				EndIf;
			EndIf;
			
		ElsIf Context.RightsSettingsOwnersTypes.Get(TypeOf(Value)) <> Undefined Then
			RightsByRightsSettingsOwner = Context.RightsByRightsSettingsOwners.Get(Value);
			If RightsByRightsSettingsOwner = Undefined Then
				Result = "False";
				
			ElsIf Condition.Node = "ObjectReadingAllowed" Then
				Result = New Map(RightsByRightsSettingsOwner);
				
			ElsIf Condition.Node = "ObjectUpdateAllowed" Then
				Result = New Map;
				For Each KeyAndValue In RightsByRightsSettingsOwner Do
					If KeyAndValue.Value Then
						Result.Insert(KeyAndValue.Key, True);
					EndIf;
				EndDo;
			Else
				Result = "False";
			EndIf;
			
		Else // Checking rights to the list.
			RightsToLeadingList = Context.RightsToLeadingLists.Get(Value);
			If RightsToLeadingList = Undefined Then
				RightsToLeadingList = Context.RightsToLeadingLists.Get(TypeOf(Value));
			EndIf;
			If RightsToLeadingList = Undefined Then
				Result = "False";
			ElsIf Context.CalculateUserRights Then
				If StrStartsWith(Condition.Node, "Read") Then
					Result = RightsToLeadingList;
					
				ElsIf StrStartsWith(Condition.Node, "Update") Then
					Result = New Map;
					For Each KeyAndValue In RightsToLeadingList Do
						If KeyAndValue.Value Then
							Result.Insert(KeyAndValue.Key, True);
						EndIf;
					EndDo;
				Else
					Result = "False";
				EndIf;
			Else
				UpdateRight = RightsToLeadingList.Get(Context.AccessGroup);
				If StrStartsWith(Condition.Node, "Read")    AND UpdateRight <> Undefined
				 Or StrStartsWith(Condition.Node, "Update") AND UpdateRight = True Then
					Result = "True";
				Else
					Result = "False";
				EndIf;
			EndIf;
		EndIf;
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'При вычислении прав на ключ доступа узел не поддерживается ""%1"".'; en = '""%1"" node is not supported while calculating rights to the access key.'; pl = 'Przy obliczaniu prawa do klucza dostępu węzeł nie jest obsługiwany ""%1"".';es_ES = 'Al calcular los derechos de clave de acceso el nodo no se admite ""%1"".';es_CO = 'Al calcular los derechos de clave de acceso el nodo no se admite ""%1"".';tr = 'Erişim anahtarı hakları hesaplanırken, ünite desteklenmiyor ""%1"".';it = 'Il nodo ""%1"" non è supportato durante il calcolo dei diritti alla chiave di accesso.';de = 'Bei der Berechnung der Zugriffsrechte auf einen Knoten wird der Knoten nicht unterstützt ""%1"".'"),
			Condition.Node);
		Raise ErrorText;
	EndIf;
	
	Return Result;
	
EndFunction

// For the CalculatedCondition function.
Procedure FillResultForUser(Result, User, Context)
	
	Result = "False";
	
	AccessGroupMembers = Context.AccessGroupsMembers.Get(Context.AccessGroup);
	If AccessGroupMembers = Undefined Then
		Return;
	EndIf;
	If AccessGroupMembers.Get(User) <> Undefined Then
		Result = New Map;
		Result.Insert(User, True);
		Return;
	EndIf;
	
	AccessGroupUserGroups = Context.AccessGroupsUserGroups.Get(Context.AccessGroup);
	If AccessGroupUserGroups = Undefined Then
		Return;
	EndIf;
	
	For Each GroupUsersDetails In AccessGroupUserGroups Do
		If GroupUsersDetails.Value.Get(User) <> Undefined Then
			Result = New Map;
			Result.Insert(User, True);
			Return;
		EndIf;
	EndDo;
	
EndProcedure

// For the CalculatedCondition function.
Procedure FillResultForUserGroup(Result, UsersGroup, Context)
	
	Result = "False";
	
	AccessGroupMembers = Context.AccessGroupsMembers.Get(Context.AccessGroup);
	If AccessGroupMembers = Undefined Then
		Return;
	EndIf;
	
	If AccessGroupMembers.Get(UsersGroup) = Undefined Then
		Result = New Map;
		Result.Insert(UsersGroup, True);
		Return;
	EndIf;
	
	AccessGroupUserGroups = Context.AccessGroupsUserGroups.Get(Context.AccessGroup);
	If AccessGroupUserGroups = Undefined Then
		Return;
	EndIf;
	
	GroupUsers = Context.UserGroupsUsers.Get(UsersGroup);
	If GroupUsers = Undefined Then
		Return;
	EndIf;
	
	Result = New Map;
	For Each UserDetails In GroupUsers Do
		If AccessGroupMembers.Get(UserDetails.Key) <> Undefined Then
			Result.Insert(UserDetails.Key, True);
			Continue;
		EndIf;
		For Each GroupUsersDetails In AccessGroupUserGroups Do
			If GroupUsersDetails.Value.Get(UserDetails.Key) <> Undefined Then
				Result.Insert(UserDetails.Key, True);
				Break;
			EndIf;
		EndDo;
	EndDo;
	
	If Result.Count() = 0 Then
		Result = "False";
	EndIf;
	
EndProcedure

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure UpdateRightsToListAccessKey(UpdateParameters, AccessKey, RightsToKey)
	
	If UpdateParameters.CalculateUserRights Then
		RightsToAccessKeyForUsers = New Map;
		UserType = UpdateParameters.UserType;
		For Each KeyAndValue In RightsToKey.ForUsers Do
			If TypeOf(KeyAndValue.Key) = UserType Then
				Set = Catalogs.AccessGroupsSets.GetRef(KeyAndValue.Key.UUID());
				RightsToAccessKeyForUsers.Insert(Set, KeyAndValue.Value);
			Else
				RightsToKey.ForGroups.Insert(KeyAndValue.Key, KeyAndValue.Value);
			EndIf;
		EndDo;
	EndIf;
	
	Lock = New DataLock;
	
	GroupsQuery = New Query;
	GroupsQuery.SetParameter("AccessKey", AccessKey);
	GroupsQuery.Text =
	"SELECT
	|	AccessGroupsAccessKeys.AccessGroup AS AccessGroup,
	|	AccessGroupsAccessKeys.Update AS Update,
	|	AccessGroupsAccessKeys.Insert AS Insert,
	|	AccessGroupsAccessKeys.IsAccessGroupsRights AS IsAccessGroupsRights,
	|	AccessGroupsAccessKeys.IsUsersRights AS IsUsersRights,
	|	AccessGroupsAccessKeys.IsExternalUsersRights AS IsExternalUsersRights
	|FROM
	|	InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|WHERE
	|	AccessGroupsAccessKeys.AccessKey = &AccessKey";
	
	GroupsLockItem = Lock.Add("InformationRegister.AccessGroupsAccessKeys");
	GroupsLockItem.SetValue("AccessKey", AccessKey);
	GroupsRecordSet = ServiceRecordSet(InformationRegisters.AccessGroupsAccessKeys);
	GroupsRecordSet.Filter.AccessKey.Set(AccessKey);
	
	Query = New Query;
	Query.SetParameter("AccessKey", AccessKey);
	Query.SetParameter("AllowedEmptySet",
		AccessManagementInternalCached.AllowedBlankAccessGroupsSet());
	
	If Not UpdateParameters.CalculateUserRights Then
		Query.Text = DifferencesSelectionOfDerivedRightsQueryTextForAccessGroups();
		RightsOwnerFieldName = "AccessGroupsSet";
		LockItem = Lock.Add("InformationRegister.AccessGroupSetsAccessKeys");
		RecordSet = ServiceRecordSet(InformationRegisters.AccessGroupSetsAccessKeys);
		
	ElsIf Not UpdateParameters.ForExternalUsers Then
		Query.Text = DifferencesSelectionOfDerivedRightsQueryTextForUsers();
		RightsOwnerFieldName = "User";
		LockItem = Lock.Add("InformationRegister.UsersAccessKeys");
		RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeys);
	Else
		Query.Text = DifferencesSelectionOfDerivedRightsQueryTextForExternalUsers();
		RightsOwnerFieldName = "ExternalUser";
		LockItem = Lock.Add("InformationRegister.ExternalUsersAccessKeys");
		RecordSet = ServiceRecordSet(InformationRegisters.ExternalUsersAccessKeys);
	EndIf;
	
	LockItem.SetValue("AccessKey", AccessKey);
	RecordSet.Filter.AccessKey.Set(AccessKey);
	
	UpdateManually = UpdateParameters.Property("UpdateRightsToKeys")
		AND UpdateParameters.UpdateRightsToKeys;
	
	BeginTransaction();
	Try
		Lock.Lock();
		
		HasRightsChanges = False;
		GroupsRequestResult = GroupsQuery.Execute();
		UpdateInitialGroupsRightsToAccessKey(GroupsRequestResult, GroupsRecordSet, "AccessGroup",
			AccessKey, RightsToKey.ForGroups, UpdateParameters, HasRightsChanges);
		
		If Not UpdateParameters.CalculateUserRights Then
			If HasRightsChanges Or UpdateManually Then
				QueryResult = Query.Execute();
				UpdateDerivedRightsToAccessKey(QueryResult, RecordSet, RightsOwnerFieldName, AccessKey);
			EndIf;
		Else
			If HasRightsChanges Or UpdateManually Then
				QueryResults = Query.ExecuteBatch();
				UsersQueryResult = QueryResults[0];
				UpdateDerivedRightsToAccessKey(QueryResults[1], RecordSet, RightsOwnerFieldName, AccessKey);
				RecordSet.Clear();
			Else
				Query.Text = StrSplit(Query.Text, ";", False)[0];
				UsersQueryResult = Query.Execute();
			EndIf;
			UpdateInitialUsersRightsToAccessKey(UsersQueryResult, RecordSet,
				RightsOwnerFieldName, AccessKey, RightsToAccessKeyForUsers, HasRightsChanges);
		EndIf;
		
		If HasRightsChanges AND UpdateParameters.DependentListsByAccessKeys.Count() > 0 Then
			ScheduleAccessKeysUsersUpdate(UpdateParameters.DependentListsByAccessKeys,
				Not UpdateParameters.ForExternalUsers, UpdateParameters.ForExternalUsers);
		EndIf;
		
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If HasRightsChanges AND UpdateParameters.Property("HasRightsChanges") Then
		UpdateParameters.HasRightsChanges = True;
	EndIf;
	
EndProcedure

// For the UpdateRightsToListAccessKey and UpdateAccessGroupsOfAllowedAccessKey procedures.
Function DifferencesSelectionOfDerivedRightsQueryTextForAccessGroups()
	
	Return
	"SELECT
	|	AllRows.AccessGroupsSet AS AccessGroupsSet,
	|	AllRows.Update AS Update,
	|	AllRows.Insert AS Insert,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind
	|FROM
	|	(SELECT
	|		GroupsInSets.Ref AS AccessGroupsSet,
	|		MAX(AccessGroupsAccessKeys.Update) AS Update,
	|		MAX(AccessGroupsAccessKeys.Insert) AS Insert,
	|		1 AS RowChangeKind
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|			INNER JOIN Catalog.AccessGroupsSets.Folders AS GroupsInSets
	|			ON (GroupsInSets.Group = AccessGroupsAccessKeys.AccessGroup)
	|				AND (AccessGroupsAccessKeys.AccessKey = &AccessKey)
	|	
	|	GROUP BY
	|		GroupsInSets.Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		&AllowedEmptySet,
	|		AccessGroupsAccessKeys.Update,
	|		AccessGroupsAccessKeys.Insert,
	|		1
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|	WHERE
	|		AccessGroupsAccessKeys.AccessGroup = VALUE(Catalog.AccessGroups.EmptyRef)
	|		AND AccessGroupsAccessKeys.AccessKey = &AccessKey
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.AccessGroupsSet,
	|		OldData.Update,
	|		OldData.Insert,
	|		-1
	|	FROM
	|		InformationRegister.AccessGroupSetsAccessKeys AS OldData
	|	WHERE
	|		OldData.AccessKey = &AccessKey) AS AllRows
	|
	|GROUP BY
	|	AllRows.AccessGroupsSet,
	|	AllRows.Update,
	|	AllRows.Insert
	|
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0
	|
	|ORDER BY
	|	RowChangeKind";
	
EndFunction

// For the UpdateRightsToListAccessKey and UpdateAccessGroupsOfAllowedAccessKey procedures.
Function DifferencesSelectionOfDerivedRightsQueryTextForUsers()
	
	Return
	"SELECT
	|	UsersAccessKeys.User AS User,
	|	UsersAccessKeys.Update AS Update,
	|	UsersAccessKeys.Insert AS Insert,
	|	UsersAccessKeys.AreGroupSetRights AS AreGroupSetRights
	|FROM
	|	InformationRegister.UsersAccessKeys AS UsersAccessKeys
	|WHERE
	|	UsersAccessKeys.AccessKey = &AccessKey
	|	AND NOT UsersAccessKeys.AreGroupSetRights
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	AllRows.User AS User,
	|	AllRows.Update AS Update,
	|	AllRows.Insert AS Insert,
	|	TRUE AS AreGroupSetRights,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind
	|FROM
	|	(SELECT
	|		GroupsInSets.Ref AS User,
	|		MAX(AccessGroupsAccessKeys.Update) AS Update,
	|		MAX(AccessGroupsAccessKeys.Insert) AS Insert,
	|		1 AS RowChangeKind
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|			INNER JOIN Catalog.AccessGroupsSets.Folders AS GroupsInSets
	|			ON (GroupsInSets.Group = AccessGroupsAccessKeys.AccessGroup)
	|				AND (AccessGroupsAccessKeys.AccessKey = &AccessKey)
	|	
	|	GROUP BY
	|		GroupsInSets.Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		&AllowedEmptySet,
	|		AccessGroupsAccessKeys.Update,
	|		AccessGroupsAccessKeys.Insert,
	|		1
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|	WHERE
	|		AccessGroupsAccessKeys.AccessGroup = VALUE(Catalog.AccessGroups.EmptyRef)
	|		AND AccessGroupsAccessKeys.AccessKey = &AccessKey
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.User,
	|		OldData.Update,
	|		OldData.Insert,
	|		-1
	|	FROM
	|		InformationRegister.UsersAccessKeys AS OldData
	|	WHERE
	|		OldData.AreGroupSetRights
	|		AND OldData.AccessKey = &AccessKey) AS AllRows
	|
	|GROUP BY
	|	AllRows.User,
	|	AllRows.Update,
	|	AllRows.Insert
	|
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0
	|
	|ORDER BY
	|	RowChangeKind";
	
EndFunction

// For the UpdateRightsToListAccessKey and UpdateAccessGroupsOfAllowedAccessKey procedures.
Function DifferencesSelectionOfDerivedRightsQueryTextForExternalUsers()
	
	Return
	"SELECT
	|	ExternalUsersAccessKeys.ExternalUser AS ExternalUser,
	|	ExternalUsersAccessKeys.Update AS Update,
	|	ExternalUsersAccessKeys.Insert AS Insert,
	|	ExternalUsersAccessKeys.AreGroupSetRights AS AreGroupSetRights
	|FROM
	|	InformationRegister.ExternalUsersAccessKeys AS ExternalUsersAccessKeys
	|WHERE
	|	ExternalUsersAccessKeys.AccessKey = &AccessKey
	|	AND NOT ExternalUsersAccessKeys.AreGroupSetRights
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	AllRows.ExternalUser AS ExternalUser,
	|	AllRows.Update AS Update,
	|	AllRows.Insert AS Insert,
	|	TRUE AS AreGroupSetRights,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind
	|FROM
	|	(SELECT
	|		GroupsInSets.Ref AS ExternalUser,
	|		MAX(AccessGroupsAccessKeys.Update) AS Update,
	|		MAX(AccessGroupsAccessKeys.Insert) AS Insert,
	|		1 AS RowChangeKind
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|			INNER JOIN Catalog.AccessGroupsSets.Folders AS GroupsInSets
	|			ON (GroupsInSets.Group = AccessGroupsAccessKeys.AccessGroup)
	|				AND (AccessGroupsAccessKeys.AccessKey = &AccessKey)
	|	
	|	GROUP BY
	|		GroupsInSets.Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		&AllowedEmptySet,
	|		AccessGroupsAccessKeys.Update,
	|		AccessGroupsAccessKeys.Insert,
	|		1
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|	WHERE
	|		AccessGroupsAccessKeys.AccessGroup = VALUE(Catalog.AccessGroups.EmptyRef)
	|		AND AccessGroupsAccessKeys.AccessKey = &AccessKey
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.ExternalUser,
	|		OldData.Update,
	|		OldData.Insert,
	|		-1
	|	FROM
	|		InformationRegister.ExternalUsersAccessKeys AS OldData
	|	WHERE
	|		OldData.AreGroupSetRights
	|		AND OldData.AccessKey = &AccessKey) AS AllRows
	|
	|GROUP BY
	|	AllRows.ExternalUser,
	|	AllRows.Update,
	|	AllRows.Insert
	|
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0
	|
	|ORDER BY
	|	RowChangeKind";
	
EndFunction

// For the UpdateRightsToListAccessKey procedure.
Procedure UpdateInitialGroupsRightsToAccessKey(QueryResult, RecordSet, RightsOwnerFieldName,
			 AccessKey, RightsToKey, UpdateParameters, HasRightsChanges)
	
	If Not UpdateParameters.CalculateUserRights Then
		IsAccessGroupsRights         = True;
		IsUsersRights        = False;
		IsExternalUsersRights = False;
	ElsIf Not UpdateParameters.ForExternalUsers Then
		IsAccessGroupsRights         = False;
		IsUsersRights        = True;
		IsExternalUsersRights = False;
	Else
		IsAccessGroupsRights         = False;
		IsUsersRights        = False;
		IsExternalUsersRights = True;
	EndIf;
	
	Selection = QueryResult.Select();
	
	While Selection.Next() Do
		Rights = RightsToKey.Get(Selection[RightsOwnerFieldName]);
		If Rights = Undefined Then
			RecordSet.Filter[RightsOwnerFieldName].Set(Selection[RightsOwnerFieldName]);
			RecordSet.Write();
			HasRightsChanges = True;
		ElsIf Selection.Update                    = Rights.Update
		        AND Selection.Insert                   = Rights.Insert
		        AND Selection.IsAccessGroupsRights         = IsAccessGroupsRights
		        AND Selection.IsUsersRights        = IsUsersRights
		        AND Selection.IsExternalUsersRights = IsExternalUsersRights Then
			RightsToKey.Insert(Selection[RightsOwnerFieldName], Null);
		EndIf;
	EndDo;
	
	OneRecord = RecordSet.Add();
	OneRecord.AccessKey = AccessKey;
	For Each RightsDetails In RightsToKey Do
		If RightsDetails.Value = Null Then
			Continue;
		EndIf;
		RecordSet.Filter[RightsOwnerFieldName].Set(RightsDetails.Key);
		OneRecord[RightsOwnerFieldName]        = RightsDetails.Key;
		OneRecord.Update                    = RightsDetails.Value.Update;
		OneRecord.Insert                   = RightsDetails.Value.Insert;
		OneRecord.IsAccessGroupsRights         = IsAccessGroupsRights;
		OneRecord.IsUsersRights        = IsUsersRights;
		OneRecord.IsExternalUsersRights = IsExternalUsersRights;
		RecordSet.Write();
		HasRightsChanges = True;
	EndDo;
	
EndProcedure

// For the UpdateRightsToListAccessKey procedure.
Procedure UpdateInitialUsersRightsToAccessKey(QueryResult, RecordSet,
			RightsOwnerFieldName, AccessKey, RightsToKey, HasRightsChanges)
	
	Selection = QueryResult.Select();
	
	While Selection.Next() Do
		Rights = RightsToKey.Get(Selection[RightsOwnerFieldName]);
		If Rights = Undefined Then
			RecordSet.Filter[RightsOwnerFieldName].Set(Selection[RightsOwnerFieldName]);
			RecordSet.Write();
			HasRightsChanges = True;
		ElsIf Selection.Update  = Rights.Update
		        AND Selection.Insert = Rights.Insert
		        AND Selection.AreGroupSetRights = False Then
			RightsToKey.Insert(Selection[RightsOwnerFieldName], Null);
		EndIf;
	EndDo;
	
	OneRecord = RecordSet.Add();
	OneRecord.AccessKey = AccessKey;
	For Each RightsDetails In RightsToKey Do
		If RightsDetails.Value = Null Then
			Continue;
		EndIf;
		RecordSet.Filter[RightsOwnerFieldName].Set(RightsDetails.Key);
		OneRecord[RightsOwnerFieldName] = RightsDetails.Key;
		OneRecord.Update  = RightsDetails.Value.Update;
		OneRecord.Insert = RightsDetails.Value.Insert;
		OneRecord.AreGroupSetRights = False;
		RecordSet.Write();
		HasRightsChanges = True;
	EndDo;
	
EndProcedure

// For the UpdateRightsToListAccessKey procedure.
Procedure UpdateDerivedRightsToAccessKey(QueryResult, RecordSet, RightsOwnerFieldName, AccessKey, HasChanges = False)
	
	Selection = QueryResult.Select();
	DeletionCompleted = False;
	
	While Selection.Next() Do
		RecordSet.Filter[RightsOwnerFieldName].Set(Selection[RightsOwnerFieldName]);
		If Not DeletionCompleted AND Selection.RowChangeKind = 1 Then
			DeletionCompleted = True;
			OneRecord = RecordSet.Add();
			OneRecord.AccessKey = AccessKey;
		EndIf;
		If DeletionCompleted Then
			FillPropertyValues(OneRecord, Selection);
		EndIf;
		RecordSet.Write();
		HasChanges = True;
	EndDo;
	
EndProcedure

// Creates a catalog service item that does not subscribe to events.
Function ServiceItem(CatalogManager, Ref = Undefined)
	
	If Ref = Undefined Then
		CatalogItem = CatalogManager.CreateItem();
	Else
		CatalogItem = Ref.GetObject();
		If CatalogItem = Undefined Then
			Return Undefined;
		EndIf;
	EndIf;
	
	CatalogItem.AdditionalProperties.Insert("DisableObjectChangeRecordMechanism");
	CatalogItem.DataExchange.Recipients.AutoFill = False;
	CatalogItem.DataExchange.Load = True;
	
	Return CatalogItem;
	
EndFunction

// Creates a record set of a service register that does subscribe to events.
Function ServiceRecordSet(RegisterManager)
	
	RecordSet = RegisterManager.CreateRecordSet();
	RecordSet.AdditionalProperties.Insert("DisableObjectChangeRecordMechanism");
	RecordSet.DataExchange.Recipients.AutoFill = False;
	RecordSet.DataExchange.Load = True;
	
	Return RecordSet;
	
EndFunction

// For the ExecuteAccessUpdate procedure.
Function MaxCountOfMinutesToPerformBackgroundAccessUpdateJob()
	
	Return 2;
	
EndFunction

// For the FillTemplatesOfObjectCheckQueryParts procedure.
Function BatchSizeMarker()
	
	Return "995";
	
EndFunction

Function DataItemsBatchSize()
	
	Return 1000;
	
EndFunction

Function AccessKeysBatchSize()
	
	Return 1000;
	
EndFunction

//  the FillPropertiesOfHeadListFieldsCheck procedure.
Function MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes()
	
	Return 100;
	
EndFunction

Function DataRestrictionsDetails() Export
	
	CommonContext = New Structure;
	CommonContext.Insert("ListsWithRestriction", AccessManagementInternalCached.ListsWithRestriction());
	CommonContext.Insert("ExternalUsersEnabled", Constants.UseExternalUsers.Get());
	
	Result = New Map;
	
	For Each ListDetails In CommonContext.ListsWithRestriction Do
		FullName = ListDetails.Key;
		RestrictionDetails = DataRestrictionDetails(CommonContext, FullName);
		Result.Insert(FullName, RestrictionDetails);
	EndDo;
	
	Return Result;
	
EndFunction

#EndRegion

#Region AccessRestrictionParameters

#Region AccessRestrictionParametersMainPart

// The main function that returns the parameters required for registering necessity to update access 
// keys to data items.
Function ListPropertiesAsLeadingOne(FullName, TransactionID = Undefined)
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	ActiveParameters = ActiveAccessRestrictionParameters(TransactionID, Undefined);
	StoredListPropertiesAsLeadingOne = ActiveParameters.LeadingLists.Get(FullName);
	
	If StoredListPropertiesAsLeadingOne = Undefined Then
		Return Undefined;
	EndIf;
	
	Cache = RestrictionParametersCache();
	
	ListPropertiesAsLeadingOne = Cache.LeadingListsChecked.Get(FullName);
	If ListPropertiesAsLeadingOne <> Undefined Then
		Return ListPropertiesAsLeadingOne;
	EndIf;
	
	ListPropertiesAsLeadingOne = New Structure(StoredListPropertiesAsLeadingOne);
	FillPreviousValuesQueryTextToCheckLeadingListFieldsChanges(FullName,
		ListPropertiesAsLeadingOne);
	
	Cache.LeadingListsChecked.Insert(FullName,
		New FixedStructure(ListPropertiesAsLeadingOne));
	
	ListsToCheck = New Array;
	For Each ListDetails In StoredListPropertiesAsLeadingOne.DependentLists Do
		If Cache.ListsRestrictions.Get(ListDetails.Key) = Undefined Then
			ListsToCheck.Add(ListDetails.Key);
		EndIf;
	EndDo;
	ListsToCheck.Add(FullName);
	
	ActiveParametersUpdated = False;
	ListsRestrictionsToAdd = New Map;
	
	FillRestrictionParameters(ListsToCheck, TransactionID,
		ActiveParametersUpdated, ListsRestrictionsToAdd);
	
	If ActiveParametersUpdated Then
		Return ListPropertiesAsLeadingOne(FullName);
	EndIf;
	
	If ListsRestrictionsToAdd.Count() > 0 Then
		For Each KeyAndValue In ListsRestrictionsToAdd Do
			Cache.ListsRestrictions.Insert(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	EndIf;
	
	Return ListPropertiesAsLeadingOne;
	
EndFunction

// For the ListPropertiesAsLeadingOne function, the FillRestrictionParameters,
// UpdateTransactionIDs, and SetParameterVersion procedures.
//
Function RestrictionParametersCache()
	
	CachedDataKey = String(SessionParameters.CachedDataKey);
	
	Return AccessManagementInternalCached.RestrictionParametersCache(CachedDataKey);
	
EndFunction

// For the ListPropertiesAsLeadingOne function.
Procedure FillPreviousValuesQueryTextToCheckLeadingListFieldsChanges(FullName, Properties)
	
	Properties.Delete("DependentLists");
	If Properties.ByFieldsValues = Undefined Then
		Return;
	EndIf;
	
	ByFieldsValues = New Structure(Properties.ByFieldsValues);
	
	If ByFieldsValues.IsReferenceType Then
		If ValueIsFilled(ByFieldsValues.HeaderFields) Then
			QueryText =
			"SELECT
			|	CurrentTable.Field1 AS Field1
			|FROM
			|	(SELECT
			|		TRUE AS TrueValue) AS TrueValue
			|		LEFT JOIN CurrentDataItemTable AS CurrentTable
			|		ON (CurrentTable.Ref = &ObjectRef)";
			FillCurrentTableSelectionFields(QueryText, FullName, ByFieldsValues.HeaderFields)
		Else
			QueryText = "";
		EndIf;
		
		For Each TabularSection In ByFieldsValues.TabularSections Do
			TabularSectionQueryText =
			"SELECT DISTINCT TOP 100
			|	CurrentTable.Field1 AS Field1
			|FROM
			|	CurrentDataItemTable AS CurrentTable
			|WHERE
			|	CurrentTable.Ref = &ObjectRef";
			FillCurrentTableSelectionFields(TabularSectionQueryText,
				FullName + "." + TabularSection.Name, TabularSection.Fields);
			
			QueryText = QueryText + ?(QueryText = "", "",
				Common.QueryBatchSeparator()) + TabularSectionQueryText;
		EndDo;
		
	ElsIf ValueIsFilled(ByFieldsValues.RegisterFields.Fields) Then
		QueryText =
		"SELECT DISTINCT TOP 100
		|	CurrentTable.Field1 AS Field1
		|FROM
		|	CurrentDataItemTable AS CurrentTable
		|WHERE
		|	&FilterByDimensions";
		FillCurrentTableSelectionFields(QueryText, FullName, ByFieldsValues.RegisterFields.Fields);
		QueryText = StrReplace(QueryText, "TOP 100", "TOP "
			+ Format(MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes(), "NG="));
	Else
		QueryText = "";
	EndIf;
	
	ByFieldsValues.Insert("QueryText", QueryText);
	Properties.ByFieldsValues = New FixedStructure(ByFieldsValues);
	
EndProcedure

// For the FillPreviousValuesQueryTextToCheckLeadingListFieldsChanges procedure.
Procedure FillCurrentTableSelectionFields(QueryText, FullName, FieldsDetails)
	
	SelectionFields = "";
	For Each FieldDetails In FieldsDetails Do
		FieldName = ?(TypeOf(FieldsDetails) = Type("FixedArray"), FieldDetails, FieldDetails.Key);
		SelectionFields = SelectionFields + ?(SelectionFields = "", "", "," + Chars.LF)
			+ "CurrentTable." + FieldName + " AS " + FieldName;
	EndDo;
	QueryText = StrReplace(QueryText,
		"CurrentTable.Field1 AS Field1", TextWithIndent(TrimL(SelectionFields), "	"));
	
	QueryText = StrReplace(QueryText, "CurrentDataItemTable", FullName);
	
	QueryText = StrReplace(QueryText, "TOP 100", "TOP " + Format(
		MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes(), "NG="));
	
EndProcedure

// The main function that returns the parameters required for checking rights upon recording data items.
Function RestrictionParameters(FullName, TransactionID = Undefined, ForExternalUsers = Undefined) Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	ActiveAccessRestrictionParameters(TransactionID, Undefined);
	Parameters = RestrictionParametersCache().ListsRestrictions.Get(FullName);
	
	If Parameters = Undefined Then
		FillRestrictionParameters(FullName, TransactionID, False);
		
		ActiveAccessRestrictionParameters(TransactionID, Undefined);
		Parameters = RestrictionParametersCache().ListsRestrictions.Get(FullName);
	EndIf;
	
	If ForExternalUsers = Undefined Then
		ForExternalUsers = UsersClientServer.IsExternalUserSession();
	EndIf;
	
	If ForExternalUsers Then
		Return Parameters.ForExternalUsers;
	EndIf;
	
	Return Parameters.ForUsers;
	
EndFunction

// For the ListPropertiesAsLeadingOne and RestrictionParameters functions.
Procedure FillRestrictionParameters(FullName, TransactionID, ActiveParametersUpdated,
			ListsRestrictionsToAdd = Undefined, CommonContext = Undefined, RepeatedCall = False)
	
	If CommonContext = Undefined Then
		CommonContext = CommonContextOfRestrictionParametersCalculation();
		CommonContext.Insert("RestrictionsDetails", New Map);
	EndIf;
	
	ListsRestrictionParameters = New Map;
	ActiveParameters = ActiveAccessRestrictionParameters(TransactionID, CommonContext);
	FullNameOnLoop = "";
	
	If TypeOf(FullName) = Type("Array") Then
		For Each CurrentFullName In FullName Do
			AddListRestrictionParameters(CurrentFullName, ListsRestrictionParameters,
				ActiveParameters, ActiveParametersUpdated, TransactionID, CommonContext);
			
			If ActiveParametersUpdated Then
				If RepeatedCall Then
					FullNameOnLoop = CurrentFullName;
					Break;
				EndIf;
				FillRestrictionParameters(FullName,
					TransactionID, False, ListsRestrictionsToAdd, CommonContext, True);
				Return;
			EndIf;
		EndDo;
	Else
		AddListRestrictionParameters(FullName, ListsRestrictionParameters,
			ActiveParameters, ActiveParametersUpdated, TransactionID, CommonContext);
		
		If ActiveParametersUpdated Then
			If RepeatedCall Then
				FullNameOnLoop = FullName;
			Else
				FillRestrictionParameters(FullName,
					TransactionID, False, ListsRestrictionsToAdd, CommonContext, True);
				Return;
			EndIf;
		EndIf;
	EndIf;
	
	If ValueIsFilled(FullNameOnLoop) Then
		Raise StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не удалось обновить параметры ограничения доступа списка ""%1""
			           |из-за нестабильной строки свойств версии параметров для вычисления хеш-суммы.'; 
			           |en = 'Cannot update parameters of the ""%1"" list access restriction
			           |due to not stable string of the parameter version properties for calculating a hash sum.'; 
			           |pl = 'Nie można zaktualizować
			           |parametrów ograniczenia dostępu do listy ""%1"" ze względu na niestabilny ciąg właściwości wersji parametru do obliczenia sumy kontrolnej.';
			           |es_ES = 'No se ha podido actualizar los parámetros de restricción de acceso de la lista ""%1""
			           |a causa de una línea inestable de las propiedades de la versión de parámetros para calcular el importe hash.';
			           |es_CO = 'No se ha podido actualizar los parámetros de restricción de acceso de la lista ""%1""
			           |a causa de una línea inestable de las propiedades de la versión de parámetros para calcular el importe hash.';
			           |tr = 'Karma toplamı hesaplamak için parametrelerin sürümünün kararsız özellik dizesi nedeniyle ""%1"" 
			           |liste erişim kısıtlaması ayarları güncellenemedi.';
			           |it = 'Impossibile aggiornare i parametri della restrizione all''accesso all''elenco ""%1""
			           |a causa di una stringa instabile delle proprietà di versione del parametro per il calcolo di una somma hash.';
			           |de = 'Es war nicht möglich, die Parameter der Zugriffsbeschränkung der Liste ""%1""
			           |zu aktualisieren, da die Eigenschaften der Version der Parameter zur Berechnung der Hash-Summe instabil sind.'"),
			FullNameOnLoop);
	EndIf;
	
	If ListsRestrictionParameters.Count() = 0 Then
		Return;
	EndIf;
	
	If ListsRestrictionsToAdd <> Undefined Then
		ListsRestrictionsToAdd = ListsRestrictionParameters;
		Return;
	EndIf;
	
	Cache = RestrictionParametersCache();
	
	For Each KeyAndValue In ListsRestrictionParameters Do
		Cache.ListsRestrictions.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	
EndProcedure

// For the FillRestrictionParameters procedure,
// StoredAccessRestrictionParameters, and AccessRestrictionsErrors functions.
//
Function CommonContextOfRestrictionParametersCalculation(AllAccessKindsUsed = False, FillListsWithRestriction = True)
	
	UserTypes = New Array;
	UserTypes.Add(Type("CatalogRef.Users"));
	UserTypes.Add(Type("CatalogRef.UserGroups"));
	UserTypes.Add(Type("CatalogRef.ExternalUsers"));
	UserTypes.Add(Type("CatalogRef.ExternalUsersGroups"));
	
	ValuesTypesToUse = New Map;
	
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	
	For Each AccessKindProperties In AccessKindsProperties.Array Do
		If Not AllAccessKindsUsed
		   AND Not AccessKindUsed(AccessKindProperties.Ref) Then
			Continue;
		EndIf;
		ValuesTypesToUse.Insert(AccessKindProperties.ValuesType, True);
		For Each AdditionalTypeDetails In AccessKindProperties.AdditionalTypes Do
			ValuesTypesToUse.Insert(AdditionalTypeDetails.ValuesType, True);
		EndDo;
	EndDo;
	
	AvailableRights = AccessManagementInternalCached.RightsForObjectsRightsSettingsAvailable();
	ExternalUsersEnabled = AllAccessKindsUsed
		Or Constants.UseExternalUsers.Get();
	
	CommonContext = New Structure;
	CommonContext.Insert("AccessKindsProperties",         AccessKindsProperties);
	CommonContext.Insert("UserTypes",             UserTypes);
	CommonContext.Insert("ValuesTypesToUse",     ValuesTypesToUse);
	CommonContext.Insert("RightsSettingsOwnersTypes",   AvailableRights.ByRefsTypes);
	CommonContext.Insert("SeparateRightsSettingsTables", AvailableRights.SeparateTables);
	CommonContext.Insert("ExternalUsersEnabled",  ExternalUsersEnabled);
	
	If FillListsWithRestriction Then
		CommonContext.Insert("ListsWithRestriction", AccessManagementInternalCached.ListsWithRestriction());
	EndIf;
	
	Return CommonContext;
	
EndFunction

// For the FillRestrictionParameters procedure.
Procedure AddListRestrictionParameters(FullName, ListsRestrictionParameters, ActiveParameters,
			ActiveParametersUpdated, TransactionID, CommonContext)
	
	If RestrictionParametersCache().ListsRestrictions.Get(FullName) <> Undefined Then
		Return;
	EndIf;
	
	RestrictionsVersion = ActiveParameters.ListsRestrictionsVersions.Get(FullName);
	CalculatedParameters = CalculatedRestrictionParameters(FullName, CommonContext, ActiveParameters);
	
	If RestrictionsVersion <> CalculatedParameters.Version Then
		ActiveParameters = ActiveAccessRestrictionParameters(TransactionID, CommonContext, , True);
		ActiveParametersUpdated = True;
		Return;
	EndIf;
	
	ListsRestrictionParameters.Insert(FullName,
		Common.FixedData(CalculatedParameters));
	
EndProcedure

// For the AddListRestrictionParameters procedure.
Function CalculatedRestrictionParameters(FullName, CommonContext, ActiveParameters)
	
	RestrictionDetails = DataRestrictionDetails(CommonContext, FullName);
	
	// For users.
	RestrictionStructureForUsers = CalculatedRestrictionStructure(FullName,
		RestrictionDetails.Text, RestrictionDetails.TextInManagerModule, False);
	
	AdditionalContext = NewAdditionalContext();
	FillPropertyValues(AdditionalContext, ActiveParameters.AdditionalContext.ForUsers);
	AddAdditionalContext(FullName, AdditionalContext, RestrictionDetails, False);
	
	ResultForUsers = RestrictionParametersByRestrictionStructure(FullName,
		RestrictionStructureForUsers, False, CommonContext, AdditionalContext);
	
	// For external users.
	RestrictionStructureForExternalUsers = CalculatedRestrictionStructure(FullName,
		RestrictionDetails.TextForExternalUsers, RestrictionDetails.TextInManagerModule, True);
	
	AdditionalContext = NewAdditionalContext();
	FillPropertyValues(AdditionalContext, ActiveParameters.AdditionalContext.ForExternalUsers);
	AddAdditionalContext(FullName, AdditionalContext, RestrictionDetails, True);
	
	ResultForExternalUsers = RestrictionParametersByRestrictionStructure(FullName,
		RestrictionStructureForExternalUsers, True, CommonContext, AdditionalContext);
	
	// Filling in parameters based on parameters of both user kinds.
	Version = CommonVersion(CommonContext, FullName, ResultForUsers.Version, ResultForExternalUsers.Version);
	WithTwoKeysRecord = Not WithouWritetKey(ResultForUsers) AND Not WithouWritetKey(ResultForExternalUsers);
	WithoutKeysRecord    =    WithouWritetKey(ResultForUsers) AND    WithouWritetKey(ResultForExternalUsers);
	ResultForUsers.Insert(       "WriteAccessKeysForUsersAndExternalUsers", WithTwoKeysRecord);
	ResultForExternalUsers.Insert("WriteAccessKeysForUsersAndExternalUsers", WithTwoKeysRecord);
	ResultForUsers.Insert(       "DoNotWriteAccessKeysForUsersAndExternalUsers", WithoutKeysRecord);
	ResultForExternalUsers.Insert("DoNotWriteAccessKeysForUsersAndExternalUsers", WithoutKeysRecord);
	
	// Generating query texts.
	AddQueryTextsToRestrictionParameters(ResultForUsers);
	AddQueryTextsToRestrictionParameters(ResultForExternalUsers);
	
	LeadingLists = New Structure;
	LeadingLists.Insert("ForUsers",        ResultForUsers.LeadingLists);
	LeadingLists.Insert("ForExternalUsers", ResultForExternalUsers.LeadingLists);
	
	Parameters = New Structure;
	Parameters.Insert("Version",                  Version);
	Parameters.Insert("LeadingLists",           LeadingLists);
	Parameters.Insert("ForUsers",        ResultForUsers);
	Parameters.Insert("ForExternalUsers", ResultForExternalUsers);
	
	Return Parameters;
	
EndFunction

// For the AccessRestrictionErrors function.
Function AccessRestrictionError(CommonContext, FullName)
	
	ErrorTextForUsers = "";
	ErrorTextForExternalUsers = "";
	
	Try
		RestrictionDetails = DataRestrictionDetails(CommonContext, FullName, True);
	Except
		ErrorInformation = ErrorInfo();
		Return DetailErrorDescription(ErrorInformation);
	EndTry;
	If TypeOf(RestrictionDetails) = Type("String") Then
		Return RestrictionDetails;
	EndIf;
	
	// For users.
	RestrictionStructureForUsers = CalculatedRestrictionStructure(FullName,
		RestrictionDetails.Text, RestrictionDetails.TextInManagerModule, False, True);
	
	If RestrictionStructureForUsers <> Undefined
	   AND RestrictionStructureForUsers.ErrorsDetails.HasErrors Then
		
		ErrorTextForUsers = ErrorsTextToCallException(FullName,
			RestrictionStructureForUsers.ErrorsDetails, False, RestrictionDetails.TextInManagerModule);
	Else
		AdditionalContext = NewAdditionalContext();
		AddAdditionalContext(FullName, AdditionalContext, RestrictionDetails, False);
		
		ErrorOnCallException = New Structure("Text", Undefined);
		AdditionalContext.Insert("ErrorOnCallException", ErrorOnCallException);
		Try
			ResultForUsers = RestrictionParametersByRestrictionStructure(FullName,
				RestrictionStructureForUsers, False, CommonContext, AdditionalContext);
		Except
			ErrorInformation = ErrorInfo();
			If ValueIsFilled(ErrorOnCallException.Text) Then
				ErrorTextForUsers = ErrorOnCallException.Text;
			Else
				ErrorTextForUsers = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Не удалось сформировать параметры ограничения доступа для пользователей по причине:
					           |%1'; 
					           |en = 'Cannot generate access restriction parameters for users due to:
					           |%1'; 
					           |pl = 'Nie udało się utworzyć ustawienia ograniczenia dostępu dla użytkowników z powodu:
					           |%1';
					           |es_ES = 'No se ha podido generar los parámetros de restricción de acceso para los usuarios a causa de:
					           |%1';
					           |es_CO = 'No se ha podido generar los parámetros de restricción de acceso para los usuarios a causa de:
					           |%1';
					           |tr = 'Kullanıcılar için erişim kısıtlaması parametreleri şu nedenle oluşturulamadı:
					           |%1';
					           |it = 'Impossibile generare i parametri di restrizione all''accesso per gli utenti a causa di:
					           |%1';
					           |de = 'Die Parameter der Zugriffsbeschränkung für Benutzer konnten aus diesem Grund nicht generiert werden:
					           |%1'"), DetailErrorDescription(ErrorInformation));
			EndIf;
		EndTry;
		
		If Not ValueIsFilled(ErrorTextForUsers) Then
			ResultForUsers.Insert("DoNotWriteAccessKeysForUsersAndExternalUsers", False);
			ResultForUsers.Context.ListsWithKeysRecordForDependentListsWithoutKeys = New Map;
			Try
				AddQueryTextsToRestrictionParameters(ResultForUsers);
			Except
				ErrorInformation = ErrorInfo();
				If ValueIsFilled(ErrorOnCallException.Text) Then
					ErrorTextForUsers = ErrorOnCallException.Text;
				Else
					ErrorTextForUsers = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Не удалось сформировать тексты запросов на основе параметров ограничения доступа
						           |для пользователей по причине:
						           |%1'; 
						           |en = 'Cannot generate query texts based on access restriction parameters
						           |for users due to:
						           |%1'; 
						           |pl = 'Nie udało się utworzyć tekstów wniosków na podstawie parametrów ograniczenia dostępu
						           |dla użytkowników z powodu:
						           |%1';
						           |es_ES = 'No se ha podido generar los textos de solicitudes a base de los parámetros de restricción del acceso
						           |para los usuarios a causa de:
						           |%1';
						           |es_CO = 'No se ha podido generar los textos de solicitudes a base de los parámetros de restricción del acceso
						           |para los usuarios a causa de:
						           |%1';
						           |tr = 'Kullanıcılar için erişim kısıtlaması parametrelerine bağlı
						           |sorgu metinleri şu nedenle oluşturulamadı:
						           |%1';
						           |it = 'Impossibile generare testi di query basati sui parametri di restrizione all''accesso
						           |per gli utenti a causa di:
						           |%1';
						           |de = 'Die Texte von Anfragen konnten aufgrund der Parameter der Zugriffsbeschränkung
						           |für Benutzer aus diesem Grund nicht generiert werden:
						           |%1'"), DetailErrorDescription(ErrorInformation));
				EndIf;
			EndTry;
		EndIf;
	EndIf;
	
	// For external users.
	RestrictionStructureForExternalUsers = CalculatedRestrictionStructure(FullName,
		RestrictionDetails.TextForExternalUsers, RestrictionDetails.TextInManagerModule, True, True);
	
	If RestrictionStructureForExternalUsers <> Undefined
	   AND RestrictionStructureForExternalUsers.ErrorsDetails.HasErrors Then
		
		ErrorTextForExternalUsers = ErrorsTextToCallException(FullName,
			RestrictionStructureForExternalUsers.ErrorsDetails, True, RestrictionDetails.TextInManagerModule);
	Else
		AdditionalContext = NewAdditionalContext();
		AddAdditionalContext(FullName, AdditionalContext, RestrictionDetails, True);
		
		ErrorOnCallException = New Structure("Text", Undefined);
		AdditionalContext.Insert("ErrorOnCallException", ErrorOnCallException);
		Try
			ResultForExternalUsers = RestrictionParametersByRestrictionStructure(FullName,
				RestrictionStructureForExternalUsers, True, CommonContext, AdditionalContext);
		Except
			ErrorInformation = ErrorInfo();
			If ValueIsFilled(ErrorOnCallException.Text) Then
				ErrorTextForExternalUsers = ErrorOnCallException.Text;
			Else
				ErrorTextForExternalUsers = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Не удалось сформировать параметры ограничения доступа для внешних пользователей по причине:
					           |%1'; 
					           |en = 'Cannot generate access restriction parameters for external users due to:
					           |%1'; 
					           |pl = 'Nie udało się utworzyć ustawienia ograniczenia dostępu dla użytkowników zewnętrznych z powodu:
					           |%1';
					           |es_ES = 'No se ha podido generar los parámetros de restricción de acceso para los usuarios externos a causa de:
					           |%1';
					           |es_CO = 'No se ha podido generar los parámetros de restricción de acceso para los usuarios externos a causa de:
					           |%1';
					           |tr = 'Harici kullanıcılar için erişim kısıtlaması parametreleri şu nedenle oluşturulamadı:
					           |%1';
					           |it = 'Impossibile generare i parametri di restrizione all''accesso per gli utenti esterni a causa di:
					           |%1';
					           |de = 'Die Parameter der Zugriffsbeschränkung für externe Benutzer konnten aus diesem Grund nicht generiert werden:
					           |%1'"), DetailErrorDescription(ErrorInformation));
			EndIf;
		EndTry;
		
		If Not ValueIsFilled(ErrorTextForExternalUsers) Then
			ResultForExternalUsers.Insert("DoNotWriteAccessKeysForUsersAndExternalUsers", False);
			ResultForExternalUsers.Context.ListsWithKeysRecordForDependentListsWithoutKeys = New Map;
			Try
				AddQueryTextsToRestrictionParameters(ResultForExternalUsers);
			Except
				ErrorInformation = ErrorInfo();
				If ValueIsFilled(ErrorOnCallException.Text) Then
					ErrorTextForExternalUsers = ErrorOnCallException.Text;
				Else
					ErrorTextForExternalUsers = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Не удалось сформировать тексты запросов на основе параметров ограничения доступа
						           |для внешних пользователей по причине:
						           |%1'; 
						           |en = 'Cannot generate query texts based on access restriction parameters
						           |for external users due to:
						           |%1'; 
						           |pl = 'Nie udało się utworzyć tekstów wniosków na podstawie parametrów ograniczenia dostępu
						           |dla użytkowników zewnętrznych z powodu:
						           |%1';
						           |es_ES = 'No se ha podido generar los textos de solicitudes a base de los parámetros de restricción del acceso
						           |para los usuarios externos a causa de:
						           |%1';
						           |es_CO = 'No se ha podido generar los textos de solicitudes a base de los parámetros de restricción del acceso
						           |para los usuarios externos a causa de:
						           |%1';
						           |tr = 'Harici kullanıcılar için erişim kısıtlaması parametrelerine bağlı
						           |sorgu metinleri şu nedenle oluşturulamadı:
						           |%1';
						           |it = 'Impossibile generare testi di query basati sui parametri di restrizione all''accesso
						           |per utenti esterni a causa di:
						           |%1';
						           |de = 'Die Texte von Abfragen konnten aus diesem Grund nicht auf der Grundlage der Parameter der Zugriffsbeschränkung
						           |für externe Benutzer generiert werden:
						           |%1'"), DetailErrorDescription(ErrorInformation));
				EndIf;
			EndTry;
		EndIf;
	EndIf;
	
	Return TrimAll(ErrorTextForUsers
		+ Chars.LF + Chars.LF + ErrorTextForExternalUsers);
	
EndFunction

// For the AccessRestrictionCheckResult function.
Function ObjectAccessRestrictionCheckResult(FullName, Val AdditionalParameters)
	
	If Not ValueIsFilled(AdditionalParameters) Then
		AdditionalParameters = New Structure;
		AdditionalParameters.Insert("Text", Undefined);
		AdditionalParameters.Insert("TextForExternalUsers", Undefined);
		AdditionalParameters.Insert("ConsiderDependencies", False);
	EndIf;
	
	ForUsers        = RestrictionCheckResultStructureForUsersKind();
	ForExternalUsers = RestrictionCheckResultStructureForUsersKind();
	
	Result = New Structure;
	Result.Insert("RestrictionDetailsError", "");
	Result.Insert("TextInManagerModule",     Undefined);
	Result.Insert("ForUsers",          ForUsers);
	Result.Insert("ForExternalUsers",   ForExternalUsers);
	Result.Insert("ImplementationSettings",        New Structure);
	
	CommonContext = Undefined;
	Try
		CommonContext = CommonContextOfRestrictionParametersCalculation(True, False);
	Except
		ErrorInformation = ErrorInfo();
		Result.RestrictionDetailsError = DetailErrorDescription(ErrorInformation);
	EndTry;
	
	If CommonContext = Undefined Then
		Return Result;
	EndIf;
	
	DependenciesAccountingAvailable = True;
	ListsWithRestriction = Undefined;
	Try
		ListsWithRestriction = AccessManagementInternalCached.ListsWithRestriction();
	Except
		ErrorInformation = ErrorInfo();
		Result.RestrictionDetailsError = DetailErrorDescription(ErrorInformation);
		DependenciesAccountingAvailable = False;
	EndTry;
	
	If ListsWithRestriction <> Undefined Then
		ListsWithRestriction = New Map(ListsWithRestriction);
	Else
		ListsWithRestriction = New Map;
		DependenciesAccountingAvailable = False;
	EndIf;
	CommonContext.Insert("ListsWithRestriction", ListsWithRestriction);
	
	RestrictionDetails = Undefined;
	Try
		RestrictionDetails = DataRestrictionDetails(CommonContext, FullName, True);
	Except
		Result.RestrictionDetailsError = DetailErrorDescription(ErrorInformation);
		DependenciesAccountingAvailable = False;
	EndTry;
	If TypeOf(RestrictionDetails) = Type("String") Then
		Result.RestrictionDetailsError = RestrictionDetails;
		RestrictionDetails = Undefined;
	EndIf;
	
	If RestrictionDetails <> Undefined Then
		Result.TextInManagerModule                    = RestrictionDetails.TextInManagerModule;
		ForUsers.RestrictionInModule                = RestrictionDetails.Text;
		ForUsers.ByOwnerWithoutSavingAccessKeys = RestrictionDetails.ByOwnerWithoutSavingAccessKeys;
		ForExternalUsers.RestrictionInModule         = RestrictionDetails.TextForExternalUsers;
		ForExternalUsers.ByOwnerWithoutSavingAccessKeys =
			RestrictionDetails.ByOwnerWithoutSavingAccessKeysForExternalUsers;
		
		If AdditionalParameters.Text = Undefined Then
			ForUsers.RestrictionToCheck = ForUsers.RestrictionInModule;
		Else
			ForUsers.RestrictionToCheck = AdditionalParameters.Text;
			RestrictionDetails.Text               = AdditionalParameters.Text;
		EndIf;
		
		If AdditionalParameters.TextForExternalUsers = Undefined Then
			ForExternalUsers.RestrictionToCheck = ForExternalUsers.RestrictionInModule;
		Else
			ForExternalUsers.RestrictionToCheck   = AdditionalParameters.TextForExternalUsers;
			RestrictionDetails.TextForExternalUsers = AdditionalParameters.TextForExternalUsers;
		EndIf;
	EndIf;
	
	If ListsWithRestriction.Get(FullName) = Undefined Then
		ListsWithRestriction.Insert(FullName, True);
		Result.TextInManagerModule = Undefined;
	EndIf;
	
	Context = New Structure;
	Context.Insert("FullName",                FullName);
	Context.Insert("CommonResult",           Result);
	Context.Insert("CommonContext",            CommonContext);
	Context.Insert("RestrictionDetails",      RestrictionDetails);
	Context.Insert("ConsiderDependencies",     AdditionalParameters.ConsiderDependencies);
	Context.Insert("DependenciesAccountingAvailable", DependenciesAccountingAvailable);
	Context.Insert("ListsRestrictionsVersions", New Map);
	Context.Insert("AdditionalContext",   New Structure("ForUsers, ForExternalUsers"));
	
	CheckRestrictionForUsersKind(Context, ForUsers, False,
		Context.AdditionalContext.ForUsers);
	
	CheckRestrictionForUsersKind(Context, ForExternalUsers, True,
		Context.AdditionalContext.ForExternalUsers);
	
	If Not Context.DependenciesAccountingAvailable Then
		Return Result;
	EndIf;
	
	If AdditionalParameters.ConsiderDependencies Then
		CommonContext.Insert("SpecialFullName", FullName);
		CommonContext.Insert("SpecialRestrictionDetails", RestrictionDetails);
		CommonContext.Insert("ListsWithRestriction", New FixedMap(ListsWithRestriction));
		NewStoredParameters = StoredAccessRestrictionParameters(CommonContext);
		ActiveParameters = New Structure(NewStoredParameters.ForWritingObjectsAndCheckingRights.Get());
		If ActiveParameters.ListsRestrictionsVersions.Get(FullName) = Undefined Then
			Context.ListsRestrictionsVersions.Insert(FullName, True);
		Else
			Context.ListsRestrictionsVersions.Insert(FullName,
			ActiveParameters.ListsRestrictionsVersions.Get(FullName));
		EndIf;
	Else
		Context.ListsRestrictionsVersions.Insert(FullName, True);
		ActiveParameters = New Structure;
		ActiveParameters.Insert("AdditionalContext", Context.AdditionalContext);
	EndIf;
	ActiveParameters.Insert("ListsRestrictionsVersions", Context.ListsRestrictionsVersions);
	
	Settings = ImplementationSettings(ActiveParameters);
	
	TablesTypesByNames = AccessManagementInternalCached.LanguageSyntax().TablesTypes.ByNames;
	SetImplementationSettings(Result.ImplementationSettings, Settings, TablesTypesByNames);
	
	Result.ForUsers.RestrictionInRoles = Settings.RestrictionsInRoles.ForUsers.Get(
		XMLFullName(FullName, TablesTypesByNames));
	
	Result.ForExternalUsers.RestrictionInRoles = Settings.RestrictionsInRoles.ForExternalUsers.Get(
		XMLFullName(FullName, TablesTypesByNames));
	
	Return Result;
	
EndFunction

// For the ObjectAccessRestrictionCheckResult function.
Procedure SetImplementationSettings(ImplementationSettings, Data, TablesTypesByNames)
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, True,
		Data.AccessValues, "AccessValue");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, True,
		Data.AccessKeysValuesOwners.References, "AccessKeysValuesOwner");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.Objects, "AccessKeysValuesOwnerObject");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.Documents, "AccessKeysValuesOwnerDocument");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.RecordSets, "AccessKeysValuesOwnerRecordSet");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.CalculationRegisterRecordSets,
			"AccessKeysValuesOwnerCalculationRegisterRecordSet");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.CalculationRegisterRecordSets,
			"AccessKeysValuesOwnerCalculationRegisterRecordSet");
	
	ImplementationSettings.Insert("RegisterAccessKeysRegisterField", "");
	ImplementationSettings.Insert("DimensionTypesForSeparateKeyRegister", Undefined);
	For Each KeyAndValue In Data.KeysRegistersDimensionsTypes Do
		If StrFind(KeyAndValue.Key, ".") > 0 Then
			Continue;
		EndIf;
		KeysRegisterName = KeyAndValue.Key;
		
		If KeysRegisterName = "AccessKeysForRegisters" Then
			AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, True,
				KeyAndValue.Value.TypesNames, "RegisterAccessKeysRegisterField");
		Else
			RegisterDimensions = Metadata.InformationRegisters[KeysRegisterName].Dimensions;
			TypesList = "";
			FieldNumber = 1;
			For Each RegisterFieldsDetails In KeyAndValue.Value.RegistersFields Do
				Break;
			EndDo;
			For Each FieldDetails In RegisterFieldsDetails.Value Do
				RegisterField = RegisterDimensions.Find("Field" + FieldNumber);
				TypesDetails = ?(RegisterField = Undefined, New TypeDescription, RegisterField.Type);
				TypesList = TypesList + ?(TypesList = "", "", Chars.LF)
					+ NStr("ru = '- для измерения'; en = '- for dimension'; pl = '- dla pomiaru';es_ES = '- para la dimensión';es_CO = '- para la dimensión';tr = '- ölçüm için';it = '- per la misurazione';de = '- zum messen'") + " " + "Field" + FieldNumber + ":" + Chars.LF
					+ "	" + TextWithIndent(TypesListFromArray(FieldDetails.Type.Types(),
						True, TablesTypesByNames, TypesDetails), "	");
				FieldNumber = FieldNumber + 1;
			EndDo;
			ImplementationSettings.Insert("DimensionTypesForSeparateKeyRegister",
				New Structure("InformationRegisterName, DimensionsTypes", KeysRegisterName, TypesList));
		EndIf;
	EndDo;
	
	ImplementationSettings.Insert("PredefinedID", Undefined);
	For Each KeyAndValue In Data.PredefinedIDs Do
		NameParts = StrSplit(KeyAndValue.Key, ".", False);
		AlreadyAdded = Metadata.Catalogs[NameParts[0]].GetPredefinedNames().Find(NameParts[1]) <> Undefined;
		ImplementationSettings.Insert("PredefinedID",
			New Structure("CatalogName, PredefinedItemName", NameParts[0],
				 "- " + NameParts[1] + ?(AlreadyAdded, " (" + NStr("ru = 'уже добавлен'; en = 'already added'; pl = 'już dodany';es_ES = 'añadido ya';es_CO = 'añadido ya';tr = 'zaten eklendi';it = 'già aggiunto';de = 'wurde bereits hinzugefügt'") + ")", "")));
		Break;
	EndDo;
	
EndProcedure

// For the SetImplementationSettings procedure.
Procedure AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, RefsTypes, TypesNames, DefinedTypeName)
	
	ImplementationSettings.Insert(DefinedTypeName, "");
	If TypesNames.Count() = 0 Then
		Return;
	EndIf;
	
	ImplementationSettings[DefinedTypeName] = TypesListFromArray(TypesNames,
		RefsTypes, TablesTypesByNames, Metadata.DefinedTypes[DefinedTypeName].Type);
	
EndProcedure

// For the SetImplementationSettings and AddTypesRequiredInDefinedType procedures.
Function TypesListFromArray(TypesNames, RefsTypes, TablesTypesByNames, TypesDetails)
	
	TypesList = "";
	For Each TypeName In TypesNames Do
		If TypeOf(TypeName) = Type("Type") Then
			Type = TypeName;
		Else
			Type = Type(TypeName);
		EndIf;
		MetadataObject = Metadata.FindByType(Type);
		FullName = MetadataObject.FullName();
		
		TypesList = TypesList + ?(TypesList = "", "", Chars.LF)
			+ "- " + ?(RefsTypes, RefTypeName(FullName, TablesTypesByNames),
				ObjectTypeOrRecordSetName(FullName, TablesTypesByNames));
		
		If TypesDetails.ContainsType(Type) Then
			TypesList = TypesList + " (" + NStr("ru = 'уже добавлен'; en = 'already added'; pl = 'już dodany';es_ES = 'añadido ya';es_CO = 'añadido ya';tr = 'zaten eklendi';it = 'già aggiunto';de = 'wurde bereits hinzugefügt'") + ")";
		EndIf;
	EndDo;
	
	Return TypesList;
	
EndFunction

// For the ObjectAccessRestrictionCheckResult function.
Function RestrictionCheckResultStructureForUsersKind()
	
	Properties = New Structure;
	Properties.Insert("RestrictionToCheck");
	Properties.Insert("ErrorsDetails");
	Properties.Insert("RestrictionParametersGenerationError");
	Properties.Insert("QueriesTextsGenerationError");
	Properties.Insert("RestrictionByOwnerPossible");
	Properties.Insert("RestrictionInRoles");
	Properties.Insert("RestrictionInModule");
	Properties.Insert("ByOwnerWithoutSavingAccessKeys");
	
	Return Properties;
	
EndFunction

// For the ObjectAccessRestrictionCheckResult function.
Procedure CheckRestrictionForUsersKind(Context, Result, ForExternalUsers, AdditionalContext)
	
	RestrictionText = ?(ForExternalUsers, Context.CommonResult.ForExternalUsers,
		Context.CommonResult.ForUsers).RestrictionToCheck;
	
	RestrictionStructure = CalculatedRestrictionStructure(Context.FullName,
		RestrictionText, Context.CommonResult.TextInManagerModule, ForExternalUsers, True);
	
	If RestrictionStructure <> Undefined
	   AND RestrictionStructure.ErrorsDetails.HasErrors Then
		
		Result.ErrorsDetails = RestrictionStructure.ErrorsDetails;
		Context.DependenciesAccountingAvailable = False;
		Return;
	EndIf;
	
	AdditionalContext = NewAdditionalContext();
	AddAdditionalContext(Context.FullName,
		AdditionalContext, Context.RestrictionDetails, ForExternalUsers);
	
	ErrorOnCallException = New Structure("Text", Undefined);
	AdditionalContext.Insert("ErrorOnCallException", ErrorOnCallException);
	
	Try
		RestrictionParameters = RestrictionParametersByRestrictionStructure(Context.FullName,
			RestrictionStructure, ForExternalUsers, Context.CommonContext, AdditionalContext);
	Except
		ErrorInformation = ErrorInfo();
		RestrictionParameters = Undefined;
		If ValueIsFilled(ErrorOnCallException.Text) Then
			Result.RestrictionParametersGenerationError = ErrorOnCallException.Text;
		Else
			Result.RestrictionParametersGenerationError =
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Не удалось сформировать параметры ограничения доступа по причине:
					           |%1'; 
					           |en = 'Cannot generate access restriction parameters due to:
					           |%1'; 
					           |pl = 'Nie udało się utworzyć ustawienia ograniczenia dostępu z powodu:
					           |%1';
					           |es_ES = 'No se ha podido generar los parámetros de restricción de acceso a causa de:
					           |%1';
					           |es_CO = 'No se ha podido generar los parámetros de restricción de acceso a causa de:
					           |%1';
					           |tr = 'Erişim kısıtlaması parametreleri şu nedenle oluşturulamadı:
					           |%1';
					           |it = 'Impossibile generare parametri di restrizione all''accesso a causa di:
					           |%1';
					           |de = 'Die Parameter der Zugriffsbeschränkung konnten aus diesem Grund nicht gebildet werden:
					           |%1'"), DetailErrorDescription(ErrorInformation));
		EndIf;
		Context.DependenciesAccountingAvailable = False;
	EndTry;
	
	If RestrictionParameters <> Undefined Then
		Result.RestrictionByOwnerPossible = RestrictionParameters.OwnerField <> Undefined;
		RestrictionParameters.Insert("DoNotWriteAccessKeysForUsersAndExternalUsers", False);
		RestrictionParameters.Context.ListsWithKeysRecordForDependentListsWithoutKeys = New Map;
		For Each KeyAndValue In RestrictionParameters.LeadingLists.ByFieldsValues Do
			Context.ListsRestrictionsVersions.Insert(KeyAndValue.Key, Undefined);
		EndDo;
		For Each KeyAndValue In RestrictionParameters.LeadingLists.ByAccessKeys Do
			Context.ListsRestrictionsVersions.Insert(KeyAndValue.Key, Undefined);
		EndDo;
		Try
			AddQueryTextsToRestrictionParameters(RestrictionParameters);
		Except
			ErrorInformation = ErrorInfo();
			If ValueIsFilled(ErrorOnCallException.Text) Then
				Result.QueriesTextsGenerationError = ErrorOnCallException.Text;
			Else
				Result.QueriesTextsGenerationError =
					StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Не удалось сформировать тексты запросов на основе параметров ограничения доступа по причине:
						           |%1'; 
						           |en = 'Cannot generate query texts based on access restriction parameters due to:
						           |%1'; 
						           |pl = 'Nie udało się utworzyć tekstów wniosków na podstawie parametrów ograniczenia dostępu z powodu:
						           |%1';
						           |es_ES = 'No se ha podido generar los textos de solicitudes a base de los parámetros de restricción del acceso a causa de:
						           |%1';
						           |es_CO = 'No se ha podido generar los textos de solicitudes a base de los parámetros de restricción del acceso a causa de:
						           |%1';
						           |tr = 'Erişim kısıtlaması parametrelerine bağlı sorgu metinleri şu nedenle oluşturulamadı:
						           |%1';
						           |it = 'Impossibile generare testi di query basati sui parametri di restrizione all''accesso a causa di:
						           |%1';
						           |de = 'Die Texte von Abfragen konnten aufgrund der Parameter der Zugriffsbeschränkung aus diesem Grund nicht generiert werden:
						           |%1'"), DetailErrorDescription(ErrorInformation));
			EndIf;
			Context.DependenciesAccountingAvailable = False;
		EndTry;
	EndIf;
	
	If Context.ConsiderDependencies Then
		Return;
	EndIf;
	
	ShortenedProperties = New Structure;
	ShortenedProperties.Insert("AccessDenied", False);
	ShortenedProperties.Insert("OwnerField", Undefined);
	ShortenedProperties.Insert("BasicFields", Undefined);
	ShortenedProperties.Insert("SeparateKeysRegisterName", Undefined);
	AdditionalContext.ListRestrictionsProperties.Insert(Context.FullName, ShortenedProperties);
	
	If Not Context.DependenciesAccountingAvailable Then
		Return;
	EndIf;
	
	FillPropertyValues(ShortenedProperties, RestrictionParameters);
	
EndProcedure

// For the StoredAccessRestrictionParameters and CalculatedRestrictionParameters functions.
Function CommonVersion(CommonContext, FullName, VersionForUsers, VersionForExternalUsers)
	
	If CommonContext.ListsWithRestriction.Get(FullName) = Undefined Then
		Return Undefined;
	EndIf;
	
	Return String(VersionForUsers) + Chars.LF + String(VersionForExternalUsers);
	
EndFunction

// For the CalculatedRestrictionParameters function.
Function WithouWritetKey(Result)
	
	Return Result.AccessDenied
	   Or Result.RestrictionDisabled
	     AND Result.Context.ListsWithKeysRecordForDependentListsWithoutKeys.Get(
	           Result.List) = Undefined;
	
EndFunction

// For the CalculatedRestrictionParameters and StoredAccessRestrictionParameters functions.
Function DataRestrictionDetails(CommonContext, FullName, WithoutCallingException = False)
	
	Restriction = New Structure;
	Restriction.Insert("Text", "");
	Restriction.Insert("TextForExternalUsers", "");
	Restriction.Insert("ByOwnerWithoutSavingAccessKeys", Undefined);
	Restriction.Insert("ByOwnerWithoutSavingAccessKeysForExternalUsers", Undefined);
	Restriction.Insert("TextInManagerModule", False);
	
	TextInManagerModule = CommonContext.ListsWithRestriction.Get(FullName);
	If TextInManagerModule = Undefined Then
		Return Restriction;
	EndIf;
	
	Restriction.TextInManagerModule = TextInManagerModule;
	
	If Common.SubsystemExists("StandardSubsystems.FilesOperations") Then
		ModuleStoredFilesInternal = Common.CommonModule("FilesOperationsInternal");
		IsFilesCatalog = ModuleStoredFilesInternal.IsFilesOrFilesVersionsCatalog(FullName);
	Else
		IsFilesCatalog = False;
	EndIf;
	
	If IsDocumentJournal(FullName) Or IsFilesCatalog Then
		// For document logs, a restriction must be by the owner document without writing access keys unless 
		// something other is required.
		// The same (by default) is required for file catalogs and file version catalogs.
		Restriction.ByOwnerWithoutSavingAccessKeys = True;
		Restriction.ByOwnerWithoutSavingAccessKeysForExternalUsers = True;
	EndIf;
	
	If TextInManagerModule Then
		Manager = Common.ObjectManagerByFullName(FullName);
		
		Try
			Manager.OnFillAccessRestriction(Restriction);
		Except
			ErrorInformation = ErrorInfo();
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = '""%1"" указан, как список с ограничением доступа в процедуре
				           |OnFillListsWithAccessRestriction общего модуля AccessManagementOverridable.
				           |
				           |Некорректно указано ограничение доступа этого списка в модуле менеджера
				           |в процедуре OnFillAccessRestriction по причине:
				           |
				           |%2'; 
				           |en = '""%1"" is specified as a list with access restriction in the OnFillListsWithAccessRestriction procedure
				           |of the AccessManagementOverridable common module.
				           |
				           |Access restriction of this list is specified incorrectly in the manager module
				           |in the OnFillAccessRestriction procedure due to:
				           |
				           |%2'; 
				           |pl = '""%1"" wyświetlone jako lista z ograniczeniem dostępu do procedury
				           | OnFillListsWithAccessRestriction do wspólnego modułu AccessManagementOverridable.
				           |
				           |Nieprawidłowo określone ograniczenia dostępu do tej listy w module menadżera
				           |w procedurze OnFillAccessRestriction z powodu:
				           |
				           |%2';
				           |es_ES = '""%1"" se ha indicado como lista con restricciones de acceso en el procedimiento
				           |OnFillListsWithAccessRestriction del módulo común AccessManagementOverridable.
				           |
				           |Se ha indicado incorrectamente la restricción de acceso de esta lista en el módulo de gestor
				           |en el procedimiento OnFillAccessRestriction a causa de:
				           |
				           |%2';
				           |es_CO = '""%1"" se ha indicado como lista con restricciones de acceso en el procedimiento
				           |OnFillListsWithAccessRestriction del módulo común AccessManagementOverridable.
				           |
				           |Se ha indicado incorrectamente la restricción de acceso de esta lista en el módulo de gestor
				           |en el procedimiento OnFillAccessRestriction a causa de:
				           |
				           |%2';
				           |tr = '""%1"" AccessManagementOverridable ortak modülünün
				           |OnFillListsWithAccessRestriction prosedüründe erişim kısıtlamalı liste olarak belirtilmiş.
				           |
				           |Bu listenin erişim kısıtlaması yönetici modülünde
				           |OnFillAccessRestriction prosedüründe yanlış belirtilmiş. Sebebi:
				           |
				           |%2';
				           |it = '""%1"" è indicato come elenco con restrizioni all''accesso nella procedura OnFillListsWithAccessRestriction
				           |del modulo comune AccessManagementOverridable.
				           |
				           |Le restrizioni all''accesso di questo elenco sono indicate in modo errato nel modulo del gestore
				           | nella procedura OnFillAccessRestriction a causa di:
				           |
				           |%2';
				           |de = '""%1""wird als Liste mit Zugriffsbeschränkung in der Prozedur
				           |OnFillListsWithAccessRestriction des allgemeinen Moduls AccessManagementOverridable angegeben.
				           |
				           |Die Zugriffsbeschränkung dieser Liste ist im Modul Manager
				           |in der Prozedur OnFillAccessRestriction aus dem Grund falsch angegeben:
				           |
				           |%2'"),
				FullName,
				DetailErrorDescription(ErrorInformation));
			
			If WithoutCallingException Then
				Return ErrorText;
			EndIf;
			Raise ErrorText;
		EndTry;
	Else
		MetadataObject = Metadata.FindByFullName(FullName);
		Try
			AccessManagementOverridable.OnFillAccessRestriction(MetadataObject, Restriction);
		Except
			ErrorInformation = ErrorInfo();
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = '""%1"" указан, как список с ограничением доступа в процедуре
				           |OnFillListsWithAccessRestriction общего модуля AccessManagementOverridable.
				           |
				           |Некорректно указано ограничение доступа этого списка в общем модуле AccessManagementOverridable
				           |в процедуре OnFillAccessRestriction по причине:
				           |
				           |%2'; 
				           |en = '""%1"" is specified as a list with access restriction in the OnFillListsWithAccessRestriction procedure
				           |of the AccessManagementOverridable common module.
				           |
				           |Access restriction of this list is specified incorrectly in the AccessManagementOverridable common module
				           |in the OnFillAccessRestriction procedure due to:
				           |
				           |%2'; 
				           |pl = '""%1"" wyświetlone jako lista z ograniczeniem dostępu do procedury
				           | OnFillListsWithAccessRestriction do wspólnego modułu AccessManagementOverridable.
				           |
				           |Nieprawidłowo określone ograniczenia dostępu do tej listy w ogólnym module AccessManagementOverridable
				           |w procedurze OnFillAccessRestriction z powodu:
				           |
				           |%2';
				           |es_ES = '""%1"" se ha indicado como lista con restricciones de acceso en el procedimiento
				           |OnFillListsWithAccessRestriction del módulo común AccessManagementOverridable.
				           |
				           |Se ha indicado incorrectamente la restricción de acceso de esta lista en el módulo AccessManagementOverridable
				           |en el procedimiento OnFillAccessRestriction a causa de:
				           |
				           |%2';
				           |es_CO = '""%1"" se ha indicado como lista con restricciones de acceso en el procedimiento
				           |OnFillListsWithAccessRestriction del módulo común AccessManagementOverridable.
				           |
				           |Se ha indicado incorrectamente la restricción de acceso de esta lista en el módulo AccessManagementOverridable
				           |en el procedimiento OnFillAccessRestriction a causa de:
				           |
				           |%2';
				           |tr = '""%1"" AccessManagementOverridable ortak modülünün
				           |OnFillListsWithAccessRestriction prosedüründe erişim kısıtlamalı liste olarak belirtilmiş.
				           |
				           |Bu listenin erişim kısıtlaması AccessManagementOverridable ortak modülünde
				           |OnFillAccessRestriction prosedüründe yanlış belirtilmiş. Sebebi:
				           |
				           |%2';
				           |it = '""%1"" è indicato come elenco con restrizioni all''accesso nella procedura OnFillListsWithAccessRestriction
				           |del modulo comune AccessManagementOverridable.
				           |
				           |Le restrizioni all''accesso di questo elenco sono indicate in modo errato nel modulo comune AccessManagementOverridable
				           | nella procedura OnFillAccessRestriction a causa di:
				           |
				           |%2';
				           |de = '""%1""wird als Liste mit Zugriffsbeschränkung in der Prozedur
				           |OnFillListsWithAccessRestriction des allgemeinen Moduls AccessManagementOverridable angegeben.
				           |
				           |Die Zugriffsbeschränkung dieser Liste ist im allgemeinen Modul AccessManagementOverridable
				           |in der Prozedur OnFillAccessRestriction aus dem Grund falsch angegeben:
				           |
				           |%2'"),
				FullName,
				DetailErrorDescription(ErrorInformation));
			
			If WithoutCallingException Then
				Return ErrorText;
			EndIf;
			Raise ErrorText;
		EndTry;
	EndIf;
	
	If IsDocumentJournal(FullName)
	   AND (    Restriction.ByOwnerWithoutSavingAccessKeys <> True
		  Or Restriction.ByOwnerWithoutSavingAccessKeysForExternalUsers <> True) Then
		
		If TextInManagerModule Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = '""%1"" указан, как список с ограничением доступа в процедуре
				           |OnFillListsWithAccessRestriction общего модуля AccessManagementOverridable.
				           |
				           |Некорректно указано ограничение доступа этого списка в модуле менеджера
				           |в процедуре OnFillAccessRestriction по причине:
				           |
				           |Для журналов документов не поддерживается ограничение, как для регистров,
				           |то есть, кроме варианта ограничения по владельцу без записи ключей доступа:
				           |
				           |AllowReadEdit
				           |WHERE
				           |	ReadObjectAllowed(Ref)'; 
				           |en = '""%1"" is specified as a list with access restriction in the OnFillListsWithAccessRestriction procedure
				           |of the AccessManagementOverridable common module.
				           |
				           | Access restriction of this list is specified incorrectly in the manager module
				           |in the OnFillAccessRestriction procedure due to:
				           |
				           |Restriction is not supported for document journals as for registers 
				           |other than restriction by owner without writing access keys:
				           |
				           | AllowReadEdit
				           |WHERE
				           |	ReadObjectAllowed(Ref)'; 
				           |pl = '""%1""określono, jak lista z ograniczeniem dostępu do procedury
				           |OnFillListsWithAccessRestriction wspólnego modułu AccessManagementOverridable.
				           |
				           |Nieprawidłowo określone ograniczenia dostępu do tej listy w module menadżera
				           |w procedurze OnFillAccessRestriction z powodu:
				           |
				           |Dla katalogów dokumentów nie są obsługiwane ograniczenia, takie jak dla rejestrów,
				           |czyli opcja ograniczenia właściciela bez zapisu kluczy dostępu:
				           |
				           |AllowReadEdit
				           |WHERE
				           |	ReadObjectAllowed(Odnośnik)';
				           |es_ES = '""%1"" se ha indicado como lista con restricciones de acceso en el procedimiento
				           |OnFillListsWithAccessRestriction del módulo común AccessManagementOverridable.
				           |
				           |Se ha indicado incorrectamente la restricción de acceso de esta lista en el módulo de gestor
				           |en el procedimiento OnFillListsWithAccessRestriction a causa de:
				           |
				           |Para los registros de documentos no se admite la restricción como para los registros
				           |es decir, excepto la opción de restricción por el propietario sin guardar las claves de acceso:
				           |
				           |AllowReadEdit
				           |DONDE
				           |	ReadObjectAllowed(Ref)';
				           |es_CO = '""%1"" se ha indicado como lista con restricciones de acceso en el procedimiento
				           |OnFillListsWithAccessRestriction del módulo común AccessManagementOverridable.
				           |
				           |Se ha indicado incorrectamente la restricción de acceso de esta lista en el módulo de gestor
				           |en el procedimiento OnFillListsWithAccessRestriction a causa de:
				           |
				           |Para los registros de documentos no se admite la restricción como para los registros
				           |es decir, excepto la opción de restricción por el propietario sin guardar las claves de acceso:
				           |
				           |AllowReadEdit
				           |DONDE
				           |	ReadObjectAllowed(Ref)';
				           |tr = '""%1"" AccessManagementOverridable ortak modülünün
				           |OnFillListsWithAccessRestriction prosedüründe erişim kısıtlamalı liste olarak belirtilmiş.
				           |
				           | Bu listenin erişim kısıtlaması yönetici modülünde
				           |OnFillAccessRestriction prosedüründe yanlış belirtilmiş. Sebebi:
				           |
				           |Erişim anahtarlarını kaydetmeden sahibi tarafından yapılan kısıtlamalar hariç
				           |belge günlükleri için kısıtlama desteklenmemektedir:
				           |
				           | AllowReadEdit
				           |WHERE
				           |	ReadObjectAllowed(Ref)';
				           |it = '""%1"" è indicato come elenco con restrizioni all''accesso nella procedura OnFillListsWithAccessRestriction 
				           |del modulo comune AccessManagementOverridable.
				           |
				           |Le restrizioni all''accesso di questo elenco sono indicate in modo errato nel modulo del gestore
				           |nella procedura OnFillAccessRestriction a causa di:
				           |
				           |le restrizioni non sono supportate per registri documenti così come per i registri dive
				           |rsi dalla restrizione da parte del proprietario senza registrazione delle chiavi di accesso:
				           |
				           | AllowReadEdit
				           |WHERE
				           |	ReadObjectAllowed(Ref)';
				           |de = '""%1""wird als Liste mit Zugriffsbeschränkung in der Prozedur
				           |OnFillListsWithAccessRestriction des allgemeinen Moduls AccessManagementOverridable angegeben.
				           |
				           |Die Zugriffsbeschränkung dieser Liste ist im Modul Manager
				           |in der Prozedur OnFillAccessRestriction aus dem Grund falsch angegeben:
				           |
				           |Die Dokumentprotokolle sind nicht wie bei Registern eingeschränkt,
				           |d.h. mit Ausnahme der Möglichkeit einer Einschränkung des Eigentümers ohne Schreiben der Zugriffsschlüssel:
				           |
				           |AllowReadEdit
				           |WHERE
				           |	ReadObjectAllowed(Ref)'"),
				FullName);
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = '""%1"" указан, как список с ограничением доступа в процедуре
				           |OnFillListsWithAccessRestriction общего модуля AccessManagementOverridable.
				           |
				           |Некорректно указано ограничение доступа этого списка в общем модуле AccessManagementOverridable
				           |в процедуре OnFillAccessRestriction по причине:
				           |
				           |Для журналов документов не поддерживается ограничение, как для регистров,
				           |то есть, кроме варианта ограничения по владельцу без записи ключей доступа:
				           |
				           |AllowReadEdit
				           |AllowReadEdit
				           |	ReadObjectAllowed(Ref)'; 
				           |en = '""%1"" is specified as a list with access restriction in the OnFillListsWithAccessRestriction procedure
				           |of the AccessManagementOverridable common module.
				           |
				           | Access restriction of this list is specified incorrectly in the AccessManagementOverridable common module
				           |in the OnFillAccessRestriction procedure due to:
				           |
				           |Restriction is not supported for document journals as for registers
				           |other than restriction by owner without writing access keys:
				           |
				           |AllowReadEdit
				           |WHERE
				           |	ReadObjectAllowed(Ref)'; 
				           |pl = '""%1""określono, jak lista z ograniczeniem dostępu do procedury
				           |OnFillListsWithAccessRestriction wspólnego modułu AccessManagementOverridable.
				           |
				           |Nieprawidłowo określone ograniczenia dostępu do tej listy w ogólnym module AccessManagementOverridable
				           |w procedurze OnFillAccessRestriction z powodu:
				           |
				           |Dla katalogów dokumentów nie są obsługiwany ograniczenia, takie jak dla rejestrów,
				           |czyli opcja ograniczenia właściciela bez zapisu kluczy dostępu:
				           |
				           |AllowReadEdit
				           |WHERE
				           |	ReadObjectAllowed(Odnośnik)';
				           |es_ES = '""%1"" se ha indicado como lista con restricciones de acceso en el procedimiento
				           |OnFillListsWithAccessRestriction del módulo común AccessManagementOverridable.
				           |
				           |Se ha indicado incorrectamente la restricción de acceso de esta lista en el módulo común AccessManagementOverridable
				           |en el procedimiento OnFillAccessRestriction a causa de:
				           |
				           |Para los registros de documentos no se admite la restricción como para los registros
				           |es decir, excepto la opción de restricción por el propietario sin guardar las claves de acceso:
				           |
				           |AllowReadEdit
				           |DONDE
				           |	ReadObjectAllowed(Ref)';
				           |es_CO = '""%1"" se ha indicado como lista con restricciones de acceso en el procedimiento
				           |OnFillListsWithAccessRestriction del módulo común AccessManagementOverridable.
				           |
				           |Se ha indicado incorrectamente la restricción de acceso de esta lista en el módulo común AccessManagementOverridable
				           |en el procedimiento OnFillAccessRestriction a causa de:
				           |
				           |Para los registros de documentos no se admite la restricción como para los registros
				           |es decir, excepto la opción de restricción por el propietario sin guardar las claves de acceso:
				           |
				           |AllowReadEdit
				           |DONDE
				           |	ReadObjectAllowed(Ref)';
				           |tr = 'ErişimKontrolüYenidenBelirlenmiş genel modülün ErişimKısıtlamaListeleriDoldurulurken prosedüründe ""%1"" erişim kısıtlama
				           | listesi olarak belirtilmiştir. 
				           |
				           | Aşağıdaki nedenle ErişimKısıtlamaDoldurulurken prosedüründe yönetici modülünde bu listenin 
				           |erişim kısıtlaması yanlış belirtilmiştir: 
				           |
				           | Belge günlükleri için kaydediciler gibi kısıtlama desteklenmiyor, 
				           | yani, erişim anahtarlarının kaydı olmadan sahibine göre kısıtlama opsiyonu hariç: 
				           |
				           |OkunabilirDeğişiklik
				           |BURADA
				           |	NesneOkunabilir (Referans)';
				           |it = '""%1"" è indicato come elenco con restrizioni di accesso nella procedura OnFillListsWithAccessRestriction 
				           |del modulo comune AccessManagementOverridable.
				           |
				           | Le restrizioni all''accesso di questo elenco sono indicate in modo errato nel modulo comune AccessManagementOverridable 
				           |nella procedura OnFillAccessRestriction a causa di:
				           |
				           |le restrizioni non sono supportate per registri documenti così come per i registri
				           |diversi dalla restrizione da parte del proprietario senza registrazione delle chiavi di accesso:
				           |
				           |AllowReadEdit
				           |WHERE
				           |	ReadObjectAllowed(Ref)';
				           |de = '""%1""wird als Liste mit Zugriffsbeschränkung in der Prozedur
				           |OnFillListsWithAccessRestriction des allgemeinen Moduls AccessManagementOverridable angegeben.
				           |
				           |Die Zugriffsbeschränkung dieser Liste ist im allgemeinen Modul AccessManagementOverridable
				           |in der Prozedur OnFillAccessRestriction aus dem Grund falsch angegeben:
				           |
				           |Die Dokumentprotokolle sind nicht wie bei Registern eingeschränkt,
				           |d.h. mit Ausnahme der Möglichkeit einer Einschränkung des Eigentümers ohne Schreiben der Zugriffsschlüssel:
				           |
				           |AllowReadEdit
				           |WHERE
				           |	ReadObjectAllowed(Ref)'"),
				FullName);
		EndIf;
		If WithoutCallingException Then
			Return ErrorText;
		EndIf;
		Raise ErrorText;
	EndIf;
	
	If Not CommonContext.ExternalUsersEnabled Then
		Restriction.TextForExternalUsers = "";
		Restriction.ByOwnerWithoutSavingAccessKeysForExternalUsers = False;
	EndIf;
	
	Return Restriction;
	
EndFunction

// For the DataRestrictionDetails function.
Function IsDocumentJournal(FullName)
	
	Return StrStartsWith(Upper(FullName), Upper("DocumentJournal."))
	    Or StrStartsWith(Upper(FullName), Upper("DocumentJournal."));
	
EndFunction

// For the CalculatedRestrictionParameters and RestrictionParametersForUsersKind functions.
Function CalculatedRestrictionStructure(FullName, RestrictionText, TextInManagerModule, ForExternalUsers, WithoutException = False)
	
	If Not ValueIsFilled(RestrictionText) Then
		Return Undefined;
	EndIf;
	
	ParsedRestriction = ParsedRestriction(FullName, RestrictionText);
	
	CheckFieldTablesAndFieldsTypes(ParsedRestriction);
	
	RestrictionStructure = RestrictionStructure(ParsedRestriction);
	
	If WithoutException Or Not RestrictionStructure.ErrorsDetails.HasErrors Then
		Return RestrictionStructure;
	EndIf;
	
	ErrorsText = ErrorsTextToCallException(FullName,
		RestrictionStructure.ErrorsDetails, ForExternalUsers, TextInManagerModule);
	
	Raise ErrorsText;
	
EndFunction

// For the ListPropertiesAsLeadingOne and RestrictionParameters functions, and the SessionParametersSetting,
// FillRestrictionParameters, and AddListRestrictionParameters procedures.
//
Function ActiveAccessRestrictionParameters(TransactionID, CommonContext,
			SetSessionParametersForTemplates = False, Update = False, HasChanges = False) Export
	
	If Update Then
		ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext, HasChanges);
		SetParametersVersion(ParametersVersion, TransactionID, CommonContext);
		Return SessionParameters.AccessRestrictionParameters.Parameters;
	EndIf;
	
	CurrentParameters = SessionParameters.AccessRestrictionParameters;
	
	If Not ValueIsFilled(CurrentParameters) Or CurrentParameters.Parameters = Undefined Then
		CurrentParameters = New Structure("Version, HashSum", "", "");
		TransactionIDs = New Map;
	Else
		TransactionIDs = RestrictionParametersCache().TransactionIDs;
	EndIf;
	
	If TransactionActive() Then
		If TransactionIDs.Get(TransactionID) <> Undefined Then
			Return CurrentParameters.Parameters;
		EndIf;
		
		VersionDetails = New Structure("Version, HashSum", "", "");
		If ValueIsFilled(CurrentParameters.Version) Then
			VersionDetails.Version   = CurrentParameters.Version;
			VersionDetails.HashSum = CurrentParameters.HashSum;
		EndIf;
		
		While True Do
			If Not ValueIsFilled(VersionDetails.Version) Then
				VersionDetails = LastVersionDetails();
			EndIf;
			If Not ValueIsFilled(VersionDetails.Version) Then
				Break;
			EndIf;
			DataLock = New DataLock;
			LockItem = DataLock.Add("InformationRegister.AccessRestrictionParameters");
			LockItem.SetValue("Version", VersionDetails.Version);
			LockItem.Mode = DataLockMode.Shared;
			DataLock.Lock();
			NewVersionDetails = LastVersionDetails();
			If Not ValueIsFilled(NewVersionDetails.Version) Then
				VersionDetails = NewVersionDetails;
				Break;
			EndIf;
			If VersionDetails.Version   = NewVersionDetails.Version
			   AND VersionDetails.HashSum = NewVersionDetails.HashSum Then
				Break;
			EndIf;
			VersionDetails = NewVersionDetails;
		EndDo;
	Else
		VersionDetails = LastVersionDetails();
	EndIf;
	
	If Not SetSessionParametersForTemplates
	   AND CurrentParameters.Version   = VersionDetails.Version
	   AND CurrentParameters.HashSum = VersionDetails.HashSum Then
		
		UpdateTransactionIDs(TransactionID);
		Return CurrentParameters.Parameters;
	EndIf;
	
	// Parameters in the database differ from the parameters in memory.
	If ValueIsFilled(VersionDetails.Version) Then
		ParametersVersion = ParametersVersion(VersionDetails.Version, SetSessionParametersForTemplates);
	Else
		ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext);
	EndIf;
	
	SetParametersVersion(ParametersVersion, TransactionID, CommonContext);
	
	Return SessionParameters.AccessRestrictionParameters.Parameters;
	
EndFunction

// For the ActiveAccessRestrictionParameters and NewAccessRestrictionParametersVersion functions.
Function LastVersionDetails()
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	AccessRestrictionParameters.Version AS Version,
	|	AccessRestrictionParameters.HashSum AS HashSum,
	|	AccessRestrictionParameters.CreationDate AS CreationDate
	|FROM
	|	InformationRegister.AccessRestrictionParameters AS AccessRestrictionParameters
	|
	|ORDER BY
	|	AccessRestrictionParameters.Version DESC";
	
	Selection = Query.Execute().Select();
	Selection.Next();
	
	Return Selection;
	
EndFunction

// For the ActiveAccessRestrictionParameters function.
Function ParametersVersion(Version, SetSessionParametersForTemplates)
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	AccessRestrictionParameters.Version AS Version,
	|	AccessRestrictionParameters.HashSum AS HashSum,
	|	AccessRestrictionParameters.CreationDate AS CreationDate,
	|	AccessRestrictionParameters.ForTemplatesInUsersSessions AS ForTemplatesInUsersSessions,
	|	AccessRestrictionParameters.ForTemplatesInExternalUsersSessions AS ForTemplatesInExternalUsersSessions,
	|	AccessRestrictionParameters.ForWritingObjectsAndCheckingRights AS ForWritingObjectsAndCheckingRights
	|FROM
	|	InformationRegister.AccessRestrictionParameters AS AccessRestrictionParameters
	|WHERE
	|	AccessRestrictionParameters.Version = &Version";
	
	If SetSessionParametersForTemplates Then
		Query.Text = StrReplace(Query.Text,
			"AccessRestrictionParameters.ForWritingObjectsAndCheckingRights", "Undefined");
		
		Query.Text = StrReplace(Query.Text, ?(UsersClientServer.IsExternalUserSession(),
			"AccessRestrictionParameters.ForTemplatesInUsersSessions",
			"AccessRestrictionParameters.ForTemplatesInExternalUsersSessions"), "Undefined");
	EndIf;
	
	Query.SetParameter("Version", Version);
	
	Selection = Query.Execute().Select();
	Selection.Next();
	
	Return Selection;
	
EndFunction

// For the ActiveAccessRestrictionParameters function.
Function NewAccessRestrictionParametersVersion(CommonContext, HasChanges = False)
	
	ListsRestrictionsVersions = New Map;
	StoredParameters = StoredAccessRestrictionParameters(CommonContext, ListsRestrictionsVersions);
	ListsRestrictionsVersions.Insert("Catalog.AccessGroupsSets", "1");
	
	RecordSet = ServiceRecordSet(InformationRegisters.AccessRestrictionParameters);
	Record = RecordSet.Add();
	FillPropertyValues(Record, StoredParameters);
	
	DataLock = New DataLock;
	LockItem = DataLock.Add("InformationRegister.AccessRestrictionParameters");
	LockedVersion = 0;
	
	BeginTransaction();
	Try
		VersionDetails = LastVersionDetails();
		While True Do
			If VersionDetails.HashSum = StoredParameters.HashSum Then
				If VersionDetails.Version = LockedVersion Then
					Break;
				EndIf;
				LockItem.Mode = DataLockMode.Shared;
				LockItem.SetValue("Version", VersionDetails.Version);
				DataLock.Lock();
				LockedVersion = VersionDetails.Version;
				VersionDetails = LastVersionDetails();
				Continue;
			EndIf;
			If ValueIsFilled(VersionDetails.Version) Then
				NewVersion = VersionDetails.Version + 1;
			Else
				NewVersion = 1;
			EndIf;
			LockItem.SetValue("Version", NewVersion);
			DataLock.Lock();
			NewVersionDetails = LastVersionDetails();
			
			If VersionDetails.Version <> NewVersionDetails.Version
			 Or NewVersionDetails.Version = NewVersion Then
				
				VersionDetails = NewVersionDetails;
				Continue;
			EndIf;
			
			StoredParameters.Insert("Version", NewVersion);
			
			Record.Version = NewVersion;
			RecordSet.Filter.Version.Set(NewVersion);
			
			If DataBaseConfigurationChangedDynamically()
			 Or Catalogs.ExtensionsVersions.ExtensionsChangedDynamically() Then
				
				StandardSubsystemsServer.RequireRestartDueToApplicationVersionDynamicUpdate();
			EndIf;
			Lists = ListsWithVersionsChange(ListsRestrictionsVersions);
			PlanningParameters = AccessUpdatePlanningParameters();
			PlanningParameters.ListsRestrictionsVersions = ListsRestrictionsVersions;
			ScheduleAccessUpdate(Lists, PlanningParameters);
			
			RecordSet.Write();
			HasChanges = True;
			Break;
		EndDo;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If Not StoredParameters.Property("Version") Then
		StoredParameters.Insert("Version",       VersionDetails.Version);
		StoredParameters.Insert("CreationDate", VersionDetails.CreationDate);
	EndIf;
	
	If HasChanges <> True AND Not TransactionActive() Then
		ParameterName = "StandardSubsystems.AccessManagement.AccessRestrictionParametersCheckDate";
		StandardSubsystemsServer.SetExtensionParameter(ParameterName, CurrentSessionDate(), True);
		SetAccessUpdate(True);
	EndIf;
	
	Return StoredParameters;
	
EndFunction

// This method is required by the NewVersionOfAccessRestrictionParameters function.
Function ListsWithVersionsChange(NewListsRestrictionsVersions)
	
	VersionDetails = LastVersionDetails();
	If Not ValueIsFilled(VersionDetails.Version) Then
		Return Undefined;
	EndIf;
	
	ParametersVersion = ParametersVersion(VersionDetails.Version, False);
	WriteParametersStorage = ParametersVersion.ForWritingObjectsAndCheckingRights;
	
	If TypeOf(WriteParametersStorage) <> Type("ValueStorage") Then
		Return Undefined;
	EndIf;
	WriteParameters = WriteParametersStorage.Get();
	
	If TypeOf(WriteParameters) <> Type("FixedStructure")
	 Or Not WriteParameters.Property("ListsRestrictionsVersions")
	 Or TypeOf(WriteParameters.ListsRestrictionsVersions) <> Type("FixedMap") Then
		Return Undefined;
	EndIf;
	
	Table = New ValueTable;
	Table.Columns.Add("List",       New TypeDescription("String"));
	Table.Columns.Add("Version",       New TypeDescription("String"));
	Table.Columns.Add("ChangeKind", New TypeDescription("Number"));
	
	For Each KeyAndValue In WriteParameters.ListsRestrictionsVersions Do
		Row = Table.Add();
		Row.List = KeyAndValue.Key;
		Row.Version = KeyAndValue.Value;
		Row.ChangeKind = -1;
	EndDo;
	
	For Each KeyAndValue In NewListsRestrictionsVersions Do
		Row = Table.Add();
		Row.List = KeyAndValue.Key;
		Row.Version = KeyAndValue.Value;
		Row.ChangeKind = 1;
	EndDo;
	
	Table.GroupBy("List, Version", "ChangeKind");
	Lists = New Array;
	
	For Each Row In Table Do
		If Row.ChangeKind = 0 Then
			Continue;
		EndIf;
		If Lists.Find(Row.List) <> Undefined Then
			Continue;
		EndIf;
		If Metadata.FindByFullName(Row.List) = Undefined Then
			Continue;
		EndIf;
		Lists.Add(Row.List);
	EndDo;
	
	Return Lists;
	
EndFunction

// For the StoredAccessRestrictionParameters procedure.
Function CacheStructureVersion()
	
	// The number has to be increased when making changes to the cache parameters, including changes to 
	// the template versions.
	Return "7";
	
EndFunction

// For the SessionParametersSetting and ClarifyAccessRestrictionTemplatesVersions procedures, and 
// the StoredTemplatesParametersStructure function.
Function AccessRestrictionTemplatesVersions()
	
	Return ",ForObject3,ForRegister3,";
	
EndFunction

// For the ActiveAccessRestrictionParameters function.
Procedure UpdateTransactionIDs(TransactionID)
	
	Cache = RestrictionParametersCache();
	
	If Not TransactionActive() AND Cache.TransactionIDs.Count() = 0
	 Or    TransactionActive() AND TransactionID = Undefined Then
		Return;
	EndIf;
	
	If TransactionID <> Undefined AND TransactionActive() Then
		Cache.TransactionIDs.Insert(TransactionID, True);
	Else
		Cache.TransactionIDs.Clear();
	EndIf;
	
EndProcedure

// For the ActiveAccessRestrictionParameters function.
Procedure SetParametersVersion(ParametersVersion, TransactionID, CommonContext, RepeatedCall = False)
	
	If Not RepeatedCall Then
		RefreshReusableValues();
	EndIf;
	
	If TransactionID <> Undefined AND TransactionActive() Then
		Cache = RestrictionParametersCache();
		Cache.TransactionIDs.Insert(TransactionID, True);
	EndIf;
	
	If TypeOf(ParametersVersion.ForWritingObjectsAndCheckingRights) = Type("ValueStorage") Then
		ForWritingObjectsAndCheckingRights = ParametersVersion.ForWritingObjectsAndCheckingRights.Get();
		
		If TypeOf(ForWritingObjectsAndCheckingRights) = Type("Structure")
		 Or Not ForWritingObjectsAndCheckingRights.Property("CacheStructureVersion")
		 Or ForWritingObjectsAndCheckingRights.CacheStructureVersion <> CacheStructureVersion() Then
			
			ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext);
			SetParametersVersion(ParametersVersion, TransactionID, CommonContext, True);
			Return;
		EndIf;
	Else
		ForWritingObjectsAndCheckingRights = Undefined;
	EndIf;
	
	StorageForAccessRestrictionTemplates = ?(UsersClientServer.IsExternalUserSession(),
		ParametersVersion.ForTemplatesInExternalUsersSessions,
		ParametersVersion.ForTemplatesInUsersSessions);
	
	If TypeOf(StorageForAccessRestrictionTemplates) = Type("ValueStorage") Then
		ForAccessRestrictionTemplates = StoredTemplatesParametersStructure(
			StorageForAccessRestrictionTemplates.Get());
		
		If ForAccessRestrictionTemplates.CacheStructureVersion <> CacheStructureVersion() Then
			ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext);
			SetParametersVersion(ParametersVersion, TransactionID, CommonContext, True);
			Return;
		EndIf;
	Else
		ForAccessRestrictionTemplates = StoredTemplatesParametersStructure();
	EndIf;
	
	SessionParameters.AccessRestrictionTemplatesVersions = ForAccessRestrictionTemplates.TemplatesVersions;
	TemplatesParameters = TemplatesParametersStructure(ForAccessRestrictionTemplates.TemplatesParameters);
	FillPropertyValues(SessionParameters, TemplatesParameters);
	
	ClarifyAccessRestrictionTemplatesVersions();
	
	UpdateAllowedSetsInSessionParameters(True);
	
	RestrictionParameters = New Structure;
	RestrictionParameters.Insert("Version",       ParametersVersion.Version);
	RestrictionParameters.Insert("HashSum",     ParametersVersion.HashSum);
	RestrictionParameters.Insert("CreationDate", ParametersVersion.CreationDate);
	RestrictionParameters.Insert("Parameters",    ForWritingObjectsAndCheckingRights);
	
	FixedRestrictionParameters = New FixedStructure(RestrictionParameters);
	SessionParameters.AccessRestrictionParameters = FixedRestrictionParameters;
	
EndProcedure

// For the SetParametersVersion procedure.
Procedure ClarifyAccessRestrictionTemplatesVersions()
	
	If SessionParameters.AccessRestrictionTemplatesVersions = AccessRestrictionTemplatesVersions() Then
		Return;
	EndIf;
	
	TemplatesVersions = StrSplit(AccessRestrictionTemplatesVersions(), ",", False);
	ClarifiedTemplateVersions = "";
	For Each TemplateVersion In TemplatesVersions Do
		ClarifiedTemplateVersions = "," + TemplateVersion;
		If StrFind(SessionParameters.AccessRestrictionTemplatesVersions, "," + TemplateVersion + ",") = 0 Then
			ClarifiedTemplateVersions = ClarifiedTemplateVersions + "SessionRestartRequired";
		EndIf;
	EndDo;
	ClarifiedTemplateVersions = ClarifiedTemplateVersions + ",";
	
	SessionParameters.AccessRestrictionTemplatesVersions = ClarifiedTemplateVersions;
	
EndProcedure

// For the SetParametersVersion, CheckAccessToObject,
// CheckAccessToRecordSet procedures, and the AccessAllowed function.
//
Procedure UpdateAllowedSetsInSessionParameters(IsSessionPatametersSetting = False)
	
	LastCheck = AccessManagementInternalCached.LastCheckOfAllowedSetsVersion();
	
	If Not IsSessionPatametersSetting AND LastCheck.Date + 3 > CurrentSessionDate() Then
		Return;
	EndIf;
	
	LastCheck.Date = CurrentSessionDate();
	BlankAccessGroupsSet = Catalogs.AccessGroupsSets.EmptyRef();
	AllowedBlankAccessGroupsSet = AccessManagementInternalCached.AllowedBlankAccessGroupsSet();
	
	If Users.IsFullUser(,, False) Then
		AllowedUser            = BlankAccessGroupsSet;
		AllowedAccessGroupsSet       = BlankAccessGroupsSet;
		AllowedUsersGroupsSet = BlankAccessGroupsSet;
	Else
		AllowedUser = Catalogs.AccessGroupsSets.GetRef(
			Users.AuthorizedUser().UUID());
		
		Query = New Query;
		Query.SetParameter("AllowedUser", AllowedUser);
		Query.Text =
		"SELECT
		|	AccessGroupsSets.AllowedAccessGroupsSet AS AllowedAccessGroupsSet,
		|	AccessGroupsSets.AllowedUserGroupsSet AS AllowedUserGroupsSet
		|FROM
		|	Catalog.AccessGroupsSets AS AccessGroupsSets
		|WHERE
		|	AccessGroupsSets.Ref = &AllowedUser";
		
		Selection = Query.Execute().Select();
		If Selection.Next() Then
			AllowedAccessGroupsSet       = Selection.AllowedAccessGroupsSet;
			AllowedUsersGroupsSet = Selection.AllowedUserGroupsSet;
		Else
			AllowedAccessGroupsSet       = BlankAccessGroupsSet;
			AllowedUsersGroupsSet = BlankAccessGroupsSet;
		EndIf;
	EndIf;
	
	If Not IsSessionPatametersSetting
	   AND SessionParameters.AllowedUser            = AllowedUser
	   AND SessionParameters.AllowedAccessGroupsSet       = AllowedAccessGroupsSet
	   AND SessionParameters.AllowedUserGroupsSet = AllowedUsersGroupsSet
	   AND SessionParameters.AllowedUserGroupsSet = AllowedBlankAccessGroupsSet  Then
		
		Return;
	EndIf;
	
	SessionParameters.AllowedUser            = AllowedUser;
	SessionParameters.AllowedAccessGroupsSet       = AllowedAccessGroupsSet;
	SessionParameters.AllowedUserGroupsSet = AllowedUsersGroupsSet;
	SessionParameters.AllowedBlankAccessGroupsSet = AllowedBlankAccessGroupsSet;
	
EndProcedure

// For the AccessAllowed, and the CheckAccessToObject and CheckAccessToRecordSet procedures.
Procedure SetAllowedSetsInQueryParameters(Query)
	
	Query.SetParameter("AllowedAccessGroupsSet",       SessionParameters.AllowedAccessGroupsSet);
	Query.SetParameter("AllowedBlankAccessGroupsSet", SessionParameters.AllowedBlankAccessGroupsSet);
	Query.SetParameter("AllowedUserGroupsSet", SessionParameters.AllowedUserGroupsSet);
	Query.SetParameter("AllowedUser",            SessionParameters.AllowedUser);
	Query.SetParameter("AuthorizedUser",         Users.AuthorizedUser());
	
EndProcedure

// This method is required by the NewVersionOfAccessRestrictionParameters function.
Function StoredAccessRestrictionParameters(CommonContext, ListsRestrictionsVersions = Undefined)
	
	If CommonContext = Undefined Then
		CommonContext = CommonContextOfRestrictionParametersCalculation();
		
	ElsIf CommonContext.Property("SpecialFullName") Then
		SpecialFullName           = CommonContext.SpecialFullName;
		SpecialRestrictionDetails = CommonContext.SpecialRestrictionDetails;
	EndIf;
	
	AdditionalContextForUsers        = NewAdditionalContext();
	AdditionalContextForExternalUsers = NewAdditionalContext();
	
	FullListsNames = New Array;
	For Each ListDetails In CommonContext.ListsWithRestriction Do
		FullName = ListDetails.Key;
		FullListsNames.Add(FullName);
		If FullName = SpecialFullName Then
			RestrictionDetails = SpecialRestrictionDetails;
		Else
			RestrictionDetails = DataRestrictionDetails(CommonContext, FullName);
		EndIf;
		
		AddAdditionalContext(FullName,
			AdditionalContextForUsers, RestrictionDetails, False);
		
		AddAdditionalContext(FullName,
			AdditionalContextForExternalUsers, RestrictionDetails, True);
	EndDo;
	
	ListsWithDate = New Map;
	ListsIDs = Common.MetadataObjectIDs(FullListsNames);
	
	// Filling for users.
	ContextForUsers = New Structure;
	ContextForUsers.Insert("ForExternalUsers",  False);
	ContextForUsers.Insert("CommonContext",            CommonContext);
	ContextForUsers.Insert("AdditionalContext",   AdditionalContextForUsers);
	ContextForUsers.Insert("LeadingLists",            New Map);
	ContextForUsers.Insert("DependencyLevels",        New Map);
	ContextForUsers.Insert("ListsRestrictionsVersions", New Map);
	ContextForUsers.Insert("TemplatesParameters",        TemplatesParametersStructure());
	ContextForUsers.Insert("ListsWithDate",             ListsWithDate);
	ContextForUsers.Insert("ListsIDs",    ListsIDs);
	
	AddStoredRestrictionParametersForUsersKind(ContextForUsers);
	
	// Filling for external users.
	ContextForExternalUsers = New Structure;
	ContextForExternalUsers.Insert("ForExternalUsers",  True);
	ContextForExternalUsers.Insert("CommonContext",            CommonContext);
	ContextForExternalUsers.Insert("AdditionalContext",   AdditionalContextForExternalUsers);
	ContextForExternalUsers.Insert("LeadingLists",            New Map);
	ContextForExternalUsers.Insert("DependencyLevels",        New Map);
	ContextForExternalUsers.Insert("ListsRestrictionsVersions", New Map);
	ContextForExternalUsers.Insert("TemplatesParameters",        TemplatesParametersStructure());
	ContextForExternalUsers.Insert("ListsWithDate",             ListsWithDate);
	ContextForExternalUsers.Insert("ListsIDs",    ListsIDs);
	
	AddStoredRestrictionParametersForUsersKind(ContextForExternalUsers);
	
	// Filling in general and separate parts of leading lists for users and external users.
	LeadingLists = New Map;
	For Each LeadingListsDetails In ContextForUsers.LeadingLists Do
		AddLeadingLists(LeadingLists,
			"ForUsers", LeadingListsDetails.Key, LeadingListsDetails.Value);
	EndDo;
	For Each LeadingListsDetails In ContextForExternalUsers.LeadingLists Do
		AddLeadingLists(LeadingLists,
			"ForExternalUsers", LeadingListsDetails.Key, LeadingListsDetails.Value);
	EndDo;
	For Each LeadingList In LeadingLists Do
		Properties = LeadingList.Value;
		If Properties.ByFieldsValues <> Undefined Then
			ByFieldsValues = Properties.ByFieldsValues;
			If ByFieldsValues.IsReferenceType Then
				TabularSections = New Array;
				For Each TabularSectionDetails In ByFieldsValues.TabularSections Do
					TabularSections.Add(TabularSectionDetails.Value);
				EndDo;
				ByFieldsValues.TabularSections = TabularSections;
			EndIf;
		EndIf;
	EndDo;
	
	// Filling in level of dependency on leading lists.
	DependencyLevels = New Map;
	For Each DependencyLevelDetails In ContextForUsers.DependencyLevels Do
		AddDependencyLevel(DependencyLevels,
			"ForUsers", DependencyLevelDetails.Key, DependencyLevelDetails.Value);
	EndDo;
	For Each DependencyLevelDetails In ContextForExternalUsers.DependencyLevels Do
		AddDependencyLevel(DependencyLevels,
			"ForExternalUsers", DependencyLevelDetails.Key, DependencyLevelDetails.Value);
	EndDo;
	
	// Calculation of access restriction versions.
	ListsRestrictionsVersions = New Map;
	Versions = New ValueList;
	Versions.Add(CacheStructureVersion());
	For Each VersionDetails In ContextForUsers.ListsRestrictionsVersions Do
		CommonVersion = CommonVersion(CommonContext, VersionDetails.Key, VersionDetails.Value,
			ContextForExternalUsers.ListsRestrictionsVersions.Get(VersionDetails.Key));
		ListsRestrictionsVersions.Insert(VersionDetails.Key, CommonVersion);
		Versions.Add(CommonVersion);
	EndDo;
	Versions.SortByValue();
	VersionsAsString = StrConcat(Versions.UnloadValues(), Chars.LF);
	DataHashing = New DataHashing(HashFunction.SHA256);
	DataHashing.Append(VersionsAsString);
	
	// Preparing additional context to calculate restriction parameters of a separate list.
	StoredProperties = "ListsWithDisabledRestriction, ListsWithReadRestrictionDisabled,
		|ListRestrictionsProperties, ListsWithKeysRecordForDependentListsWithoutKeys";
	ForUsers = New Structure(StoredProperties);
	FillPropertyValues(ForUsers, ContextForUsers.AdditionalContext);
	ForExternalUsers = New Structure(StoredProperties);
	FillPropertyValues(ForExternalUsers, ContextForExternalUsers.AdditionalContext);
	AdditionalContext = New Structure;
	AdditionalContext.Insert("ForUsers", ForUsers);
	AdditionalContext.Insert("ForExternalUsers", ForExternalUsers);
	
	WriteParameters = New Structure;
	WriteParameters.Insert("CacheStructureVersion",       CacheStructureVersion());
	WriteParameters.Insert("ListsRestrictionsVersions",  ListsRestrictionsVersions);
	WriteParameters.Insert("LeadingLists",             LeadingLists);
	WriteParameters.Insert("AdditionalContext",    AdditionalContext);
	WriteParameters.Insert("DependencyLevels",         DependencyLevels);
	WriteParameters.Insert("ListsWithDate",              ListsWithDate);
	
	StoredParameters = New Structure;
	
	StoredTemplatesParametersForUsers = StoredTemplatesParametersStructure();
	StoredTemplatesParametersForUsers.TemplatesParameters = ContextForUsers.TemplatesParameters;
	StoredParameters.Insert("ForTemplatesInUsersSessions",
		New ValueStorage(Common.FixedData(StoredTemplatesParametersForUsers)));
	
	StoredTemplatesParametersForExternalUsers = StoredTemplatesParametersStructure();
	StoredTemplatesParametersForExternalUsers.TemplatesParameters = ContextForExternalUsers.TemplatesParameters;
	StoredParameters.Insert("ForTemplatesInExternalUsersSessions",
		New ValueStorage(Common.FixedData(StoredTemplatesParametersForExternalUsers)));
	
	StoredParameters.Insert("ForWritingObjectsAndCheckingRights",
		New ValueStorage(Common.FixedData(WriteParameters)));
	
	StoredParameters.Insert("HashSum", Base64String(DataHashing.HashSum));
	StoredParameters.Insert("CreationDate", CurrentSessionDate());
	
	Return StoredParameters;
	
EndFunction

// For the CalculatedRestrictionParameters and StoredAccessRestrictionParameters functions.
Function NewAdditionalContext()
	
	AdditionalContext = New Structure;
	AdditionalContext.Insert("RestrictionsDetails",                  New Map);
	AdditionalContext.Insert("ListRestrictionsProperties",           New Map);
	AdditionalContext.Insert("ListsWithRestrictionByOwner",       New Map);
	AdditionalContext.Insert("ListsWithDisabledRestriction",       New Map);
	AdditionalContext.Insert("ListsWithReadRestrictionDisabled", New Map);
	AdditionalContext.Insert("ListsWithKeysRecordForDependentListsWithoutKeys", Undefined);
	
	Return AdditionalContext;
	
EndFunction

// For the CalculatedRestrictionParameters and StoredAccessRestrictionParameters functions.
Procedure AddAdditionalContext(FullName, AdditionalContext,
				RestrictionDetails, ForExternalUsers)
	
	If ForExternalUsers Then
		Text               = RestrictionDetails.TextForExternalUsers;
		ByOwner         = RestrictionDetails.ByOwnerWithoutSavingAccessKeysForExternalUsers;
	Else
		Text               = RestrictionDetails.Text;
		ByOwner         = RestrictionDetails.ByOwnerWithoutSavingAccessKeys;
	EndIf;
	InManagerModule = RestrictionDetails.TextInManagerModule;
	
	BriefRestrictionDetails = New Structure;
	BriefRestrictionDetails.Insert("Text",               Text);
	BriefRestrictionDetails.Insert("InManagerModule",    InManagerModule);
	
	AdditionalContext.RestrictionsDetails.Insert(FullName, BriefRestrictionDetails);
	
	If ByOwner <> Undefined Then
		AdditionalContext.ListsWithRestrictionByOwner.Insert(FullName, ByOwner);
	EndIf;
	
EndProcedure

// For the StoredAccessRestrictionParameters procedure.
Procedure AddStoredRestrictionParametersForUsersKind(Context)
	
	// Prepare parameters considering dependencies by access keys only.
	PropertiesTable = New ValueTable;
	PropertiesTable.Columns.Add("FullName", New TypeDescription("String"));
	PropertiesTable.Columns.Add("DependentItem", New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("LeadingItems",   New TypeDescription("Array"));
	PropertiesTable.Columns.Add("Level",   New TypeDescription("Number"));
	PropertiesTable.Columns.Add("Master",   New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("DependentItems", New TypeDescription("Array"));
	PropertiesTable.Columns.Add("Parameters", New TypeDescription("Structure"));
	PropertiesTable.Columns.Add("Processed", New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("RestrictionByOwnerPossible",  New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("RestrictionByOwnerEnabled",  New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("RestrictionByOwnerDisabled", New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("UsersAccessKeys",       New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("HasDependantListsWithoutAccessKeysRecords", New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("UsersAndAccessGroupsAccessKeys",    New TypeDescription("Boolean"));
	
	ListsWithRestriction = New Map(Context.CommonContext.ListsWithRestriction);
	ListsWithDisabledRestriction       = New Map;
	ListsWithReadRestrictionDisabled = New Map;
	
	For Each ListDetails In ListsWithRestriction Do
		FullName = ListDetails.Key;
		
		If TypeOf(ListDetails.Value) = Type("Boolean") Then
			Properties = PropertiesTable.Add();
			Properties.FullName = FullName;
			ListsWithRestriction.Insert(FullName, Properties);
			Parameters = RestrictionParametersForUsersKind(FullName, Context);
			Properties.Parameters = Parameters;
		Else
			Properties = ListDetails.Value;
			Parameters = Properties.Parameters;
		EndIf;
		
		If Parameters.RightToWriteRestrictionDisabled Then
			ListsWithReadRestrictionDisabled.Insert(FullName, True);
		EndIf;
		If Parameters.RestrictionDisabled Then
			ListsWithDisabledRestriction.Insert(FullName, True);
		EndIf;
		If Parameters.HasUsersRestriction Then
			Properties.UsersAccessKeys = True;
		EndIf;
		
		LeadingLists = Parameters.LeadingLists;
		If LeadingLists.ByAccessKeys.Count() > 0 Then
			Properties.DependentItem = True;
			For Each KeyAndValue In LeadingLists.ByAccessKeys Do
				LeadingList = KeyAndValue.Key;
				Properties.LeadingItems.Add(LeadingList);
				LeadingListProperties = ListsWithRestriction.Get(LeadingList);
				If LeadingListProperties = Undefined Or TypeOf(LeadingListProperties) = Type("Boolean") Then
					LeadingListProperties = PropertiesTable.Add();
					LeadingListProperties.FullName = LeadingList;
					ListsWithRestriction.Insert(LeadingList, LeadingListProperties);
					LeadingListParameters = RestrictionParametersForUsersKind(LeadingList, Context);
					LeadingListProperties.Parameters = LeadingListParameters;
					If LeadingListParameters.RightToWriteRestrictionDisabled Then
						ListsWithReadRestrictionDisabled.Insert(LeadingList, True);
					EndIf;
					If LeadingListParameters.RestrictionDisabled Then
						ListsWithDisabledRestriction.Insert(LeadingList, True);
					EndIf;
					If LeadingListParameters.HasUsersRestriction Then
						LeadingListProperties.UsersAccessKeys = True;
					EndIf;
				EndIf;
				LeadingListProperties.Master = True;
				LeadingListProperties.DependentItems.Add(FullName);
			EndDo;
		EndIf;
	EndDo;
	
	MaxLevel = 0;
	Rows = PropertiesTable.FindRows(New Structure("DependentItem, Master", False, True));
	For Each Row In Rows Do
		SetDependentListsLevel(Row, ListsWithRestriction, New Array, MaxLevel);
	EndDo;
	// Processing dependent lists being leading for themselves (looped on themselves).
	Rows = PropertiesTable.FindRows(New Structure("Processed", False));
	For Each Row In Rows Do
		SetDependentListsLevel(Row, ListsWithRestriction, New Array, MaxLevel);
	EndDo;
	
	Rows = PropertiesTable.FindRows(New Structure("DependentItem, Master", True, False));
	For Each Row In Rows Do
		SetOptimizationByOwnerField(Row, ListsWithRestriction, Context);
	EndDo;
	
	// Shortening dependencies by access keys of dependent objects.
	ListsWithKeysRecordForDependentListsWithoutKeys = New Map;
	Filter = New Structure("HasDependantListsWithoutAccessKeysRecords", True);
	Rows = PropertiesTable.FindRows(Filter);
	For Each Row In Rows Do
		ListsWithKeysRecordForDependentListsWithoutKeys.Insert(Row.FullName, False);
	EndDo;
	AdditionalContext = Context.AdditionalContext;
	AdditionalContext.ListsWithReadRestrictionDisabled = ListsWithReadRestrictionDisabled;
	AdditionalContext.ListsWithDisabledRestriction       = ListsWithDisabledRestriction;
	AdditionalContext.ListsWithKeysRecordForDependentListsWithoutKeys
		= ListsWithKeysRecordForDependentListsWithoutKeys;
	
	ListsPropertiesByLevels = New Array;
	For Level = 1 To MaxLevel Do
		ListsProperties = PropertiesTable.FindRows(New Structure("Level", Level));
		ListsPropertiesByLevels.Add(ListsProperties);
	EndDo;
	
	CommonContextListsWithRestriction = Context.CommonContext.ListsWithRestriction;
	
	For Each ListsProperties In ListsPropertiesByLevels Do
		For Each ListProperties In ListsProperties Do
			
			UsersAccessKeys = False;
			AccessGroupsAccessKeys = False;
			For Each Master In ListProperties.LeadingItems Do
				LeadingListProperties = ListsWithRestriction.Get(Master);
				If LeadingListProperties.UsersAccessKeys Then
					UsersAccessKeys = True;
				Else
					AccessGroupsAccessKeys = True;
				EndIf;
			EndDo;
			If UsersAccessKeys Then
				ListProperties.UsersAccessKeys = True;
				If AccessGroupsAccessKeys Then
					ListProperties.UsersAndAccessGroupsAccessKeys = True;
				EndIf;
			EndIf;
			If ListProperties.RestrictionByOwnerEnabled Then
				Continue;
			EndIf;
			
			AllLeadingListsWithRestriction = True;
			For Each Master In ListProperties.LeadingItems Do
				If CommonContextListsWithRestriction.Get(Master) = Undefined
				 Or ListsWithDisabledRestriction.Get(Master) <> Undefined Then
					AllLeadingListsWithRestriction = False;
					Break;
				EndIf;
			EndDo;
			If AllLeadingListsWithRestriction Then
				Continue;
			EndIf;
			
			ListProperties.Parameters =
				RestrictionParametersForUsersKind(ListProperties.FullName, Context);
			
			If ListsWithKeysRecordForDependentListsWithoutKeys.Get(ListProperties.FullName) = False Then
				ListsWithKeysRecordForDependentListsWithoutKeys.Insert(ListProperties.FullName, True);
			EndIf;
			
			LeadingLists = ListProperties.Parameters.LeadingLists.ByAccessKeys;
			If LeadingLists.Count() = ListProperties.LeadingItems.Count() Then
				Continue;
			EndIf;
			
			For Each Master In ListProperties.LeadingItems Do
				If LeadingLists.Get(Master) = Undefined Then
					LeadingListProperties = ListsWithRestriction.Get(Master);
					ItemIndex = LeadingListProperties.DependentItems.Find(ListProperties.FullName);
					LeadingListProperties.DependentItems.Delete(ItemIndex);
					LeadingListProperties.Master = LeadingListProperties.DependentItems.Count() > 0;
				EndIf;
			EndDo;
			
			If ListProperties.Parameters.RightToWriteRestrictionDisabled Then
				ListsWithReadRestrictionDisabled.Insert(ListProperties.FullName, True);
			EndIf;
			If ListProperties.Parameters.RestrictionDisabled Then
				ListsWithDisabledRestriction.Insert(ListProperties.FullName, True);
			EndIf;
			
			NewDependencyLevel = 0;
			For Each Master In ListProperties.LeadingItems Do
				LeadingListProperties = ListsWithRestriction.Get(Master);
				If NewDependencyLevel < LeadingListProperties.Level + 1 Then
					NewDependencyLevel = LeadingListProperties.Level + 1;
				EndIf;
				If LeadingListProperties.UsersAccessKeys Then
					ListProperties.UsersAccessKeys = True;
				EndIf;
			EndDo;
			ListProperties.Level = NewDependencyLevel;
			ListProperties.DependentItem = ListProperties.LeadingItems.Count() > 0;
		EndDo;
	EndDo;
	
	// Filling in stored list properties.
	For Each ListProperties In PropertiesTable Do
		FullName = ListProperties.FullName;
		UpdateParametersVersion = False;
		
		If ListProperties.Parameters.AccessDenied Then
			SetRestrictionProperty(FullName, "AccessDenied", True, Context);
		EndIf;
		If ValueIsFilled(ListProperties.Parameters.SeparateKeysRegisterName) Then
			SetRestrictionProperty(FullName,
				"SeparateKeysRegisterName", ListProperties.Parameters.SeparateKeysRegisterName, Context);
		EndIf;
		If ValueIsFilled(ListProperties.Parameters.BasicFields) Then
			BasicFields = New Structure("All, AllItemsTypes, Used");
			FillPropertyValues(BasicFields, ListProperties.Parameters.BasicFields);
			SetRestrictionProperty(FullName, "BasicFields", BasicFields, Context);
		EndIf;
		If Not ListProperties.RestrictionByOwnerEnabled
		   AND ListProperties.UsersAccessKeys Then
			
			If Not ListProperties.Parameters.CalculateUserRights Then
				UpdateParametersVersion = True;
			EndIf;
			SetRestrictionProperty(FullName, "CalculateUserRights", True, Context);
		EndIf;
		If ListProperties.UsersAndAccessGroupsAccessKeys Then
			SetRestrictionProperty(FullName,
				"TemplateRestrictionsWithUserAccessKeysAndAccessGroups", True, Context);
		ElsIf ListProperties.UsersAccessKeys Then
			SetRestrictionProperty(FullName,
				"TemplateRestrictionsWithUserAccessKeys", True, Context);
		EndIf;
		If ListProperties.RestrictionByOwnerEnabled Then
			If Not ListProperties.Parameters.UsesRestrictionByOwner Then
				UpdateParametersVersion = True;
			EndIf;
			SetRestrictionProperty(FullName,
				"OwnerField", ListProperties.Parameters.OwnerField, Context);
		EndIf;
		If ListProperties.Parameters.RightToWriteRestrictionDisabled Then
			ListsWithReadRestrictionDisabled.Insert(FullName, True);
		EndIf;
		If ListProperties.Parameters.RestrictionDisabled Then
			ListsWithDisabledRestriction.Insert(FullName, True);
		EndIf;
		If ListsWithKeysRecordForDependentListsWithoutKeys.Get(ListProperties.FullName) = False Then
			UpdateParametersVersion = True;
			ListsWithKeysRecordForDependentListsWithoutKeys.Insert(ListProperties.FullName, True);
		EndIf;
		SetRestrictionProperty(FullName, "UsedAccessValuesTypes",
			New ValueStorage(ListProperties.Parameters.UsedAccessValuesTypes), Context);
		
		If UpdateParametersVersion Then
			ListProperties.Parameters = RestrictionParametersForUsersKind(ListProperties.FullName, Context);
		EndIf;
		Context.ListsRestrictionsVersions.Insert(FullName, ListProperties.Parameters.Version);
		
		LeadingLists = ListProperties.Parameters.LeadingLists;
		
		If LeadingLists.ByFieldsValues.Count() > 0
		 Or LeadingLists.ByAccessKeys.Count() > 0
		 Or LeadingLists.ByValuesWithGroups.Count() > 0 Then
			
			Context.LeadingLists.Insert(FullName, LeadingLists);
		EndIf;
		
		SetTemplatesParameters(ListProperties, Context.TemplatesParameters);
		
		If ListProperties.Level > 0 Then
			ListID = Context.ListsIDs.Get(ListProperties.FullName);
			Context.DependencyLevels.Insert(ListID, Level);
		EndIf;
		
		If ListProperties.Parameters.ListWithDate Then
			Context.ListsWithDate.Insert(ListProperties.FullName, True);
		EndIf;
	EndDo;
	
EndProcedure

// For the StoredRestrictionParametersForUsersKind procedure.
Function RestrictionParametersForUsersKind(FullName, Context)
	
	RestrictionDetails = Context.AdditionalContext.RestrictionsDetails.Get(FullName);
	
	If RestrictionDetails = Undefined Then
		RestrictionStructure = Undefined;
	Else
		RestrictionStructure = CalculatedRestrictionStructure(FullName,
			RestrictionDetails.Text, RestrictionDetails.InManagerModule, Context.ForExternalUsers);
	EndIf;
	
	Return RestrictionParametersByRestrictionStructure(FullName,
		RestrictionStructure,
		Context.ForExternalUsers,
		Context.CommonContext,
		Context.AdditionalContext);
	
EndFunction

// For the AddStoredRestrictionParametersForUsersKind procedure.
Procedure SetDependentListsLevel(LeadingListProperties, ListsProperties, PreviousLeadingLists,
			MaxLevel)
	
	PreviousLeadingLists.Add(LeadingListProperties.FullName);
	
	For Each DependentList In LeadingListProperties.DependentItems Do
		If PreviousLeadingLists.Find(DependentList) <> Undefined Then
			LoopMembers = "";
			Index = PreviousLeadingLists.Count() - 1;
			While True Do
				LoopMembers = "- " + PreviousLeadingLists[Index] + Chars.LF + LoopMembers;
				If PreviousLeadingLists[Index] = DependentList Then
					Break;
				EndIf;
				Index = Index - 1;
			EndDo;
			LoopMembers = LoopMembers + "(!) " + DependentList;
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Ограничения доступа, заполненные в процедурах OnFillAccessRestriction
				           |модулей менеджеров или общем модуле AccessManagementOverridable,
				           |содержат недопустимую циклическую зависимость при использовании функции
				           |ReadObjectAllowed или EditObjectAllowed в одном или нескольких
				           |списках-участниках цикла:
				           |%1'; 
				           |en = 'Access restrictions filled in the OnFillAccessRestriction procedures
				           |of manager modules or the AccessManagementOverridable common module
				           |contain invalid circular dependency while using function
				           |ReadObjectAllowed or EditObjectAllowed in one or several
				           |lists of the cycle:
				           |%1'; 
				           |pl = 'Ograniczenia dostępu, wypełnione w procedurach OnFillAccessRestriction
				           |modułów menedżerów lub ogólnym module AccessManagementOverridable,
				           |zawierają niedozwoloną cykliczną zależność przy użyciu funkcji
				           |ReadObjectAllowed lub EditObjectAllowed w jednym lub kilku
				           |listach uczestniczących w cyklu:
				           |%1';
				           |es_ES = 'Restricciones de acceso rellenadas en los procedimientos OnFillAccessRestriction
				           |de los módulos de gestores o en el módulo común AccessManagementOverridable
				           |que contienen una dependencia cíclica no admisible al usar la función
				           |ReadObjectAllowed o EditObjectAllowed en una o varias
				           |listas-miembros del ciclo:
				           |%1';
				           |es_CO = 'Restricciones de acceso rellenadas en los procedimientos OnFillAccessRestriction
				           |de los módulos de gestores o en el módulo común AccessManagementOverridable
				           |que contienen una dependencia cíclica no admisible al usar la función
				           |ReadObjectAllowed o EditObjectAllowed en una o varias
				           |listas-miembros del ciclo:
				           |%1';
				           |tr = 'Yönetici modüllerinin ErişimKısıtlamasıDoldurulurken prosedürlerinde veya ErişimKontrolüYenidenBelirlenen ortak modülünde doldurulan erişim kısıtlamaları, 
				           |NesneOkunabilir veya NesneDeğişikliğineİzinVerildi işlevi
				           |
				           | döngüye katılan bir veya birkaç %1listelerde kullanılırken izin verilmeyen döngüsel bağlılık içermektedir: 
				           |
				           |';
				           |it = 'Le restrizioni all''accesso hanno compilato le procedure OnFillAccessRestriction
				           |dei moduli del gestore del modulo comune AccessManagementOverridable
				           |contengono una dipendenza circolare errata durante l''utilizzo della funzione
				           |ReadObjectAllowed o EditObjectallowed in uno o più elenchi 
				           |del ciclo:
				           |%1';
				           |de = 'Zugriffsbeschränkungen, die in den Prozeduren OnFillAccessRestriction
				           |der Manager-Module oder des allgemeinen Moduls AccessManagementOverridable ausgefüllt wurden,
				           |enthalten eine inakzeptable zyklische Abhängigkeit bei Verwendung der Funktion
				           |ReadObjectAllowed oder EditObjectAllowed in einer oder mehreren
				           |Listen der Zyklusteilnehmer:
				           |%1'"), LoopMembers);
			Raise ErrorText;
		EndIf;
		DependentListProperties = ListsProperties.Get(DependentList);
		If DependentListProperties.Level < LeadingListProperties.Level + 1 Then
			DependentListProperties.Level = LeadingListProperties.Level + 1;
			If MaxLevel < DependentListProperties.Level Then
				MaxLevel = DependentListProperties.Level;
			EndIf;
		EndIf;
		If Not DependentListProperties.Master Then
			DependentListProperties.Processed = True;
			Continue;
		EndIf;
		SetDependentListsLevel(DependentListProperties, ListsProperties, PreviousLeadingLists, MaxLevel);
	EndDo;
	
	PreviousLeadingLists.Delete(PreviousLeadingLists.Count() - 1);
	LeadingListProperties.Processed = True;
	
EndProcedure

// For the AddStoredRestrictionParametersForUsersKind procedure.
Procedure SetOptimizationByOwnerField(DependentListProperties, ListsProperties, Context)
	
	DependentListProperties.RestrictionByOwnerPossible =
		DependentListProperties.Parameters.OwnerField <> Undefined;
	
	DependentListProperties.RestrictionByOwnerEnabled =
		     DependentListProperties.RestrictionByOwnerPossible
		AND Not DependentListProperties.RestrictionByOwnerDisabled;
	
	DependentListWithOptimization = DependentListProperties.RestrictionByOwnerEnabled;
	
	For Each LeadingList In DependentListProperties.LeadingItems Do
		LeadingListProperties = ListsProperties.Get(LeadingList);
		If LeadingListProperties.Parameters.AccessDenied Then
			Continue;
		EndIf;
		If Not LeadingListProperties.DependentItem Then
			If DependentListWithOptimization Then
				LeadingListProperties.HasDependantListsWithoutAccessKeysRecords = True;
			EndIf;
			Continue;
		EndIf;
		If DependentListWithOptimization Then
			If LeadingListProperties.Parameters.OwnerField <> Undefined Then
				If LeadingListProperties.Parameters.RestrictionByOwnerRequired Then
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Установлен признак оптимизации ограничения %1, но такая
						           |оптимизация невозможна, так как она требуется для зависимого списка ""%2"".'; 
						           |en = '%1 restriction optimization check box is selected but such
						           |optimization is not possible as it is required for the dependent ""%2"" list.'; 
						           |pl = 'Pole wyboru optymalizacji ograniczenia %1 jest zaznaczone ale taka
						           |optymalizacja nie jest możliwa dla zależnej listy ""%2"".';
						           |es_ES = 'Se ha establecido un atributo de optimización de restricción%1, pero esta
						           |optimización es imposible porque se requiere para la lista dependiente ""%2"".';
						           |es_CO = 'Se ha establecido un atributo de optimización de restricción%1, pero esta
						           |optimización es imposible porque se requiere para la lista dependiente ""%2"".';
						           |tr = 'Bir kısıtlama optimizasyon işareti belirlendi%1, ancak bu nedenle bağlı "
" liste için gerekli olduğu için optimasyon %2yapılamaz.';
						           |it = 'La casella di controllo di ottimizzazione della restrizione %1 è selezionata, ma tale ottimizzazione non è
						           |possibile poiché è richiesta per l''elenco dipendente ""%2"".';
						           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt %1, aber eine solche
						           |Optimierung ist nicht möglich, da sie für die abhängige Liste ""%2"" erforderlich ist.'"),
						"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""),
						DependentListProperties.FullName);
					ErrorContext = New Structure("ListsWithRestriction, RestrictionsDetails");
					ErrorContext.Insert("List",                  LeadingListProperties.FullName);
					ErrorContext.Insert("RestrictionsDetails",     Context.AdditionalContext.RestrictionsDetails);
					ErrorContext.Insert("ForExternalUsers", Context.ForExternalUsers);
					ErrorText = ErrorTextWithTitle(ErrorText, ErrorContext);
					Raise ErrorText;
				Else
					LeadingListProperties.RestrictionByOwnerDisabled = True;
				EndIf;
			EndIf;
			LeadingListProperties.HasDependantListsWithoutAccessKeysRecords = True;
		EndIf;
		SetOptimizationByOwnerField(LeadingListProperties, ListsProperties, Context);
	EndDo;
	
EndProcedure

// For the AddStoredRestrictionParametersForUsersKind procedure.
Procedure SetRestrictionProperty(FullName, PropertyName, PropertyValue, Context)
	
	Properties = ListRestrictionProperties(FullName, Context.AdditionalContext, True);
	
	Properties[PropertyName] = PropertyValue;
	
EndProcedure

// For the SetRestrictionProperty and FillReadUpdateRightCheckQueries procedures.
Function ListRestrictionProperties(FullName, Context, AddToCollection = False)
	
	Properties = Context.ListRestrictionsProperties.Get(FullName);
	
	If Properties = Undefined Then
		Properties = New Structure;
		Properties.Insert("AccessDenied", False);
		Properties.Insert("OwnerField",  Undefined);
		Properties.Insert("BasicFields",    Undefined);
		Properties.Insert("SeparateKeysRegisterName", "");
		Properties.Insert("CalculateUserRights", False);
		Properties.Insert("TemplateRestrictionsWithUserAccessKeys", False);
		Properties.Insert("TemplateRestrictionsWithUserAccessKeysAndAccessGroups", False);
		Properties.Insert("UsedAccessValuesTypes", Undefined);
		If AddToCollection Then
			Context.ListRestrictionsProperties.Insert(FullName, Properties);
		EndIf;
	EndIf;
	
	Return Properties;
	
EndFunction

// For the StoredAccessRestrictionParameters function.
Procedure AddLeadingLists(LeadingLists, UsersKindPropertyName, DependentList,
			LeadingListsOfDependentList)
	
	For Each LeadingListDetails In LeadingListsOfDependentList.ByFieldsValues Do
		LeadingList = CurrentLeadingListProperties(LeadingLists, LeadingListDetails.Key);
		LeadingList.DependentLists.Insert(DependentList, True);
		
		If LeadingList.ByFieldsValues = Undefined Then
			ByFieldsValues = New Structure;
			ByFieldsValues.Insert("IsReferenceType", LeadingListDetails.Value.IsReferenceType);
			If ByFieldsValues.IsReferenceType Then
				ByFieldsValues.Insert("HeaderFields", New Map);
				ByFieldsValues.Insert("TabularSections",  New Map);
			Else
				ByFieldsValues.Insert("RegisterFields", New Structure);
				ByFieldsValues.RegisterFields.Insert("Fields",            New Array);
				ByFieldsValues.RegisterFields.Insert("DependentLists", New Map);
			EndIf;
			LeadingList.ByFieldsValues = ByFieldsValues;
		EndIf;
		
		AddLeadingListFields(LeadingList.ByFieldsValues,
			LeadingListDetails.Value, DependentList, UsersKindPropertyName);
	EndDo;
	
	AddLeadingListsByDependencyKind(LeadingLists,
		UsersKindPropertyName, DependentList, LeadingListsOfDependentList, "ByAccessKeys");
	
	AddLeadingListsByDependencyKind(LeadingLists,
		UsersKindPropertyName, DependentList, LeadingListsOfDependentList, "ByValuesWithGroups");
	
EndProcedure

// For the AddLeadingLists procedure.
Procedure AddLeadingListsByDependencyKind(LeadingLists, UsersKindPropertyName,
			DependentList, LeadingListsOfDependentList, DependencyKind)
	
	For Each LeadingListDetails In LeadingListsOfDependentList[DependencyKind] Do
		LeadingList = CurrentLeadingListProperties(LeadingLists, LeadingListDetails.Key);
		LeadingList.DependentLists.Insert(DependentList, True);
		
		If LeadingList[DependencyKind] = Undefined Then
			Properties = New Structure;
			Properties.Insert("ForUsers",        Undefined);
			Properties.Insert("ForExternalUsers", Undefined);
			LeadingList[DependencyKind] = Properties;
		Else
			Properties = LeadingList[DependencyKind];
		EndIf;
		
		If Properties[UsersKindPropertyName] = Undefined Then
			Properties[UsersKindPropertyName] = New Array;
		EndIf;
		
		Properties[UsersKindPropertyName].Add(DependentList);
	EndDo;
	
EndProcedure

// For the AddLeadingLists procedure.
Function CurrentLeadingListProperties(LeadingLists, FullName)
	
	LeadingList = LeadingLists.Get(FullName);
	If LeadingList = Undefined Then
		LeadingList = New Structure;
		LeadingList.Insert("DependentLists",      New Map);
		LeadingList.Insert("ByFieldsValues",     Undefined);
		LeadingList.Insert("ByAccessKeys",      Undefined);
		LeadingList.Insert("ByValuesWithGroups", Undefined);
		LeadingLists.Insert(FullName, LeadingList)
	EndIf;
	
	Return LeadingList;
	
EndFunction

// For the AddLeadingLists procedure.
Procedure AddLeadingListFields(CurrentFields, FieldsToAdd, DependentList,
			UsersKindPropertyName)
	
	If Not CurrentFields.IsReferenceType Then
		For Each Field In FieldsToAdd.HeaderFields Do
			If CurrentFields.RegisterFields.Fields.Find(Field) = Undefined Then
				CurrentFields.RegisterFields.Fields.Add(Field);
			EndIf;
			Clarification = CurrentFields.RegisterFields.DependentLists.Get(DependentList);
			If Clarification = Undefined Then
				Clarification = New Structure("ForUsers, ForExternalUsers", False, False);
				CurrentFields.RegisterFields.DependentLists.Insert(DependentList, Clarification);
			EndIf;
			Clarification[UsersKindPropertyName] = True;
		EndDo;
		
		Return;
	EndIf;
	
	For Each Field In FieldsToAdd.HeaderFields Do
		DependentLists = CurrentFields.HeaderFields.Get(Field);
		If DependentLists = Undefined Then
			DependentLists = New Map;
			CurrentFields.HeaderFields.Insert(Field, DependentLists);
		EndIf;
		Clarification = DependentLists.Get(DependentList);
		If Clarification = Undefined Then
			Clarification = New Structure("ForUsers, ForExternalUsers", False, False);
			DependentLists.Insert(DependentList, Clarification);
		EndIf;
		Clarification[UsersKindPropertyName] = True;
	EndDo;
	
	For Each TabularSection In FieldsToAdd.TabularSections Do
		TabularSectionDetails = CurrentFields.TabularSections.Get(TabularSection.Key);
		If TabularSectionDetails = Undefined Then
			TabularSectionDetails = New Structure;
			TabularSectionDetails.Insert("Name",  TabularSection.Key);
			TabularSectionDetails.Insert("Fields", New Array);
			TabularSectionDetails.Insert("DependentLists", New Map);
			CurrentFields.TabularSections.Insert(TabularSection.Key, TabularSectionDetails);
		EndIf;
		For Each Field In TabularSection.Value Do
			If TabularSectionDetails.Fields.Find(Field) = Undefined Then
				TabularSectionDetails.Fields.Add(Field);
			EndIf;
		EndDo;
		Clarification = TabularSectionDetails.DependentLists.Get(DependentList);
		If Clarification = Undefined Then
			Clarification = New Structure("ForUsers, ForExternalUsers", False, False);
			TabularSectionDetails.DependentLists.Insert(DependentList, Clarification);
		EndIf;
		Clarification[UsersKindPropertyName] = True;
	EndDo;
	
EndProcedure

// For the StoredAccessRestrictionParameters function.
Procedure AddDependencyLevel(DependencyLevels, UsersKindPropertyName, DependentList, Level)
	
	DependencyLevelDetails = DependencyLevels.Get(DependentList);
	If DependencyLevelDetails = Undefined Then
		DependencyLevelDetails = New Structure("ForUsers, ForExternalUsers", 0, 0);
		DependencyLevels.Insert(DependentList, DependencyLevelDetails);
	EndIf;
	DependencyLevelDetails[UsersKindPropertyName] = Level;
	
EndProcedure

// For the AddStoredRestrictionParametersForUsersKind procedure.
Procedure SetTemplatesParameters(ListProperties, TemplatesParameters)
	
	Parameters = ListProperties.Parameters;
	If Parameters.AccessDenied Then
		Return;
	EndIf;
	
	If Parameters.RightToWriteRestrictionDisabled Then
		TemplatesParameters.ListsWithReadRestrictionDisabled =
			TemplatesParameters.ListsWithReadRestrictionDisabled
				+ ListProperties.FullName + Chars.LF;
		Return;
	EndIf;
	
	If Parameters.OwnerField <> Undefined Then
		Fields = ":" + Parameters.OwnerField.Name;
		
	ElsIf Parameters.IsReferenceType Then
		Fields = ":";
	Else
		BasicFields = Parameters.BasicFields;
		If ValueIsFilled(Parameters.SeparateKeysRegisterName) Then
			Fields = "AccessKeysToRegister" + StrSplit(ListProperties.FullName, ".")[1];
		Else
			Fields = AccessManagementInternalCached.PredefinedMetadataObjectIDDetails(
				ListProperties.FullName);
		EndIf;
		Fields = ":[" + Fields + "]";
		Number = 1;
		NumberOfUsedOne = 1;
		For Each FieldName In BasicFields.All Do
			Fields = Fields + ":" + FieldName;
			If BasicFields.Used.Find(FieldName) <> Undefined Then
				TemplatesParameters.ListsWithRestrictionByFields = TemplatesParameters.ListsWithRestrictionByFields
					+ ListProperties.FullName + ":Field" + NumberOfUsedOne + "=Field" + Number + ";" + Chars.LF;
				NumberOfUsedOne = NumberOfUsedOne + 1;
			EndIf;
			Number = Number + 1;
		EndDo;
		For Number = NumberOfUsedOne To BasicFields.MaxCount Do
			TemplatesParameters.ListsWithRestrictionByFields = TemplatesParameters.ListsWithRestrictionByFields
				+ ListProperties.FullName + ":Field" + Number + "=Null;" + Chars.LF;
		EndDo;
		BlankFieldNumber = BasicFields.All.Count() + 1;
		For Number = BlankFieldNumber To BasicFields.MaxQuantity Do
			Fields = Fields + ":";
		EndDo;
	EndIf;
	
	If ListProperties.UsersAndAccessGroupsAccessKeys Then
		ParameterName = "ListsWithUsersAndAccessGroupsAccessKeysRestriction";
		
	ElsIf ListProperties.UsersAccessKeys Then
		ParameterName = "ListsWithUsersAccessKeysRestriction";
	Else
		ParameterName = "ListsWithAccessGroupsAccessKeysRestriction";
	EndIf;
	
	TemplatesParameters[ParameterName] = TemplatesParameters[ParameterName]
		+ ListProperties.FullName + Fields + ";*+" + Chars.LF;
	
EndProcedure

// For the SetParametersVersion procedure and the StoredAccessRestrictionParameters function.
Function StoredTemplatesParametersStructure(Values = Undefined)
	
	StoredTemplatesParameters = New Structure;
	StoredTemplatesParameters.Insert("CacheStructureVersion", CacheStructureVersion());
	StoredTemplatesParameters.Insert("TemplatesVersions",      AccessRestrictionTemplatesVersions());
	StoredTemplatesParameters.Insert("TemplatesParameters",   TemplatesParametersStructure());
	
	If TypeOf(Values)                     = Type("FixedStructure")
	   AND TypeOf(Values.CacheStructureVersion) = Type("String")
	   AND TypeOf(Values.TemplatesVersions)      = Type("String")
	   AND TypeOf(Values.TemplatesParameters)   = Type("FixedStructure") Then
		
		FillPropertyValues(StoredTemplatesParameters, Values);
	EndIf;
	
	Return StoredTemplatesParameters;
	
EndFunction

// For the SetParametersVersion procedure, the StoredAccessRestrictionParameters and
// StoredTemplatesParametersStructure functions.
Function TemplatesParametersStructure(Values = Undefined)
	
	TemplatesParameters = New Structure;
	TemplatesParameters.Insert("ListsWithAccessGroupsAccessKeysRestriction", "");
	TemplatesParameters.Insert("ListsWithUsersAccessKeysRestriction", "");
	TemplatesParameters.Insert("ListsWithUsersAndAccessGroupsAccessKeysRestriction", "");
	TemplatesParameters.Insert("ListsWithRestrictionByFields", "");
	TemplatesParameters.Insert("ListsWithReadRestrictionDisabled",  "");
	
	If TypeOf(Values) <> Type("FixedStructure")
	 Or Values.Count() <> TemplatesParameters.Count() Then
		
		Return TemplatesParameters;
	EndIf;
	
	For Each KeyAndValue In TemplatesParameters Do
		If Not Values.Property(KeyAndValue.Key)
		 Or Not TypeOf(Values[KeyAndValue.Key]) = TypeOf(KeyAndValue.Value) Then
			Return TemplatesParameters;
		EndIf;
	EndDo;
	FillPropertyValues(TemplatesParameters, Values);
	
	Return TemplatesParameters;
	
EndFunction

#EndRegion

#Region AccessRestrictionParametersForListSeparately

// The main area function, which returns access restriction parameters for the list user kind, 
// without considering dependencies on other lists both by access keys and by presence of the Users 
// and ExternalUsers access kinds.
//
Function RestrictionParametersByRestrictionStructure(List, RestrictionStructure,
			ForExternalUsers, CommonContext, AdditionalContext)
	
	LeadingLists = New Structure;
	// Lists with fields, on which access restriction depends (for registering update jobs).
	LeadingLists.Insert("ByFieldsValues", New Map);
	// Lists, on whose access keys access restriction depends (for setting session parameters and 
	// registering update jobs).
	LeadingLists.Insert("ByAccessKeys",  New Map);
	// Lists of access values with groups, on which access restriction depends (for registering update jobs).
	LeadingLists.Insert("ByValuesWithGroups", New Map);
	
	Result = New Structure;
	// Full name of the metadata object table.
	Result.Insert("List", List);
	// User kind, for which the parameters are intended.
	Result.Insert("ForExternalUsers", ForExternalUsers);
	// Hash of access restriction parameters to track their changes.
	Result.Insert("Version", "");
	// Lists with fields, on which access restriction depends.
	Result.Insert("LeadingLists", LeadingLists);
	// True if the restriction text is "WHERE FALSE", and it is also not specified for external users.
	Result.Insert("AccessDenied", ForExternalUsers);
	// True if the restriction text is not specified or it is specified but the restriction is disabled 
	// because of disabling the use of access kinds involved in it.
	Result.Insert("RestrictionDisabled", Not ForExternalUsers);
	// True if a reading restriction text is not specified or it is specified but the restriction is 
	// disabled because of disabling the use of access kinds involved in it.
	Result.Insert("RightToWriteRestrictionDisabled", Not ForExternalUsers);
	
	// Owner field, when restriction is possible only by the owner object.
	Result.Insert("OwnerField");
	// The optimization flag specified by the developer next to the restriction text.
	Result.Insert("RestrictionByOwnerRequired", False);
	
	// Flag of using optimization calculated on the second pass of the graph.
	Result.Insert("UsesRestrictionByOwner", False);
	// Flag of calculation of rights to access keys for users, not for access groups, calculated on the 
	// second pass of the graph. Makes sense only when flag UsesRestrictionByOwner = False.
	Result.Insert("CalculateUserRights", False);
	// Shows that the leading list must write keys for dependent lists that do not write their own keys.
	//  The flag is calculated on the second pass of the graph.
	Result.Insert("HasDependantListsWithoutAccessKeysRecords", False);
	// The flag calculated on the second pass of the graph. When HasDependentListsWithoutWriteAccessKeys 
	// = True, it indicates that the Read right is available in one of the BasicRights* or BasicExternalUsersRights* roles.
	Result.Insert("ReadingAllowedForAllUsers", False);
	// The flag calculated on the second pass of the graph. When HasDependentListsWithoutWriteAccessKeys 
	// = True, it indicates that the Update right is available in one of the BasicRights* or BasicExternalUsersRights* roles.
	Result.Insert("EditionAllowedForAllUsers", False);
	
	// Shows that there are leading access keys in the restriction.
	Result.Insert("HasMasterAccessKeys", False);
	// Shows that there are leading lists by rights in the restriction.
	Result.Insert("HasHeadRightsLists", False);
	
	// Types of right setting owners used when calculating rights to access keys.
	Result.Insert("RightsSettingsOwnersTypes", CommonContext.RightsSettingsOwnersTypes);
	// List ID if separate right settings or a blank ID are used for it.
	Result.Insert("RightSettingsTableID", Catalogs.MetadataObjectIDs.EmptyRef());
	// Shows if there are restrictions by right settings owner.
	Result.Insert("HasRightsSettingsOwners", False);
	// Description of access value types used in access restriction.
	Result.Insert("UsedAccessValuesTypes", New Array);
	
	Result.Insert("SeparateKeysRegisterName", ""); // For registers.
	Result.Insert("BasicFields"); // For registers.
	
	// Number describing attributes used in the key.
	Result.Insert("FieldsComposition");
	
	// It is set if the read restriction differs from "WHERE TRUE".
	Result.Insert("HasReadRestriction", False);
	// It is set if the change restriction differs from "WHERE TRUE".
	Result.Insert("HasLimitChanges", False);
	
	// It is set if User or UsersGroup or ExternalUser or ExternalUsersGroup values are checked for the 
	// ValueAllowed or IsAuthorizedUser functions.
	// 
	Result.Insert("HasUsersRestriction", False);
	
	
	// Contains a restriction structure adjusted to the format of placing values in access keys.
	Result.Insert("ReadRightCalculationStructure",    New Structure);
	Result.Insert("EditRightCalculationStructure", New Structure);
	
	TypeCollectionName = "";
	Result.Insert("IsReferenceType", IsReferenceTableType(List, TypeCollectionName));
	Result.Insert("ListWithDate",
		    TypeCollectionName = "Documents"
		Or TypeCollectionName = "BusinessProcesses"
		Or TypeCollectionName = "Tasks");
	
	Context = New Structure;
	Result.Insert("Context", Context);
	
	For Each KeyAndValue In CommonContext Do
		Context.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	For Each KeyAndValue In AdditionalContext Do
		Context.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	
	Context.Insert("List",                  List);
	Context.Insert("ForExternalUsers", ForExternalUsers);
	Context.Insert("IsReferenceType",         Result.IsReferenceType);
	Context.Insert("ListWithDate",            Result.ListWithDate);
	Context.Insert("TypeCollectionName",        TypeCollectionName);
	Context.Insert("VersionProperties",          New Array);
	
	AddVersionProperty(Context, Context, "List");
	AddVersionProperty(Context, Context, "ForExternalUsers");
	
	RestrictionDetails = Context.RestrictionsDetails.Get(Context.List);
	If RestrictionDetails = Undefined Then
		RestrictionDetails = New Structure("Text", "");
	EndIf;
	AddVersionProperty(Context, RestrictionDetails, "Text");
	
	AddVersionProperty(Context, Context, "IsReferenceType");
	AddVersionProperty(Context, Context, "ListWithDate");
	
	// Basic fields are not required for reference data types (always Ref).
	FillNewBasicFieldsDetails(Result, Context);
	
	If Context.ListsWithKeysRecordForDependentListsWithoutKeys <> Undefined Then
		Properties = ListRestrictionProperties(Context.List, Context);
		Result.UsesRestrictionByOwner        = Properties.OwnerField <> Undefined;
		Result.CalculateUserRights            = Properties.CalculateUserRights;
		If Context.ListsWithKeysRecordForDependentListsWithoutKeys.Get(List) <> Undefined Then
			Result.HasDependantListsWithoutAccessKeysRecords = True;
			MetadataObject = Metadata.FindByFullName(List);
			Result.ReadingAllowedForAllUsers =
				RightAllowedForAllUsers("Read",    MetadataObject, ForExternalUsers);
			Result.EditionAllowedForAllUsers =
				RightAllowedForAllUsers("Update", MetadataObject, ForExternalUsers);
		EndIf;
	EndIf;
	Context.Insert("UsesRestrictionByOwner",        Result.UsesRestrictionByOwner);
	Context.Insert("CalculateUserRights",            Result.CalculateUserRights);
	Context.Insert("HasDependantListsWithoutAccessKeysRecords", Result.HasDependantListsWithoutAccessKeysRecords);
	Context.Insert("ReadingAllowedForAllUsers",       Result.ReadingAllowedForAllUsers);
	Context.Insert("EditionAllowedForAllUsers",    Result.EditionAllowedForAllUsers);
	
	If RestrictionStructure = Undefined Then
		Return Result;
	EndIf;
	
	Result.AccessDenied = False;
	Result.RestrictionDisabled = True;
	Result.RightToWriteRestrictionDisabled = True;
	
	FillHasRestrictionByRights(Context, Result, RestrictionStructure);
	
	Context.Insert("RestrictionStructure",                    RestrictionStructure);
	Context.Insert("LeadingListsByFieldsValues",           New Map);
	Context.Insert("LeadingListsByAccessKeys",            New Map);
	Context.Insert("LeadingListsByValuesWithGroups",       New Map);
	Context.Insert("HasAuthorizedUserCheck", False);
	Context.Insert("UnusedAccessValueTypes",       New Array);
	
	FillFieldProperties(Context);
	FillRestrictionByOwnerObject(Result, Context);
	FillHasLeadingKeysAndListsAndRightsSettingsOwners(Result, Context);
	DeleteNotUsedAccessKindsFields(Result, Context);
	FillHasRestrictionByUsersAccessKind(Result, Context);
	FillHasReadRestriction(Result, Context);
	
	Context.Insert("HasUsersRestriction", Result.HasUsersRestriction);
	
	If Context.ListsWithKeysRecordForDependentListsWithoutKeys = Undefined Then
		Result.UsesRestrictionByOwner = Result.OwnerField <> Undefined;
		Result.CalculateUserRights     = Result.HasUsersRestriction;
		
		Context.Insert("UsesRestrictionByOwner", Result.UsesRestrictionByOwner);
		Context.Insert("CalculateUserRights",     Result.CalculateUserRights);
	EndIf;
	AddVersionProperty(Context, Context, "UsesRestrictionByOwner");
	AddVersionProperty(Context, Context, "CalculateUserRights");
	AddVersionProperty(Context, Context, "HasDependantListsWithoutAccessKeysRecords");
	AddVersionProperty(Context, Context, "ReadingAllowedForAllUsers");
	AddVersionProperty(Context, Context, "EditionAllowedForAllUsers");
	
	Context.Insert("FieldsGroups");
	Context.Insert("ObjectTabularSectionsAliases");
	Context.Insert("AdditionalTablesGroups");
	Context.Insert("KeyTabularSectionsCount");
	
	FillFieldsAndAdditionalTablesGroups(Context);
	
	If Context.FieldsProperties.Count() = 0 Then // Restriction disabled.
		Return Result;
	EndIf;
	
	Result.RestrictionDisabled = False;
	
	Result.FieldsComposition = Context.FieldsComposition;
	
	Context.Insert("RightName", "Read");
	FillRightCalculationStructure(Result.ReadRightCalculationStructure,
		RestrictionStructure.ReadRestriction, Context);
	
	Context.Insert("RightName", "Update");
	FillRightCalculationStructure(Result.EditRightCalculationStructure,
		RestrictionStructure.UpdateRestriction, Context);
	
	Context.Delete("RightName");
	
	If Not Context.IsReferenceType Then
		Result.SeparateKeysRegisterName = Context.SeparateKeysRegisterName;
	EndIf;
	
	LeadingLists.ByFieldsValues     = Context.LeadingListsByFieldsValues;
	LeadingLists.ByAccessKeys      = Context.LeadingListsByAccessKeys;
	LeadingLists.ByValuesWithGroups = Context.LeadingListsByValuesWithGroups;
	
	DataHashing = New DataHashing(HashFunction.SHA256);
	VersionPropertiesString = StrConcat(Context.VersionProperties, Chars.LF);
	DataHashing.Append(VersionPropertiesString);
	Result.Version = Base64String(DataHashing.HashSum);
	
	Return Result;
	
EndFunction

// For the RestrictionParametersByRestrictionStructure procedure.
Function RightAllowedForAllUsers(RightName, MetadataObject, ForExternalUsers)
	
	If MetadataObject = Undefined Then
		Return False;
	EndIf;
	
	RolesNamesBasicRights = AccessManagementInternalCached.RolesNamesBasicRights(ForExternalUsers);
	RoleMetadata = Metadata.Roles;
	
	For Each RoleName In RolesNamesBasicRights Do
		If AccessRight(RightName, MetadataObject, RoleMetadata[RoleName]) Then
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

// For the DeleteNotUsedAccessKindsFields procedure and AdditionalTablesGroups function.
Procedure AddVersionProperties(Context, Structure, FieldsNames = "")
	
	If ValueIsFilled(FieldsNames) Then
		StructureToSave = New Structure(FieldsNames);
		FillPropertyValues(StructureToSave, Structure);
	Else
		StructureToSave = Structure;
	EndIf;
	
	ValueList = New ValueList;
	For Each KeyAndValue In StructureToSave Do
		ValueList.Add(KeyAndValue.Value, KeyAndValue.Key)
	EndDo;
	ValueList.SortByPresentation();
	
	For Each ListItem In ValueList Do
		AddVersionItem(Context, ListItem.Presentation, ListItem.Value);
	EndDo;
	
EndProcedure

// For the RestrictionParametersByRestrictionStructure procedure.
Procedure AddVersionProperty(Context, Structure, FieldName)
	
	AddVersionItem(Context, FieldName, Structure[FieldName]);
	
EndProcedure

// For the AddVersionProperties and AddVersionProperty procedures.
Procedure AddVersionItem(Context, FieldName, Value)
	
	If TypeOf(Value) = Type("String") Then
		Context.VersionProperties.Add(FieldName + " = " + Value);
		
	ElsIf TypeOf(Value) = Type("Number") Then
		
		Context.VersionProperties.Add(FieldName + " = " + Format(Value, "NG="));
		
	ElsIf TypeOf(Value) = Type("Boolean")
	      Or TypeOf(Value) = Type("Undefined") Then
		
		Context.VersionProperties.Add(FieldName + " = " + String(Value));
		
	ElsIf TypeOf(Value) = Type("FixedArray") Then
		Context.VersionProperties.Add(FieldName + " = " + DataStringForHashing(New Array(Value)));
		
	ElsIf TypeOf(Value) = Type("TypeDescription")
	      Or TypeOf(Value) = Type("Array") Then
		
		Context.VersionProperties.Add(FieldName + " = " + DataStringForHashing(Value));
	Else
		ErrorText = NStr("ru = 'Некорректный тип данных для версии ограничения доступа.'; en = 'Incorrect data type for access restriction version.'; pl = 'Nieprawidłowy typ danych dla wersji ograniczenia dostępu.';es_ES = 'Tipo incorrecto de datos para la versión de restricción de acceso.';es_CO = 'Tipo incorrecto de datos para la versión de restricción de acceso.';tr = 'Erişim kısıtlama sürümü için yanlış veri türü.';it = 'Tipo di dati errato per la versione di restrizione all''accesso.';de = 'Falscher Datentyp für die Version mit Zugriffsbeschränkung.'");
		Raise ErrorText;
	EndIf;
	
EndProcedure

// For the RestrictionParametersByRestrictionStructure function and the AccessUpdateManualControl form.
Function IsReferenceTableType(FullName, TypeCollectionName = "") Export
	
	LanguageSyntax = AccessManagementInternalCached.LanguageSyntax();
	NameContent = StrSplit(FullName, ".", False);
	
	TableType = LanguageSyntax.TablesTypes.ByNames.Get(Upper(NameContent[0]));
	If TableType = Undefined Then
		Return False;
	EndIf;
	
	TypeCollectionName = TableType.CollectionName;
	
	Return TableType.IsReferenceType;
	
EndFunction

// For the RestrictionParametersByRestrictionStructure function.
Procedure FillNewBasicFieldsDetails(Result, Context)
	
	BasicFields = New Structure;
	BasicFields.Insert("List",           New ValueList);
	BasicFields.Insert("All",              New Array);
	BasicFields.Insert("AllItemsTypes",         New Array);
	BasicFields.Insert("Used",     New Array);
	BasicFields.Insert("UsedItemsTypes", New Array);
	BasicFields.Insert("MaxCount", 0);
	BasicFields.Insert("MaxQuantity", 0);
	
	Context.Insert("BasicFields", BasicFields);
	
	If Context.IsReferenceType Then
		Return;
	EndIf;
	
	SeparateKeysRegisterName = "AccessKeysToRegister" + StrSplit(Context.List, ".")[1];
	If Metadata.InformationRegisters.Find(SeparateKeysRegisterName) = Undefined Then
		SeparateKeysRegisterName = "";
	EndIf;
	Context.Insert("SeparateKeysRegisterName", SeparateKeysRegisterName);
	
	BasicFields.MaxCount =
		AccessManagementInternalCached.BasicRegisterFieldsCount(SeparateKeysRegisterName);
	
	BasicFields.MaxQuantity =
		AccessManagementInternalCached.MaxBasicRegisterFieldsCount();
	
	If BasicFields.MaxCount > BasicFields.MaxQuantity Then
		// Increasing the quantity of basic fields in a separate register.
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Количество опорных полей в регистре сведений %1
			           |превышает максимально допустимое количество: %2'; 
			           |en = 'Number of basic fields in the %1 information register
			           |exceeds the maximum allowed value: %2'; 
			           |pl = 'Ilość oporowych pól w rejestrze informacji %1
			           | jest większa niż maksymalna liczba: %2';
			           |es_ES = 'Cantidad de campos base en el registro de información%1
			           |supera la cantidad máxima admitida: %2';
			           |es_CO = 'Cantidad de campos base en el registro de información%1
			           |supera la cantidad máxima admitida: %2';
			           |tr = 'Bilgi kaydındaki %1
			           |referans alanların sayısı izin verilen maksimum sayıyı aşıyor: %2';
			           |it = 'Il numero di campi base nel registro informazioni %1
			           |supera il valore massimo consentito: %2';
			           |de = 'Die Anzahl der Referenzfelder im Datenregister %1
			           |überschreitet die maximal zulässige Anzahl: %2'"),
			?(SeparateKeysRegisterName = "", "AccessKeysForRegisters", SeparateKeysRegisterName),
			BasicFields.MaxQuantity);
		
		If Context.Property("ErrorOnCallException") Then
			Context.ErrorOnCallException.Text = ErrorText;
		EndIf;
		Raise ErrorText;
	EndIf;
	
	AddVersionProperty(Context, BasicFields, "MaxCount");
	
	Result.BasicFields = New Structure("All, AllItemsTypes, Used, UsedItemsTypes,
	|MaxCount, MaxQuantity");
	FillPropertyValues(Result.BasicFields, Context.BasicFields);
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure FillHasRestrictionByRights(Context, Result, RestrictionStructure)
	
	Result.HasReadRestriction =
		ValueIsFilled(RestrictionStructure.ReadRestriction)
		AND (    RestrictionStructure.ReadRestriction.Node <> "Constant"
		   Or RestrictionStructure.ReadRestriction.Value <> True);
	
	Result.HasLimitChanges =
		ValueIsFilled(RestrictionStructure.UpdateRestriction)
		AND (    RestrictionStructure.UpdateRestriction.Node <> "Constant"
		   Or RestrictionStructure.UpdateRestriction.Value <> True);
	
	AddVersionProperty(Context, Result, "HasReadRestriction");
	AddVersionProperty(Context, Result, "HasLimitChanges");
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure FillRestrictionByOwnerObject(Result, Context)
	
	RestrictionByOwner = Context.ListsWithRestrictionByOwner.Get(Context.List);
	If TypeOf(RestrictionByOwner) = Type("Boolean") AND Not RestrictionByOwner Then
		Return;
	EndIf;

	RestrictionByOwnerRequired = ?(TypeOf(RestrictionByOwner) = Type("Boolean"),
		RestrictionByOwner, False);
	
	Result.RestrictionByOwnerRequired = RestrictionByOwnerRequired;
	OwnerField = New Structure("Name, EditAsRead", "", False);
	
	ReadRestriction    = Context.RestrictionStructure.ReadRestriction;
	UpdateRestriction = Context.RestrictionStructure.UpdateRestriction;
	
	If Result.HasReadRestriction Then
		
		If ReadRestriction.Node <> "ObjectReadingAllowed" Then
			If RestrictionByOwnerRequired Then
				If ValueIsFilled(UpdateRestriction) Then
					ErrorTemplate =
						NStr("ru = 'Установлен признак оптимизации ограничения %1,
						           |но указанное ограничение чтения изменения не представлено одной функцией ReadObjectAllowed.'; 
						           |en = '%1 restriction optimization check box is selected
						           |but the specified change reading restriction is not provided by the ReadObjectAllowed function.'; 
						           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
						           |ale ograniczenie odczytu zmiany nie przedstawiono jedną funkcją ReadObjectAllowed.';
						           |es_ES = 'Se ha establecido un atributo de optimización de restricción %1,
						           |pero la restricción de leer el cambio indicada no está presenta con ninguna de funciones ReadObjectAllowed.';
						           |es_CO = 'Se ha establecido un atributo de optimización de restricción %1,
						           |pero la restricción de leer el cambio indicada no está presenta con ninguna de funciones ReadObjectAllowed.';
						           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
						           |ancak belirtilen değişiklik okuma kısıtlaması tek NesneOkunabilir işlevi tarafından temsil edilmedi.';
						           |it = 'La casella di controllo di ottimizzazione della restrizione %1 è selezionata
						           |, ma la restrizione di lettura delle modifiche non è fornita dalla funzione ReadObjectAllowed.';
						           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
						           |aber die angegebene Einschränkung des Lesens der Änderung wird nicht durch eine Funktion LesenObjektErlaubt dargestellt.'");
				Else
					ErrorTemplate =
						NStr("ru = 'Установлен признак оптимизации ограничения %1,
						           |но указанное ограничение чтения не представлено одной функцией ReadObjectAllowed.'; 
						           |en = '%1 restriction optimization check box is selected
						           |but the specified reading restriction is not provided by the ReadObjectAllowed function.'; 
						           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
						           |ale ograniczenie odczytu nie przedstawiono jedną funkcją ReadObjectAllowed.';
						           |es_ES = 'Se ha establecido un atributo de optimización de restricción %1,
						           |pero la restricción de leer no está presenta con ninguna de funciones ReadObjectAllowed.';
						           |es_CO = 'Se ha establecido un atributo de optimización de restricción %1,
						           |pero la restricción de leer no está presenta con ninguna de funciones ReadObjectAllowed.';
						           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
						           |ancak belirtilen okuma kısıtlaması tek NesneOkunabilir işlevi tarafından temsil edilmedi.';
						           |it = 'La casella di controllo di ottimizzazione della restrizione %1 è selezionata
						           |, ma la restrizione di lettura non è fornita dalla funzione ReadObjectAllowed.';
						           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
						           |aber die angegebene Einschränkung des Lesens wird nicht durch eine Funktion LesenObjektErlaubt dargestellt.'");
				EndIf;
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate,
					"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""));
				ErrorText = ErrorTextWithTitle(ErrorText, Context);
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			Else
				Return;
			EndIf;
		EndIf;
		If Not FunctionWithoutClarificationOfTypesWithFieldWithoutAttachments(ReadRestriction) Then
			If RestrictionByOwnerRequired Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Установлен признак оптимизации ограничения %1,
					           |но параметры функции ReadObjectAllowed не представлены
					           |только одним параметром - полем владельцем без других параметров.'; 
					           |en = '%1 restriction optimization check box is selected
					           |but parameters of the ReadObjectAllowed function are not provided
					           |only by one parameter which is an owner field without other parameters.'; 
					           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
					           |ale parametry funkcji ReadObjectAllowed nie są przedstawione
					           |tylko jednym parametrem - polem właścicielem bez innych opcji.';
					           |es_ES = 'Se ha instalado un atributo de optimización de restricción%1,
					           |pero los parámetros de función ReadObjectAllowed no están presentes
					           |solo por un parámetro - campo de propietario sin otros parámetros.';
					           |es_CO = 'Se ha instalado un atributo de optimización de restricción%1,
					           |pero los parámetros de función ReadObjectAllowed no están presentes
					           |solo por un parámetro - campo de propietario sin otros parámetros.';
					           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
					           |ancak NesneOkunabilir işlev parametreleri yalnızca bir parametre - 
					           |alan sahibi tarafından temsil edilmedi.';
					           |it = 'La casella di controllo di ottimizzazione della restrizione %1 è selezionata
					           |ma i parametri della funzione ReadObjectAllowed non sono forniti
					           |da un solo parametro che è un campo proprietario senza altri parametri.';
					           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
					           |aber die Parameter der Funktion LesenObjektErlaubt werden nicht
					           |nur durch einen Parameter repräsentiert - dem Feld vom Eigentümer ohne weitere Parameter.'"),
					"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""));
				ErrorText = ErrorTextWithTitle(ErrorText, Context);
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			Else
				Return;
			EndIf;
		EndIf;
		OwnerField.Name = ReadRestriction.Field.Name;
	EndIf;
	
	If Result.HasLimitChanges Then
		
		If UpdateRestriction.Node <> "ObjectReadingAllowed"
		   AND UpdateRestriction.Node <> "ObjectUpdateAllowed" Then
			
			If RestrictionByOwnerRequired Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Установлен признак оптимизации ограничения %1,
					           |но указанное ограничение изменения не представлено одной функцией
					           |ReadObjectAllowed  или EditObjectAllowed.'; 
					           |en = '%1 restriction optimization check box is selected
					           |but the specified change reading restriction is not provided by the 
					           |ReadObjectAllowed or EditObjectAllowed function.'; 
					           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
					           |ale ograniczenie to nie przedstawiono jedną funkcją
					           |ReadObjectAllowed lub EditObjectAllowed.';
					           |es_ES = 'Se ha establecido un atributo de optimización de restricción %1,
					           |pero la restricción de cambio indicada no está presenta con ninguna de funciones
					           | ReadObjectAllowed o EditObjectAllowed.';
					           |es_CO = 'Se ha establecido un atributo de optimización de restricción %1,
					           |pero la restricción de cambio indicada no está presenta con ninguna de funciones
					           | ReadObjectAllowed o EditObjectAllowed.';
					           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
					           |ancak belirtilen değişiklik kısıtlaması tek NesneOkunabilir ya da NesneDeğiştirilebilir 
					           |işlevi tarafından temsil edilmedi.';
					           |it = 'La casella di controllo di ottimizzazione della restrizione %1 è selezionata
					           |ma le restrizioni alla lettura delle modifiche non sono fornite dalla funzione 
					           |ReadObjectAllowed o EditObjectAllowed.';
					           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt %1,
					           |aber die angegebene Einschränkung wird nicht durch eine Funktion
					           |LesenObjektErlaubt oder ÄndernObjektErlaubt repräsentiert.'"),
					"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""));
				ErrorText = ErrorTextWithTitle(ErrorText, Context);
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			Else
				Return;
			EndIf;
		EndIf;
		If Not FunctionWithoutClarificationOfTypesWithFieldWithoutAttachments(UpdateRestriction) Then
			If RestrictionByOwnerRequired Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Установлен признак оптимизации ограничения %1,
					           |но параметры функции %2 не представлены
					           |только одним параметром - полем владельцем без других параметров.'; 
					           |en = '%1 restriction optimization check box is selected
					           |but parameters of the %2 function are not provided
					           |only by one parameter, which is an owner field without other parameters.'; 
					           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
					           |ale parametry funkcji %2 nie są tylko przedstawione
					           |tylko jednym parametrem - polem właścicielem bez innych parametrów.';
					           |es_ES = 'Se ha instalado un atributo de optimización de restricción%1,
					           |pero los parámetros de función %2 no están presentes
					           |solo por un parámetro - campo de propietario sin otros parámetros.';
					           |es_CO = 'Se ha instalado un atributo de optimización de restricción%1,
					           |pero los parámetros de función %2 no están presentes
					           |solo por un parámetro - campo de propietario sin otros parámetros.';
					           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
					           |ancak %2 işlev parametreleri yalnızca bir parametre - 
					           |alan sahibi tarafından temsil edilmedi.';
					           |it = 'La casella di controllo di ottimizzazione della restrizione %1 è selezionata
					           |ma i parametri della funzione %2 non sono forniti
					           |da un solo parametro che è un campo proprietario senza altri parametri.';
					           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
					           |aber die Parameter der Funktion %2 werden nicht
					           |nur durch einen Parameter repräsentiert- das Feld vom Eigentümer ohne andere Parameter.'"),
					"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""),
					UpdateRestriction.Node);
				ErrorText = ErrorTextWithTitle(ErrorText, Context);
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			Else
				Return;
			EndIf;
		EndIf;
		
		If OwnerField.Name = "" Then
			OwnerField.Name = UpdateRestriction.Field.Name;
			
		ElsIf OwnerField.Name <> UpdateRestriction.Field.Name Then
			If RestrictionByOwnerRequired Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Установлен признак оптимизации ограничения %1,
					           |но поле владельца не совпадает в ограничениях чтения и изменения.'; 
					           |en = '%1 restriction optimization check box is selected
					           |but owner field does not match in read and change restrictions.'; 
					           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
					           |ale pole właściciel nie pokrywa się z ograniczeniami odczytu i zmiany.';
					           |es_ES = 'Se ha establecido un atributo de optimización de restricción%1,
					           |pero el campo de propietario no corresponde en las restricciones de lectura y cambio.';
					           |es_CO = 'Se ha establecido un atributo de optimización de restricción%1,
					           |pero el campo de propietario no corresponde en las restricciones de lectura y cambio.';
					           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
					           | ancak sahibin alanı okuma ve değişiklik kısıtlamalarında uyumlu değildir.';
					           |it = 'La casella di controllo di ottimizzazione della restrizione %1 è selezionata
					           |, ma il campo proprietario non corrisponde nelle restrizioni di lettura e modifica.';
					           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
					           |aber das Feld des Eigentümers stimmt nicht mit den Lese- und Änderungsbeschränkungen überein.'"),
					"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""),
					UpdateRestriction.Node);
				ErrorText = ErrorTextWithTitle(ErrorText, Context);
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			Else
				Return;
			EndIf;
		EndIf;
		OwnerField.EditAsRead =
			UpdateRestriction.Node <> "ObjectUpdateAllowed";
	Else
		OwnerField.EditAsRead = True;
	EndIf;
	
	FieldsProperties = Context.FieldsProperties;
	
	If FieldsProperties.Count() <> 1 Then
		If RestrictionByOwnerRequired AND FieldsProperties.Count() <> 0 Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Установлен признак оптимизации ограничения %1,
				           |но количество полей, используемых в ограничении, более одного.'; 
				           |en = '%1 restriction optimization check box is selected
				           |but the number of fields used in the restriction is more than one.'; 
				           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
				           |ale ilość pól używanych w ograniczeniu, więcej niż jeden.';
				           |es_ES = 'Se ha establecido un atributo de optimización de restricción%1,
				           |pero la cantidad de campos usados en la restricción es más que uno.';
				           |es_CO = 'Se ha establecido un atributo de optimización de restricción%1,
				           |pero la cantidad de campos usados en la restricción es más que uno.';
				           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
				           | ancak kısıtlamada kullanılan alanların sayısı birden fazladır.';
				           |it = 'La casella di controllo di ottimizzazione della restrizione %1 è selezionata
				           |, ma il numero di campi utilizzati nella restrizione sono più di uno.';
				           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
				           |aber die Anzahl der in der Einschränkung verwendeten Felder ist größer als eins.'"),
				"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""));
			ErrorText = ErrorTextWithTitle(ErrorText, Context);
			If Context.Property("ErrorOnCallException") Then
				Context.ErrorOnCallException.Text = ErrorText;
			EndIf;
			Raise ErrorText;
		Else
			Return;
		EndIf;
	EndIf;
	
	FieldProperties = FieldsProperties[0];
	
	MOIDType = Type("CatalogRef.MetadataObjectIDs");
	EOIDType = Type("CatalogRef.ExtensionObjectIDs");
	
	IDsTypesCountInFinalField = 0;
	If FieldProperties.EndFieldType.ContainsType(MOIDType) Then
		IDsTypesCountInFinalField = 1;
	EndIf;
	If FieldProperties.EndFieldType.ContainsType(EOIDType) Then
		IDsTypesCountInFinalField = IDsTypesCountInFinalField + 1;
	EndIf;
	
	If FieldProperties.EndFieldType.Types().Count() - IDsTypesCountInFinalField
	  <> FieldProperties.AccessKeySavingTypes.Count() Then
		
		IncorrectTypes = New Array;
		For Each Type In FieldProperties.EndFieldType.Types() Do
			If FieldProperties.AccessKeySavingTypes.Find(Type) <> Undefined
			 Or Type = MOIDType
			 Or Type = EOIDType Then
				Continue;
			EndIf;
			IncorrectTypes.Add(TypeNameInQueryLanguage(Type));
		EndDo;
		If RestrictionByOwnerRequired Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Установлен признак оптимизации ограничения %1,
				           |но для следующих таблиц невозможно записать ключи доступа:
				           |%2'; 
				           |en = '%1 restriction optimization check box is selected
				           |but you cannot write access keys for the following tables:
				           |%2'; 
				           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
				           |ale dla następujących tabel nie można zapisać klucze dostępu:
				           |%2';
				           |es_ES = 'Se ha establecido un atributo de optimización de restricción%1,
				           |pero para las siguientes tablas es imposible guardar las claves de acceso:
				           |%2';
				           |es_CO = 'Se ha establecido un atributo de optimización de restricción%1,
				           |pero para las siguientes tablas es imposible guardar las claves de acceso:
				           |%2';
				           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
				           | ancak aşağıdaki tablolar için erişim anahtarları kaydedilemez: 
				           |%2';
				           |it = 'La casella di controllo di ottimizzazione della restrizione %1 è selezionata,
				           | ma non è possibile scrivere chiavi di accesso per le tabelle seguenti:
				           |%2';
				           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
				           |aber die Zugriffsschlüssel für die folgenden Tabellen können nicht aufgeschrieben werden:
				           |%2'"),
				"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""),
				StrConcat(IncorrectTypes, Chars.LF));
			ErrorText = ErrorTextWithTitle(ErrorText, Context);
			If Context.Property("ErrorOnCallException") Then
				Context.ErrorOnCallException.Text = ErrorText;
			EndIf;
			Raise ErrorText;
		Else
			Return;
		EndIf;
	EndIf;
	
	Result.OwnerField = OwnerField;
	
	AddVersionProperty(Context, OwnerField, "EditAsRead");
	AddVersionProperty(Context, OwnerField, "Name");
	
EndProcedure

// For the FillRestrictionByOwnerObject function and the SetOptimizationByOwnerField procedure.
Function ErrorTextWithTitle(ErrorText, Context)
	
	ErrorsDetails = New Structure;
	ErrorsDetails.Insert("HasErrors", True);
	ErrorsDetails.Insert("Errors", New Array(1));
	ErrorsDetails.Insert("ErrorsText", ErrorText);
	ErrorsDetails.Insert("Restriction", "");
	ErrorsDetails.Insert("AddOn", "");
	
	RestrictionDetails = Context.RestrictionsDetails.Get(Context.List);
	
	ErrorsDetails.Restriction =
		NumberedRestrictionTextWithErrorsMarks(RestrictionDetails.Text,
			New Array, StrLen(Format(StrLineCount(RestrictionDetails.Text), "NG=")));
	
	Return TrimAll(ErrorsTextToCallException(Context.List,
		ErrorsDetails, Context.ForExternalUsers, RestrictionDetails.InManagerModule));
	
EndFunction

// For the FillRestrictionByOwnerObject procedure.
Function FunctionWithoutClarificationOfTypesWithFieldWithoutAttachments(Restriction)
	
	If Restriction.Types.Count() <> 0
	 Or Restriction.ComparisonClarifications.Count() <> 0 Then
		Return False;
	EndIf;
	
	Field = Restriction.Field;
	
	Return Not ValueIsFilled(Field.Cast)
	      AND Not ValueIsFilled(Field.Attachment)
	      AND Not ValueIsFilled(Field.IsNull);
	
EndFunction

// For the AccessRestrictionParameters function.
Procedure FillHasLeadingKeysAndListsAndRightsSettingsOwners(Result, Context)
	
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.AccessKeySavingTypes.Count() > 0 Then
			Result.HasMasterAccessKeys = True;
		EndIf;
		If FieldProperties.HasHeadListType Then
			Result.HasHeadRightsLists = True;
		EndIf;
		If FieldProperties.HasRightsSettingsOwnerType Then
			Result.HasRightsSettingsOwners = True;
		EndIf;
		If FieldProperties.HasAuthorizedUserCheck Then
			Context.HasAuthorizedUserCheck = True;
		EndIf;
		For Each Type In FieldProperties.UsedAccessValuesTypes Do
			Result.UsedAccessValuesTypes.Add(Type);
		EndDo;
		For Each Type In FieldProperties.UnusedAccessValueTypes Do
			Context.UnusedAccessValueTypes.Add(Type);
		EndDo;
	EndDo;
	
	For Each KeyAndValue In Context.SeparateRightsSettingsTables Do
		If KeyAndValue.Value = Context.List Then
			Result.RightSettingsTableID = KeyAndValue.Key;
			Break;
		EndIf;
	EndDo;
	
	AddVersionProperty(Context, Result, "HasMasterAccessKeys");
	AddVersionProperty(Context, Result, "HasHeadRightsLists");
	AddVersionProperty(Context, Result, "HasRightsSettingsOwners");
	AddVersionProperty(Context, Result, "UsedAccessValuesTypes");
	AddVersionProperty(Context, Context,  "UnusedAccessValueTypes");
	
	PropertiesToSave = New Structure("SeparateRightsSettingsTable",
		ValueIsFilled(Result.RightSettingsTableID));
	
	AddVersionProperty(Context, PropertiesToSave, "SeparateRightsSettingsTable");
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure DeleteNotUsedAccessKindsFields(Result, Context)
	
	FieldsProperties = Context.FieldsProperties;
	
	If Not Result.HasMasterAccessKeys
	   AND Not Result.HasHeadRightsLists
	   AND Not Result.HasRightsSettingsOwners
	   AND Not Context.HasAuthorizedUserCheck
	   AND Result.UsedAccessValuesTypes.Count() = 0
	   AND Context.UnusedAccessValueTypes.Count() > 0 Then
		
		FieldsProperties.Clear();
		Return;
	EndIf;
	
	Index = FieldsProperties.Count();
	While Index > 0 Do
		Index = Index - 1;
		FieldProperties = FieldsProperties.Get(Index);
		
		If FieldProperties.EndFieldType.Types().Count()
				= FieldProperties.UnusedAccessValueTypes.Count() Then
			
			FieldsProperties.Delete(Index);
			Continue;
		EndIf;
		SetBasicFieldUse(Context.BasicFields, FieldProperties);
		AddVersionProperties(Context, FieldProperties,
		"HasAdjustmentNull,
		|HasAdjustmentUndefined,
		|FieldNameForQuery,
		|MultipleValuesGroups,
		|EndFieldType,
		|ValueGroupSavingTypes,
		|ValueSavingTypes,
		|AccessKeySavingTypes,
		|EmptyRefSavingTypes,
		|AllowedTypeSavingTypes,
		|ProhibitedTypeSavingTypes,
		|TypeSavingTypes,
		|ConfigurationTypeSavingTypes,
		|SimpleTypeSavingTypes,
		|ExtensionTypeSavingTypes,
		|TypesString");
	EndDo;
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure FillHasRestrictionByUsersAccessKind(Result, Context)
	
	If Result.HasRightsSettingsOwners Then
		Result.HasUsersRestriction = True;
	Else
		For Each FieldProperties In Context.FieldsProperties Do
			If FieldProperties.ValueSavingTypes.Count() = 0 Then
				Continue;
			EndIf;
			TypesDetails = New TypeDescription(FieldProperties.ValueSavingTypes);
			If Not Result.ForExternalUsers
			   AND (    TypesDetails.ContainsType(Type("CatalogRef.Users"))
			      Or TypesDetails.ContainsType(Type("CatalogRef.UserGroups")) ) Then
				
				Result.HasUsersRestriction = True;
				Break;
			EndIf;
			If Result.ForExternalUsers
			   AND (    TypesDetails.ContainsType(Type("CatalogRef.ExternalUsers"))
			      Or TypesDetails.ContainsType(Type("CatalogRef.ExternalUsersGroups")) ) Then
				
				Result.HasUsersRestriction = True;
				Break;
			EndIf;
		EndDo;
	EndIf;
	
	AddVersionProperty(Context, Result, "HasUsersRestriction");
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure FillHasReadRestriction(Result, Context)
	
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.Read Then
			Result.RightToWriteRestrictionDisabled = False;
			Break;
		EndIf;
	EndDo;
	
	AddVersionProperty(Context, Result, "RightToWriteRestrictionDisabled");
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure FillFieldsAndAdditionalTablesGroups(Context)
	
	// Header fields (start from the header, grouping by a blank alias if there is no tabular section name).
	// Fields of each tabular section (start from the tabular section, grouping by the tabular section name).
	// Fields of a group of linked additional tables (start from an instance of an additional table - 
	// grouping by alias. If one table refers to another in the connection, a group of tables is generated).
	
	LastHeaderAttributeNumberWithSeveralAccessValuesGroups = 0;
	LastObjectTabularSectionNumber = 0;
	ObjectTabularSectionsNumbers = New Map;
	
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.TableAlias = "CurrentList"
		   AND FieldProperties.MultipleValuesGroups Then
			
			LastHeaderAttributeNumberWithSeveralAccessValuesGroups =
				LastHeaderAttributeNumberWithSeveralAccessValuesGroups + 1;
			
		ElsIf FieldProperties.TableAlias <> "CurrentList"
		        AND StrStartsWith(FieldProperties.TableAlias, "CurrentList")
			    AND ObjectTabularSectionsNumbers.Get(FieldProperties.TableAlias) = Undefined Then
			
			LastObjectTabularSectionNumber = LastObjectTabularSectionNumber + 1;
			ObjectTabularSectionsNumbers.Insert(FieldProperties.TableAlias, LastObjectTabularSectionNumber);
		EndIf;
	EndDo;
	
	AccessKeyDimensions = AccessManagementInternalCached.AccessKeyDimensions();
	
	KeyTabularSectionsCountForObjectHeaderAttributes = Int(
		(LastHeaderAttributeNumberWithSeveralAccessValuesGroups
			+ AccessKeyDimensions.TabularSectionAttributesCount - 1)
		/ AccessKeyDimensions.TabularSectionAttributesCount);
	
	AdditionalTablesGroups = AdditionalTablesGroups(Context);
	KeyTabularSectionsCount = LastObjectTabularSectionNumber
		+ AdditionalTablesGroups.TablesByGroups.Count()
		+ KeyTabularSectionsCountForObjectHeaderAttributes;
	
	CompleteBasicFieldsPreparation(Context);
	
	If KeyTabularSectionsCount > AccessKeyDimensions.TabularSectionsCount Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В ограничении доступа списка %1
			           |количество полей, требующих отдельных табличных частей в ключе доступа,
			           |более, чем количество доступных табличных частей в ключе доступа.
			           |
			           |К таким полям относятся:
			           |- поля табличных частей,
			           |- поля дополнительных таблиц, присоединенных к списку,
			           |- поля шапки, у которых значение доступа может иметь более одной группы значений доступа.'; 
			           |en = 'In the %1 list access restriction,
			           |the number of fields requiring separate tabular sections in the access key
			           |is more than the number of available tabular sections in the access key.
			           |
			           |These fields include:
			           |- Fields of tabular sections.
			           |- Fields of additional tables attached to the list.
			           |- Header fields, in which the access value can have more than one access value group.'; 
			           |pl = 'W ograniczeniu dostępu listy %1
			           | ilość pól, które wymagają oddzielnych części tabelarycznych w kluczu dostępu,
			           |bardziej niż ilość dostępnych części tabelarycznych w kluczu dostępu.
			           |
			           |Do takich pól należą:
			           |- pola tabelarycznych części,
			           |- pola dodatkowych tabel, przyłączonych do listy,
			           |- pola nagłówka, u których wartość dostępu może mieć więcej niż jedną grupę wartości dostępu.';
			           |es_ES = 'En la restricción de acceso de la lista %1
			           | la cantidad de campos que requieren las secciones tabulares separadas en la clave de acceso
			           |más de cantidad de secciones tabulares disponibles en la clave de acceso.
			           |
			           |A estos campos se refieren:
			           |- campos de secciones tabulares,
			           |- campos de tablas adicionales adjuntas a la lista,
			           |- campos de encabezado cuyo valor de acceso puede tener más de un grupo de valores de acceso.';
			           |es_CO = 'En la restricción de acceso de la lista %1
			           | la cantidad de campos que requieren las secciones tabulares separadas en la clave de acceso
			           |más de cantidad de secciones tabulares disponibles en la clave de acceso.
			           |
			           |A estos campos se refieren:
			           |- campos de secciones tabulares,
			           |- campos de tablas adicionales adjuntas a la lista,
			           |- campos de encabezado cuyo valor de acceso puede tener más de un grupo de valores de acceso.';
			           |tr = 'Liste %1
			           |erişimi kısıtlamasında, erişim anahtarındaki tek tek tablo kısımlarını gerektiren alanların sayısı, 
			           |erişim anahtarındaki mevcut tablo kısımlarının sayısından daha fazladır.
			           |
			           |Bu alanlar şunları içerir: 
			           |- tablo bölümleri alanları, 
			           |- listeye eklenen ek tablolar alanları 
			           |- erişim değeri birden fazla erişim değeri grubuna sahip olan başlık alanları.';
			           |it = 'Nella restrizione all''accesso dell''elenco %1, 
			           |il numero di campi richiedenti sezioni tabellari separati nella chiave di accesso
			           |è maggiore del numero di sezioni tabellari disponibili nella chiave di accesso.
			           |
			           |Questi campi includono:
			           |- Campi di sezioni tabellari.
			           |- Campi di tabelle aggiuntive allegate all''elenco.
			           |- Campi intestazione, in cui il valore di accesso può avere più di un gruppo di valore di accesso.';
			           |de = 'Bei der Einschränkung des Zugriffs auf die Liste %1
			           |ist die Anzahl der Felder, die separate Tabellenteile im Zugriffsschlüssel erfordern,
			           |größer als die Anzahl der verfügbaren Tabellenteile im Zugriffsschlüssel.
			           |
			           |Zu diesen Feldern gehören:
			           |- Tabellenteilfelder,
			           |- Felder von Zusatztabellen, die an die Liste angehängt sind,
			           |- Kopffelder, in denen der Zugriffswert mehr als eine Gruppe von Zugriffswerten haben kann.'"),
			Context.List);
		
		If Context.Property("ErrorOnCallException") Then
			Context.ErrorOnCallException.Text = ErrorText;
		EndIf;
		Raise ErrorText;
	EndIf;
	
	If Not Context.IsReferenceType
	   AND Context.BasicFields.All.Count() > Context.BasicFields.MaxCount Then
		
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В ограничении доступа списка %1
			           |количество полей списка, используемых в ограничении доступа,
			           |превышает максимально допустимое количество опорных полей: %2.'; 
			           |en = 'In the %1 list access restriction,
			           |the number of list fields used in access restriction
			           |exceeds the maximum allowed number of basic fields: %2.'; 
			           |pl = 'W ograniczeniu dostępu do listy %1
			           |ilość pól listy stosowanych w ograniczeniu dostępu,
			           |przekracza maksymalną dopuszczalną ilość oporowych pól: %2.';
			           |es_ES = 'En la restricción de acceso de lista %1
			           |la cantidad de campos usados en la restricción de acceso
			           |supera la cantidad máxima admitida de la cantidad de campos base: %2.';
			           |es_CO = 'En la restricción de acceso de lista %1
			           |la cantidad de campos usados en la restricción de acceso
			           |supera la cantidad máxima admitida de la cantidad de campos base: %2.';
			           |tr = 'Liste erişimi %1
			           |kısıtlamasında, erişim kısıtlamasında kullanılan liste alanı sayısı, 
			           |izin verilen maksimum referans alanı sayısını aşmaktadır:%2.';
			           |it = 'Nella restrizione all''accesso dell''elenco %1,
			           |il numero di campi dell''elenco utilizzati nella restrizione all''accesso
			           |supera il numero massimo consentito di campi di base: %2.';
			           |de = 'Bei der Einschränkung des Zugriffs auf die Liste %1
			           |überschreitet die Anzahl der Listenfelder, die bei der Einschränkung des Zugriffs verwendet werden,
			           |die maximale Anzahl der Referenzfelder: %2.'"),
			Context.List,
			Context.BasicFields.MaxCount);
		
		If Context.Property("ErrorOnCallException") Then
			Context.ErrorOnCallException.Text = ErrorText;
		EndIf;
		Raise ErrorText;
	EndIf;
	
	FieldsGroups = New Map;
	ObjectTabularSectionsAliases = New Map;
	LastHeaderAttributeNumber = 0;
	LastHeaderAttributeNumberWithSeveralAccessValuesGroups = 0;
	
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.TableAlias = "CurrentList" Then
			
			If FieldProperties.MultipleValuesGroups Then
				LastHeaderAttributeNumberWithSeveralAccessValuesGroups =
					LastHeaderAttributeNumberWithSeveralAccessValuesGroups + 1;
				
				KeyTabularSectionNumber = Int(LastHeaderAttributeNumberWithSeveralAccessValuesGroups
					/ AccessKeyDimensions.TabularSectionAttributesCount) + 1;
				
				FieldsGroupName = "TabularSection" + KeyTabularSectionNumber;
			Else
				LastHeaderAttributeNumber = LastHeaderAttributeNumber + 1;
				If LastHeaderAttributeNumber < 6 Then
					FieldsGroupName = "Header0";
				ElsIf LastHeaderAttributeNumber < 11 Then
					FieldsGroupName = "Header1";
				ElsIf LastHeaderAttributeNumber < 16 Then
					FieldsGroupName = "Header2";
				Else
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'В ограничении доступа списка %1
						           |количество полей списка, используемых в ограничении доступа,
						           |превышает максимально допустимое количество: 15.'; 
						           |en = 'In the %1 list access restriction,
						           |the number of list fields used in access restriction
						           |exceeds the maximum allowed number: 15.'; 
						           |pl = 'W ograniczeniu dostępu do listy %1
						           | ilość pól listy, stosowanych w ograniczeniu dostępu,
						           |przekracza maksymalną dopuszczalną ilość: 15.';
						           |es_ES = 'En la restricción de acceso de lista %1
						           |la cantidad de campos usados en la restricción de acceso
						           |supera la cantidad máxima admitida: 15.';
						           |es_CO = 'En la restricción de acceso de lista %1
						           |la cantidad de campos usados en la restricción de acceso
						           |supera la cantidad máxima admitida: 15.';
						           |tr = 'Liste erişimi %1
						           |kısıtlamasında, erişim kısıtlamasında kullanılan liste alanı sayısı, 
						           |izin verilen maksimum referans alanı sayısını aşmaktadır: 15.';
						           |it = 'Nella restrizione all''accesso dell''elenco %1, 
						           |il numero di campi dell''elenco utilizzati nella restrizione all''accesso
						           |supera il numero massimo consentito: 15.';
						           |de = 'Bei der Einschränkung des Zugriffs auf die Liste %1
						           |überschreitet die Anzahl der Felder in der Liste, die bei der Einschränkung des Zugriffs verwendet werden,
						           |die maximal zulässige Anzahl: 15.'"),
						Context.List);
					If Context.Property("ErrorOnCallException") Then
						Context.ErrorOnCallException.Text = ErrorText;
					EndIf;
					Raise ErrorText;
				EndIf;
			EndIf;
		Else
			If FieldProperties.TableAlias <> "CurrentList"
			   AND StrStartsWith(FieldProperties.TableAlias, "CurrentList") Then
				
				KeyTabularSectionNumber = KeyTabularSectionsCountForObjectHeaderAttributes
					+ ObjectTabularSectionsNumbers.Get(FieldProperties.TableAlias);
				
				If ObjectTabularSectionsAliases.Get(KeyTabularSectionNumber) = Undefined Then
					ObjectTabularSectionsAliases.Insert(KeyTabularSectionNumber, FieldProperties.TableAlias)
				EndIf;
			Else
				KeyTabularSectionNumber = KeyTabularSectionsCountForObjectHeaderAttributes
					+ ObjectTabularSectionsNumbers.Count()
					+ AdditionalTablesGroups.NumbersByAliases.Get(FieldProperties.TableAlias);
			EndIf;
			FieldsGroupName = "TabularSection" + KeyTabularSectionNumber;
		EndIf;
		FieldsGroup = FieldsGroups.Get(FieldsGroupName);
		If FieldsGroup = Undefined Then
			FieldsGroup = New Array;
			FieldsGroups.Insert(FieldsGroupName, FieldsGroup);
		EndIf;
		FieldsGroup.Add(FieldProperties);
		FieldProperties.Insert("AccessKeyFieldsGroupName", FieldsGroupName);
		FieldProperties.Insert("AccessKeyFieldsGroupAttributeName", "Value" + String(
			FieldsGroup.Count() + ?(FieldsGroupName = "Header1" Or FieldsGroupName = "Header2", 5, 0)));
		
		If Not StrStartsWith(FieldsGroupName, "Header")
		   AND FieldsGroup.Count() > AccessKeyDimensions.TabularSectionAttributesCount Then
			
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'В ограничении доступа списка %1
				           |количество полей одной табличной части, используемых в ограничении доступа,
				           |превышает максимально допустимое количество: %2.'; 
				           |en = 'In the %1 list access restriction,
				           |the number of fields of one tabular section used in access restriction
				           |exceeds the maximum allowed number: %2.'; 
				           |pl = 'W ograniczeniu dostępu do listy %1
				           | ilość pól jednej tabelarycznej części używanych do ograniczenia dostępu,
				           |przekracza maksymalną liczbę: %2.';
				           |es_ES = 'En la restricción de acceso de lista %1
				           |la cantidad de campos usados en la restricción de acceso
				           |supera la cantidad máxima admitida: %2.';
				           |es_CO = 'En la restricción de acceso de lista %1
				           |la cantidad de campos usados en la restricción de acceso
				           |supera la cantidad máxima admitida: %2.';
				           |tr = 'Liste erişimi %1
				           |kısıtlamasında, erişim kısıtlamasında kullanılan bir tablo kısmının sayısı, 
				           |izin verilen maksimum referans alanı sayısını aşmaktadır:%2.';
				           |it = 'Nella restrizione all''accesso dell''elenco %1,
				           |il numero di campi di una sezione tabellare utilizzata nella restrizione all''accesso
				           |supera il numero massimo consentito:%2.';
				           |de = 'Bei der Einschränkung des Zugriffs auf die Liste %1
				           |überschreitet die Anzahl der Felder in einem Tabellenteil, die bei der Einschränkung des Zugriffs verwendet werden,
				           |die maximal zulässige Anzahl von Feldern: %2.'"),
				Context.List,
				AccessKeyDimensions.TabularSectionAttributesCount);
			
			If Context.Property("ErrorOnCallException") Then
				Context.ErrorOnCallException.Text = ErrorText;
			EndIf;
			Raise ErrorText;
		EndIf;
	EndDo;
	
	Context.Insert("FieldsGroups",                      FieldsGroups);
	Context.Insert("ObjectTabularSectionsAliases", ObjectTabularSectionsAliases);
	Context.Insert("AdditionalTablesGroups",       AdditionalTablesGroups);
	Context.Insert("KeyTabularSectionsCount",   KeyTabularSectionsCount);
	
	// Calculating the FieldsContent number.
	
	// Header and tabular sections:     TS4  TS3  TS2  TS1    H.
	// Binary format:           0000 0000 0000 0000 0000.
	// Hex format:    x0   x0   x0   x0   x0.
	//
	// For example, H0=1, TS1=1.
	// Binary format:           0000 0000 0000 0001 0001.
	// Hex format:    x0   x0   x0   x1   x1.
	// Number = 1*16^0 + 1*16^1 = 1 + 16 = 17.
	
	FieldsContent = LastHeaderAttributeNumber;
	
	For KeyTabularSectionNumber = 1 To KeyTabularSectionsCount Do
		KeyTabularSectionName = "TabularSection" + KeyTabularSectionNumber;
		FieldsGroup = FieldsGroups.Get(KeyTabularSectionName);
		FieldsContent = FieldsContent + FieldsGroup.Count() * Power16(KeyTabularSectionNumber);
	EndDo;
	
	Context.Insert("FieldsComposition", FieldsContent);
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure FillRightCalculationStructure(CalculationCondition, Condition, Context, ConditionRoot = True)
	
	If Not ValueIsFilled(Condition) Then
		Return;
	EndIf;
	
	If ConditionRoot Then
		Context.Insert("RequiredKeyTabularSectionsAttributes", New Map);
		Context.Insert("VersionPropertiesRightCalculationStructure", New Array);
	EndIf;
	
	FieldProperties = Undefined;
	AddCalculationStructureVersionProperty(Context, "Node", Condition.Node);
	
	If Condition.Node = "Field" Then
		FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition);
		
	ElsIf Upper( Condition.Node ) = Upper( "AND" ) // PATCHED:
	      Or Condition.Node = "Or" Then
		
		CalculationCondition = New Structure("Node, Arguments", Condition.Node, New Array);
		Index = 0;
		For Each Argument In Condition.Arguments Do
			CalculationCondition.Arguments.Add(Undefined);
			FillRightCalculationStructure(CalculationCondition.Arguments[Index], Argument, Context, False);
			Index = Index + 1;
		EndDo;
		FieldProperties = Null;
		
	ElsIf Condition.Node = "Not" Then
		CalculationCondition = New Structure("Node, Argument", Condition.Node, Undefined);
		FillRightCalculationStructure(CalculationCondition.Argument, Condition.Argument, Context, False);
		FieldProperties = Null;
		
	ElsIf Condition.Node = "ForAllRows"
	      Or Condition.Node = "ForAtLeastOneRow" Then
		
		If Not ConditionRoot Then
			RequiredKeyTabularSectionsAttributes = Context.RequiredKeyTabularSectionsAttributes;
			Context.Insert("RequiredKeyTabularSectionsAttributes", New Map);
		EndIf;
		
		CalculationCondition = New Structure("Node, Argument", Condition.Node, Undefined);
		FillRightCalculationStructure(CalculationCondition.Argument, Condition.Argument, Context, False);
		
		If Not ConditionRoot Then
			CalculationCondition.Insert("RequiredKeyTabularSectionsAttributes", Context.RequiredKeyTabularSectionsAttributes);
			Context.Insert("RequiredKeyTabularSectionsAttributes", RequiredKeyTabularSectionsAttributes);
		EndIf;
		FieldProperties = Null;
		
	ElsIf Condition.Node = "IsNull" Then
		FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition.Argument);
		
	ElsIf Condition.Node = "="
	      Or Condition.Node = "<>" Then
		
		FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition.FirstArgument);
		If FieldProperties = Undefined Then
			FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition.SecondArgument);
		EndIf;
		
	ElsIf Upper( Condition.Node ) = Upper( "IN" ) Then // PATCHED:
		FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition.SearchFor);
		
	ElsIf Condition.Node = "Case" Then
		CalculationCondition = New Structure("Node, When, Else", Condition.Node, New Array, Undefined);
		For Each When In Condition.When Do
			StructureWhen = New Structure("Condition, Value");
			CalculationCondition.When.Add(StructureWhen);
			If Condition.Case = Undefined Then
				FillRightCalculationStructure(StructureWhen.Condition, When.Condition, Context, False);
			Else
				Properties = Context.AccessKeyFieldsProperties.Get(When.Condition);
				AddCalculationStructureVersionProperty(Context, "Node", "Field");
				CalculationConditionField(StructureWhen.Condition, Properties, Context);
			EndIf;
			FillRightCalculationStructure(StructureWhen.Value, When.Value, Context, False);
		EndDo;
		FillRightCalculationStructure(CalculationCondition.Else, Condition.Else, Context, False);
		FieldProperties = Null;
		
	ElsIf Condition.Node = "ValueAllowed"
	      Or Condition.Node = "IsAuthorizedUser"
	      Or Condition.Node = "ObjectReadingAllowed"
	      Or Condition.Node = "ObjectUpdateAllowed"
	      Or Condition.Node = "ListReadingAllowed"
	      Or Condition.Node = "ListUpdateAllowed" Then
		
		CalculationCondition = New Structure("Node, Field", Condition.Node, Undefined);
		CalculationCondition.Insert("ComparisonClarifications", New Map);
		For Each KeyAndValue In Condition.ComparisonClarifications Do
			If KeyAndValue.Key = "Null"
			 Or KeyAndValue.Key = "Undefined"
			 Or KeyAndValue.Key = "EmptyRef"
			 Or KeyAndValue.Key = "Disabled" Then
			 	CalculationCondition.ComparisonClarifications.Insert(KeyAndValue.Key, KeyAndValue.Value);
			Else
				TypeName = StrReplace(KeyAndValue.Key, ".", "Ref.");
				CalculationCondition.ComparisonClarifications.Insert(Type(TypeName), KeyAndValue.Value);
			EndIf;
		EndDo;
		AddCalculationStructureVersionProperty(Context, "ComparisonClarifications", Condition.ComparisonClarifications);
		FillRightCalculationStructure(CalculationCondition.Field, Condition.Field, Context, False);
		
		If CalculationCondition.Field = Null Then
			CalculationCondition = New Structure("Node, Value", "Constant", True);
		EndIf;
		FieldProperties = Null;
		
	ElsIf Condition.Node = "Constant" Then
		CalculationCondition = New Structure("Node, Value", Condition.Node, Condition.Value);
		AddCalculationStructureVersionProperty(Context, "Value", Condition.Value);
		FieldProperties = Null;
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'При заполнении структуры расчета права %1 на ключи доступа
			           |списка ""%2""
			           |узел не поддерживается ""%3"".'; 
			           |en = 'When filling the structure of calculation of right %1 to access keys
			           |of the ""%2"" list,
			           |the ""%3"" node is not supported.'; 
			           |pl = 'Po wypełnieniu struktury obliczenia prawa %1 do kluczy dostępu
			           |do listy ""%2""
			           |węzeł nie jest obsługiwany ""%3"".';
			           |es_ES = 'Al rellenar la estructura de calcular el derecho %1en claves de acceso
			           |de la lista ""%2""
			           |el nodo no se admite ""%3"".';
			           |es_CO = 'Al rellenar la estructura de calcular el derecho %1en claves de acceso
			           |de la lista ""%2""
			           |el nodo no se admite ""%3"".';
			           |tr = '''''%2'''' listesinin erişim anahtar 
			           |hakları %1 hesaplama yapısı doldurulurken 
			           | ünite ''''%3'''' desteklenmiyor.';
			           |it = 'Durante la compilazione della struttura del calcolo del diritto %1 alle chiavi di accesso
			           |dell''elenco ""%2"",
			           |non è supportato il nodo ""%3"".';
			           |de = 'Beim Ausfüllen der Struktur zur Berechnung der Zugriffsrechte %1 auf die Zugriffsschlüssel
			           |in der Liste ""%2""
			           |wird der Knoten nicht von ""%3"" unterstützt.'"),
			Context.RightName,
			Context.List,
			Condition.Node);
		Raise ErrorText;
	EndIf;
	
	If FieldProperties = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'При заполнении структуры расчета права %1 на ключи доступа
			           |списка ""%2""
			           |свойства поля не определены для узла ""%3"".'; 
			           |en = 'When filling the structure of calculation of right %1 to access keys
			           |of the ""%2"" list,
			           |field properties are not determined for the ""%3"" node.'; 
			           |pl = 'Po wypełnieniu struktury obliczenia prawa %1 do kluczy dostępu
			           |do listy ""%2""
			           |właściwości pola nie są określone dla węzła ""%3"".';
			           |es_ES = 'Al rellenar la estructura de calcular el derecho %1en claves de acceso
			           |de la lista ""%2""
			           |la propiedad del campo no se han determinado para el nodo ""%3"".';
			           |es_CO = 'Al rellenar la estructura de calcular el derecho %1en claves de acceso
			           |de la lista ""%2""
			           |la propiedad del campo no se han determinado para el nodo ""%3"".';
			           |tr = '""%2"" listesinin erişim anahtar 
			           | hakları %1hesaplama yapısı 
			           |doldurulurken ""%3"" ünite için alan özellikleri belirlenmemiştir.';
			           |it = 'Durante la compilazione della struttura di calcolo del diritto %1 alle chiavi di accesso
			           |dell''elenco ""%2"",
			           |le proprietà di campo non sono determinate per il nodo ""%3"".';
			           |de = 'Beim Ausfüllen der Struktur zur Berechnung der Rechte %1 auf die Zugriffsschlüssel
			           |in der Liste ""%2""
			           |sind die Feldeigenschaften für den Knoten ""%3"" nicht definiert.'"),
			Context.RightName,
			Context.List,
			Condition.Node);
		Raise ErrorText;
	EndIf;
	
	If FieldProperties <> Null Then
		CalculationConditionField(CalculationCondition, FieldProperties, Context);
	EndIf;
	
	If ConditionRoot Then
		CalculationCondition.Insert("RequiredKeyTabularSectionsAttributes",
			Context.RequiredKeyTabularSectionsAttributes);
		
		AddVersionItem(Context, "RightCalculationStructure" + Context.RightName,
			Context.VersionPropertiesRightCalculationStructure);
		
		Context.Delete("VersionPropertiesRightCalculationStructure");
	EndIf;
	
EndProcedure

// For the FillRightCalculationStructure procedure.
Procedure CalculationConditionField(CalculationCondition, FieldProperties, Context)
	
	If Context.FieldsProperties.Find(FieldProperties) = Undefined Then
		CalculationCondition = Null; // Field is deleted due to not used access value types.
	Else
		CalculationCondition = New Structure("Node", "Field");
		CalculationCondition.Insert("Table",  FieldProperties.AccessKeyFieldsGroupName);
		CalculationCondition.Insert("Attribute", FieldProperties.AccessKeyFieldsGroupAttributeName);
		If StrStartsWith(CalculationCondition.Table, "TabularSection") Then
			Attributes = Context.RequiredKeyTabularSectionsAttributes.Get(CalculationCondition.Table);
			If Attributes = Undefined Then
				Attributes = New Array;
				Context.RequiredKeyTabularSectionsAttributes.Insert(CalculationCondition.Table, Attributes);
			EndIf;
			If Attributes.Find(CalculationCondition.Attribute) = Undefined Then
				Attributes.Add(CalculationCondition.Attribute);
			EndIf;
		EndIf;
		AddCalculationStructureVersionProperty(Context, "Table",  CalculationCondition.Table);
		AddCalculationStructureVersionProperty(Context, "Attribute", CalculationCondition.Attribute);
		If FieldProperties.Property("CheckHasNull") Then
			CalculationCondition.Insert("CheckHasNull");
			AddCalculationStructureVersionProperty(Context, "CheckHasNull", True);
		EndIf;
	EndIf;
	
EndProcedure

// For the FillRightCalculationStructure and CalculationConditionField procedures.
Procedure AddCalculationStructureVersionProperty(Context, Name, Value);
	
	If TypeOf(Value) = Type("Map") Then
		ValueList = New ValueList;
		For Each KeyAndValue In Value Do
			ValueList.Add(KeyAndValue.Value, KeyAndValue.Key);
		EndDo;
		ValueList.SortByPresentation();
		For Each ListItem In ValueList Do
			Context.VersionPropertiesRightCalculationStructure.Add(ListItem.Presentation);
			Context.VersionPropertiesRightCalculationStructure.Add(ListItem.Value);
		EndDo;
	Else
		Context.VersionPropertiesRightCalculationStructure.Add(Name);
		Context.VersionPropertiesRightCalculationStructure.Add(Value);
	EndIf;
	
EndProcedure

// For the FillFieldsAndAdditionalTablesGroups procedure.
Function Power16(Power)
	
	Power16 = 1;
	
	For Counter = 1 To Power Do
		Power16 = Power16 * 16;
	EndDo;
	
	Return Power16;
	
EndFunction

// For the FillFieldsAndAdditionalTablesGroups function.
Function AdditionalTablesGroups(Context)
	
	AdditionalTables = Context.RestrictionStructure.AdditionalTables;
	GroupsNumbersByAliases = New Map;
	
	BasicFields = Context.BasicFields;
	BasicFields.Insert("ByAdditionalTables", New Map);
	
	Context.Insert("AdditionalTablesConnectionConditionsFields", New Array);
	
	LastGroup = 0;
	For Each AdditionalTable In AdditionalTables Do
		AdditionalTable.Insert("RequiredTablesAliases", New Array);
		AdditionalTable.Insert("ConnectionTestField", "");
		
		ConnectionConditionText = ConnectionConditionText(AdditionalTable, Context);
		AdditionalTable.Insert("ConnectionConditionText", ?(Left(ConnectionConditionText, 1) = "(",
			ConnectionConditionText, "(" + ConnectionConditionText + ")"));
		
		If Not ValueIsFilled(AdditionalTable.ConnectionTestField) Then
			AccessKeyFields = Context.RestrictionStructure.InternalData.AccessKeyFields;
			For Each FieldDetails In AccessKeyFields Do
				If FieldDetails.Field.Alias = AdditionalTable.Alias Then
					AdditionalTable.ConnectionTestField =
						AdditionalTable.Alias + "." + FieldDetails.Field.Name;
				EndIf;
			EndDo;
		EndIf;
		
		CurrentGroup = GroupsNumbersByAliases.Get(AdditionalTable.Alias);
		If CurrentGroup = Undefined Then
			LastGroup = LastGroup + 1;
			CurrentGroup = LastGroup;
			GroupsNumbersByAliases.Insert(AdditionalTable.Alias, CurrentGroup);
		EndIf;
		
		For Each Alias In AdditionalTable.RequiredTablesAliases Do
			RequiredTableGroup = GroupsNumbersByAliases.Get(Alias);
			If RequiredTableGroup = Undefined Then
				GroupsNumbersByAliases.Insert(Alias, CurrentGroup);
				Continue;
			EndIf;
			If RequiredTableGroup = CurrentGroup Then
				Continue;
			EndIf;
			GroupToReplaceAliases = New Array;
			For Each KeyAndValue In GroupsNumbersByAliases Do
				If KeyAndValue.Value <> RequiredTableGroup Then
					Continue;
				EndIf;
				GroupToReplaceAliases.Add(KeyAndValue.Key);
			EndDo;
			For Each Alias In GroupToReplaceAliases Do
				GroupsNumbersByAliases.Insert(Alias, CurrentGroup);
			EndDo;
		EndDo;
	EndDo;
	
	TablesWithFiledsAliases = New Map;
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.TableAlias = "CurrentList" Then
			Continue;
		EndIf;
		TablesWithFiledsAliases.Insert(FieldProperties.TableAlias, True);
	EndDo;
	
	GroupsUse = New Map;
	For Folder = 1 To LastGroup Do
		For Each KeyAndValue In GroupsNumbersByAliases Do
			If KeyAndValue.Value <> Folder Then
				Continue;
			EndIf;
			If GroupsUse.Get(Folder) = Undefined Then
				GroupsUse.Insert(Folder, False);
			EndIf;
			If TablesWithFiledsAliases.Get(KeyAndValue.Key) <> Undefined Then
				GroupsUse.Insert(Folder, True);
			EndIf;
		EndDo;
	EndDo;
	
	NewGroup = 1;
	NewGroups = New Map;
	For Each AdditionalTable In AdditionalTables Do
		OldGroup = GroupsNumbersByAliases.Get(AdditionalTable.Alias);
		If Not GroupsUse.Get(OldGroup) Then
			Continue;
		EndIf;
		If NewGroups.Get(OldGroup) <> Undefined Then
			Continue;
		EndIf;
		NewGroups.Insert(OldGroup, NewGroup);
		NewGroup = NewGroup + 1;
	EndDo;
	
	Groups = New Structure;
	Groups.Insert("NumbersByAliases",     New Map);
	Groups.Insert("TablesByGroups",        New Map);
	Groups.Insert("TablesWithFiledsAliases", TablesWithFiledsAliases);
	
	For Each AdditionalTable In AdditionalTables Do
		OldGroup = GroupsNumbersByAliases.Get(AdditionalTable.Alias);
		If Not GroupsUse.Get(OldGroup) Then
			Continue;
		EndIf;
		SetBasicFieldUse(BasicFields, , AdditionalTable);
		Folder = NewGroups.Get(OldGroup);
		Groups.NumbersByAliases.Insert(AdditionalTable.Alias, Folder);
		TablesGroup = Groups.TablesByGroups.Get(Folder);
		If TablesGroup = Undefined Then
			TablesGroup = New Array;
			Groups.TablesByGroups.Insert(Folder, TablesGroup);
		EndIf;
		TablesGroup.Add(AdditionalTable);
	EndDo;
	
	For Each FieldNode In Context.AdditionalTablesConnectionConditionsFields Do
		If TablesWithFiledsAliases.Get(FieldNode.Alias) <> Undefined Then
			AddLeadingListsByFieldsValues(Context, FieldNode);
		EndIf;
		If Groups.NumbersByAliases.Get(FieldNode.Alias) <> Undefined Then
			AddVersionProperties(Context, FieldNode, "Alias, Name, TypesString");
		EndIf;
	EndDo;
	
	Return Groups;
	
EndFunction

// For the AdditionalTablesGroups function.
Function ConnectionConditionText(AdditionalTable, Context, Condition = Null)
	
	If Condition = Null Then
		Condition = AdditionalTable.ConnectionCondition;
	EndIf;
	
	// Possible nodes: "Field", ''Value", "Constant", "AND", "=".
	
	If Condition.Node = "Field" Then
		If Condition.Alias = Context.RestrictionStructure.MainTableAlias Then
			AddBasicField(Context, Condition, , AdditionalTable);
			Return FieldNameExpandingBasicFieldsByTypes("CurrentList", Condition);
		EndIf;
		Alias = Condition.Alias;
		If Alias = AdditionalTable.Alias Then
			If AdditionalTable.ConnectionTestField = "" Then
				AdditionalTable.ConnectionTestField = Alias + "." + Condition.Name;
			EndIf;
		ElsIf AdditionalTable.RequiredTablesAliases.Find(Alias) = Undefined Then
			AdditionalTable.RequiredTablesAliases.Add(Alias);
		EndIf;
		Context.AdditionalTablesConnectionConditionsFields.Add(Condition);
		Return Alias + "." + Condition.Name;
	EndIf;
	
	If Condition.Node = "Value"
	 Or Condition.Node = "Constant" Then
		
		Return ValueOrConstantNodeExpression(Condition);
	EndIf;
	
	If Upper( Condition.Node ) = Upper( "AND" ) Then // PATCHED:
		Text = "";
		For Each Argument In Condition.Arguments Do
			Text = Text + ?(Text = "", "", Chars.LF + "AND ");
			Text = Text + ConnectionConditionText(AdditionalTable, Context, Argument);
		EndDo;
		Return Text;
	EndIf;
	
	If Condition.Node = "=" Then
		FirstArgument = ConnectionConditionText(AdditionalTable,
			Context, Condition.FirstArgument);
		
		SecondArgument = ConnectionConditionText(AdditionalTable,
			Context, Condition.SecondArgument);
		
		If StrFind(SecondArgument, "CurrentList.") > 0 Then
			Return "(" + FirstArgument + " = " + SecondArgument + ")";
		Else
			Return "(" + SecondArgument + " = " + FirstArgument + ")";
		EndIf;
	EndIf;
	
	ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("ru = 'Не определена обработка узла ""%1""'; en = '""%1"" node data processor is not determined'; pl = 'Nie zdefiniowane przetwarzanie węzła ""%1""';es_ES = 'El procesamiento del nodo no se ha realizado ""%1""';es_CO = 'El procesamiento del nodo no se ha realizado ""%1""';tr = '""%1"" ünitenin işlemesi belirlenmemiştir';it = '""%1"" nodo elaboratore dati non è determinato';de = 'Die Bearbeitung des Knotens ""%1"" ist nicht definiert'"), Condition.Node);
	
	Raise ErrorText;
	
EndFunction

// For the FieldProperties and ConnectionConditionText functions.
Procedure AddBasicField(Context, FieldNode, FieldProperties = Undefined, AdditionalTable = Undefined)
	
	If Not FieldNode.Property("DefaultOrder") Then
		Return;
	EndIf;
	
	Position = StrFind(FieldNode.Name, ".");
	If Position = 0 Then
		BasicFieldName = FieldNode.Name;
	Else
		BasicFieldName = Left(FieldNode.Name, Position - 1);
	EndIf;
	
	BasicFields = Context.BasicFields;
	
	If FieldProperties <> Undefined Then
		BasicFields.ByFIeldProperties.Insert(FieldProperties, BasicFieldName);
	EndIf;
	
	If AdditionalTable <> Undefined Then
		BasicFieldsNames = BasicFields.ByAdditionalTables.Get(AdditionalTable);
		If BasicFieldsNames = Undefined Then
			BasicFieldsNames = New Array;
			BasicFields.ByAdditionalTables.Insert(AdditionalTable, BasicFieldsNames);
		EndIf;
		BasicFieldsNames.Add(BasicFieldName);
	EndIf;
	
	If BasicFields.List.FindByValue(BasicFieldName) = Undefined Then
		BasicFields.List.Add(BasicFieldName, FieldNode.DefaultOrder);
		BasicFieldTypes = FieldNode.FieldTypes[0];
		BasicFields.TypesByFieldNames.Insert(BasicFieldName, BasicFieldTypes);
		If Not ValueIsFilled(Context.SeparateKeysRegisterName) Then
			RestrictedTypes = New Array;
			If HasSimpleType(BasicFieldTypes) Then
				For Each Type In BasicFieldTypes.Types() Do
					If IsSimpleType(Type) Then
						RestrictedTypes.Add(String(Type));
					EndIf;
				EndDo;
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'В ограничении доступа списка %1
					           |опорное поле %2 содержит простые типы: %3.
					           |
					           |Это недопустимо при использовании общего регистра сведений AccessKeysForRegisters.
					           |Требуется либо исключить простые типы из состава типов опорного поля,
					           |либо создать отдельный регистр ключей доступа для этого списка.'; 
					           |en = 'In the %1 list access restriction
					           |, basic field %2 contains simple types: %3.
					           |
					           |It is not allowed when using common information register AccessKeysForRegisters.
					           |Either exclude simple types from the basic field types
					           |or create a separate register of access keys for this list.'; 
					           |pl = 'W ograniczeniu dostępu do listy %1
					           |referencyjne pole %2 zawiera proste typy: %3.
					           |
					           |To niedopuszczalne przy użyciu wspólnego rejestru informacji AccessKeysForRegisters.
					           |Należy wykluczyć proste typy ze składu typów referencyjnego pola,
					           |albo utworzyć oddzielny rejestr kluczy dostępu do tej listy.';
					           |es_ES = 'En la restricción de acceso de la lista %1
					           |el campo base %2 contiene tipos simples: %3.
					           |
					           |No se admite al usar el registro común de información AccessKeysForRegisters.
					           |Se requiere excluir los tipos simples del contenido del campo base
					           |o crear un registro separado de claves de acceso para esta lista.';
					           |es_CO = 'En la restricción de acceso de la lista %1
					           |el campo base %2 contiene tipos simples: %3.
					           |
					           |No se admite al usar el registro común de información AccessKeysForRegisters.
					           |Se requiere excluir los tipos simples del contenido del campo base
					           |o crear un registro separado de claves de acceso para esta lista.';
					           |tr = 'Liste erişim kısıtlamasında %1
					           | referans alanı %2 basit türleri içerir: %3. 
					           |
					           |
					           | KaydedicilereErişimAnahtarları ortak veri kaydedicisi kullanılırken buna izin verilmez. 
					           | Referans alanın türlerinin arasından basit türler çıkarılmalı ya da bu liste için ayrı anahtar kaydedicisi oluşturulmalıdır.';
					           |it = 'Nella restrizione all''accesso dell''elenco %1
					           |, il campo di base %2 contiene tipi semplici:%3.
					           |
					           |Non è permesso durante l''utilizzo del registro informazioni comune AccessKeysForRegisters.
					           |Nessuno di essi esclude tipi semplici dai tipi di campo di base
					           | o crea un registro separato di chiavi di accesso per questo elenco.';
					           |de = 'In der Listenzugriffsbeschränkung enthält %1
					           |das Referenzfeld %2 einfache Typen: %3.
					           |
					           |Dies ist bei Verwendung des allgemeinen Datenregisters ZugriffSchlüsselZuRegister nicht erlaubt.
					           |Sie müssen entweder einfache Typen von den Referenzfeldtypen ausschließen
					           |oder ein eigenes Register der Zugriffsschlüssel für diese Liste erstellen.'"),
					Context.List,
					BasicFieldName,
					StrConcat(RestrictedTypes, ", "));
				
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			EndIf;
		EndIf;
	EndIf;
	
EndProcedure

// For the DeleteNotUsedAccessKindsFields and AdditionalTablesGroups procedures.
Procedure SetBasicFieldUse(BasicFields, FieldProperties = Undefined, AdditionalTable = Undefined)
	
	If FieldProperties <> Undefined Then
		BasicFieldName = BasicFields.ByFIeldProperties.Get(FieldProperties);
		If BasicFieldName <> Undefined Then
			BasicFields.List.FindByValue(BasicFieldName).Check = True;
		EndIf;
	Else
		BasicFieldsNames = BasicFields.ByAdditionalTables.Get(AdditionalTable);
		If BasicFieldsNames <> Undefined Then
			For Each BasicFieldName In BasicFieldsNames Do
				BasicFields.List.FindByValue(BasicFieldName).Check = True;
			EndDo;
		EndIf;
	EndIf;
	
EndProcedure

// For the FillFieldsAndAdditionalTablesGroups procedure.
Procedure CompleteBasicFieldsPreparation(Context)
	
	BasicFields = Context.BasicFields;
	BasicFields.List.SortByPresentation();
	
	For Each ListItem In BasicFields.List Do
		BasicFields.All.Add(ListItem.Value);
		BasicFields.AllItemsTypes.Add(New ValueStorage(
			BasicFields.TypesByFieldNames.Get(ListItem.Value)));
		
		If ListItem.Check Then
			BasicFields.Used.Add(ListItem.Value);
			BasicFields.UsedItemsTypes.Add(New ValueStorage(
				BasicFields.TypesByFieldNames.Get(ListItem.Value)));
		EndIf;
	EndDo;
	
	BasicFields.Delete("List");
	BasicFields.Delete("TypesByFieldNames");
	BasicFields.Delete("ByFIeldProperties");
	BasicFields.Delete("ByAdditionalTables");
	
EndProcedure

// For the ConnectionConditionText and FieldProperties functions.
Function FieldNameExpandingBasicFieldsByTypes(Alias, FieldNode)
	
	If Not FieldNode.Property("DefaultOrder")
	 Or Not FieldNode.Property("NextFieldTables") Then
		
		Return Alias + "." + FieldNode.Name;
	EndIf;
	
	Position = StrFind(FieldNode.Name, ".");
	BasicField = Alias + "." + Left(FieldNode.Name, Position - 1);
	OtherFields = Mid(FieldNode.Name, Position + 1);
	
	FieldName = "";
	For Each TypeName In FieldNode.NextFieldTables[0] Do
		CurrentFieldName = "CAST(" + BasicField + " AS " + TypeName + ")." + OtherFields;
		If ValueIsFilled(FieldName) Then
			FieldName =
				"ISNULL(" + CurrentFieldName + ",
				|	" + TextWithIndent(FieldName, "	") + ")";
		Else
			FieldName = CurrentFieldName;
		EndIf;
	EndDo;
	
	Return FieldName;
	
EndFunction

// For the AccessRestrictionParameters function.
Procedure FillFieldProperties(Context)
	
	// 1. For argument fields of =, <>, In, IsNull comparison nodes, the comparison result is calculated 
	// and saved to the key.
	
	// 2. These values are saved for values of the Boolean type:
	// - Enumerations.AdditionalAccessValues.ValueTrue,
	// - Enumerations.AdditionalAccessValues.ValueFalse.
	
	// 3. For the values of types Number, Date, and String, the result of the comparison with the True 
	//    value is saved as indicated in clause 2.
	
	Context.Insert("AccessKeyFieldsProperties", New Map);
	
	Context.BasicFields.Insert("TypesByFieldNames", New Map);
	Context.BasicFields.Insert("ByFIeldProperties",  New Map);
	
	AddedFields = New Map;
	FieldsNamesForQuery = New Array;
	AccessKeyFields = Context.RestrictionStructure.InternalData.AccessKeyFields;
	For Each FieldDetails In AccessKeyFields Do
		FieldProperties = FieldProperties(FieldDetails.Field, Context);
		FieldProperties.Insert("Read", FieldDetails.Read);
		ClarifyComparisonFieldProperties(FieldProperties, FieldDetails, Context);
		FieldsSet = WhenConditionFieldsSet(FieldProperties, FieldDetails, Context);
		For Each FieldProperties In FieldsSet Do
			AddFieldTypesProperties(FieldProperties, FieldDetails, Context);
			SimilarFields = AddedFields.Get(Upper(FieldProperties.FieldNameForQuery));
			If SimilarFields = Undefined Then
				SimilarFields = New Array;
				AddedFields.Insert(Upper(FieldProperties.FieldNameForQuery), SimilarFields);
				FieldsNamesForQuery.Add(FieldProperties.FieldNameForQuery);
			EndIf;
			SimilarFields.Add(FieldProperties);
		EndDo;
	EndDo;
	
	FieldsProperties = New Array;
	CombinedFields = New Map;
	For Each FieldNameForQuery In FieldsNamesForQuery Do
		SimilarFields = AddedFields.Get(Upper(FieldNameForQuery));
		ProcessedSimilarFields = New Array;
		For Each FieldProperties In SimilarFields Do
			CombinedField = ProcessedCombinedField(ProcessedSimilarFields, FieldProperties);
			If CombinedField <> Undefined Then
				CombinedFields.Insert(FieldProperties, CombinedField);
				Continue;
			EndIf;
			ProcessedSimilarFields.Add(FieldProperties);
		EndDo;
		For Each FieldProperties In ProcessedSimilarFields Do
			FieldsProperties.Add(FieldProperties);
		EndDo;
	EndDo;
	
	For Each Details In Context.AccessKeyFieldsProperties Do
		CombinedField = CombinedFields.Get(Details.Value);
		If CombinedField <> Undefined Then
			Context.AccessKeyFieldsProperties[Details.Key] = CombinedField;
		EndIf;
	EndDo;
	
	For Each FieldProperties In FieldsProperties Do
		FieldProperties.Insert("ConfigurationTypeSavingTypes", New Array);
		FieldProperties.Insert("ExtensionTypeSavingTypes",   New Array);
		FieldProperties.Insert("SimpleTypeSavingTypes",      New Array);
		
		For Each Type In FieldProperties.TypeSavingTypes Do
			MetadataObject = Undefined;
			TypeName = TypeNameInQueryLanguage(Type, MetadataObject);
			
			If StrFind(TypeName, ".") = 0 Then
				FieldProperties.SimpleTypeSavingTypes.Add(Type);
				
			ElsIf MetadataObject.ConfigurationExtension() = Undefined Then
				FieldProperties.ConfigurationTypeSavingTypes.Add(Type);
			Else
				FieldProperties.ExtensionTypeSavingTypes.Add(Type);
			EndIf;
		EndDo;
	EndDo;
	
	Context.Insert("FieldsProperties", FieldsProperties);
	
EndProcedure

// For the FillFieldsProperties procedure.
Function ProcessedCombinedField(ProcessedSimilarFields, FieldProperties)
	
	For Each Field In ProcessedSimilarFields Do
		Compatible = True;
		If Field.TableAlias = "CurrentList"
		   AND Field.MultipleValuesGroups <> FieldProperties.MultipleValuesGroups Then
			Continue;
		EndIf;
		// Cannot determine a value type by a blank reference to an access key or a Null value, that is why 
		// saving the access key is incompatible with the other options.
		For Each Type In FieldProperties.AccessKeySavingTypes Do
			If Field.ValueSavingTypes.Find(Type)        <> Undefined
			 Or Field.ValueGroupSavingTypes.Find(Type)   <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.ProhibitedTypeSavingTypes.Find(Type) <> Undefined
			 Or Field.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible = False;
				Break;
			EndIf;
		EndDo;
		For Each Type In Field.AccessKeySavingTypes Do
			If FieldProperties.ValueSavingTypes.Find(Type)        <> Undefined
			 Or FieldProperties.ValueGroupSavingTypes.Find(Type)   <> Undefined
			 Or FieldProperties.TypeSavingTypes.Find(Type)           <> Undefined
			 Or FieldProperties.ProhibitedTypeSavingTypes.Find(Type) <> Undefined
			 Or FieldProperties.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible = False;
				Break;
			EndIf;
		EndDo;
		If Not Compatible Then
			Continue;
		EndIf;
		// Cannot determine a value type by a Null value, that is why saving a group of values is 
		// incompatible with the other options.
		For Each Type In FieldProperties.ValueGroupSavingTypes Do
			If Field.ValueSavingTypes.Find(Type)        <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.ProhibitedTypeSavingTypes.Find(Type) <> Undefined
			 Or Field.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible = False;
				Break;
			EndIf;
		EndDo;
		For Each Type In Field.ValueGroupSavingTypes Do
			If FieldProperties.ValueSavingTypes.Find(Type)        <> Undefined
			 Or FieldProperties.TypeSavingTypes.Find(Type)           <> Undefined
			 Or FieldProperties.ProhibitedTypeSavingTypes.Find(Type) <> Undefined
			 Or FieldProperties.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible = False;
				Break;
			EndIf;
		EndDo;
		// Instead of simple types, the AllowedType or RestrictedType values are saved, that is why saving 
		// of a restricted simple type is incompatible with other options.
		For Each Type In FieldProperties.ProhibitedTypeSavingTypes Do
			If Not IsSimpleType(Type) Then
				Continue;
			EndIf;
			If Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible = False;
				Break;
			EndIf;
		EndDo;
		For Each Type In Field.ProhibitedTypeSavingTypes Do
			If Not IsSimpleType(Type) Then
				Continue;
			EndIf;
			If FieldProperties.TypeSavingTypes.Find(Type)           <> Undefined
			 Or FieldProperties.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible = False;
				Break;
			EndIf;
		EndDo;
		If Not Compatible Then
			Continue;
		EndIf;
		// Merging clarifications of special values.
		Field.HasAdjustmentNull =
			Field.HasAdjustmentNull Or FieldProperties.HasAdjustmentNull;
		Field.HasAdjustmentUndefined =
			Field.HasAdjustmentUndefined Or FieldProperties.HasAdjustmentUndefined;
		Field.HasHeadListType =
			Field.HasHeadListType Or FieldProperties.HasHeadListType;
		Field.HasRightsSettingsOwnerType =
			Field.HasRightsSettingsOwnerType Or FieldProperties.HasRightsSettingsOwnerType;
		Field.HasAuthorizedUserCheck =
			Field.HasAuthorizedUserCheck Or FieldProperties.HasAuthorizedUserCheck;
		// Merging types of saving of a blank reference.
		For Each Type In FieldProperties.EmptyRefSavingTypes Do
			If Field.EmptyRefSavingTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Field.EmptyRefSavingTypes.Add(Type);
		EndDo;
		// Merging types of saving of the AllowedType value.
		For Each Type In FieldProperties.AllowedTypeSavingTypes Do
			If Field.ValueSavingTypes.Find(Type)        <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Index = Field.ProhibitedTypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.ProhibitedTypeSavingTypes.Delete(Index);
				Field.TypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			Field.AllowedTypeSavingTypes.Add(Type);
		EndDo;
		// Merging types of saving of the RestrictedType value.
		For Each Type In FieldProperties.ProhibitedTypeSavingTypes Do
			If Field.ValueSavingTypes.Find(Type)        <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.ProhibitedTypeSavingTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Index = Field.AllowedTypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.AllowedTypeSavingTypes.Delete(Index);
				Field.TypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			Field.ProhibitedTypeSavingTypes.Add(Type);
		EndDo;
		// Merging types of saving of a value type.
		For Each Type In FieldProperties.TypeSavingTypes Do
			If Field.ValueSavingTypes.Find(Type) <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)    <> Undefined Then
				Continue;
			EndIf;
			Index = Field.ProhibitedTypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.ProhibitedTypeSavingTypes.Delete(Index);
			EndIf;
			Index = Field.AllowedTypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.AllowedTypeSavingTypes.Delete(Index);
			EndIf;
			Field.TypeSavingTypes.Add(Type);
		EndDo;
		// Merging types of saving a value.
		For Each Type In FieldProperties.ValueSavingTypes Do
			If Field.ValueSavingTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Index = Field.TypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.TypeSavingTypes.Delete(Index);
			EndIf;
			Index = Field.ProhibitedTypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.ProhibitedTypeSavingTypes.Delete(Index);
			EndIf;
			Index = Field.AllowedTypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.AllowedTypeSavingTypes.Delete(Index);
			EndIf;
			Field.ValueSavingTypes.Add(Type);
		EndDo;
		// Merging not used types of access values.
		For Each Type In FieldProperties.UnusedAccessValueTypes Do
			If Field.UnusedAccessValueTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Field.UnusedAccessValueTypes.Add(Type);
		EndDo;
		// Merging used access value types.
		For Each Type In FieldProperties.UsedAccessValuesTypes Do
			If Field.UsedAccessValuesTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Field.UsedAccessValuesTypes.Add(Type);
		EndDo;
		Field.Read = Field.Read Or FieldProperties.Read;
		If Field.TypesString <> FieldProperties.TypesString Then
			Field.TypesString = Field.TypesString + Chars.LF + FieldProperties.TypesString;
		EndIf;
		Return Field;
	EndDo;
	
	Return Undefined;
	
EndFunction

// For the FillFieldsProperties procedure.
Procedure ClarifyComparisonFieldProperties(Properties, FieldDetails, Context)
	
	Context.AccessKeyFieldsProperties.Insert(FieldDetails.Field, Properties);
	
	Parent = FieldDetails.Parents[0];
	
	Nodes = ",ValueType,=,<>,IN,IsNull,"; // A comparison result is saved to the key.
	If StrFind(Nodes, "," + Parent.Node + ",") = 0 Then
		Return;
	EndIf;
	
	If Parent.Node = "ValueType" Then
		ComparisonNodeParent = FieldDetails.Parents[1];
		
		If ComparisonNodeParent.SecondArgument = Parent Then
			NodeType         = ComparisonNodeParent.FirstArgument;
			NodeValueType = ComparisonNodeParent.SecondArgument;
		Else
			NodeType         = ComparisonNodeParent.SecondArgument;
			NodeValueType = ComparisonNodeParent.FirstArgument;
		EndIf;
		Context.AccessKeyFieldsProperties.Insert(NodeValueType, Properties);
		
		ValueTypeExpression = "VALUETYPE(" + Properties.FieldNameForQuery + ")";
		TypeExpression = "TYPE(" + NodeType.Name + ")";
		AsOneString = StrLen(ValueTypeExpression) + StrLen(TypeExpression) < 60;
		
		Properties.FieldNameForQuery = ValueTypeExpression + ?(AsOneString, " ", "
		|			") + ComparisonNodeParent.Node + " " + TypeExpression;
		
	ElsIf Parent.Node = "="
	      Or Parent.Node = "<>" Then
		
		ValueOrConstantNode = ?(Parent.SecondArgument = FieldDetails.Field,
			Parent.FirstArgument, Parent.SecondArgument);
		
		NodeExpression = ValueOrConstantNodeExpression(ValueOrConstantNode);
		AsOneString = StrLen(Properties.FieldNameForQuery) + StrLen(NodeExpression) < 60;
		
		Properties.FieldNameForQuery = Properties.FieldNameForQuery + ?(AsOneString, " ", "
		|			") + Parent.Node + " " + NodeExpression;
		
	ElsIf Upper( Parent.Node ) = Upper( "IN" ) Then // PATCHED:
		
		ValueList = "";
		For Each ValueOrConstantNode In Parent.Values Do
			ValueList = ValueList + ?(ValueList = "", "", ",");
			LastRow = StrGetLine(ValueList, StrLineCount(ValueList));
			If StrLen(LastRow) > 40 Then
				ValueList = ValueList + "
				|			";
			Else
				ValueList = ValueList + " ";
			EndIf;
			ValueList = ValueList
				+ ValueOrConstantNodeExpression(ValueOrConstantNode);
		EndDo;
		Properties.FieldNameForQuery = Properties.FieldNameForQuery + "
		|	IN (" + ValueList + ")";
	
	Else // Parent.Node = "IsNull".
		Properties.FieldNameForQuery = Properties.FieldNameForQuery + " IS NULL";
		Properties.Insert("CheckHasNull");
	EndIf;
	
	Properties.EndFieldType = New TypeDescription("Boolean");
	
EndProcedure

// For the FillFieldsProperties procedure.
Function WhenConditionFieldsSet(InitialFieldProperties, FieldDetails, Context)
	
	Parent = FieldDetails.Parents[0];
	FieldsSet = New Array;
	
	If Parent.Node <> "Case"
	 Or Parent.Case = Undefined Then
		
		FieldsSet.Add(InitialFieldProperties);
		Return FieldsSet;
	EndIf;
	
	// For "CASE <Field> WHEN <Value>" comparison result "<Field> = <Value>" is saved to key.
	// 
	
	For Each WhenDetails In Parent.When Do
		FixedProperties = New FixedStructure(InitialFieldProperties);
		Properties = New Structure(FixedProperties);
		
		NodeExpression = ValueOrConstantNodeExpression(WhenDetails.Condition);
		AsOneString = StrLen(Properties.FieldNameForQuery) + StrLen(NodeExpression) < 60;
		
		Properties.FieldNameForQuery = Properties.FieldNameForQuery + ?(AsOneString, " = ", "
		|			= ") + NodeExpression;
		
		Properties.EndFieldType = New TypeDescription("Boolean");
		FieldsSet.Add(Properties);
		
		Context.AccessKeyFieldsProperties.Insert(WhenDetails.Condition, Properties);
	EndDo;
	
	Return FieldsSet;
	
EndFunction

// For FieldProperties, ClarifyComparisonFieldProperties, and WhenConditionFieldsSet functions.
Function NoNullValue(FieldProperties, OneAdditionalTableWithFieldsInGroup)
	
	Return StrOccurrenceCount(FieldProperties.FieldNameForQuery, ".") = 1
	      AND Not FieldProperties.Property("FieldContainsNull")
	      AND (    StrStartsWith(FieldProperties.FieldNameForQuery, "CurrentList")
	         Or OneAdditionalTableWithFieldsInGroup);
	
EndFunction

// For the FillFieldsProperties procedure.
Procedure AddFieldTypesProperties(Properties, FieldDetails, Context)
	
	Properties.Insert("AccessKeySavingTypes",               New Array);
	Properties.Insert("ValueGroupSavingTypes",               New Array);
	Properties.Insert("ValueSavingTypes",                    New Array);
	Properties.Insert("EmptyRefSavingTypes",                New Array);
	Properties.Insert("TypeSavingTypes",                       New Array);
	Properties.Insert("ProhibitedTypeSavingTypes",             New Array);
	Properties.Insert("AllowedTypeSavingTypes",             New Array);
	Properties.Insert("UnusedAccessValueTypes",         New Array);
	Properties.Insert("UsedAccessValuesTypes",           New Array);
	Properties.Insert("MultipleValuesGroups",                    False);
	Properties.Insert("IsAccessValueListWithValueGroups", False);
	Properties.Insert("HasAdjustmentNull",                         False);
	Properties.Insert("HasAdjustmentUndefined",                 False);
	Properties.Insert("HasHeadListType",                     False);
	Properties.Insert("HasRightsSettingsOwnerType",              False);
	Properties.Insert("HasAuthorizedUserCheck",   False);
	
	Parent = FieldDetails.Parents[0];
	
	If Parent.Node = "ObjectReadingAllowed"
	 Or Parent.Node = "ObjectUpdateAllowed"
	 Or Parent.Node = "ListReadingAllowed"
	 Or Parent.Node = "ListUpdateAllowed"
	 Or Parent.Node = "ValueAllowed"
	 Or Parent.Node = "IsAuthorizedUser" Then
		
		HasBlankRefClarification          = TypeClarified(Parent, "EmptyRef");
		Properties.HasAdjustmentNull         = TypeClarified(Parent, "Null") Or Properties.Property("HasExpress");
		Properties.HasAdjustmentUndefined = TypeClarified(Parent, "Undefined");
	EndIf;
	
	If Parent.Node = "ObjectReadingAllowed"
	 Or Parent.Node = "ObjectUpdateAllowed"
	 Or Parent.Node = "ListReadingAllowed"
	 Or Parent.Node = "ListUpdateAllowed" Then
		
		For Each Type In Properties.EndFieldType.Types() Do
			TypeName = TypeNameInQueryLanguage(Type);
			
			Clarification = TypeClarification(Parent, TypeName);
			If Clarification = "True" Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			ElsIf Clarification = "False" Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Not CheckingType(Parent, TypeName) Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If IsSimpleType(Type) Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Type = Type("CatalogRef.MetadataObjectIDs")
			 Or Type = Type("CatalogRef.ExtensionObjectIDs") Then
				Properties.ValueSavingTypes.Add(Type);
				Properties.HasHeadListType = True;
				Continue;
			EndIf;
			
			If Parent.Node = "ListReadingAllowed"
			 Or Parent.Node = "ListUpdateAllowed" Then
				
				Properties.TypeSavingTypes.Add(Type);
				Properties.HasHeadListType = True;
				Continue;
			EndIf;
			
			If Context.ListsWithKeysRecordForDependentListsWithoutKeys <> Undefined
			   AND Not Context.UsesRestrictionByOwner
			   AND (    Context.ListsWithRestriction.Get(TypeName) = Undefined
			      Or Context.ListsWithDisabledRestriction.Get(TypeName) <> Undefined) Then
				
				Properties.TypeSavingTypes.Add(Type);
				Properties.HasHeadListType = True;
				Continue;
			EndIf;
			
			If HasBlankRefClarification Then
				Properties.EmptyRefSavingTypes.Add(Type);
			EndIf;
			
			Value = Context.RightsSettingsOwnersTypes.Get(Type);
			If Value <> Undefined
			   AND Upper(Context.List) = Upper(Value[0].RightsOwner) Then
				
				Properties.ValueSavingTypes.Add(Type);
				Properties.HasRightsSettingsOwnerType = True;
				Continue;
			EndIf;
			
			Properties.AccessKeySavingTypes.Add(Type);
			Context.LeadingListsByAccessKeys.Insert(TypeName, True);
		EndDo;
		
		Return;
	EndIf;
	
	If Parent.Node = "ValueAllowed" Then
		AccessKindsProperties = Context.AccessKindsProperties;
		
		For Each Type In Properties.EndFieldType.Types() Do
			TypeName = TypeNameInQueryLanguage(Type);
			
			Clarification = TypeClarification(Parent, TypeName);
			If Clarification = "True" Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			ElsIf Clarification = "False" Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Not CheckingType(Parent, TypeName) Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			AccessKindProperties = AccessKindsProperties.ByGroupsAndValuesTypes.Get(Type);
			If AccessKindProperties = Undefined Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Context.ValuesTypesToUse.Get(AccessKindProperties.ValuesType) = Undefined Then
				Properties.UnusedAccessValueTypes.Add(AccessKindProperties.ValuesType);
				
				If TypeClarification(Parent, "Disabled") = "False" Then
					Properties.ProhibitedTypeSavingTypes.Add(Type);
				Else
					Properties.AllowedTypeSavingTypes.Add(Type);
				EndIf;
				Continue;
			EndIf;
			
			Properties.UsedAccessValuesTypes.Add(AccessKindProperties.ValuesType);
			
			If AccessKindsProperties.ByValuesTypes.Get(Type) = Undefined Then
				// Group type of access values.
				If Context.List = Metadata.FindByType(Type).FullName() Then
					Properties.ValueSavingTypes.Add(Type);
				Else
					Properties.AllowedTypeSavingTypes.Add(Type);
				EndIf;
				Continue;
			EndIf;
			
			If HasBlankRefClarification Then
				Properties.EmptyRefSavingTypes.Add(Type);
			EndIf;
			
			If AccessKindsProperties.AccessValuesTypesWithGroups.Get(Type) = Undefined
			 Or Context.UserTypes.Find(Type) <> Undefined Then
				
				Properties.ValueSavingTypes.Add(Type);
				Continue;
			EndIf;
			Properties.ValueGroupSavingTypes.Add(Type);
			
			If Context.List = TypeName
			   AND Upper(Properties.FieldNameForQuery) = Upper("CurrentList.Ref") Then
				
				Properties.IsAccessValueListWithValueGroups = True;
			Else
				Context.LeadingListsByValuesWithGroups.Insert(TypeName, True);
			EndIf;
			
			If AccessKindsProperties.WithOneGroupForAccessValue.Find(Type) = Undefined Then
				Continue;
			EndIf;
			Properties.MultipleValuesGroups = True;
		EndDo;
		
		Return;
	EndIf;
	
	If Parent.Node = "IsAuthorizedUser" Then
		Properties.HasAuthorizedUserCheck = True;
		
		For Each Type In Properties.EndFieldType.Types() Do
			TypeName = TypeNameInQueryLanguage(Type);
			
			Clarification = TypeClarification(Parent, TypeName);
			If Clarification = "True" Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			ElsIf Clarification = "False" Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Not CheckingType(Parent, TypeName) Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Type <> Type("CatalogRef.Users")
			   AND Type <> Type("CatalogRef.ExternalUsers") Then
				
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If HasBlankRefClarification Then
				Properties.EmptyRefSavingTypes.Add(Type);
			EndIf;
			
			Properties.ValueSavingTypes.Add(Type);
		EndDo;
		
		Return;
	EndIf;
	
	// Only Field nodes are available to receive the Boolean value.
	Properties.ValueSavingTypes.Add(Type("Boolean"));
	
	If Properties.EndFieldType.Types().Count() = 1
	   AND Properties.EndFieldType.ContainsType(Type("Boolean")) Then
		Return;
	EndIf;
	Properties.EndFieldType = New TypeDescription("Boolean");
	Properties.FieldNameForQuery = Properties.FieldNameForQuery + " = TRUE";
	
EndProcedure

// For the FieldsProperties and AddFieldTypesProperties functions.
Function TypeNameInQueryLanguage(Type, MetadataObject = Undefined)
	
	MetadataObject = Metadata.FindByType(Type);
	If MetadataObject <> Undefined Then
		Return MetadataObject.FullName();
	EndIf;
	
	Return String(Type);
	
EndFunction

// For the FillFieldsProperties procedure.
Function FieldProperties(FieldNode, Context, FieldProperties = Undefined)
	
	Properties = New Structure;
	IsRootNode = FieldProperties = Undefined;
	
	If IsRootNode Then
		FieldProperties = Properties;
		// The IsNull() function can have only a field inside, it cannot have the Express() function.
		If ValueIsFilled(FieldNode.Cast) Then
			Types = New Array;
			Types.Add(RefTypeByFullMetadataName(FieldNode.Cast));
			EndFieldType = New TypeDescription(Types);
		Else
			EndFieldType = FieldNode.FieldTypes[FieldNode.FieldTypes.Count() - 1];
			If ValueIsFilled(FieldNode.IsNull) Then
				Types = New Array;
				Types.Add(ValueOrConstantNodeValueType(FieldNode.IsNull));
				EndFieldType = New TypeDescription(EndFieldType, Types);
			EndIf;
		EndIf;
	EndIf;
	
	If FieldNode.Attachment <> Undefined Then
		AttachmentProperties = FieldProperties(FieldNode.Attachment, Context, FieldProperties);
		TableAlias  = AttachmentProperties.TableAlias;
		FieldNameForQuery = AttachmentProperties.FieldNameForQuery + "." + FieldNode.Name;
		TypesString       = AttachmentProperties.TypesString + Chars.LF + FieldNode.TypesString;
	Else
		If TypeOf(FieldNode.FieldTypes[0]) = Type("TypeDescription") Then
			
			If ValueIsFilled(FieldNode.Alias)
			   AND FieldNode.Alias <> Context.RestrictionStructure.MainTableAlias Then
				
				TableAlias = FieldNode.Alias;
				FieldNameForQuery = TableAlias + "." + FieldNode.Name;
			Else
				TableAlias = "CurrentList";
				AddBasicField(Context, FieldNode, FieldProperties);
				If Not ValueIsFilled(FieldNode.Cast) Then
					FieldNameForQuery = TextWithIndent(
						FieldNameExpandingBasicFieldsByTypes(TableAlias, FieldNode), "		");
				Else
					FieldNameForQuery = TableAlias + "." + FieldNode.Name;
				EndIf;
			EndIf;
			
		Else // The first part of the field name is a tabular section name.
			TableAlias = "CurrentList" + FieldNode.FieldTypes[0];
			NameParts = StrSplit(FieldNode.Name, ".");
			NameParts.Delete(0);
			FieldNameForQuery = TableAlias + "." + StrConcat(NameParts);
		EndIf;
		TypesString = FieldNode.TypesString;
	EndIf;
	
	// The IsNull() function can have only a field inside, it cannot have the Express() function.
	If ValueIsFilled(FieldNode.IsNull) Then
		FieldNameForQuery = "ISNULL(" + FieldNameForQuery + ", "
			+ ValueOrConstantNodeExpression(FieldNode.IsNull) + ")";
		
		If IsRootNode Then
			Properties.Insert("NoNullValue", True);
		EndIf;
	EndIf;
	
	If ValueIsFilled(FieldNode.Cast) Then
		FieldNameForQuery = "CAST(" + FieldNameForQuery + " AS " + FieldNode.Cast + ")";
		FieldProperties.Insert("HasExpress");
	EndIf;
	
	Properties.Insert("TableAlias",  TableAlias);
	Properties.Insert("FieldNameForQuery", FieldNameForQuery);
	Properties.Insert("EndFieldType",  EndFieldType);
	Properties.Insert("TypesString",       TypesString);
	
	If FieldNode.Property("FieldContainsNull") Then
		Properties.Insert("FieldContainsNull");
	EndIf;
	
	AddLeadingListsByFieldsValues(Context, FieldNode);
	
	Return Properties;
	
EndFunction

// For the AdditionalTablesGroups and FieldProperties functions.
Procedure AddLeadingListsByFieldsValues(Context, FieldNode)
	
	FieldsNames = StrSplit(FieldNode.Name, ".");
	
	If FieldNode.Attachment <> Undefined Then
		AddLeadingListField(Context, FieldNode.Table, FieldsNames[0], True, True);
		
	ElsIf ValueIsFilled(FieldNode.Alias)
	        AND FieldNode.Alias <> Context.RestrictionStructure.MainTableAlias Then
		
		AddLeadingListField(Context, FieldNode.Table, FieldsNames[0]);
	EndIf;
	
	FieldsNames = StrSplit(FieldNode.Name, ".");
	FirstFieldIndex = ?(TypeOf(FieldNode.FieldTypes[0]) = Type("TypeDescription"), 0, 1);
	
	For Index = FirstFieldIndex + 1 To FieldsNames.Count()-1 Do
		Field = FieldsNames[Index];
		For Each Table In FieldNode.NextFieldTables[Index-1] Do
			AddLeadingListField(Context, Table, Field, True, True);
		EndDo;
	EndDo;
	
EndProcedure

// For the AddLeadingListsByFieldsValues procedure.
Procedure AddLeadingListField(Context, Table, Field, IsListTable = Undefined, IsReferenceTableType = Undefined)
	
	If IsListTable = Undefined
	   AND StrOccurrenceCount(Table, ".") = 2 Then
		
		NameContent = StrSplit(Table, ".");
		TabularSection = NameContent[2];
		NameContent.Delete(2);
		FullName = StrConcat(NameContent, ".");
	Else
		TabularSectionName = "";
		FullName = Table;
	EndIf;
	
	If Upper(Context.List) = Upper(FullName) Then
		Return;
	EndIf;
	
	FieldsDetails = Context.LeadingListsByFieldsValues.Get(FullName);
	If FieldsDetails = Undefined Then
		If IsReferenceTableType = Undefined Then
			NameContent = StrSplit(Table, ".");
			TableType = Context.RestrictionStructure.InternalData.TablesTypesByNames.Get(Upper(NameContent[0]));
			IsReferenceTableType = TableType.IsReferenceType;
		EndIf;
		FieldsDetails = New Structure("HeaderFields, TabularSections, IsReferenceType",
			New Array, New Map, IsReferenceTableType);
		Context.LeadingListsByFieldsValues.Insert(FullName, FieldsDetails);
	EndIf;
	
	If ValueIsFilled(TabularSection) Then
		Fields = FieldsDetails.TabularSections.Get(TabularSection);
		If Fields = Undefined Then
			Fields = New Array;
			FieldsDetails.TabularSections.Insert(TabularSection, Fields);
		EndIf;
	Else
		Fields = FieldsDetails.HeaderFields;
	EndIf;
	
	If Fields.Find(Field) <> Undefined Then
		Return;
	EndIf;
	
	If Upper(Field) = Upper("Ref") Or Upper(Field) = Upper("Ref") Then
		If IsReferenceTableType = Undefined Then
			NameContent = StrSplit(Table, ".");
			TableType = Context.RestrictionStructure.InternalData.TablesTypesByNames.Get(Upper(NameContent[0]));
			IsReferenceTableType = TableType.IsReferenceType;
		EndIf;
		If IsReferenceTableType Then
			Return;
		EndIf;
	EndIf;
	
	Fields.Add(Field);
	
EndProcedure

// For the AddBasicField, AddDimensionTypes, AddFieldTypesProperties, and
// AddCheckByTypes procedures and the FieldProperties function.
//
Function IsSimpleType(Type)
	
	Return Type = Type("Boolean")
	    Or Type = Type("Date")
	    Or Type = Type("String")
	    Or Type = Type("Number")
	    Or Type = Type("UUID")
	    Or Type = Type("ValueStorage");
	
EndFunction

// For the AddFieldTypesProperties function.
Function CheckingType(Node, FullName)
	
	If Node.Types.Count() = 0 Then
		Return True;
	EndIf;
	
	TypeSpecified = False;
	For Each TableName In Node.Types Do
		If Upper(TableName) = Upper(FullName) Then
			TypeSpecified = True;
			Break;
		EndIf;
	EndDo;
	
	Return Node.CheckTypesExceptListed AND Not TypeSpecified
	 Or Not Node.CheckTypesExceptListed AND    TypeSpecified;
	
EndFunction

// For the AddFieldTypesProperties function.
Function TypeClarified(Node, TypeNameInQueryLanguage)
	
	TypeClarified = False;
	For Each ComparisonClarification In Node.ComparisonClarifications Do
		If Upper(ComparisonClarification.Key) = Upper(TypeNameInQueryLanguage) Then
			TypeClarified = True;
			Break;
		EndIf;
	EndDo;
	
	Return TypeClarified;
	
EndFunction

// For the AddFieldTypesProperties function.
Function TypeClarification(Node, TypeNameInQueryLanguage)
	
	Clarification = "";
	For Each ComparisonClarification In Node.ComparisonClarifications Do
		If Upper(ComparisonClarification.Key) = Upper(TypeNameInQueryLanguage) Then
			Clarification = ComparisonClarification.Value;
			Break;
		EndIf;
	EndDo;
	
	Return Clarification;
	
EndFunction

// For the FieldProperties function.
Function ValueOrConstantNodeValueType(Node)
	
	If Node.Node = "Value" Then
		Return RefTypeByFullPredefinedItemName(Node.Name);
	EndIf;
	
	Return TypeOf(Node.Value);
	
EndFunction

// For the ConnectionConditionText, FieldProperties, and WhenConditionFieldsSet functions and the 
// ClarifyComparisonFieldProperties procedure.
//
Function ValueOrConstantNodeExpression(Node)
	
	If Node.Node = "Value" Then
		Expression = "Value(" + Node.Name + ")";
	
	ElsIf TypeOf(Node.Value) = Type("Boolean") Then
		Expression = ?(Node.Value, "True", "False");
		
	ElsIf TypeOf(Node.Value) = Type("Number") Then
		Expression = Format(Node.Value, "NG=");
		
	ElsIf TypeOf(Node.Value) = Type("Undefined") Then
		Expression = "Undefined";
	Else
		Expression = """" + Node.Value + """";
	EndIf;
	
	Return Expression;
	
EndFunction

// For the ValueOrConstantNodeValueType function.
Function RefTypeByFullPredefinedItemName(FullPredefinedItemName)
	
	NameParts = StrSplit(FullPredefinedItemName, ".");
	NameParts.Delete(2);
	
	FullName = StrConcat(NameParts, ".");
	
	Return RefTypeByFullMetadataName(FullName);
	
EndFunction

// For the FieldProperties and RefTypeByFullPredefinedItemName functions.
Function RefTypeByFullMetadataName(FullName)
	
	If IsRussianVersionOfMetadataObjectKind(FullName) Then
		RefTypeName = StrReplace(FullName, ".", "Ref.");
	Else
		RefTypeName = StrReplace(FullName, ".", "Ref.");
	EndIf;
	
	Return Type(RefTypeName);
	
EndFunction

// For the RefTypeByFullMetadataName function.
Function IsRussianVersionOfMetadataObjectKind(FullName)
	
	FirstChar = Left(FullName, 1);
	
	Return FirstChar > "A" AND FirstChar < "Z"
	    Or FirstChar > "a" AND FirstChar < "z";
	
EndFunction

#EndRegion

#Region AccessRestrictionParametersQueryTextsForList

// The main function of the area, which is the second part of the 
// RestrictionParametersByRestrictionStructure function. It is not used when preparing stored access 
// restriction parameters, but is used when calling the RestrictionParameters function.
// 
//
Procedure AddQueryTextsToRestrictionParameters(Result)
	
	Context = Result.Context;
	Result.Delete("Context");
	
	// Checking the Read and Update object rights or a record set in the database.
	Result.Insert("ReadEditRightsCheckQueryText");
	// Checking the Read object right or a record set in the database.
	Result.Insert("ReadRightsCheckQueryText");
	
	AddDateQueryTextOfNextDataItem(Result, Context); 
	
	If Result.RestrictionDisabled
	 Or Result.AccessDenied
	 Or Result.UsesRestrictionByOwner Then
		
		If Result.UsesRestrictionByOwner
		 Or Context.ListsWithKeysRecordForDependentListsWithoutKeys.Get(
		         Result.List) = Undefined Then
			
			// Query of objects or record filters.
			Result.Insert("DataItemForKeyClearingQueryText");
			AddQueryTextOfDataItemsToClearKeys(Result, Context);
		Else
			// Query of objects or record filters.
			Result.Insert("DataItemWithObsoleteAllowedKeyQueryText");
			AddQueryTextOfDataItemsWithObsoleteAllowedKey(Result, Context);
		EndIf;
		If Result.UsesRestrictionByOwner Then
			// Generating right checking queries.
			FillReadUpdateRightsCheckQueries(Result, Context);
		EndIf;
		Return;
	EndIf;
	
	// Names of used key tables.
	Result.Insert("KeyTables");
	// Names of used key table attributes.
	Result.Insert("KeyTablesAttributes");
	// Query of objects or record filters.
	Result.Insert("DataItemWithObsoleteKeysQueryText");
	// Query of object values or record filters.
	Result.Insert("DataItemValueForAccessKeysQueryText");
	// Query of values from access keys to compare them with values from objects or record filters.
	Result.Insert("ValueFromAccessKeysForComparisonQueryText");
	// Query of record filters that are missing in the register of register access keys.
	Result.Insert("NewCombinationsOfBasicFieldsValuesQueryText");
	// Query of values from access keys to calculate users and access groups, for which they are allowed.
	Result.Insert("ValueFromAccessKeysForRightsCalculationQueryText");
	
	Context.Insert("SeparateRegister", True); // Clarifying a key register for non-reference types.
	
	Context.Insert("KeyTables",                                   New Array);
	Context.Insert("KeyTablesAttributes",                           New Map);
	Context.Insert("CheckConditionParts",                           New Array);
	Context.Insert("PartsOfValuesFromObjectsQuery",                 New Array);
	Context.Insert("PartsOfValuesFromObjectsQueryToCompare",       New Array);
	Context.Insert("PartsOfValuesFromKeysQueryToCalculateRights",     New Array);
	Context.Insert("ConditionPartsToSelectLeadingAccessKeysRights",     New Array);
	Context.Insert("ConditionPartsToSelectLeadingListsRights",           New Array);
	Context.Insert("ConditionPartsToSelectRightsByRightsSettingsOwners", New Array);
	
	// Generating a query of data items with obsolete keys.
	FillTemplatesOfCheckQueryParts(Context);
	
	For HeaderNumber = 0 To 2 Do
		AddKeyHeaderCheck(Context, HeaderNumber);
	EndDo;
	
	For KeyTabularSectionNumber = 1 To Context.KeyTabularSectionsCount Do
		AddKeyTabularSectionCheck(Context, KeyTabularSectionNumber);
	EndDo;
	ComposeCheckQueryParts(Result, Context);
	
	// Generating queries of values from data items and keys.
	For HeaderNumber = 0 To 2 Do
		AddKeyHeaderFilling(Context, HeaderNumber);
	EndDo;
	AddKeysChoiceWithoutFieldsInHeader(Context);
	
	For KeyTabularSectionNumber = 1 To Context.KeyTabularSectionsCount Do
		AddKeyTabularSectionFilling(Context, KeyTabularSectionNumber);
	EndDo;
	ComposeFillQueryParts(Result, Context);
	
	Result.KeyTables         = Context.KeyTables;
	Result.KeyTablesAttributes = Context.KeyTablesAttributes;
	
	// Generating right checking queries.
	FillReadUpdateRightsCheckQueries(Result, Context);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddDateQueryTextOfNextDataItem(Result, Context)
	
	If Not Result.IsReferenceType Or Not Result.ListWithDate Then
		Return;
	EndIf;
	
	QueryText =
	"SELECT TOP 1
	|	CurrentList.Date AS Date
	|FROM
	|	&CurrentList AS CurrentList
	|WHERE
	|	CurrentList.Date < &StartDate
	|
	|ORDER BY
	|	CurrentList.Date DESC";
	
	QueryText = StrReplace(QueryText, "&CurrentList", Result.List);
	
	Result.Insert("NextDataItemDateQueryText", QueryText);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddQueryTextOfDataItemsToClearKeys(Result, Context)
	
	If Result.IsReferenceType Then
		FillTemplatesOfObjectCheckQueryParts(Context);
		QueryText = Context.CheckQueryPartText;
		
		If Result.DoNotWriteAccessKeysForUsersAndExternalUsers Then
			Condition = "NOT AccessKeysForObjects.Object IS NULL";
		Else
			If Result.ForExternalUsers Then
				Condition =
				"	NOT AccessKeysForObjects.Object IS NULL
				|	AND AccessKeysForObjects.ExternalUsersAccessKey <> VALUE(Catalog.AccessKeys.EmptyRef)";
			Else
				Condition =
				"	NOT AccessKeysForObjects.Object IS NULL
				|	AND AccessKeysForObjects.UsersAccessKey <> VALUE(Catalog.AccessKeys.EmptyRef)";
			EndIf;
		EndIf;
		QueryText = StrReplace(QueryText, "#Joins", "");
		QueryText = StrReplace(QueryText, "#Condition", Condition);
		QueryText = StrReplace(QueryText, "&CurrentList", Result.List);
		
		Result.DataItemForKeyClearingQueryText = QueryText;
		Return;
	EndIf;
	
	If ValueIsFilled(Result.SeparateKeysRegisterName) Then
		RegisterName = Result.SeparateKeysRegisterName;
		BasicFieldsForOrdering = "";
		BasicFieldsForFilter = "";
	Else
		RegisterName                = "AccessKeysForRegisters";
		BasicFieldsForFilter       = "AccessKeysForRegisters.Register = &RegisterID";
		BasicFieldsForOrdering = "AccessKeysForRegisters.Register";
	EndIf;
	
	If Result.DoNotWriteAccessKeysForUsersAndExternalUsers Then
		BasicFieldsForFilter = BasicFieldsForFilter + ?(BasicFieldsForFilter = "", "", "
		|	AND ") + "AccessKeysForRegisters.ForExternalUsers >= FALSE";
	Else
		If Result.ForExternalUsers Then
			BasicFieldsForFilter = BasicFieldsForFilter + ?(BasicFieldsForFilter = "", "", "
			|	AND ") + "AccessKeysForRegisters.ForExternalUsers = TRUE";
		Else
			BasicFieldsForFilter = BasicFieldsForFilter + ?(BasicFieldsForFilter = "", "", "
			|	AND ") + "AccessKeysForRegisters.ForExternalUsers = FALSE";
		EndIf;
	EndIf;
	
	SelectionFields = "AccessKeysForRegisters.ForExternalUsers";
	For FieldNumber = 1 To Context.BasicFields.MaxCount Do
		SelectionFields = SelectionFields + ?(SelectionFields = "", "", ",
		|	") + "AccessKeysForRegisters.Field" + FieldNumber + " AS Field" + FieldNumber;
		
		BasicFieldsForFilter = BasicFieldsForFilter + ?(BasicFieldsForFilter = "", "", "
		|	AND ") + "AccessKeysForRegisters.Field" + FieldNumber + " >= &Field" + FieldNumber;
		
		BasicFieldsForOrdering = BasicFieldsForOrdering + ?(BasicFieldsForOrdering = "", "", ",
		|	") + "AccessKeysForRegisters.Field" + FieldNumber;
	EndDo;
	
	QueryText =
	"SELECT TOP " + BatchSizeMarker() + "
	|	" + TextWithIndent(TrimL(SelectionFields), "	") +"
	|FROM
	|	InformationRegister." + RegisterName + " AS AccessKeysForRegisters
	|WHERE
	|	" + BasicFieldsForFilter + "
	|
	|ORDER BY
	|	" + BasicFieldsForOrdering;
	
	Result.DataItemForKeyClearingQueryText = QueryText;
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddQueryTextOfDataItemsWithObsoleteAllowedKey(Result, Context)
	
	If Not Result.IsReferenceType Then
		Return;
	EndIf;
	
	FillTemplatesOfObjectCheckQueryParts(Context);
	QueryText = Context.CheckQueryPartText;
	
	Condition = "AccessKeysForObjects.Object IS NULL";
	If Result.ForExternalUsers Then
		ConnectionCondition = "	AND AccessKeysForObjects.ExternalUsersAccessKey = &AllowedAccessKey";
	Else
		ConnectionCondition = "	AND AccessKeysForObjects.UsersAccessKey = &AllowedAccessKey";
	EndIf;
	QueryText = StrReplace(QueryText, "#Joins", ConnectionCondition);
	QueryText = StrReplace(QueryText, "#Condition", Condition);
	QueryText = StrReplace(QueryText, "&CurrentList", Result.List);
	
	Result.DataItemWithObsoleteAllowedKeyQueryText = QueryText;
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure FillTemplatesOfCheckQueryParts(Context)
	
	If Context.IsReferenceType Then
		FillTemplatesOfObjectCheckQueryParts(Context);
	Else
		FillTemplatesOfRegisterCheckQueryParts(Context);
	EndIf;
	
EndProcedure

// For the FillTemplatesOfCheckQueryParts procedure.
Procedure FillTemplatesOfObjectCheckQueryParts(Context)
	
	Context.Insert("CheckQueryText");
	Context.Insert("CheckQueryPartText");
	
	If Context.ListWithDate Then
		Context.CheckQueryText =
		"SELECT TOP " + BatchSizeMarker() + "
		|	CurrentList.Ref AS CurrentRef,
		|	CurrentList.Date AS Date
		|FROM
		|	&CurrentList AS CurrentList
		|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
		|WHERE
		|	CurrentList.Date BETWEEN &StartDate AND &EndDate
		|	AND (AccessKeysForObjects.Object IS NULL
		|			OR #Condition)
		|
		|ORDER BY
		|	CurrentList.Date DESC";
		
		Context.CheckQueryPartText =
		"SELECT DISTINCT TOP " + BatchSizeMarker() + "
		|	CurrentList.Ref AS CurrentRef,
		|	CurrentList.Date AS Date
		|FROM
		|	&CurrentList AS CurrentList
		|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
		|		#Joins
		|WHERE
		|	CurrentList.Date BETWEEN &StartDate AND &EndDate
		|	AND #Condition
		|
		|ORDER BY
		|	CurrentList.Date DESC";
	Else
		Context.CheckQueryText =
		"SELECT TOP " + BatchSizeMarker() + "
		|	CurrentList.Ref AS CurrentRef
		|FROM
		|	&CurrentList AS CurrentList
		|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
		|WHERE
		|	CurrentList.Ref >= &LastProcessedRef
		|	AND (AccessKeysForObjects.Object IS NULL
		|			OR #Condition)
		|
		|ORDER BY
		|	CurrentList.Ref";
		
		Context.CheckQueryPartText =
		"SELECT DISTINCT TOP " + BatchSizeMarker() + "
		|	CurrentList.Ref AS CurrentRef
		|FROM
		|	&CurrentList AS CurrentList
		|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
		|		#Joins
		|WHERE
		|	CurrentList.Ref >= &LastProcessedRef
		|	AND #Condition
		|
		|ORDER BY
		|	CurrentList.Ref";
	EndIf;
	
EndProcedure

// For the FillTemplatesOfCheckQueryParts procedure.
Procedure FillTemplatesOfRegisterCheckQueryParts(Context)
	
	BasicFields = Context.BasicFields;
	BasicFields.Insert("ForSelection",         "");
	BasicFields.Insert("ConnectionCondition", "");
	BasicFields.Insert("ForFilter",         "");
	BasicFields.Insert("ForOrdering",   "");
	
	// For a new combination query.
	BasicFieldsForSelection = "";
	BasicFieldsConnectionCondition = "";
	BasicFieldsForOrdering = "";
	
	If Not ValueIsFilled(Context.SeparateKeysRegisterName) Then
		Context.SeparateRegister = False;
		// For a new combination query.
		BasicFieldsConnectionCondition  = "(AccessKeysForRegisters.Register = &RegisterID)";
		// For other queries.
		BasicFields.ConnectionCondition = "(CurrentListSource.Register = CurrentList.Register)";
		BasicFields.ForFilter         = "CurrentList.Register = &RegisterID";
	EndIf;
	
	FilterByUsersType = ?(Context.ForExternalUsers, "TRUE", "FALSE");
	
	// For a new combination query.
	BasicFieldsConnectionCondition = BasicFieldsConnectionCondition + ?(BasicFieldsConnectionCondition = "", "", "
	|			AND ") + "(AccessKeysForRegisters.ForExternalUsers = " + FilterByUsersType + ")";
	
	// For other queries.
	BasicFields.ConnectionCondition = BasicFields.ConnectionCondition + ?(BasicFields.ConnectionCondition = "", "", "
	|	AND ") + "(CurrentListSource.ForExternalUsers = " + FilterByUsersType + ")";
	
	BasicFields.ForFilter = BasicFields.ForFilter + ?(BasicFields.ForFilter = "", "", "
	|	AND ") + "CurrentList.ForExternalUsers = " + FilterByUsersType;
	
	Number = 0;
	For Each BasicFieldName In BasicFields.Used Do
		Number = Number + 1;
		
		// For a new combination query.
		BasicFieldsForSelection = BasicFieldsForSelection + ?(BasicFieldsForSelection = "", "", ",
		|	") + "CurrentRegister." + BasicFieldName + " AS Field" + Number;
		
		BasicFieldsConnectionCondition = BasicFieldsConnectionCondition + ?(BasicFieldsConnectionCondition = "", "", "
		|			AND ") + "(AccessKeysForRegisters.Field" + Number + " = CurrentRegister." + BasicFieldName + ")";
		
		BasicFieldsForOrdering = BasicFieldsForOrdering + ?(BasicFieldsForOrdering = "", "", ", ") + BasicFieldName;
		
		// For other queries.
		BasicFields.ForSelection = BasicFields.ForSelection + ?(BasicFields.ForSelection = "", "", ",
		|	") + "CurrentList.Field" + Number + " AS Field" + Number;
		
		BasicFields.ConnectionCondition = BasicFields.ConnectionCondition + ?(BasicFields.ConnectionCondition = "", "", "
		|	AND ") + "(CurrentListSource.Field" + Number + " = CurrentList.Field" + Number + ")";
		
		Filter = "";
		For AdditionalNumber = 1 To Number - 1 Do
			Filter = Filter + ?(AdditionalNumber = 1, "", "
			|	AND ") + "CurrentList.Field" + AdditionalNumber + " = &Field" + AdditionalNumber;
		EndDo;
		Filter = Filter + ?(Filter = "", "", "
		|	AND ") + "CurrentList.Field" + Number + " > &Field" + Number;
		
		Filter = ?(Number = 1, ?(BasicFields.Used.Count() > 1, "(", "") + Filter, "
		|		OR " + TextWithIndent(Filter, "		"));
		
		BasicFields.ForFilter = BasicFields.ForFilter + ?(BasicFields.ForFilter = "", "", ?(Number = 1, "
		|	AND ", "")) + Filter;
		
		BasicFields.ForOrdering = BasicFields.ForOrdering + ?(BasicFields.ForOrdering = "", "", ", ") + "Field" + Number;
	EndDo;
	
	If BasicFields.Used.Count() > 1 Then
		BasicFields.ForFilter = BasicFields.ForFilter + ")";
	EndIf;
	
	// For a new combination query.
	InitialNumber = Number + 1;
	For Number = InitialNumber To BasicFields.MaxCount Do
		BasicFieldsConnectionCondition = BasicFieldsConnectionCondition + ?(BasicFieldsConnectionCondition = "", "", "
		|			AND ") + "(AccessKeysForRegisters.Field" + Number + " = VALUE(Enum.AdditionalAccessValues.Null))";
	EndDo;
	
	// Check query parts.
	NewCombinationsQueryText =
	"SELECT DISTINCT TOP " + BatchSizeMarker() + "
	|	" + BasicFieldsForSelection + "
	|FROM
	|	&CurrentRegister AS CurrentRegister
	|		LEFT JOIN &CurrentList AS AccessKeysForRegisters
	|		ON " + BasicFieldsConnectionCondition + "
	|WHERE
	|	AccessKeysForRegisters.Field1 IS NULL
	|
	|ORDER BY
	|	" + BasicFieldsForOrdering;
	
	CheckCombinationsQueryText =
	"SELECT DISTINCT TOP " + BatchSizeMarker() + "
	|	" + BasicFields.ForSelection + "
	|FROM
	|	&CurrentList AS CurrentList
	|WHERE
	|	" + BasicFields.ForFilter + "
	|	AND (#Condition)
	|
	|ORDER BY
	|	" + BasicFields.ForOrdering;
	
	// Setting a query template.
	Context.Insert("CheckQueryText");
	
	FullCheckQueryText =
	"SELECT DISTINCT TOP " + BatchSizeMarker() + "
	|	" + BasicFields.ForSelection + "
	|FROM (
	|	#PartialRequestsForObjects
	|	
	|	) AS CurrentListParts
	|
	|ORDER BY
	|	" + BasicFields.ForOrdering;
	
	FullCheckQueryText = StrReplace(FullCheckQueryText,
		"CurrentList.", "CurrentListParts.");
	
	WrapperTextOfCheckQueryPart =
	"SELECT
	|	" + BasicFields.ForSelection + "
	|FROM
	|	(#RequestForPartOfObjects) AS CurrentListPart";
	
	WrapperTextOfCheckQueryPart = StrReplace(WrapperTextOfCheckQueryPart,
		"CurrentList.", "CurrentListPart.");
	
	ObjectsPartQueryText = StrReplace(WrapperTextOfCheckQueryPart,
		"#RequestForPartOfObjects", TextWithIndent(NewCombinationsQueryText, "	"));
	
	ObjectsPartQueryText = ObjectsPartQueryText + "
	|
	|UNION ALL
	|
	|";
	
	ObjectsPartQueryText = ObjectsPartQueryText + StrReplace(WrapperTextOfCheckQueryPart,
		"#RequestForPartOfObjects", TextWithIndent(CheckCombinationsQueryText, "	"));
	
	Context.CheckQueryText = StrReplace(FullCheckQueryText,
		"#PartialRequestsForObjects", TextWithIndent(ObjectsPartQueryText, "	"));
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure ComposeCheckQueryParts(Result, Context)
	
	Condition = "";
	For Each ConditionPartText In Context.CheckConditionParts Do
		If ValueIsFilled(Condition) Then
			Condition = Condition + "
			|		OR ";
		EndIf;
		Condition = Condition + TextWithIndent(ConditionPartText, "			");
	EndDo;
	
	Context.CheckQueryText = StrReplace(Context.CheckQueryText,
		"#Condition", TextWithIndent(Condition, ?(Context.IsReferenceType, "	", "			")));
	
	InsertCommonParametersIntoQuery(Context.CheckQueryText, Context);
	Result.DataItemWithObsoleteKeysQueryText = Context.CheckQueryText;
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure ComposeFillQueryParts(Result, Context)
	
	QueryText = StrConcat(Context.PartsOfValuesFromObjectsQuery,
		Common.QueryBatchSeparator());
	InsertCommonParametersIntoQuery(QueryText, Context);
	Result.DataItemValueForAccessKeysQueryText = QueryText;
	
	QueryText = StrConcat(Context.PartsOfValuesFromObjectsQueryToCompare,
		Common.QueryBatchSeparator());
	InsertCommonParametersIntoQuery(QueryText, Context);
	Result.ValueFromAccessKeysForComparisonQueryText = QueryText;
	
	AddQueryPartOfLeadingKeysRightsSelection(Context);
	AddQueryPartOfLeadingListsRightsSelection(Context);
	AddQueryPartOfRightsSelectionByRightsSettingsOwners(Context);
	QueryText = StrConcat(Context.PartsOfValuesFromKeysQueryToCalculateRights,
		Common.QueryBatchSeparator());
	InsertCommonParametersIntoQuery(QueryText, Context);
	Result.ValueFromAccessKeysForRightsCalculationQueryText = QueryText;
	
EndProcedure

// For the ComposeFillQueriesParts procedure.
Procedure AddQueryPartOfLeadingKeysRightsSelection(Context)
	
	If Context.ConditionPartsToSelectLeadingAccessKeysRights.Count() = 0 Then
		Return;
	EndIf;
	
	If Context.ConditionPartsToSelectLeadingAccessKeysRights.Count() = 1 Then
		FilterCriterion = Context.ConditionPartsToSelectLeadingAccessKeysRights[0];
	Else
		FilterCriterion = "(" + StrConcat(Context.ConditionPartsToSelectLeadingAccessKeysRights,
			Chars.LF + "			OR ") + ")";
	EndIf;
	
	QueryText =
	"SELECT
	|	RightsToLeadingAccessKeysLists.Table AS List,
	|	RightsToLeadingAccessKeysLists.AccessGroup AS AccessGroup,
	|	RightsToLeadingAccessKeysLists.Update AS Update
	|FROM
	|	InformationRegister.AccessGroupsTables AS RightsToLeadingAccessKeysLists
	|WHERE
	|	RightsToLeadingAccessKeysLists.Table IN
	|			(SELECT DISTINCT
	|				HeadAccessKeyLists.List
	|			FROM
	|				Catalog.AccessKeys AS HeadAccessKeyLists
	|			WHERE
	|				&FilterCriterion)
	|TOTALS BY
	|	List";
	
	QueryText = StrReplace(QueryText, "&FilterCriterion",
		StrReplace(FilterCriterion, "#FieldToCheck", "HeadAccessKeyLists.Ref"));
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
	QueryText =
	"SELECT
	|	HeadAccessKeyLists.Ref AS AccessKey,
	|	HeadAccessKeyLists.List AS List
	|FROM
	|	Catalog.AccessKeys AS HeadAccessKeyLists
	|WHERE
	|	&FilterCriterion";
	
	QueryText = StrReplace(QueryText, "&FilterCriterion",
		StrReplace(FilterCriterion, "#FieldToCheck", "HeadAccessKeyLists.Ref"));
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
	If Not Context.CalculateUserRights Then
		QueryText =
		"SELECT
		|	RightsToAccessKeys.AccessKey AS AccessKey,
		|	RightsToAccessKeys.AccessGroup AS RightsOwner,
		|	RightsToAccessKeys.Update AS Update
		|FROM
		|	InformationRegister.AccessGroupsAccessKeys AS RightsToAccessKeys
		|WHERE
		|	VALUETYPE(RightsToAccessKeys.AccessGroup) = TYPE(Catalog.AccessGroups)
		|	AND &FilterCriterion
		|TOTALS BY
		|	AccessKey";
	ElsIf Not Context.ForExternalUsers Then
		QueryText =
		"SELECT
		|	RightsToAccessKeys.AccessKey AS AccessKey,
		|	RightsToAccessKeys.AccessGroup AS RightsOwner,
		|	RightsToAccessKeys.Update AS Update
		|FROM
		|	InformationRegister.AccessGroupsAccessKeys AS RightsToAccessKeys
		|WHERE
		|	&FilterCriterion
		|
		|UNION ALL
		|
		|SELECT
		|	RightsToAccessKeys.AccessKey,
		|	RightsToAccessKeys.User.User,
		|	RightsToAccessKeys.Update
		|FROM
		|	InformationRegister.UsersAccessKeys AS RightsToAccessKeys
		|WHERE
		|	RightsToAccessKeys.AreGroupSetRights = FALSE
		|	AND ISNULL(RightsToAccessKeys.User.User, VALUE(Catalog.Users.EmptyRef)) <> VALUE(Catalog.Users.EmptyRef)
		|	AND &FilterCriterion
		|TOTALS BY
		|	AccessKey";
	Else
		QueryText =
		"SELECT
		|	RightsToAccessKeys.AccessKey AS AccessKey,
		|	RightsToAccessKeys.AccessGroup AS RightsOwner,
		|	RightsToAccessKeys.Update AS Update
		|FROM
		|	InformationRegister.AccessGroupsAccessKeys AS RightsToAccessKeys
		|WHERE
		|	&FilterCriterion
		|
		|UNION ALL
		|
		|SELECT
		|	RightsToAccessKeys.AccessKey,
		|	RightsToAccessKeys.ExternalUser.User,
		|	RightsToAccessKeys.Update
		|FROM
		|	InformationRegister.ExternalUsersAccessKeys AS RightsToAccessKeys
		|WHERE
		|	RightsToAccessKeys.AreGroupSetRights = FALSE
		|	AND ISNULL(RightsToAccessKeys.ExternalUser.User, VALUE(Catalog.Users.EmptyRef)) <> VALUE(Catalog.Users.EmptyRef)
		|	AND &FilterCriterion
		|TOTALS BY
		|	AccessKey";
	EndIf;
	
	QueryText = StrReplace(QueryText, "&FilterCriterion",
		StrReplace(FilterCriterion, "#FieldToCheck", "RightsToAccessKeys.AccessKey"));
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
EndProcedure

// For the ComposeFillQueriesParts procedure.
Procedure AddQueryPartOfLeadingListsRightsSelection(Context)
	
	If Context.ConditionPartsToSelectLeadingListsRights.Count() = 0 Then
		Return;
	EndIf;
	
	If Context.Property("HeadListsWithTypesRightsSelectionCriteriaParts") Then
		QueryText =
		"SELECT
		|	RightsToLists.Table AS List,
		|	VALUETYPE(RightsToLists.Table.EmptyRefValue) AS ValueType,
		|	RightsToLists.AccessGroup AS RightsOwner,
		|	RightsToLists.Update AS Update
		|FROM
		|	InformationRegister.AccessGroupsTables AS RightsToLists
		|WHERE
		|	&FilterCriterion
		|TOTALS BY
		|	List";
	Else
		QueryText =
		"SELECT
		|	RightsToLists.Table AS List,
		|	RightsToLists.AccessGroup AS RightsOwner,
		|	RightsToLists.Update AS Update
		|FROM
		|	InformationRegister.AccessGroupsTables AS RightsToLists
		|WHERE
		|	&FilterCriterion
		|TOTALS BY
		|	List";
	EndIf;
	
	If Context.ConditionPartsToSelectLeadingListsRights.Count() = 1 Then
		FilterCriterion = Context.ConditionPartsToSelectLeadingListsRights[0];
	Else
		FilterCriterion = "(" + StrConcat(Context.ConditionPartsToSelectLeadingListsRights,
			Chars.LF + "			OR ") + ")";
	EndIf;
	FilterCriterion = StrReplace(FilterCriterion, "#FieldToCheck", "RightsToLists.Table");
	QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
EndProcedure

// For the ComposeFillQueriesParts procedure.
Procedure AddQueryPartOfRightsSelectionByRightsSettingsOwners(Context)
	
	If Context.ConditionPartsToSelectRightsByRightsSettingsOwners.Count() = 0 Then
		Return;
	EndIf;
	
	QueryText =
	"SELECT DISTINCT
	|	SettingsInheritance.Object AS Object
	|INTO ObjectsWithReadProhibition
	|FROM
	|	InformationRegister.ObjectsRightsSettings AS RightsSettings
	|		INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|		ON RightsSettings.Object = SettingsInheritance.Parent
	|			AND (SettingsInheritance.UsageLevel < RightsSettings.ReadingProhibitionLevel)
	|			AND (&FilterCriterion)
	|
	|INDEX BY
	|	Object
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	SettingsInheritance.Object AS Object
	|INTO ObjectsWithEditProhibition
	|FROM
	|	InformationRegister.ObjectsRightsSettings AS RightsSettings
	|		INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|		ON RightsSettings.Object = SettingsInheritance.Parent
	|			AND (RightsSettings.Table = &RightSettingsTableID)
	|			AND (SettingsInheritance.UsageLevel < RightsSettings.ChangingProhibitionLevel)
	|			AND (&FilterCriterion)
	|
	|INDEX BY
	|	Object
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	RightsSettings.Object AS RightsSettingsOwner,
	|	RightsSettings.User AS RightsOwner,
	|	MAX(RightsSettings.EditionAllowed) = TRUE
	|		AND MAX(RightsSettings.DataChangesDenied) = FALSE AS Update
	|FROM
	|	(SELECT
	|		SettingsInheritance.Object AS Object,
	|		CASE
	|			WHEN SettingsInheritance.Object IN
	|					(SELECT
	|						ObjectsWithReadProhibition.Object
	|					FROM
	|						ObjectsWithReadProhibition)
	|				THEN UserGroupCompositions.User
	|			ELSE UserGroupCompositions.UsersGroup
	|		END AS User,
	|		TRUE AS ReadingAllowed,
	|		FALSE AS ReadProhibited,
	|		FALSE AS EditionAllowed,
	|		FALSE AS DataChangesDenied
	|	FROM
	|		InformationRegister.ObjectsRightsSettings AS RightsSettings
	|			INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|			ON RightsSettings.Object = SettingsInheritance.Parent
	|				AND (SettingsInheritance.UsageLevel < RightsSettings.ReadingPermissionLevel)
	|				AND (&FilterCriterion)
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = RightsSettings.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (UserGroupCompositions.Used)
	|				AND (UserGroupCompositions.User.IBUserID <> &EmptyUniqueID)
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		SettingsInheritance.Object,
	|		UserGroupCompositions.User,
	|		FALSE,
	|		TRUE,
	|		FALSE,
	|		FALSE
	|	FROM
	|		InformationRegister.ObjectsRightsSettings AS RightsSettings
	|			INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|			ON (SettingsInheritance.Object IN
	|					(SELECT
	|						ObjectsWithReadProhibition.Object
	|					FROM
	|						ObjectsWithReadProhibition))
	|				AND RightsSettings.Object = SettingsInheritance.Parent
	|				AND (SettingsInheritance.UsageLevel < RightsSettings.ReadingProhibitionLevel)
	|				AND (&FilterCriterion)
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = RightsSettings.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (UserGroupCompositions.Used)
	|				AND (UserGroupCompositions.User.IBUserID <> &EmptyUniqueID)
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		SettingsInheritance.Object,
	|		CASE
	|			WHEN SettingsInheritance.Object IN
	|					(SELECT
	|						ObjectsWithEditProhibition.Object
	|					FROM
	|						ObjectsWithEditProhibition)
	|				THEN UserGroupCompositions.User
	|			ELSE UserGroupCompositions.UsersGroup
	|		END,
	|		FALSE,
	|		FALSE,
	|		TRUE,
	|		FALSE
	|	FROM
	|		InformationRegister.ObjectsRightsSettings AS RightsSettings
	|			INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|			ON RightsSettings.Object = SettingsInheritance.Parent
	|				AND (RightsSettings.Table = &RightSettingsTableID)
	|				AND (SettingsInheritance.UsageLevel < RightsSettings.ChangingPermissionLevel)
	|				AND (&FilterCriterion)
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = RightsSettings.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (UserGroupCompositions.Used)
	|				AND (UserGroupCompositions.User.IBUserID <> &EmptyUniqueID)
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		SettingsInheritance.Object,
	|		UserGroupCompositions.User,
	|		FALSE,
	|		FALSE,
	|		FALSE,
	|		TRUE
	|	FROM
	|		InformationRegister.ObjectsRightsSettings AS RightsSettings
	|			INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|			ON (SettingsInheritance.Object IN
	|					(SELECT
	|						ObjectsWithEditProhibition.Object
	|					FROM
	|						ObjectsWithEditProhibition))
	|				AND RightsSettings.Object = SettingsInheritance.Parent
	|				AND (RightsSettings.Table = &RightSettingsTableID)
	|				AND (SettingsInheritance.UsageLevel < RightsSettings.ChangingProhibitionLevel)
	|				AND (&FilterCriterion)
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = RightsSettings.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (UserGroupCompositions.Used)
	|				AND (UserGroupCompositions.User.IBUserID <> &EmptyUniqueID)) AS RightsSettings
	|
	|GROUP BY
	|	RightsSettings.Object,
	|	RightsSettings.User
	|
	|HAVING
	|	MAX(RightsSettings.ReadingAllowed) = TRUE AND
	|	MAX(RightsSettings.ReadProhibited) = FALSE
	|TOTALS BY
	|	RightsSettingsOwner";
	
	If Context.ForExternalUsers Then
		QueryText = StrReplace(QueryText, "Catalog.Users", "Catalog.ExternalUsers");
	EndIf;
	
	If Context.ConditionPartsToSelectRightsByRightsSettingsOwners.Count() = 1 Then
		FilterCriterion = Context.ConditionPartsToSelectRightsByRightsSettingsOwners[0];
	Else
		FilterCriterion =  StrConcat(Context.ConditionPartsToSelectRightsByRightsSettingsOwners,
			Chars.LF + "			OR ");
	EndIf;
	FilterCriterion = StrReplace(FilterCriterion, "#FieldToCheck", "SettingsInheritance.Object");
	QueryText = StrReplace(QueryText, "&FilterCriterion", TextWithIndent(FilterCriterion, "	"));
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure FillReadUpdateRightsCheckQueries(Result, Context)
	
	If Context.TypeCollectionName = "DocumentJournals" Then
		Return;
	EndIf;
	
	Properties = ListRestrictionProperties(Context.List, Context);
	
	If Context.IsReferenceType
	 Or Result.UsesRestrictionByOwner Then
		
		If Properties.TemplateRestrictionsWithUserAccessKeysAndAccessGroups Then
			If Context.ForExternalUsers Then
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|WHERE
				|	AccessKeysForObjects.Object = &Object
				|	AND (TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.ExternalUsersAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
				|					AND AllowedAccessKeys.ExternalUser IN (&AllowedUser, &AllowedUserGroupsSet, &AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet)
				|					AND AllowedAccessKeys.Update)
				|			OR TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
				|					AND AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet)
				|					AND AllowedAccessKeys.Update))";
			Else
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|WHERE
				|	AccessKeysForObjects.Object = &Object
				|	AND (TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.UsersAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey
				|					AND AllowedAccessKeys.User IN (&AllowedUser, &AllowedUserGroupsSet, &AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet)
				|					AND AllowedAccessKeys.Update)
				|			OR TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey
				|					AND AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet)
				|					AND AllowedAccessKeys.Update))";
			EndIf;
		ElsIf Properties.TemplateRestrictionsWithUserAccessKeys Then
			If Context.ForExternalUsers Then
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|		INNER JOIN InformationRegister.ExternalUsersAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForObjects.Object = &Object)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey)
				|			AND (AllowedAccessKeys.ExternalUser IN (&AllowedUser, &AllowedUserGroupsSet, &AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.Update)";
			Else
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|		INNER JOIN InformationRegister.UsersAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForObjects.Object = &Object)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey)
				|			AND (AllowedAccessKeys.User IN (&AllowedUser, &AllowedUserGroupsSet, &AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.Update)";
			EndIf;
		Else
			If Context.ForExternalUsers Then
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|		INNER JOIN InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForObjects.Object = &Object)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey)
				|			AND (AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.Update)";
			Else
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|		INNER JOIN InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForObjects.Object = &Object)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey)
				|			AND (AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.Update)";
			EndIf;
		EndIf;
	EndIf;
	
	If Not Result.UsesRestrictionByOwner Then
		QueryTextWithCheckByRightsSettingsOwners = "";
	Else
		EndFieldType = Context.FieldsProperties[0].EndFieldType;
		FieldRightsSettingsOwnersTypes = New Map;
		For Each KeyAndValue In Context.RightsSettingsOwnersTypes Do
			If EndFieldType.ContainsType(KeyAndValue.Key) Then
				FieldRightsSettingsOwnersTypes.Insert(KeyAndValue.Key,
					TypeNameInQueryLanguage(KeyAndValue.Key));
			EndIf;
		EndDo;
		If FieldRightsSettingsOwnersTypes.Count() = 0 Then
			QueryTextWithCheckByRightsSettingsOwners = "";
			
		ElsIf EndFieldType.Types().Count() = FieldRightsSettingsOwnersTypes.Count() Then
			QueryTextWithCheckByRightsSettingsOwners =
				QueryTextWithCheckByRightsSettingsOwners();
		Else
			If Context.IsReferenceType Then
				QueryTextWithCheckByRightsSettingsOwners =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|WHERE
				|	CASE
				|			WHEN &RightsSettingsOwnerTypeCheckCondition
				|				THEN &ConditionWithRightsSettingsOwnersCheck
				|			ELSE TRUE IN
				|				(&StandardCheckQueryText)
				|		END";
			Else
				QueryTextWithCheckByRightsSettingsOwners =
				"SELECT TOP 1
				|	FALSE AS FalseValue
				|FROM
				|	" + Context.List + " AS CurrentTable
				|WHERE
				|	&FilterByDimensions
				|	AND CASE
				|			WHEN &RightsSettingsOwnerTypeCheckCondition
				|				THEN &ConditionWithRightsSettingsOwnersCheck
				|			ELSE TRUE IN
				|				(&StandardCheckQueryText)
				|		END";
			EndIf;
			TypeCheckCondition = "";
			For Each TypeProperties In FieldRightsSettingsOwnersTypes Do
				TypeCheckCondition = TypeCheckCondition + ?(TypeCheckCondition = "", "", "
				|					") + "VALUETYPE(&Object) = TYPE(" + TypeProperties.Value + ")";
			EndDo;
			QueryTextWithCheckByRightsSettingsOwners = StrReplace(
				QueryTextWithCheckByRightsSettingsOwners,
				"&RightsSettingsOwnerTypeCheckCondition",
				TypeCheckCondition);
			
			QueryTextWithCheckByRightsSettingsOwners = StrReplace(
				QueryTextWithCheckByRightsSettingsOwners,
				"&ConditionWithRightsSettingsOwnersCheck",
				TextWithIndent(ConditionFromQueryWithCheckByRightsSettingsOwners(),
					"				"));
			
			QueryTextWithCheckByRightsSettingsOwners = StrReplace(
				QueryTextWithCheckByRightsSettingsOwners,
				"&StandardCheckQueryText",
				TextWithIndent(QueryText, "				"));
		EndIf;
	EndIf;
	
	If Result.UsesRestrictionByOwner Then
		If Context.IsReferenceType Then
			ObjectField = "CAST(&Object AS " + Context.List + ")." + Result.OwnerField.Name;
		Else
			ObjectField = "CurrentTable." + Result.OwnerField.Name;
		EndIf;
		QueryText = StrReplace(QueryText, "&Object", ObjectField);
		QueryTextWithCheckByRightsSettingsOwners =
			StrReplace(QueryTextWithCheckByRightsSettingsOwners, "&Object", ObjectField);
		
	ElsIf Not Context.IsReferenceType Then
		
		If Properties.TemplateRestrictionsWithUserAccessKeys Then
			If Context.ForExternalUsers Then
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
				|		INNER JOIN InformationRegister.ExternalUsersAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef))
				|			AND (AccessKeysForRegisters.ForExternalUsers = TRUE)
				|			AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey)
				|			AND (AllowedAccessKeys.ExternalUser IN (&AllowedUser, &AllowedUserGroupsSet, &AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.Update)";
			Else
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
				|		INNER JOIN InformationRegister.UsersAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef))
				|			AND (AccessKeysForRegisters.ForExternalUsers = FALSE)
				|			AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey)
				|			AND (AllowedAccessKeys.User IN (&AllowedUser, &AllowedUserGroupsSet, &AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.Update)";
			EndIf;
		Else
			If Context.ForExternalUsers Then
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
				|		INNER JOIN InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef))
				|			AND (AccessKeysForRegisters.ForExternalUsers = TRUE)
				|			AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey)
				|			AND (AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.Update)";
			Else
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
				|		INNER JOIN InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef))
				|			AND (AccessKeysForRegisters.ForExternalUsers = FALSE)
				|			AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey)
				|			AND (AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.Update)";
			EndIf;
		EndIf;
		
		ClarifyKeysRegisterAndConnectionCondition(QueryText, Result, Context);
		
		If Context.ForExternalUsers Then
			NewCombinationsOfBasicFieldsValuesQueryText =
			"SELECT DISTINCT
			|	&CurrentTableField1 AS CurrentTableField1
			|FROM
			|	&List AS CurrentTable
			|		LEFT JOIN InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
			|		ON (AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef))
			|			AND (AccessKeysForRegisters.ForExternalUsers = TRUE)
			|			AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)
			|WHERE
			|	&FilterByDimensions
			|	AND AccessKeysForRegisters.ForExternalUsers IS NULL";
		Else
			NewCombinationsOfBasicFieldsValuesQueryText =
			"SELECT DISTINCT
			|	&CurrentTableField1 AS CurrentTableField1
			|FROM
			|	&List AS CurrentTable
			|		LEFT JOIN InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
			|		ON (AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef))
			|			AND (AccessKeysForRegisters.ForExternalUsers = FALSE)
			|			AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)
			|WHERE
			|	&FilterByDimensions
			|	AND AccessKeysForRegisters.ForExternalUsers IS NULL";
		EndIf;
		ClarifyKeysRegisterAndConnectionCondition(NewCombinationsOfBasicFieldsValuesQueryText,
			Result, Context, True);
		
		Result.NewCombinationsOfBasicFieldsValuesQueryText =
			NewCombinationsOfBasicFieldsValuesQueryText;
	EndIf;
	
	If Not Context.IsReferenceType Then
		QueryText =
		"SELECT TOP 1
		|	FALSE AS FalseValue
		|FROM
		|	" + Context.List + " AS CurrentTable
		|WHERE
		|	&FilterByDimensions
		|	AND NOT TRUE IN
		|				(" + TextWithIndent(QueryText, "				") + ")";
	EndIf;
	
	If ValueIsFilled(QueryTextWithCheckByRightsSettingsOwners) Then
		Result.ReadEditRightsCheckQueryText = QueryTextWithCheckByRightsSettingsOwners;
	Else
		Result.ReadEditRightsCheckQueryText = QueryText;
	EndIf;
	
	If Not Result.RightToWriteRestrictionDisabled Then
		Result.ReadRightsCheckQueryText = StrReplace(QueryText,
			"AllowedAccessKeys.Update", "True");
	EndIf;
	
	If Result.UsesRestrictionByOwner
	   AND Result.OwnerField.EditAsRead Then
		
		Result.ReadEditRightsCheckQueryText = Result.ReadRightsCheckQueryText;
	EndIf;
	
EndProcedure

// For the FillReadUpdateRightsCheckQueries procedure.
Function ConditionFromQueryWithCheckByRightsSettingsOwners()
	
	Rows = StrSplit(QueryTextWithCheckByRightsSettingsOwners(), Chars.LF, "");
	Rows.Delete(0);
	Rows.Delete(0);
	Rows.Delete(0);
	
	Return TrimAll(StrConcat(Rows, Chars.LF));
	
EndFunction

// For the FillReadUpdateRightsCheckQueries procedure.
Function QueryTextWithCheckByRightsSettingsOwners()
	
	Return
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|WHERE
	|	TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				InformationRegister.ObjectsRightsSettings AS RightsSettings
	|					INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|					ON
	|						SettingsInheritance.Object = &Object
	|							AND RightsSettings.Object = SettingsInheritance.Parent
	|							AND RightsSettings.Table = &RightSettingsTableID
	|							AND SettingsInheritance.UsageLevel < RightsSettings.ChangingPermissionLevel
	|					INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|					ON
	|						UserGroupCompositions.User = &AuthorizedUser
	|							AND UserGroupCompositions.UsersGroup = RightsSettings.User)
	|	AND NOT FALSE IN
	|				(SELECT TOP 1
	|					FALSE
	|				FROM
	|					InformationRegister.ObjectsRightsSettings AS RightsSettings
	|						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|						ON
	|							SettingsInheritance.Object = &Object
	|								AND RightsSettings.Object = SettingsInheritance.Parent
	|								AND RightsSettings.Table = &RightSettingsTableID
	|								AND SettingsInheritance.UsageLevel < RightsSettings.ChangingProhibitionLevel
	|						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|						ON
	|							UserGroupCompositions.User = &AuthorizedUser
	|								AND UserGroupCompositions.UsersGroup = RightsSettings.User)";
	
EndFunction

// For the FillReadUpdateRightsCheckQueries procedure.
Procedure ClarifyKeysRegisterAndConnectionCondition(QueryText, Result, Context, AddSelectionFields = False)
	
	If ValueIsFilled(Result.SeparateKeysRegisterName) Then
		QueryText = StrReplace(QueryText,
			"InformationRegister.AccessKeysForRegisters",
			"InformationRegister." + Result.SeparateKeysRegisterName);
		QueryText = StrReplace(QueryText,
			"AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef)",
			"TRUE");
	Else
		QueryText = StrReplace(QueryText,
			"MetadataObjectIDs.EmptyRef",
			AccessManagementInternalCached.PredefinedMetadataObjectIDDetails(
				Context.List));
	EndIf;
	
	ConnectionCondition = "";
	FieldNumber = 1;
	For Each Field In Result.BasicFields.Used Do
		ConnectionCondition = ConnectionCondition + Chars.LF
			+ "AND (AccessKeysForRegisters.Field" + FieldNumber + " = CurrentTable." + Field + ")";
		FieldNumber = FieldNumber + 1;
	EndDo;
	For CurrentNumber = FieldNumber To Result.BasicFields.MaxCount Do
		ConnectionCondition = ConnectionCondition + Chars.LF
			+ "AND (AccessKeysForRegisters.Field" + CurrentNumber
			+ " = Value(Enum.AdditionalAccessValues.Null))";
	EndDo;
	QueryText = StrReplace(QueryText,
		"AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)",
		TextWithIndent(TrimL(ConnectionCondition), "			"));
	
	If Not AddSelectionFields Then
		Return;
	EndIf;
	
	SelectionFields = "";
	FieldNumber = 1;
	For Each Field In Result.BasicFields.Used Do
		SelectionFields = SelectionFields + ?(SelectionFields = "", "", "," + Chars.LF)
			+ "CurrentTable." + Field + " AS Field" + FieldNumber;
		FieldNumber = FieldNumber + 1;
	EndDo;
	
	QueryText = StrReplace(QueryText,
		"&CurrentTableField1 AS CurrentTableField1",
		TextWithIndent(TrimL(SelectionFields), "	"));
	
	QueryText = StrReplace(QueryText, "&List", Context.List);
	
EndProcedure

// For the ComposeQueriesParts function.
Procedure InsertCommonParametersIntoQuery(QueryText, Context)
	
	If Context.ForExternalUsers Then
		QueryText = StrReplace(QueryText, "#ObjectUserAccessKey", "ExternalUsersAccessKey");
	Else
		QueryText = StrReplace(QueryText, "#ObjectUserAccessKey", "UsersAccessKey");
	EndIf;
	
	If Context.IsReferenceType Then
		QueryText = StrReplace(QueryText, "&CurrentList", Context.List);
		QueryText = StrReplace(QueryText, "#DataAccessKeys", "AccessKeysForObjects");
		
		If Context.ForExternalUsers Then
			QueryText = StrReplace(QueryText, "#UsersAccessKey", "ExternalUsersAccessKey");
		Else
			QueryText = StrReplace(QueryText, "#UsersAccessKey", "UsersAccessKey");
		EndIf;
	Else
		QueryText = StrReplace(QueryText, "&CurrentRegister", Context.List);
		QueryText = StrReplace(QueryText, "#DataAccessKeys", "CurrentList");
		Number = 0;
		For Each BasicFieldName In Context.BasicFields.Used Do
			Number = Number + 1;
			QueryText = StrReplace(QueryText, "CurrentList."
				+ BasicFieldName, "CurrentList.Field" + Number);
			
			QueryText = StrReplace(QueryText, "CurrentListSource."
				+ BasicFieldName, "CurrentListSource.Field" + Number);
		EndDo;
		QueryText = StrReplace(QueryText, "&CurrentList", ?(Context.SeparateKeysRegisterName = "",
			"InformationRegister.AccessKeysForRegisters", "InformationRegister." + Context.SeparateKeysRegisterName));
		
		QueryText = StrReplace(QueryText, "#UsersAccessKey", "AccessKey");
	EndIf;
	
	QueryText = StrReplace(QueryText, "&FieldsComposition", Format(Context.FieldsComposition, "NG="));
	QueryText = StrReplace(QueryText, "&ForExternalUsers",
		?(Context.ForExternalUsers, "TRUE", "FALSE"));
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeyHeaderCheck(Context, HeaderNumber)
	
	FieldsGroup = Context.FieldsGroups.Get("Header" + HeaderNumber);
	If FieldsGroup = Undefined Then
		If HeaderNumber > 0 Then
			Return;
		EndIf;
		ConnectionsAndFields = New Structure("Joins, Fields", "", "");
	Else
		ConnectionsAndFields = ConnectionsAndFieldsByTables(FieldsGroup,
			False, HeaderNumber).Get("CurrentList");
	EndIf;
	
	If HeaderNumber = 0 Then
		Connections = ConnectionsAndFields.Joins + "
		|LEFT JOIN Catalog.AccessKeys AS Header0
		|ON " + ?(Context.SeparateRegister, "", "(CurrentList.Register = &RegisterID)
		|	AND ") + "(Header0.Ref = #DataAccessKeys.#UsersAccessKey)
		|	AND (Header0.FieldsComposition = &FieldsComposition)
		|	AND (Header0.DeletionMark = FALSE)";
	Else
		Connections = ConnectionsAndFields.Joins + "
		|LEFT JOIN Catalog.AccessKeys.Header AS Header?
		|ON " + ?(Context.SeparateRegister, "", "(CurrentList.Register = &RegisterID)
		|	AND ") + "(Header?.Ref = #DataAccessKeys.#UsersAccessKey)
		|	AND (Header?.LineNumber = " + HeaderNumber + ")";
	EndIf;
	
	Connections = TrimL(Connections) + TextWithIndent(ConnectionsAndFields.Fields, "	");
	Connections = TextWithIndent(Connections, "		");
	
	Condition = "NOT Header?.Ref IS NULL";
	Condition = TextWithIndent(Condition, "	");
	
	ConditionPartTextTemplate =
	"NOT TRUE IN
	|(SELECT TOP 1
	|	TRUE
	|FROM
	|	(SELECT
	|		TRUE AS TrueValue) AS TrueValue
	|		#Joins
	|WHERE
	|	#Condition)";
	
	ConditionPartText = ConditionPartTextTemplate;
	ConditionPartText = StrReplace(ConditionPartText, "#Joins", Connections);
	ConditionPartText = StrReplace(ConditionPartText, "#Condition",    Condition);
	
	ConditionPartText = StrReplace(ConditionPartText, "Header?", "Header" + HeaderNumber);
	Context.CheckConditionParts.Add(ConditionPartText);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeyTabularSectionCheck(Context, KeyTabularSectionNumber)
	
	TablesByGroups  = Context.AdditionalTablesGroups.TablesByGroups;
	AdditionalTablesGroup = TablesByGroups.Get(KeyTabularSectionNumber);
	
	KeyTabularSectionName = "TabularSection" + KeyTabularSectionNumber;
	FieldsGroup = Context.FieldsGroups.Get(KeyTabularSectionName);
	
	ConnectionsAndFieldsByTables = ConnectionsAndFieldsByTables(FieldsGroup,
		True, , , OneAdditionalTableWithFieldsInGroup(Context, AdditionalTablesGroup));
	
	Connections = "";
	Condition = "";
	Fields = "";
	
	If AdditionalTablesGroup = Undefined Then
		ObjectTabularSectionAlias = Context.ObjectTabularSectionsAliases.Get(KeyTabularSectionNumber);
		ObjectTabularSectionName = StrReplace(ObjectTabularSectionAlias, "CurrentList", "");
		ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(ObjectTabularSectionAlias);
		Connections = Connections + "
		|LEFT JOIN &CurrentList." + ObjectTabularSectionName + " AS " + ObjectTabularSectionAlias + "
		|ON " + ObjectTabularSectionAlias + ".Ref = CurrentList.Ref"
		+ ConnectionsAndFields.Joins;
		Condition = ObjectTabularSectionAlias + ".Ref #CheckNULL";
		Fields = ConnectionsAndFields.Fields;
	Else
		For Each AdditionalTable In AdditionalTablesGroup Do
			Connections = Connections + "
			|LEFT JOIN " + AdditionalTable.Table + " AS " + AdditionalTable.Alias + "
			|ON " + ?(Context.SeparateRegister, "", "(CurrentList.Register = &RegisterID)
			|	AND ") + TextWithIndent(AdditionalTable.ConnectionConditionText, "	");
			ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(AdditionalTable.Alias);
			If ConnectionsAndFields = Undefined Then
				Continue;
			EndIf;
			Connections = Connections + ConnectionsAndFields.Joins;
			Condition = Condition + ?(Condition = "", "", "
			|OR ") + AdditionalTable.ConnectionTestField + " #CheckNULL";
			Fields = Fields + ConnectionsAndFields.Fields;
		EndDo;
		If StrLineCount(Condition) > 1 Then
			Condition = "(" + Condition + ")";
		EndIf;
	EndIf;
	InitialConnections = Connections;
	InitialCondition = Condition;
	
	ConditionPartTextTemplate =
	"FALSE IN
	|(SELECT TOP 1
	|	FALSE
	|FROM
	|	(SELECT
	|		TRUE AS TrueValue) AS TrueValue
	|		#Joins
	|WHERE
	|	#Condition)";
	
	// Direct connection (checking if required records are in the key).
	Connections = InitialConnections + "
	|LEFT JOIN Catalog.AccessKeys.TabularSection? AS TabularSection?
	|ON (TabularSection?.Ref = #DataAccessKeys.#UsersAccessKey)";
	Connections = TrimL(Connections) + TextWithIndent(Fields, "	");
	Connections = TextWithIndent(Connections, "		");
	
	Condition =
	"TabularSection?.Ref IS NULL
	|AND " + TextWithIndent(TrimL(InitialCondition), "	");
	Condition = TextWithIndent(Condition, "	");
	Condition = StrReplace(Condition, "#CheckNULL", "IS NOT NULL");
	
	ConditionPartText = ConditionPartTextTemplate;
	ConditionPartText = StrReplace(ConditionPartText, "#Joins",     Connections);
	ConditionPartText = StrReplace(ConditionPartText, "#Condition",        Condition);
	ConditionPartText = StrReplace(ConditionPartText, "TabularSection?", KeyTabularSectionName);
	Context.CheckConditionParts.Add(ConditionPartText);
	
	// Reversed connection (checking if there are excess records in the key).
	If AdditionalTablesGroup = Undefined
	 Or AdditionalTablesGroup.Count() = 1 Then
		
		Connections =
		"LEFT JOIN Catalog.AccessKeys.TabularSection? AS TabularSection?
		|ON " + ?(Context.SeparateRegister, "", "(CurrentList.Register = &RegisterID)
		|	AND ") + "(TabularSection?.Ref = #DataAccessKeys.#UsersAccessKey)";
		
		If AdditionalTablesGroup = Undefined Then
			Connections = Connections + "
			|LEFT JOIN &CurrentList." + ObjectTabularSectionName + " AS " + ObjectTabularSectionAlias
				  + TextWithIndent(ConnectionsAndFields.Joins, "	") + "
			|ON " + ObjectTabularSectionAlias + ".Ref = CurrentList.Ref"
			      + TextWithIndent(ConnectionsAndFields.Fields, "	");
		Else
			AdditionalTable = AdditionalTablesGroup[0];
			ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(AdditionalTable.Alias);
			Connections = Connections + "
			|LEFT JOIN " + AdditionalTable.Table + " AS " + AdditionalTable.Alias
				  + TextWithIndent(ConnectionsAndFields.Joins, "	") + "
			|ON " + TextWithIndent(AdditionalTable.ConnectionConditionText, "	")
			      + TextWithIndent(ConnectionsAndFields.Fields, "	");
		EndIf;
		Connections = TextWithIndent(Connections, "		");
		
		Condition =
		"TabularSection?.Ref IS NOT NULL
		|AND " + TrimL(InitialCondition);
		Condition = TextWithIndent(Condition, "	");
		Condition = StrReplace(Condition, "#CheckNULL", "IS NULL");
	Else
		Connections =
		"LEFT JOIN Catalog.AccessKeys.TabularSection? AS TabularSection?
		|ON " + ?(Context.SeparateRegister, "", "(CurrentList#.Register = &RegisterID)
		|	AND ") + "(TabularSection?.Ref = #DataAccessKeys.#UsersAccessKey)
		|LEFT JOIN &CurrentList AS CurrentListSource"
			+ TextWithIndent(InitialConnections, "	") + "
		|ON " + ?(Context.IsReferenceType, "(CurrentListSource.Ref = CurrentList#.Ref)",
			Context.BasicFields.ConnectionCondition);
		
		Connections = Connections + TextWithIndent(Fields, "	");
		Connections = TextWithIndent(Connections, "		");
		Connections = StrReplace(Connections, "CurrentList.", "CurrentListSource.");
		Connections = StrReplace(Connections, "CurrentList#.", "CurrentList.");
		
		If Context.IsReferenceType Then
			Condition =
			"TabularSection?.Ref IS NOT NULL
			|AND CurrentListSource.Ref IS NULL";
		Else
			Condition =
			"TabularSection?.Ref IS NOT NULL
			|AND CurrentListSource.Field1 IS NULL";
		EndIf;
		Condition = TextWithIndent(Condition, "	");
	EndIf;
	
	ConditionPartText = ConditionPartTextTemplate;
	ConditionPartText = StrReplace(ConditionPartText, "#Joins",     Connections);
	ConditionPartText = StrReplace(ConditionPartText, "#Condition",        Condition);
	ConditionPartText = StrReplace(ConditionPartText, "TabularSection?", KeyTabularSectionName);
	Context.CheckConditionParts.Add(ConditionPartText);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeyHeaderFilling(Context, HeaderNumber)
	
	If Not Context.IsReferenceType AND HeaderNumber = 0 Then
		QueryText =
		"SELECT
		|	CurrentList.CurrentRef AS CurrentRef,
		|	" + Context.BasicFields.ForSelection + "
		|	INTO CurrentList
		|FROM
		|	&BasicFieldsValues AS CurrentList";
		Context.PartsOfValuesFromObjectsQuery.Add(QueryText);
	EndIf;
	
	FieldsGroup = Context.FieldsGroups.Get("Header" + HeaderNumber);
	If FieldsGroup = Undefined Then
		Return;
	EndIf;
	AddKeyTableDetails("Header" + HeaderNumber, FieldsGroup, Context);
	
	ConnectionsAndFields = ConnectionsAndFieldsByTables(FieldsGroup, False,
		HeaderNumber, True).Get("CurrentList");
	
	// Selecting values from objects to search and create access keys.
	If Context.IsReferenceType Then
		QueryText =
		"SELECT
		|	CurrentList.Ref AS CurrentRef" + TextWithIndent(ConnectionsAndFields.Fields, "	") + "
		|FROM
		|	&CurrentList AS CurrentList" + TextWithIndent(ConnectionsAndFields.Joins, "	") + "
		|WHERE
		|	CurrentList.Ref IN (&ObjectsRefs)
		|
		|ORDER BY
		|	CurrentRef
		|TOTALS BY
		|	CurrentRef";
	Else
		QueryText =
		"SELECT
		|	CurrentList.CurrentRef AS CurrentRef" + TextWithIndent(ConnectionsAndFields.Fields, "	") + "
		|FROM
		|	CurrentList AS CurrentList" + TextWithIndent(ConnectionsAndFields.Joins, "	") + "
		|
		|ORDER BY
		|	CurrentRef, " + Context.BasicFields.ForOrdering + "
		|TOTALS BY
		|	CurrentRef";
	EndIf;
	
	Context.PartsOfValuesFromObjectsQuery.Add(QueryText);
	
	// Selecting values from access keys to compare with the required key values.
	If HeaderNumber = 0 Then
		QueryText =
		"SELECT
		|	Header0.Ref AS CurrentRef" + TextWithIndent(ConnectionsAndFields.Attributes, "	") + "
		|FROM
		|	Catalog.AccessKeys AS Header0
		|WHERE
		|	Header0.Hash IN(&Hashes)
		|	AND Header0.List = &List
		|	AND Header0.FieldsComposition = &FieldsComposition
		|	AND Header0.ForExternalUsers = &ForExternalUsers
		|	AND Header0.DeletionMark = FALSE
		|
		|ORDER BY
		|	CurrentRef
		|TOTALS BY
		|	CurrentRef";
	Else
		QueryText =
		"SELECT
		|	Header?.Ref AS CurrentRef" + TextWithIndent(ConnectionsAndFields.Attributes, "	") + "
		|FROM
		|	Catalog.AccessKeys.Header AS Header?
		|WHERE
		|	Header?.LineNumber = " + HeaderNumber + "
		|	AND Header?.Ref.Hash IN(&Hashes)
		|	AND Header?.Ref.List = &List
		|	AND Header?.Ref.FieldsComposition = &FieldsComposition
		|	AND Header?.Ref.ForExternalUsers = &ForExternalUsers
		|	AND Header?.Ref.DeletionMark = FALSE
		|
		|ORDER BY
		|	CurrentRef
		|TOTALS BY
		|	CurrentRef";
	EndIf;
	
	QueryText = StrReplace(QueryText, "Header?", "Header" + HeaderNumber);
	Context.PartsOfValuesFromObjectsQueryToCompare.Add(QueryText);
	
	// Selecting values from access keys to calculate users and access groups, to which they are allowed.
	If HeaderNumber = 0 Then
		QueryText =
		"SELECT TOP " + BatchSizeMarker() + "
		|	AccessKeys.Ref AS Ref
		|INTO KeysBatch
		|FROM
		|	Catalog.AccessKeys AS AccessKeys
		|WHERE
		|	AccessKeys.List = &List
		|	AND AccessKeys.FieldsComposition = &FieldsComposition
		|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
		|	AND AccessKeys.DeletionMark = FALSE
		|	AND AccessKeys.Ref > &LastAccessKey
		|
		|INDEX BY
		|	Ref";
		Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	EndIf;
	
	If HeaderNumber = 0 Then
		QueryText =
		"SELECT
		|	KeysBatch.Ref AS Ref" + TextWithIndent(ConnectionsAndFields.Attributes, "	") + "
		|FROM
		|	KeysBatch AS KeysBatch
		|	LEFT JOIN Catalog.AccessKeys AS Header0
		|	ON
		|		Header0.Ref = KeysBatch.Ref
		|
		|ORDER BY
		|	Ref
		|TOTALS BY
		|	Ref";
	Else
		QueryText =
		"SELECT
		|	KeysBatch.Ref AS Ref" + TextWithIndent(ConnectionsAndFields.Attributes, "	") + "
		|FROM
		|	KeysBatch AS KeysBatch
		|	LEFT JOIN Catalog.AccessKeys.Header AS Header?
		|	ON
		|		Header?.Ref = KeysBatch.Ref
		|		AND Header?.LineNumber = " + HeaderNumber + "
		|
		|ORDER BY
		|	Ref
		|TOTALS BY
		|	Ref";
	EndIf;
	
	QueryText = StrReplace(QueryText, "Header?", "Header" + HeaderNumber);
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
	// The filter condition of leading access key rights.
	AddRightsFilterConditionForKeyHeader(Context, FieldsGroup, HeaderNumber, "ForLeadingKeys");
	
	// The filter condition of leading list rights.
	AddRightsFilterConditionForKeyHeader(Context, FieldsGroup, HeaderNumber, "ForLeadingLists");
	
	// The filter condition of rights by right setting owners.
	AddRightsFilterConditionForKeyHeader(Context, FieldsGroup, HeaderNumber, "ForRightSettingsOwners");
	
EndProcedure

// For the AddKeyHeaderFilling procedure.
Procedure AddRightsFilterConditionForKeyHeader(Context, FieldsGroup, HeaderNumber, ConditionAssignment)
	
	// The selection condition of leading access key rights.
	For Each FieldProperties In FieldsGroup Do
		If ConditionAssignment = "ForLeadingKeys"
		   AND FieldProperties.AccessKeySavingTypes.Count() = 0
		 Or ConditionAssignment = "ForLeadingLists"
		   AND Not FieldProperties.HasHeadListType
		 Or ConditionAssignment = "ForRightSettingsOwners"
		   AND Not FieldProperties.HasRightsSettingsOwnerType Then
			Continue;
		EndIf;
		
		If ConditionAssignment = "ForLeadingLists"
		   AND FieldProperties.ValueSavingTypes.Count() > 0 Then
			
			Context.Insert("HeadListsWithTypesRightsSelectionCriteriaParts");
			FilterCriterion =
			"#FieldToCheck IN
			|				(SELECT
			|					ISNULL(ConfigurationTypes.Ref, ISNULL(ExtensionTypes.Ref, Header?.Attribute?))
			|				FROM
			|					KeysBatch AS KeysBatch
			|						LEFT JOIN Catalog.AccessKeys AS Header?
			|						ON
			|							Header?.Ref = KeysBatch.Ref
			|							
			|						LEFT JOIN Catalog.MetadataObjectIDs AS ConfigurationTypes
			|						ON
			|							Header?.Attribute? <> UNDEFINED
			|							AND VALUETYPE(Header?.Attribute?) <> TYPE(Catalog.MetadataObjectIDs)
			|							AND VALUETYPE(Header?.Attribute?) <> TYPE(Catalog.ExtensionObjectIDs)
			|							AND VALUETYPE(ConfigurationTypes.EmptyRefValue) = VALUETYPE(Header?.Attribute?)
			|							
			|						LEFT JOIN Catalog.ExtensionObjectIDs AS ExtensionTypes
			|						ON
			|							Header?.Attribute? <> UNDEFINED
			|							AND VALUETYPE(ExtensionTypes.EmptyRefValue) = VALUETYPE(Header?.Attribute?))";
		Else
			FilterCriterion =
			"#FieldToCheck IN
			|				(SELECT
			|					Header?.Attribute?
			|				FROM
			|					KeysBatch AS KeysBatch
			|						LEFT JOIN Catalog.AccessKeys AS Header?
			|						ON
			|							Header?.Ref = KeysBatch.Ref)";
		EndIf;
		If HeaderNumber > 0 Then
			FilterCriterion = StrReplace(FilterCriterion,
				"Catalog.AccessKeys AS Header?", "Catalog.AccessKeys.Header AS Header?");
			FilterCriterion = StrReplace(FilterCriterion,
				"Header?.Ref = KeysBatch.Ref", TextWithIndent(
				"Header?.Ref = KeysBatch.Ref
				|	AND Header?.LineNumber = " + HeaderNumber, "							"));
		EndIf;
		FilterCriterion = StrReplace(FilterCriterion, "Header?", "Header" + HeaderNumber);
		FilterCriterion = StrReplace(FilterCriterion, "Attribute?", FieldProperties.AccessKeyFieldsGroupAttributeName);
		
		If ConditionAssignment = "ForLeadingKeys" Then
			Context.ConditionPartsToSelectLeadingAccessKeysRights.Add(FilterCriterion);
			
		ElsIf ConditionAssignment = "ForLeadingLists" Then
			Context.ConditionPartsToSelectLeadingListsRights.Add(FilterCriterion);
		Else
			Context.ConditionPartsToSelectRightsByRightsSettingsOwners.Add(FilterCriterion);
		EndIf;
	EndDo;
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeysChoiceWithoutFieldsInHeader(Context)
	
	If Context.FieldsGroups.Get("Header0") <> Undefined Then
		Return;
	EndIf;
	
	// Selecting values from access keys to compare with the required key values.
	QueryText =
	"SELECT
	|	AccessKeys.Ref AS CurrentRef
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|WHERE
	|	AccessKeys.Hash IN(&Hashes)
	|	AND AccessKeys.List = &List
	|	AND AccessKeys.FieldsComposition = &FieldsComposition
	|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
	|	AND AccessKeys.DeletionMark = FALSE
	|
	|ORDER BY
	|	CurrentRef";
	
	Context.PartsOfValuesFromObjectsQueryToCompare.Add(QueryText);
	
	// Selecting values from access keys to calculate users and access groups, to which they are allowed.
	QueryText =
	"SELECT TOP " + BatchSizeMarker() + "
	|	AccessKeys.Ref AS Ref
	|INTO KeysBatch
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|WHERE
	|	AccessKeys.List = &List
	|	AND AccessKeys.FieldsComposition = &FieldsComposition
	|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
	|	AND AccessKeys.DeletionMark = FALSE
	|	AND AccessKeys.Ref > &LastAccessKey
	|
	|INDEX BY
	|	Ref";
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeyTabularSectionFilling(Context, KeyTabularSectionNumber)
	
	TablesByGroups  = Context.AdditionalTablesGroups.TablesByGroups;
	AdditionalTablesGroup = TablesByGroups.Get(KeyTabularSectionNumber);
	
	KeyTabularSectionName = "TabularSection" + KeyTabularSectionNumber;
	FieldsGroup = Context.FieldsGroups.Get(KeyTabularSectionName);
	
	AddKeyTableDetails(KeyTabularSectionName, FieldsGroup, Context);
	
	ConnectionsAndFieldsByTables = ConnectionsAndFieldsByTables(FieldsGroup,
		True, , True, OneAdditionalTableWithFieldsInGroup(Context, AdditionalTablesGroup));
	
	// Selecting values from objects to search and create access keys.
	If AdditionalTablesGroup = Undefined Then
		ObjectTabularSectionAlias = Context.ObjectTabularSectionsAliases.Get(KeyTabularSectionNumber);
		ObjectTabularSectionName = StrReplace(ObjectTabularSectionAlias, "CurrentList", "");
		ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(ObjectTabularSectionAlias);
		SelectionFields = TextWithIndent(ConnectionsAndFields.Fields, "	");
		Connections = TextWithIndent(ConnectionsAndFields.Joins, "	");
		OrderingFields = ConnectionsAndFields.OrderingFields;
		Attributes        = ConnectionsAndFields.Attributes;
		QueryText =
		"SELECT DISTINCT
		|	" + ObjectTabularSectionAlias + ".Ref AS CurrentRef" + SelectionFields + "
		|FROM
		|	&CurrentList." + ObjectTabularSectionName + " AS " + ObjectTabularSectionAlias + Connections + "
		|WHERE
		|	" + ObjectTabularSectionAlias + ".Ref IN (&ObjectsRefs)
		|
		|ORDER BY
		|	CurrentRef" + OrderingFields + "
		|TOTALS BY
		|	CurrentRef";
	Else
		SelectionFields = "";
		Connections = "";
		Condition = "";
		OrderingFields = "";
		Attributes = "";
		For Each AdditionalTable In AdditionalTablesGroup Do
			ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(AdditionalTable.Alias);
			Connections = Connections + "
			|LEFT JOIN " + AdditionalTable.Table + " AS " + AdditionalTable.Alias + "
			|ON " + TextWithIndent(AdditionalTable.ConnectionConditionText, "	");
			If ConnectionsAndFields = Undefined Then
				Continue;
			EndIf;
			Connections = Connections + ConnectionsAndFields.Joins;
			Condition = Condition + ?(Condition = "", "", "
			|OR ") + AdditionalTable.ConnectionTestField + " IS NOT NULL";
			SelectionFields       = SelectionFields       + ConnectionsAndFields.Fields;
			OrderingFields = OrderingFields + ConnectionsAndFields.OrderingFields;
			Attributes        = Attributes        + ConnectionsAndFields.Attributes;
		EndDo;
		If StrLineCount(Condition) > 1 Then
			Condition = "(" + Condition + ")";
		EndIf;
		If Context.IsReferenceType Then
			QueryText =
			"SELECT DISTINCT
			|	CurrentList.Ref AS CurrentRef" + TextWithIndent(SelectionFields, "	") + "
			|FROM
			|	&CurrentList AS CurrentList" + TextWithIndent(Connections, "	") + "
			|WHERE
			|	CurrentList.Ref IN (&ObjectsRefs)
			|	AND " + TextWithIndent(Condition, "	") + "
			|
			|ORDER BY
			|	CurrentRef" + OrderingFields + "
			|TOTALS BY
			|	CurrentRef";
		Else
			QueryText =
			"SELECT
			|	CurrentList.CurrentRef AS CurrentRef"  + TextWithIndent(SelectionFields, "	") + "
			|FROM
			|	CurrentList AS CurrentList" + TextWithIndent(Connections, "	") + "
			|WHERE
			|	" + TextWithIndent(Condition, "	") + "
			|
			|ORDER BY
			|	CurrentRef, " + Context.BasicFields.ForOrdering + OrderingFields + "
			|TOTALS BY
			|	CurrentRef";
		EndIf;
	EndIf;
	
	Context.PartsOfValuesFromObjectsQuery.Add(QueryText);
	
	// Selecting values from access keys to compare with the required key values.
	QueryText =
	"SELECT
	|	TabularSection?.Ref AS CurrentRef" + TextWithIndent(Attributes, "	") + "
	|FROM
	|	Catalog.AccessKeys.TabularSection? AS TabularSection?
	|WHERE
	|	TabularSection?.Ref.Hash IN(&Hashes)
	|	AND TabularSection?.Ref.List = &List
	|	AND TabularSection?.Ref.FieldsComposition = &FieldsComposition
	|	AND TabularSection?.Ref.ForExternalUsers = &ForExternalUsers
	|	AND TabularSection?.Ref.DeletionMark = FALSE
	|
	|ORDER BY
	|	CurrentRef" + OrderingFields + "
	|TOTALS BY
	|	CurrentRef";
	
	QueryText = StrReplace(QueryText, "TabularSection?", "TabularSection" + KeyTabularSectionNumber);
	Context.PartsOfValuesFromObjectsQueryToCompare.Add(QueryText);
	
	// Selecting values from access keys to calculate users and access groups, to which they are allowed.
	QueryText =
	"SELECT
	|	KeysBatch.Ref AS Ref" + TextWithIndent(Attributes, "	") + "
	|FROM
	|	KeysBatch AS KeysBatch
	|	LEFT JOIN Catalog.AccessKeys.TabularSection? AS TabularSection?
	|	ON
	|		TabularSection?.Ref = KeysBatch.Ref
	|
	|ORDER BY
	|	Ref
	|TOTALS BY
	|	Ref";
	
	QueryText = StrReplace(QueryText, "TabularSection?", "TabularSection" + KeyTabularSectionNumber);
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
	// The filter condition of leading access key rights.
	AddRightsFilterConditionForKeyTabularSection(Context,
		FieldsGroup, KeyTabularSectionNumber, "ForLeadingKeys");
	
	// The filter condition of leading list rights.
	AddRightsFilterConditionForKeyTabularSection(Context,
		FieldsGroup, KeyTabularSectionNumber, "ForLeadingLists");
	
	// The filter condition of rights by right setting owners.
	AddRightsFilterConditionForKeyTabularSection(Context,
		FieldsGroup, KeyTabularSectionNumber, "ForRightSettingsOwners");
	
EndProcedure

// For the AddKeyTabularSectionFilling procedure.
Procedure AddRightsFilterConditionForKeyTabularSection(Context, FieldsGroup,
			KeyTabularSectionNumber, ConditionAssignment)
	
	For Each FieldProperties In FieldsGroup Do
		If ConditionAssignment = "ForLeadingKeys"
		   AND FieldProperties.AccessKeySavingTypes.Count() = 0
		 Or ConditionAssignment = "ForLeadingLists"
		   AND Not FieldProperties.HasHeadListType
		 Or ConditionAssignment = "ForRightSettingsOwners"
		   AND Not FieldProperties.HasRightsSettingsOwnerType Then
			Continue;
		EndIf;
		
		If ConditionAssignment = "ForLeadingLists"
		   AND FieldProperties.ValueSavingTypes.Count() > 0 Then
			
			Context.Insert("HeadListsWithTypesRightsSelectionCriteriaParts");
			FilterCriterion =
			"#FieldToCheck IN
			|				(SELECT
			|					ISNULL(ConfigurationTypes.Ref, ISNULL(ExtensionTypes.Ref, TabularSection?.Attribute?))
			|				FROM
			|					KeysBatch AS KeysBatch
			|						LEFT JOIN Catalog.AccessKeys.TabularSection? AS TabularSection?
			|						ON
			|							TabularSection?.Ref = KeysBatch.Ref
			|							
			|						LEFT JOIN Catalog.MetadataObjectIDs AS ConfigurationTypes
			|						ON
			|							TabularSection?.Attribute? <> UNDEFINED
			|							AND VALUETYPE(TabularSection?.Attribute?) <> TYPE(Catalog.MetadataObjectIDs)
			|							AND VALUETYPE(TabularSection?.Attribute?) <> TYPE(Catalog.ExtensionObjectIDs)
			|							AND VALUETYPE(ConfigurationTypes.EmptyRefValue) = VALUETYPE(TabularSection?.Attribute?)
			|							
			|						LEFT JOIN Catalog.ExtensionObjectIDs AS ExtensionTypes
			|						ON
			|							TabularSection?.Attribute? <> UNDEFINED
			|							AND VALUETYPE(ExtensionTypes.EmptyRefValue) = VALUETYPE(TabularSection?.Attribute?))";
		Else
			FilterCriterion =
			"#FieldToCheck IN
			|				(SELECT
			|					TabularSection?.Attribute?
			|				FROM
			|					KeysBatch AS KeysBatch
			|						LEFT JOIN Catalog.AccessKeys.TabularSection? AS TabularSection?
			|						ON
			|							TabularSection?.Ref = KeysBatch.Ref)";
		EndIf;
		
		FilterCriterion = StrReplace(FilterCriterion, "TabularSection?", "TabularSection" + KeyTabularSectionNumber);
		FilterCriterion = StrReplace(FilterCriterion, "Attribute?", FieldProperties.AccessKeyFieldsGroupAttributeName);
		
		If ConditionAssignment = "ForLeadingKeys" Then
			Context.ConditionPartsToSelectLeadingAccessKeysRights.Add(FilterCriterion);
			
		ElsIf ConditionAssignment = "ForLeadingLists" Then
			Context.ConditionPartsToSelectLeadingListsRights.Add(FilterCriterion);
		Else
			Context.ConditionPartsToSelectRightsByRightsSettingsOwners.Add(FilterCriterion);
		EndIf;
	EndDo;
	
EndProcedure

// For the AddKeyHeaderFilling and AddKeyTabularSectionFilling procedures.
Procedure AddKeyTableDetails(KeyTableName, FieldsGroup, Context)
	
	KeyTableFields = New Array;
	
	For Each FieldProperties In FieldsGroup Do
		KeyTableFields.Add(FieldProperties.AccessKeyFieldsGroupAttributeName);
	EndDo;
	
	Context.KeyTables.Add(KeyTableName);
	Context.KeyTablesAttributes.Insert(KeyTableName, KeyTableFields);
	
EndProcedure

// For the AddKeyHeaderCheck and AddKeyTabularSectionCheck procedures.
Function ConnectionsAndFieldsByTables(FieldsGroup, KeyTabularSection, HeaderNumber = 0, ForValuesSelection = False,
			OneAdditionalTableWithFieldsInGroup = False)
	
	ConnectionsAndFieldsByTables = New Map;
	AttributeNumber = 1 + ?(HeaderNumber = 0, 0, 5);
	
	For Each FieldProperties In FieldsGroup Do
		
		ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(FieldProperties.TableAlias);
		If ConnectionsAndFields = Undefined Then
			ConnectionsAndFields = New Structure;
			ConnectionsAndFields.Insert("Joins",       "");
			ConnectionsAndFields.Insert("Fields",             "");
			ConnectionsAndFields.Insert("OrderingFields", "");
			ConnectionsAndFields.Insert("Attributes",        "");
			ConnectionsAndFieldsByTables.Insert(FieldProperties.TableAlias, ConnectionsAndFields);
		EndIf;
		
		Connections = "";
		If FieldProperties.AccessKeySavingTypes.Count() > 0 Then
			Connections = Connections + "
			|LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects?
			|ON (AccessKeysForObjects?.Object = #FieldNameForQuery)";
		EndIf;
		
		If FieldProperties.ValueGroupSavingTypes.Count() > 0 Then
			If Not FieldProperties.IsAccessValueListWithValueGroups Then
				Connections = Connections + "
				|LEFT JOIN InformationRegister.AccessValuesGroups AS ValueGroups?
				|ON (ValueGroups?.AccessValue = #FieldNameForQuery)
				|	AND (ValueGroups?.DataGroup = 0)";
			ElsIf FieldProperties.MultipleValuesGroups Then
				Connections = Connections + "
				|LEFT JOIN &CurrentList.AccessGroups AS ValueGroups?
				|ON (ValueGroups?.Ref = #FieldNameForQuery)";
			EndIf;
		EndIf;
		
		If FieldProperties.ConfigurationTypeSavingTypes.Count() > 0 Then
			Connections = Connections + "
			|LEFT JOIN Catalog.MetadataObjectIDs AS ConfigurationTypes?
			|ON (#FieldNameForQuery <> UNDEFINED)
			|	AND (VALUETYPE(ConfigurationTypes?.EmptyRefValue) = VALUETYPE(#FieldNameForQuery))";
		EndIf;
		
		If FieldProperties.ExtensionTypeSavingTypes.Count() > 0 Then
			Connections = Connections + "
			|LEFT JOIN Catalog.ExtensionObjectIDs AS ExtensionTypes?
			|ON (#FieldNameForQuery <> UNDEFINED)
			|	AND (VALUETYPE(ExtensionTypes?.EmptyRefValue) = VALUETYPE(#FieldNameForQuery))";
		EndIf;
		
		Field = FieldComparison(FieldProperties, OneAdditionalTableWithFieldsInGroup);
		
		If ForValuesSelection Then
			Field = StrReplace(Field, "Header?.Value? = ", "");
			Field = StrReplace(Field, "						", "			");
			Field = "," + Chars.LF + Mid(Field, 5, StrLen(Field) - 5) + " AS Value?";
			
			ConnectionsAndFields.OrderingFields = ConnectionsAndFields.OrderingFields
				+ ", " + "Value" + AttributeNumber;
			
			ConnectionsAndFields.Attributes  = ConnectionsAndFields.Attributes + ",
			|Header?.Value"  + AttributeNumber + " AS Value" + AttributeNumber;
		EndIf;
		
		FillAliasByAttributeNumber(Connections, Field, AttributeNumber, "Value?");
		FillAliasByAttributeNumber(Connections, Field, AttributeNumber, "ValueGroups?");
		FillAliasByAttributeNumber(Connections, Field, AttributeNumber, "AccessKeysForObjects?");
		FillAliasByAttributeNumber(Connections, Field, AttributeNumber, "ConfigurationTypes?");
		FillAliasByAttributeNumber(Connections, Field, AttributeNumber, "ExtensionTypes?");
		
		Connections = StrReplace(Connections, "#FieldNameForQuery", FieldProperties.FieldNameForQuery);
		Field       = StrReplace(Field,       "#FieldNameForQuery", FieldProperties.FieldNameForQuery);
		
		If KeyTabularSection Then
			Field = StrReplace(Field, "Header?", "TabularSection?");
			ConnectionsAndFields.Attributes = StrReplace(ConnectionsAndFields.Attributes, "Header?", "TabularSection?");
		EndIf;
		
		ConnectionsAndFields.Joins = ConnectionsAndFields.Joins + Connections;
		ConnectionsAndFields.Fields       = ConnectionsAndFields.Fields       + Field;
		AttributeNumber = AttributeNumber + 1;
	EndDo;
	
	Return ConnectionsAndFieldsByTables;
	
EndFunction

// For the ConnectionsAndFieldsByTables function.
Function OneAdditionalTableWithFieldsInGroup(Context, AdditionalTablesGroup)
	
	If AdditionalTablesGroup = Undefined Then
		Return False;
	EndIf;
	
	If AdditionalTablesGroup.Count() = 1 Then
		Return True;
	EndIf;
	
	TablesWithFiledsAliases = Context.AdditionalTablesGroups.TablesWithFiledsAliases;
	
	AdditionalTablesWithFieldsCount = 0;
	For Each AdditionalTable In AdditionalTablesGroup Do
		If TablesWithFiledsAliases.Get(AdditionalTable.Alias) = Undefined Then
			Continue;
		EndIf;
		AdditionalTablesWithFieldsCount = AdditionalTablesWithFieldsCount + 1;
	EndDo;
	
	Return AdditionalTablesWithFieldsCount = 1;
	
EndFunction

// For the ConnectionsAndFieldsByTables function.
Function FieldComparison(FieldProperties, OneAdditionalTableWithFieldsInGroup)
	
	FieldTypesCount = FieldProperties.EndFieldType.Types().Count();
	
	WithoutUndefinedValue = FieldTypesCount = 1;
	If FieldProperties.Property("NoNullValue") Then
		NoNullValue = FieldProperties.NoNullValue;
	Else
		NoNullValue = NoNullValue(FieldProperties, OneAdditionalTableWithFieldsInGroup);
	EndIf;
	
	WithoutClarificationUndefined = Not FieldProperties.HasAdjustmentUndefined Or WithoutUndefinedValue;
	WithoutClarificationNull         = Not FieldProperties.HasAdjustmentNull         Or NoNullValue;
	
	// Saving access keys only.
	If FieldProperties.EmptyRefSavingTypes.Count() = 0
	   AND WithoutClarificationUndefined
	   AND WithoutClarificationNull
	   AND FieldProperties.AccessKeySavingTypes.Count() = FieldTypesCount Then
		Return "
		|AND (Header?.Value? = ISNULL(AccessKeysForObjects?.#ObjectUserAccessKey,
		|						VALUE(Enum.AdditionalAccessValues.Null)))";
	EndIf;
	
	// Saving access value groups only.
	If FieldProperties.EmptyRefSavingTypes.Count() = 0
	   AND WithoutClarificationUndefined
	   AND WithoutClarificationNull
	   AND FieldProperties.ValueGroupSavingTypes.Count() = FieldTypesCount Then
		
		If Not FieldProperties.IsAccessValueListWithValueGroups Then
			Return "
			|AND (Header?.Value? = ISNULL(ValueGroups?.AccessValuesGroup,
			|						VALUE(Enum.AdditionalAccessValues.Null)))";
		ElsIf FieldProperties.MultipleValuesGroups Then
			Return "
			|AND (Header?.Value? = ISNULL(ValueGroups?.AccessGroup,
			|						VALUE(Enum.AdditionalAccessValues.Null)))";
		Else
			Return "
			|AND (Header?.Value? = ISNULL(CurrentList.AccessGroup,
			|						VALUE(Enum.AdditionalAccessValues.Null)))";
		EndIf;
	EndIf;
	
	// Saving values only.
	If Not HasSimpleType(FieldProperties.EndFieldType)
	   AND FieldProperties.ValueSavingTypes.Count() = FieldTypesCount Then
		
		If NoNullValue Then
			Return "
			|AND (Header?.Value? = #FieldNameForQuery)";
		Else
			Return "
			|AND (Header?.Value? = ISNULL(#FieldNameForQuery,
			|						VALUE(Enum.AdditionalAccessValues.Null)))";
		EndIf;
	EndIf;
	
	// Saving a reference type.
	If WithoutClarificationNull
	   AND FieldTypesCount = 1
	   AND FieldProperties.TypeSavingTypes.Count() = FieldTypesCount
	   AND FieldProperties.SimpleTypeSavingTypes.Count() = 0 Then
		
		If FieldProperties.ExtensionTypeSavingTypes.Count() = 0 Then
			Return "
			|AND (Header?.Value? = ISNULL(ConfigurationTypes?.Ref,
			|						VALUE(Catalog.MetadataObjectIDs.EmptyRef)))";
		ElsIf FieldProperties.ConfigurationTypeSavingTypes.Count() = 0 Then
			Return "
			|AND (Header?.Value? = ISNULL(ExtensionTypes?.Ref,
			|						VALUE(Catalog.ExtensionObjectIDs.EmptyRef)))";
		EndIf;
	EndIf;
	
	// Saving one simple type.
	If WithoutClarificationNull
	   AND FieldTypesCount = 1
	   AND FieldProperties.SimpleTypeSavingTypes.Count() = 1 Then
		
		Return "
		|AND (Header?.Value? = VALUE(Enum.AdditionalAccessValues.AllowedType))";
	EndIf;
	
	If FieldProperties.ProhibitedTypeSavingTypes.Count() = FieldTypesCount Then
		Return "
		|AND (Header?.Value? = VALUE(Enum.AdditionalAccessValues.ProhibitedType))";
	EndIf;
	
	// Saving the AllowedType value only.
	If FieldProperties.AllowedTypeSavingTypes.Count() = FieldTypesCount Then
		Return "
		|AND (Header?.Value? = VALUE(Enum.AdditionalAccessValues.AllowedType))";
	EndIf;
	
	FieldComparison = "
	|AND (CASE
	|	#SelectionContent
	|END)";
	SelectionContent = "";
	
	SaveBooleanValue = FieldProperties.ValueSavingTypes.Find(Type("Boolean")) <> Undefined;
	
	If Not NoNullValue
	   AND Not (SaveBooleanValue AND FieldTypesCount = 1) Then
		SelectionContent = SelectionContent + "
		|WHEN #FieldNameForQuery IS NULL
		|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.Null)";
	EndIf;
	If FieldTypesCount > 1 Then
		SelectionContent = SelectionContent + "
		|WHEN #FieldNameForQuery = UNDEFINED
		|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.Undefined)";
	EndIf;
	If SaveBooleanValue Then
		If FieldTypesCount > 1 Then
			SelectionContent = SelectionContent + "
			|WHEN #FieldNameForQuery
			|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.True)
			|WHEN NOT #FieldNameForQuery
			|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.False)";
		Else
			SelectionContent = SelectionContent + "
			|WHEN #FieldNameForQuery
			|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.True)
			|ELSE Header?.Value? = VALUE(Enum.AdditionalAccessValues.False)";
		EndIf;
	EndIf;
	
	ChecksByTypes = New ValueList;
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.SimpleTypeSavingTypes,
		"Header?.Value? = VALUE(Enum.AdditionalAccessValues.AllowedType)");
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.AccessKeySavingTypes,
		"Header?.Value? = ISNULL(AccessKeysForObjects?.#ObjectUserAccessKey,
		|					VALUE(Enum.AdditionalAccessValues.Null))");
	
	If Not FieldProperties.IsAccessValueListWithValueGroups Then
		AddCheckByTypes(ChecksByTypes, FieldProperties.ValueGroupSavingTypes,
			"Header?.Value? = ISNULL(ValueGroups?.AccessValuesGroup,
			|					VALUE(Enum.AdditionalAccessValues.Null))");
	ElsIf FieldProperties.MultipleValuesGroups Then
		AddCheckByTypes(ChecksByTypes, FieldProperties.ValueGroupSavingTypes,
			"Header?.Value? = ISNULL(ValueGroups?.AccessGroup,
			|					VALUE(Enum.AdditionalAccessValues.Null))");
	Else
		AddCheckByTypes(ChecksByTypes, FieldProperties.ValueGroupSavingTypes,
			"Header?.Value? = ISNULL(CurrentList.AccessGroup,
			|					VALUE(Enum.AdditionalAccessValues.Null))");
	EndIf;
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.ValueSavingTypes,
		"Header?.Value? = #FieldNameForQuery", , SaveBooleanValue);
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.EmptyRefSavingTypes,
		"Header?.Value? = VALUE(Enum.AdditionalAccessValues.EmptyRefAnyType)",
		"IsEmptyRefCheck");
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.ConfigurationTypeSavingTypes,
		"Header?.Value? = ISNULL(ConfigurationTypes?.Ref,
		|					VALUE(Catalog.MetadataObjectIDs.EmptyRef))");
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.ExtensionTypeSavingTypes,
		"Header?.Value? = ISNULL(ExtensionTypes?.Ref,
		|					VALUE(Catalog.ExtensionObjectIDs.EmptyRef))");
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.ProhibitedTypeSavingTypes,
		"Header?.Value? = VALUE(Enum.AdditionalAccessValues.ProhibitedType)");
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.AllowedTypeSavingTypes,
		"Header?.Value? = VALUE(Enum.AdditionalAccessValues.AllowedType)");
	
	ChecksByTypes.SortByPresentation();
	
	For Each CheckByTypes In ChecksByTypes Do
		If CheckByTypes.Value.Types.Count() = 0 Then
			Continue;
		EndIf;
		If ChecksByTypes.IndexOf(CheckByTypes) < ChecksByTypes.Count() - 1 Then
			TypesCheck = "";
			For Each Type In CheckByTypes.Value.Types Do
				If IsSimpleType(Type) Then
					TypeName = String(Type);
				Else
					TypeName = Metadata.FindByType(Type).FullName();
				EndIf;
				If TypesCheck <> "" Then
					TypesCheck = TypesCheck + "
					|			OR ";
				EndIf;
				CheckTemplate = ?(CheckByTypes.Value.Property("IsEmptyRefCheck"),
					"#FieldNameForQuery = VALUE(#TypeName.EmptyRef)",
					"VALUETYPE(#FieldNameForQuery) = TYPE(#TypeName)");
				TypesCheck = TypesCheck + StrReplace(CheckTemplate, "#TypeName", TypeName);
			EndDo;
			CheckSSL = "
			|WHEN #CheckTypes
			|	THEN #CheckSSL";
			CheckSSL = StrReplace(CheckSSL, "#CheckTypes", TypesCheck);
		Else
			CheckSSL = "
			|ELSE #CheckSSL";
		EndIf;
		CheckSSL = StrReplace(CheckSSL, "#CheckSSL", CheckByTypes.Value.CheckSSL);
		SelectionContent = SelectionContent + CheckSSL;
	EndDo;
	
	Return StrReplace(FieldComparison, "#SelectionContent", TextWithIndent(TrimL(SelectionContent), "	"));
	
EndFunction

// For the FieldComparison function.
Procedure AddCheckByTypes(ChecksByTypes, InitialTypes, CheckSSL, AdditionalProperty = "", SkipBoolean = False)
	
	Types = New Array;
	For Each Type In InitialTypes Do
		If SkipBoolean AND Type = Type("Boolean") Then
			Continue;
		EndIf;
		Types.Add(Type);
	EndDo;
	
	If Types.Count() = 0 Then
		Return;
	EndIf;
	
	Structure = New Structure("Types, CheckSSL", Types, CheckSSL);
	ChecksByTypes.Add(Structure, Format(Structure.Types.Count(), "ND=10; NLZ=; NG="));
	
	If AdditionalProperty = "" Then
		Return;
	EndIf;
	
	Structure.Insert(AdditionalProperty);
	
EndProcedure

// For the AddKeyHeaderCheck function.
Procedure FillAliasByAttributeNumber(Connections, Field, AttributeNumber, Alias)
	
	AliasWithNumber = StrReplace(Alias, "?", AttributeNumber);
	
	Connections = StrReplace(Connections, Alias, AliasWithNumber);
	Field       = StrReplace(Field,       Alias, AliasWithNumber);
	
EndProcedure

// For the AddKeyHeaderCheck and FieldComparison functions.
Function TextWithIndent(Text, Indent)
	
	Return StrReplace(Text, Chars.LF, Chars.LF + Indent);
	
EndFunction

// For the FieldComparison and AddBasicField functions.
Function HasSimpleType(TypesDetails)
	
	Return TypesDetails.ContainsType(Type("Boolean"))
	    Or TypesDetails.ContainsType(Type("Date"))
	    Or TypesDetails.ContainsType(Type("String"))
	    Or TypesDetails.ContainsType(Type("Number"))
	    Or TypesDetails.ContainsType(Type("UUID"))
	    Or TypesDetails.ContainsType(Type("ValueStorage"));
	
EndFunction

#EndRegion

#EndRegion

#Region TransformRestrictionsTextsIntoStructures

// See AccessManagement.ParsedRestriction. 
Function ParsedRestriction(MainTable, RestrictionText) Export
	
	InternalData = New Structure;
	InternalData.Insert("MainTable",  MainTable);
	InternalData.Insert("RestrictionText", TrimAll(RestrictionText));
	
	InternalData.Insert("LanguageSyntax", AccessManagementInternalCached.LanguageSyntax());
	InternalData.Insert("TablesFields",     New Map);
	InternalData.Insert("Aliases",     New Map);
	
	InternalData.Insert("AccessKeyFields", New Array);
	
	InternalData.Insert("CharsetsTable", CharsetsTable(InternalData));
	InternalData.Insert("RestrictionParts",       RestrictionParts(InternalData));
	
	Result = New Structure;
	Result.Insert("InternalData", InternalData);
	Result.Insert("TablesFields", InternalData.TablesFields);
	
	Return Result;
	
EndFunction

// See AccessManagement.RestrictionStructure. 
Function RestrictionStructure(ParsedRestriction) Export
	
	InternalData = ParsedRestriction.InternalData;
	
	MarkIncorrectFieldsTablesAndFieldsTypesNames(ParsedRestriction.TablesFields,
		InternalData);
	
	// Filling found errors.
	ErrorsDetails = New Structure;
	ErrorsDetails.Insert("HasErrors",  False);
	ErrorsDetails.Insert("ErrorsText", "");
	ErrorsDetails.Insert("Restriction", "");
	ErrorsDetails.Insert("Errors",      New Array);
	ErrorsDetails.Insert("AddOn",  "");
	
	Table = InternalData.CharsetsTable;
	FilterRowsWithoutErrors = New Structure("ErrorText", "");
	If Table.Count() <> Table.FindRows(FilterRowsWithoutErrors).Count() Then
		ErrorsDetails.HasErrors = True;
		AdditionRequired = False;
		RowNumberLength = StrLen(Format(StrLineCount(InternalData.RestrictionText), "NG="));
		For Each Row In Table Do
			If Row.ErrorText = "" Then
				Continue;
			EndIf;
			AddError(Row, ErrorsDetails, InternalData, RowNumberLength);
			If Row.ErrorPosition = -1 Then
				AdditionRequired = True;
			EndIf;
		EndDo;
		ErrorsDetails.Restriction = NumberedRestrictionTextWithErrorsMarks(
			InternalData.RestrictionText, ErrorsDetails.Errors, RowNumberLength);
		If AdditionRequired Then
			ErrorsDetails.AddOn = AllowedTemplatesDetails();
		EndIf;
	EndIf;
	
	RestrictionParts = InternalData.RestrictionParts;
	
	RestrictionStructure = New Structure;
	RestrictionStructure.Insert("ErrorsDetails",           ErrorsDetails);
	RestrictionStructure.Insert("AdditionalTables",    RestrictionParts.AdditionalTables);
	RestrictionStructure.Insert("MainTableAlias", RestrictionParts.MainTableAlias);
	RestrictionStructure.Insert("ReadRestriction",        RestrictionParts.ReadRestriction);
	RestrictionStructure.Insert("UpdateRestriction",     RestrictionParts.UpdateRestriction);
	
	// Additional information for internal use.
	TableTypeName = StrSplit(InternalData.MainTable, ".")[0];
	TablesTypeProperties = InternalData.LanguageSyntax.TablesTypes.ByNames.Get(Upper(TableTypeName));
	
	NewInternalData = New Structure;
	NewInternalData.Insert("AccessKeyFields",   InternalData.AccessKeyFields);
	NewInternalData.Insert("IsReferenceType",    TablesTypeProperties.IsReferenceType);
	NewInternalData.Insert("TypeCollectionName",   TablesTypeProperties.CollectionName);
	NewInternalData.Insert("TablesTypesByNames", InternalData.LanguageSyntax.TablesTypes.ByNames);
	
	RestrictionStructure.Insert("InternalData", NewInternalData);
	
	For Each Row In InternalData.CharsetsTable Do
		Row.Rows.Clear();
		Row.EndString = Undefined;
	EndDo;
	InternalData.CharsetsTable.Clear();
	InternalData.RestrictionParts.Clear();
	InternalData.Clear();
	
	Return RestrictionStructure;
	
EndFunction

// Generates a full text of errors in access restriction description with an addition that can be 
// specified as a text to call an exception.
//
// Parameters:
//  FullName               - String    - a full name of a list table.
//  ErrorsDetails          - Structure - a value returned by the RestrictionStructure function.
//  ForExternalUsers - Boolean    - if True is passed, an error text will contain the restriction 
//                                        purpose for external users.
//
// Returns:
//  String - a text to call an exception.
//
Function ErrorsTextToCallException(FullName, ErrorsDetails, ForExternalUsers, InManagerModule)
	
	If Not ErrorsDetails.HasErrors Then
		Return "";
	EndIf;
	
	If ErrorsDetails.Errors.Count() = 1 Then
		If InManagerModule = Undefined Then
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("ru = 'Ошибка в ограничении доступа внешних пользователей к списку ""%1"":'; en = 'An error in restriction of external user access to the ""%1"" list:'; pl = 'Błąd w ograniczeniu dostępu użytkowników zewnętrznych do listy ""%1"":';es_ES = 'Error al restringir el acceso de los usuarios externos a la lista ""%1"":';es_CO = 'Error al restringir el acceso de los usuarios externos a la lista ""%1"":';tr = '""%1"" listesine harici kullanıcı erişiminin kısıtlanmasında hata oluştu:';it = 'Un errore di restrizione dell''accesso di utenti esterni all''elenco ""%1"":';de = 'Fehler bei der Einschränkung des Zugriffs externer Benutzer auf die Liste ""%1"":'");
			Else
				ErrorTitle = 
					NStr("ru = 'Ошибка в ограничении доступа пользователей к списку ""%1"":'; en = 'An error in restriction of user access to the ""%1"" list:'; pl = 'Błąd w ograniczeniu dostępu użytkowników do listy ""%1"":';es_ES = 'Error al restringir el acceso de usuarios a la lista ""%1"":';es_CO = 'Error al restringir el acceso de usuarios a la lista ""%1"":';tr = '""%1"" listesine kullanıcı erişiminin kısıtlanmasında hata oluştu:';it = 'Un errore nella restrizione all''accesso dell''utente all''elenco ""%1"":';de = 'Fehler bei der Einschränkung des Benutzerzugriffs auf die Liste ""%1"":'");
			EndIf;
		ElsIf InManagerModule Then
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("ru = 'Ошибка в ограничении доступа внешних пользователей к списку ""%1"",
					           |указанному в процедуре OnFillAccessRestriction модуля менеджера объекта метаданных:'; 
					           |en = 'An error in restriction of external user access to the ""%1"" list
					           |specified in the OnFillAccessRestriction procedure of the metadata object manager module:'; 
					           |pl = 'Błąd w ograniczeniu dostępu użytkowników zewnętrznych do listy ""%1"",
					           |podanemu w procedurze OnFillAccessRestriction modułu menadżera obiektu metadanych:';
					           |es_ES = 'Error al restringir el acceso de usuarios externos a la lista ""%1"",
					           |indicada en el procedimiento OnFillAccessRestriction del módulo de gestor de objeto de metadatos:';
					           |es_CO = 'Error al restringir el acceso de usuarios externos a la lista ""%1"",
					           |indicada en el procedimiento OnFillAccessRestriction del módulo de gestor de objeto de metadatos:';
					           |tr = 'Metaveri nesne yönetici modülünün ErişimKısıtlamasıDoldurulurken prosedürümde belirtilen ""%1""
					           | listesine harici kullanıcıların erişimi kısıtlanırken bir hata oluştu:';
					           |it = 'Un errore nella restrizione all''accesso dell''utente esterno all''elenco ""%1""
					           |indicato nella procedura OnFillAccessRestriction del modulo del gestore dell''oggetto di metadata:';
					           |de = 'Fehler bei der Beschränkung des Zugriffs externer Benutzer auf die Liste ""%1"",
					           |die in der Prozedur OnFillAccessRestriction des Metadaten-Objekt-Manager-Moduls angegeben ist:'");
			Else
				ErrorTitle = 
					NStr("ru = 'Ошибка в ограничении доступа пользователей к списку ""%1"",
					           |указанному в процедуре OnFillAccessRestriction модуля менеджера объекта метаданных:'; 
					           |en = 'An error in restriction of user access to the ""%1"" list
					           |specified in the OnFillAccessRestriction procedure of the metadata object manager module:'; 
					           |pl = 'Błąd w ograniczeniu dostępu użytkowników do listy ""%1"",
					           |podanemu w procedurze OnFillAccessRestriction do modułu menadżera obiektu metadanych:';
					           |es_ES = 'Error al restringir el acceso de usuarios a la lista ""%1"",
					           |indicada en el procedimiento OnFillAccessRestriction del módulo de gestor del objeto de metadatos:';
					           |es_CO = 'Error al restringir el acceso de usuarios a la lista ""%1"",
					           |indicada en el procedimiento OnFillAccessRestriction del módulo de gestor del objeto de metadatos:';
					           |tr = 'Metaveri nesne yönetici modülünün ErişimKısıtlamasıDoldurulurken prosedürümde belirtilen ""%1""
					           | listesine kullanıcıların erişimi kısıtlanırken bir hata oluştu:';
					           |it = 'Un errore di restrizione all''accesso dell''utente all''elenco ""%1""
					           |indicato nella procedura OnFillAccessRestriction del modulo di gestione dell''oggetto di metadati:';
					           |de = 'Fehler bei der Beschränkung des Benutzerzugriffs auf die Liste ""%1"",
					           |die in der Prozedur OnFillAccessRestriction des Metadaten-Objekt-Manager-Moduls angegeben ist:'");
			EndIf;
		Else
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("ru = 'Ошибка в ограничении доступа внешних пользователей к списку ""%1"",
					           |указанному в процедуре AccessManagementOverridable.OnFillAccessRestriction:'; 
					           |en = 'An error in restriction of external user access to the ""%1"" list
					           |specified in the AccessManagementOverridable.OnFillAccessRestriction procedure:'; 
					           |pl = 'Błąd w ograniczeniu dostępu użytkowników zewnętrznych do listy ""%1"",
					           |podanemu w procedurze AccessManagementOverridable.OnFillAccessRestriction:';
					           |es_ES = 'Error al restringir el acceso de usuarios externos a la lista ""%1"",
					           |indicada en el procedimiento AccessManagementOverridable.OnFillAccessRestriction:';
					           |es_CO = 'Error al restringir el acceso de usuarios externos a la lista ""%1"",
					           |indicada en el procedimiento AccessManagementOverridable.OnFillAccessRestriction:';
					           |tr = 'ErişimKontrolüYenidenTanımlanmış. ErişimKısıtlamasıDoldurulurken prosedürümde belirtilen ""%1""
					           | listesine harici kullanıcıların erişimi kısıtlanırken bir hata oluştu:';
					           |it = 'Un errore di restrizione dell''accesso all''utente esterno all''elenco ""%1""
					           |indicato nella procedura AccessManagementOverridable.OnFillAccessRestriction:';
					           |de = 'Fehler bei der Beschränkung des Zugriffs externer Benutzer auf die Liste ""%1"",
					           |die in der Prozedur AccessManagementOverridable.OnFillAccessRestriction angegeben ist:'");
			Else
				ErrorTitle = 
					NStr("ru = 'Ошибка в ограничении доступа пользователей к списку ""%1"",
					           |указанному в процедуре AccessManagementOverridable.OnFillAccessRestriction:'; 
					           |en = 'An error in restriction of user access to the ""%1"" list
					           |specified in the AccessManagementOverridable.OnFillAccessRestriction procedure:'; 
					           |pl = 'Błąd w ograniczeniu dostępu użytkowników do listy ""%1"",
					           |podanemu w procedurze AccessManagementOverridable.OnFillAccessRestriction:';
					           |es_ES = 'Error al restringir el acceso de usuarios a la lista ""%1"",
					           |indicada en el procedimiento AccessManagementOverridable.OnFillAccessRestriction:';
					           |es_CO = 'Error al restringir el acceso de usuarios a la lista ""%1"",
					           |indicada en el procedimiento AccessManagementOverridable.OnFillAccessRestriction:';
					           |tr = 'AccessManagementOverridable. OnFillAccessRestriction prosedürümde belirtilen ""%1""
					           | listesine kullanıcıların erişimi kısıtlanırken bir hata oluştu:';
					           |it = 'Un errore di restrizione dell''accesso all''utente all''elenco ""%1""
					           |indicato nella procedura AccessManagementOverridable.OnFillAccessRestriction:';
					           |de = 'Fehler bei der Beschränkung des Benutzerzugriffs auf die Liste ""%1"",
					           |die in der Prozedur AccessManagementOverridable.OnFillAccessRestriction angegeben ist:'");
			EndIf;
		EndIf;
	Else
		If InManagerModule = Undefined Then
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("ru = 'Ошибки в ограничении доступа внешних пользователей к списку ""%1"":'; en = 'Errors in restriction of external user access to the ""%1"" list:'; pl = 'Błędy w ograniczeniu dostępu użytkowników zewnętrznych do listy ""%1"":';es_ES = 'Error al restringir el acceso de usuarios externos a la lista ""%1"":';es_CO = 'Error al restringir el acceso de usuarios externos a la lista ""%1"":';tr = '""%1"" listesine harici kullanıcı erişiminin kısıtlanmasında hatalar oluştu:';it = 'Errore di restrizione dell''accesso dell''utente esterno all''elenco ""%1"":';de = 'Fehler bei der Einschränkung des Zugriffs externer Benutzer auf die Liste ""%1"":'");
			Else
				ErrorTitle = 
					NStr("ru = 'Ошибки в ограничении доступа пользователей к списку ""%1"":'; en = 'Errors in restriction of user access to the ""%1"" list:'; pl = 'Błędy w ograniczeniu dostępu użytkowników do listy ""%1"":';es_ES = 'Error al restringir el acceso de usuarios a la lista ""%1"":';es_CO = 'Error al restringir el acceso de usuarios a la lista ""%1"":';tr = '""%1"" listesine kullanıcı erişiminin kısıtlanmasında hatalar oluştu:';it = 'Errore di restrizione dell''accesso dell''utente all''elenco ""%1"":';de = 'Fehler bei der Einschränkung des Benutzerzugriffs auf die Liste ""%1"":'");
			EndIf;
		ElsIf InManagerModule Then
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("ru = 'Ошибки в ограничении доступа внешних пользователей к списку ""%1"",
					           |указанному в процедуре OnFillAccessRestriction модуля менеджера объекта метаданных:'; 
					           |en = 'Errors in restriction of external user access to the ""%1"" list
					           |specified in the OnFillAccessRestriction procedure of the metadata object manager module:'; 
					           |pl = 'Błędy w ograniczeniu dostępu użytkowników zewnętrznych do listy ""%1"",
					           |podanemu w procedurze OnFillAccessRestriction modułu menadżera obiektu metadanych:';
					           |es_ES = 'Error al restringir el acceso de usuarios externos a la lista ""%1"",
					           |indicada en el procedimiento OnFillAccessRestriction del módulo de gestor del objeto de metadatos:';
					           |es_CO = 'Error al restringir el acceso de usuarios externos a la lista ""%1"",
					           |indicada en el procedimiento OnFillAccessRestriction del módulo de gestor del objeto de metadatos:';
					           |tr = 'Metaveri nesne yönetici modülünün ErişimKısıtlamasıDoldurulurken prosedüründe belirtilen ""%1""
					           | listesine harici kullanıcıların erişimi kısıtlanırken hatalar oluştu:';
					           |it = 'Errore di restrizione dell''accesso dell''utente esterno all''elenco ""%1""
					           |indicato nella procedura OnFillAccessRestriction del modulo di gestione dell''oggetto di metadati:';
					           |de = 'Fehler bei der Beschränkung des Zugriffs externer Benutzer auf die Liste ""%1"",
					           |die in der Prozedur OnFillAccessRestriction des Metadaten-Objekt-Manager-Moduls angegeben ist:'");
			Else
				ErrorTitle = 
					NStr("ru = 'Ошибки в ограничении доступа пользователей к списку ""%1"",
					           |указанному в процедуре OnFillAccessRestriction модуля менеджера объекта метаданных:'; 
					           |en = 'Errors in restriction of user access to the ""%1"" list
					           |specified in the OnFillAccessRestriction procedure of the metadata object manager module:'; 
					           |pl = 'Błędy w ograniczeniu dostępu użytkowników do listy ""%1"",
					           |podanemu w procedurze OnFillAccessRestriction do modułu menadżera obiektu metadanych:';
					           |es_ES = 'Error al restringir el acceso de usuarios a la lista ""%1"",
					           |indicada en el procedimiento OnFillAccessRestriction del módulo de gestor del objeto de metadatos:';
					           |es_CO = 'Error al restringir el acceso de usuarios a la lista ""%1"",
					           |indicada en el procedimiento OnFillAccessRestriction del módulo de gestor del objeto de metadatos:';
					           |tr = 'Metaveri nesne yönetici modülünün ErişimKısıtlamasıDoldurulurken prosedüründe belirtilen ""%1""
					           | listesine kullanıcıların erişimi kısıtlanırken hatalar oluştu:';
					           |it = 'Errore di restrizione dell''accesso dell''utente all''elenco ""%1""
					           |indicato nella procedura OnFillAccessRestriction del modulo di gestione dell''oggetto di metadati:';
					           |de = 'Fehler bei der Beschränkung des Benutzerzugriffs auf die Liste ""%1"",
					           |die in der Prozedur OnFillAccessRestriction des Metadaten-Objekt-Manager-Moduls angegeben ist:'");
			EndIf;
		Else
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("ru = 'Ошибки в ограничении доступа внешних пользователей к списку ""%1"",
					           |указанному в процедуре AccessManagementOverridable.OnFillAccessRestriction:'; 
					           |en = 'Errors in restriction of external user access to the ""%1"" list
					           |specified in the AccessManagementOverridable.OnFillAccessRestriction procedure:'; 
					           |pl = 'Błędy w ograniczeniu dostępu użytkowników zewnętrznych do listy ""%1"",
					           |podanemu w procedurze AccessManagementOverridable.OnFillAccessRestriction:';
					           |es_ES = 'Error al restringir el acceso de usuarios externos a la lista ""%1"",
					           |indicada en el procedimiento AccessManagementOverridable.OnFillAccessRestriction:';
					           |es_CO = 'Error al restringir el acceso de usuarios externos a la lista ""%1"",
					           |indicada en el procedimiento AccessManagementOverridable.OnFillAccessRestriction:';
					           |tr = 'AccessManagementOverridable. OnFillAccessRestriction prosedürümde belirtilen ""%1""
					           | listesine harici kullanıcıların erişimi kısıtlanırken hatalar oluştu:';
					           |it = 'Errore di restrizione dell''accesso dell''utente esterno all''elenco ""%1""
					           |indicato nella procedura AccessManagementOverridable.OnFillAccessRestriction:';
					           |de = 'Fehler bei der Beschränkung des Zugriffs externer Benutzer auf die Liste ""%1"",
					           |die in der Prozedur AccessManagementOverridable.OnFillAccessRestriction angegeben ist:'");
			Else
				ErrorTitle = 
					NStr("ru = 'Ошибки в ограничении доступа пользователей к списку ""%1"",
					           |указанному в процедуре AccessManagementOverridable.OnFillAccessRestriction:'; 
					           |en = 'Errors in restriction of user access to the ""%1"" list
					           |specified in the AccessManagementOverridable.OnFillAccessRestriction procedure:'; 
					           |pl = 'Błędy w ograniczeniu dostępu użytkowników do listy ""%1"",
					           |podanemu w procedurze AccessManagementOverridable.OnFillAccessRestriction:';
					           |es_ES = 'Error al restringir el acceso de usuarios a la lista ""%1"",
					           |indicada en el procedimiento AccessManagementOverridable.OnFillAccessRestriction:';
					           |es_CO = 'Error al restringir el acceso de usuarios a la lista ""%1"",
					           |indicada en el procedimiento AccessManagementOverridable.OnFillAccessRestriction:';
					           |tr = 'AccessManagementOverridable. OnFillAccessRestriction prosedürümde belirtilen ""%1""
					           | listesine kullanıcıların erişimi kısıtlanırken hatalar oluştu:';
					           |it = 'Errore di restrizione dell''accesso dell''utente all''elenco ""%1""
					           |indicato nella procedura AccessManagementOverridable.OnFillAccessRestriction:';
					           |de = 'Fehler bei der Beschränkung des Benutzerzugriffs auf die Liste ""%1"",
					           |die in der Prozedur AccessManagementOverridable.OnFillAccessRestriction angegeben ist:'");
			EndIf;
		EndIf;
	EndIf;
	
	ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTitle, FullName);
	ErrorText = ErrorText + Chars.LF + Chars.LF + ErrorsDetails.ErrorsText;
	ErrorText = ErrorText + Chars.LF + Chars.LF + ErrorsDetails.Restriction;
	
	If ValueIsFilled(ErrorsDetails.AddOn) Then
		ErrorText = ErrorText + Chars.LF + Chars.LF + ErrorsDetails.AddOn;
	EndIf;
	
	Return Chars.LF + ErrorText + Chars.LF;
	
EndFunction

// For the RestrictionStructure function.
Procedure AddError(Row, ErrorsDetails, InternalData, RowNumberLength)
	
	PositionInText = Row.Position;
	ErrorPositionInRowEnd = False;
	RestrictionText = InternalData.RestrictionText;
	
	If Row.ErrorPosition > 0 Then
		PositionInText = PositionInText + Row.ErrorPosition;
		If Row.ErrorPosition = StrLen(Row.Chars) Then
			PositionInText = PositionInText - 1;
			ErrorPositionInRowEnd = True;
		EndIf;
	ElsIf Row.Position > StrLen(RestrictionText) Then
		PositionInText = PositionInText - 1;
		ErrorPositionInRowEnd = True;
	EndIf;
	
	Coordinates = PositionCoordinatesInText(RestrictionText, PositionInText);
	Coordinates.PositionInRow = Coordinates.PositionInRow + ?(ErrorPositionInRowEnd, 1, 0);
	
	ErrorRow = StrGetLine(RestrictionText, Coordinates.LineNumber);
	ErrorRow = Left(ErrorRow, Coordinates.PositionInRow - 1)
		+ "<<?>>" + Mid(ErrorRow, Coordinates.PositionInRow);
	
	Error = New Structure;
	Error.Insert("LineNumber",    Coordinates.LineNumber);
	Error.Insert("PositionInRow", Coordinates.PositionInRow);
	Error.Insert("ErrorText",    Row.ErrorText);
	Error.Insert("ErrorRow",   ErrorRow);
	
	ErrorsDetails.Errors.Add(Error);
	
	If ValueIsFilled(ErrorsDetails.ErrorsText) Then
		ErrorsDetails.ErrorsText = ErrorsDetails.ErrorsText + Chars.LF + Chars.LF;
	EndIf;
	
	ErrorsDetails.ErrorsText = ErrorsDetails.ErrorsText
		+ "{(" + Format(Error.LineNumber, "ND=" + RowNumberLength + "; NLZ=; NG=")
		+ ", " + Format(Error.PositionInRow, "NG=") + ")}:"
		+ " " + Error.ErrorText + Chars.LF + Error.ErrorRow;
	
EndProcedure

// For the RestrictionStructure function.
Function NumberedRestrictionTextWithErrorsMarks(RestrictionText, Errors, RowNumberLength)
	
	StringsCount = StrLineCount(RestrictionText);
	RestrictionTextRows = New Array;
	
	For RowNumber = 1 To StringsCount Do
		Row = StrGetLine(RestrictionText, RowNumber);
		RestrictionTextRows.Add(Row);
	EndDo;
	
	Index = Errors.Count() - 1;
	While Index >= 0 Do
		Error = Errors[Index];
		Row = RestrictionTextRows[Error.LineNumber - 1];
		RestrictionTextRows[Error.LineNumber - 1] = Left(Row, Error.PositionInRow - 1)
			+ "<<?>>" + Mid(Row, Error.PositionInRow);
		Index = Index - 1;
	EndDo;
	
	Text = "";
	RowNumber = 1;
	
	For Each Row In RestrictionTextRows Do
		Text = Text + ?(Text = "", "", Chars.LF)
			+ ?(StrFind(Row, "<<?>>") > 0, "*", " ")
			+ " " + Format(RowNumber, "ND=" + RowNumberLength + "; NLZ=; NG=") + " " + Row;
		RowNumber = RowNumber + 1;
	EndDo;
	
	Return Text;
	
EndFunction

// For the RestrictionStructure function.
Function AllowedTemplatesDetails()
	
	If ScriptVariantRussian() Then
		Template1 =
		"        AllowReadUpdate
		|        WHERE ...";
		
		Template2 =
		"        AllowRead
		|        WHERE ...
		|        ;
		|        AllowUpdateIfReadingAllowed
		|        WHERE ...";
		
		Template3 =
		"        AttachAdditionalTables
		|        ThisList AS <Alias>
		|        LEFT JOIN ...
		|        ;
		|        AllowRead
		|        WHERE ...
		|        ;
		|        AllowUpdateIfReadingAllowed
		|        WHERE ...";
	Else
		Template1 =
		"        AllowReadWrite
		|        WHERE ...";
		
		Template2 =
		"        AllowRead
		|        WHERE ...
		|        ;
		|        AllowWriteIfAllowRead
		|        WHERE ...";
		
		Template3 =
		"        AttachAdditionalTables
		|        LIST AS <Alias>
		|        LEFT/INNER JOIN ...
		|        ;
		|        AllowRead
		|        WHERE ...
		|        ;
		|        AllowWriteIfAllowRead
		|        WHERE ...";
	EndIf;
	
	Details = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("ru = 'Ограничение может состоять из 1-3 частей в одном из 4 вариантов:
		           |1) одинаковое ограничение чтения и изменения:
		           |%1
		           |2) разные ограничения чтения и изменения:
		           |%2
		           |3) любой из вариантов выше с дополнительными таблицами, например:
		           |%3'; 
		           |en = 'Restriction can contain 1-3 parts in one of 4 options:
		           |1. Similar read and update restriction:
		           |%1
		           | 2. Different read and update restrictions:
		           |%2
		           | 3. Any of the options mentioned above with additional tables, for example:
		           |%3'; 
		           |pl = 'Ograniczenie może składać się z 1 do 3 sztuk w jednym z 4 opcji:
		           |1. takie same ograniczenia odczytu i zmiany:
		           |%1
		           | 2. różne ograniczenia odczytu i zmiany:
		           |%2
		           | 3. w każdej z opcji powyżej, z dodatkowymi tabelami, np.:
		           |%3';
		           |es_ES = 'La restricción puede ser compuesta de 1-3 partes en una de las 4 opciones: 
		           |1) la misma restricción de lectura y modificación:
		           |%1
		           |2) restricciones diferentes de lectura y modificación:
		           |%2
		           |3) cualquiera de las opciones superiores con las tablas adicionales, por ejemplo:
		           |%3';
		           |es_CO = 'La restricción puede ser compuesta de 1-3 partes en una de las 4 opciones: 
		           |1) la misma restricción de lectura y modificación:
		           |%1
		           |2) restricciones diferentes de lectura y modificación:
		           |%2
		           |3) cualquiera de las opciones superiores con las tablas adicionales, por ejemplo:
		           |%3';
		           |tr = 'Kısıtlama, 4 seçenekten birinde 1-3 bölümden oluşabilir: 
		           |1) Okuma ve değiştirmenin aynı kısıtlaması: 
		           |%1
		           |2) farklı okuma ve değiştirme kısıtlamaları: 
		           |%2
		           |3) ek tablolarla yukarıdaki seçeneklerden herhangi biri, örneğin :
		           |%3';
		           |it = 'La restrizione può contenere 1-3 parti in una di 4 opzioni:
		           |1. Restrizioni simili di lettura e aggiornamento:
		           |%1
		           | 2. Diverse restrizioni di lettura e aggiornamento:
		           |%2
		           | 3. Tutte le opzioni precedenti con tabelle aggiuntive, ad esempio:
		           |%3';
		           |de = 'Die Einschränkung kann aus 1-3 Teilen in einer von 4 Varianten bestehen:
		           |1) die gleiche Einschränkung beim Lesen und Ändern:
		           |%1
		           |2) unterschiedliche Einschränkung beim Lesen und Ändern:
		           |%2
		           |3) eine der oben genannten Optionen mit zusätzlichen Tabellen, zum Beispiel:
		           |%3'"),
		Template1, Template2, Template3);
	
	Return Details;
	
EndFunction

// For the AddError procedure.
Function PositionCoordinatesInText(Text, PositionInText)
	
	Result = New Structure;
	Result.Insert("LineNumber", 0);
	Result.Insert("PositionInRow", 0);
	
	StringsCount = StrLineCount(Text);
	RowBeginningPosition = 1;
	For RowNumber = 1 To StringsCount Do
		CurrentRowLength = StrLen(StrGetLine(Text, RowNumber));
		If PositionInText < RowBeginningPosition + CurrentRowLength Then
			Break;
		EndIf;
		RowBeginningPosition = RowBeginningPosition + CurrentRowLength + 1;
	EndDo;
	
	Result.LineNumber = RowNumber;
	
	Row = StrGetLine(Text, RowNumber);
	Result.PositionInRow = PositionInText - RowBeginningPosition + 1;
	
	Return Result;
	
EndFunction

#Region LexicalAnalysis

// For the ParsedRestriction function.
// Splits the text in a table of character sets, in which:
// - There are no indent characters (spaces, tabs, line breaks).
// - Characters of arbitrary strings and numbers are highlighted.
// - Keywords and operations are defined.
// - Format of names and numbers is checked.
// - Errors with description are added.
// 
// Parameters:
//  RestrictionText - String - an access restriction text.
//
// Returns:
//  ValueTable - a table with the following columns:
//    * Chars       - String - a character, a pair of characters, or a word.
//    * Position       - Number  - a position of characters in the restriction text.
//    * Kind           - String - "KeyWord", "Operation", "Name", "Separator",
//                               "Number", "ArbitraryString", "ProhibitedChar", "End".
//    * Type           - String - a type for the "KeyWord" and "Operation" kinds.
//    * Priority     - Number  - a priority for the "KeyWord" and "Operation" kinds.
//    * Clarification     - Number  - a numeric value for the "Number" kind.
//                    - String - a name for the "KeyWord" kind, a string of characters for the "ArbitraryString" kind.
//    * IsReserve     - Boolean - if True, this is a reserved operation or a keyword.
//    * ErrorPosition - Number  - an error position in a restriction text if the error text is not blank.
//    * ErrorText   - String - an error text if an error occurs.
//
Function CharsetsTable(InternalData)
	
	CharsetsTable = New ValueTable;
	CharsetsTable.Columns.Add("Chars",       New TypeDescription("String"));
	CharsetsTable.Columns.Add("Position",       New TypeDescription("Number"));
	CharsetsTable.Columns.Add("Kind",           New TypeDescription("String"));
	CharsetsTable.Columns.Add("Type",           New TypeDescription("String"));
	CharsetsTable.Columns.Add("Priority",     New TypeDescription("Number"));
	CharsetsTable.Columns.Add("Clarification",     New TypeDescription("Number, String"));
	CharsetsTable.Columns.Add("IsReserve",     New TypeDescription("Boolean"));
	CharsetsTable.Columns.Add("ErrorPosition", New TypeDescription("Number"));
	CharsetsTable.Columns.Add("ErrorText",   New TypeDescription("String"));
	
	RestrictionText = InternalData.RestrictionText;
	
	If Not ValueIsFilled(RestrictionText) Then
		Return CharsetsTable;
	EndIf;
	
	RestrictionTextLength = StrLen(RestrictionText);
	
	LanguageSyntax = InternalData.LanguageSyntax;
	LanguageChars = LanguageSyntax.LanguageChars;
	
	CharsetKind = ""; // Word, ArbitraryString, Operation.
	CharsetPosition = 0;
	Charset = New Array;
	TableRow = Undefined;
	
	For CharNumber = 1 To RestrictionTextLength Do
		Char = Mid(RestrictionText, CharNumber, 1);
		CharType = LanguageChars.Get(Char);
		// Processing word characters first as they are the most common.
		If CharType = "WordChar" AND CharsetKind = "Word" Then
			Charset.Add(Char);
			Continue;
		EndIf;
		// Processing an arbitrary string of characters.
		If CharsetKind = "ArbitraryLine" Then
			If CharType = "LineLimiter" Then
				If Mid(RestrictionText, CharNumber + 1, 1) <> Char Then
					TableRow.Clarification = StrConcat(Charset);
					TableRow.Position = CharsetPosition;
					Charset = New Array;
					CharsetKind = "";
					Continue;
				Else
					CharNumber = CharNumber + 1;
				EndIf;
			EndIf;
			Charset.Add(Char);
			Continue;
		EndIf;
		If CharsetKind = "Word" Then
			// At the beginning of the cycle, CharType = "WordChar" is already processed, for the remaining 
			// character types the word is completed and it needs to be added to the tree.
			CharsetKind = "";
			AddWordToCharsetsTable(CharsetsTable,
				Charset, CharsetPosition, LanguageSyntax);
			Charset = New Array;
		EndIf;
		// Processing a set of composite separators.
		If CharsetKind = "Operation" Then
			If CharType = "OperationChar" Then
				Charset.Add(Char);
				Continue;
			EndIf;
			CharsetKind = "";
			AddOperationToCharsetsTable(CharsetsTable,
				Charset, CharsetPosition, LanguageSyntax);
			Charset = New Array;
		EndIf;
		// Processing the first character of character sets.
		If CharsetKind = "" Then
			If CharType = "WordChar" Then
				CharsetKind = "Word";
				CharsetPosition = CharNumber;
				Charset.Add(Char);
				Continue;
			EndIf;
			If CharType = "OperationChar" Then
				CharsetKind = "Operation";
				CharsetPosition = CharNumber;
				Charset.Add(Char);
				Continue;
			EndIf;
			If CharType = "LineLimiter" Then
				CharsetKind = "ArbitraryLine";
				CharsetPosition = CharNumber;
				TableRow = CharsetsTable.Add();
				TableRow.Chars = Char;
				TableRow.Kind = CharsetKind;
				Continue;
			EndIf;
		EndIf;
		// Processing separate characters.
		If CharType = "Indent" Then
			Continue;
		EndIf;
		If CharType = "Separator" Then
			TableRow = CharsetsTable.Add();
			TableRow.Chars = Char;
			TableRow.Position = CharNumber;
			TableRow.Kind = "Separator";
			Continue;
		EndIf;
		TableRow = CharsetsTable.Add();
		TableRow.Chars = Char;
		TableRow.Position = CharNumber;
		TableRow.Kind = "IllegalCharacter";
		TableRow.ErrorText   = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Недопустимый символ ""%1"" с кодом %2'; en = 'Invalid character ""%1"" with code %2'; pl = 'Nieprawidłowy symbol ""%1"" z kodem %2';es_ES = 'Símbolo no disponible ""%1"" con el código %2';es_CO = 'Símbolo no disponible ""%1"" con el código %2';tr = '%1Kodlu izin verilmeyen karakter ""%2""';it = 'Carattere non permesso ""%1"" con codice %2';de = 'Ungültiges Symbol ""%1"" mit Code %2'"), Char, CharCode(Char));
	EndDo;
	
	If CharsetKind = "Word" Then
		AddWordToCharsetsTable(CharsetsTable,
			Charset, CharsetPosition, LanguageSyntax);
		
	ElsIf CharsetKind = "Operation" Then
		AddOperationToCharsetsTable(CharsetsTable,
			Charset, CharsetPosition, LanguageSyntax);
		
	ElsIf CharsetKind = "ArbitraryLine" Then
		TableRow.Clarification = StrConcat(Charset);
		TableRow.Position = CharsetPosition;
		TableRow.ErrorPosition = CharNumber - CharsetPosition;
		TableRow.ErrorText   = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не указан символ окончания произвольной строки %1'; en = 'Character of %1 arbitrary string end is not specified'; pl = 'Nie podano symbol zakończenia dowolnego wiersza %1';es_ES = 'No se ha indicado un símbolo de terminación de línea libre %1';es_CO = 'No se ha indicado un símbolo de terminación de línea libre %1';tr = 'Rasgele satır sonu karakteri belirtilmedi%1';it = 'Carattere della fine stringa arbitraria %1 non indicato';de = 'Kein beliebiger Zeilenabschluss angegeben %1'"), TableRow.Chars);
	EndIf;
	
	LastRow = CharsetsTable.Add();
	LastRow.Position = StrLen(RestrictionText) + 1;
	LastRow.Kind = "End"; // To set the lack of description error text.
	CharsetsTable.Indexes.Add("Kind, Clarification");
	
	Return CharsetsTable;
	
EndFunction

// For the CharsetsTable function.
Procedure AddWordToCharsetsTable(Table,
			Charset, CharsetPosition, LanguageSyntax)
	
	CharactersString = StrConcat(Charset);
	WordProperties  = LanguageSyntax.LanguageWords.Get(Upper(CharactersString));
	
	NewRow = Table.Add();
	NewRow.Chars = CharactersString;
	NewRow.Position = CharsetPosition;
	
	If WordProperties <> Undefined Then
		NewRow.Kind       = "Keyword";
		NewRow.Type       = WordProperties.Type;
		NewRow.Priority = WordProperties.Priority;
		NewRow.Clarification = WordProperties.ID;
		NewRow.IsReserve = WordProperties.IsReserve;
		
		If WordProperties.IsReserve Then
			NewRow.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Ключевое слово ""%1"" не поддерживается'; en = 'Keyword ""%1"" is not supported'; pl = 'Słowo kluczowe ""%1"" nie jest obsługiwane';es_ES = 'Palabra clave ""%1"" no se admite';es_CO = 'Palabra clave ""%1"" no se admite';tr = '""%1"" anahtar kelimesi desteklenmiyor';it = 'Parola chiave ""%1"" non supportata';de = 'Das Schlüsselwort ""%1"" wird nicht unterstützt'"), CharactersString);
		EndIf;
		Return;
	EndIf;
	
	// The word is a name or a number.
	NumbersChars = LanguageSyntax.NumbersChars;
	
	If Charset[0] = "." Then
		If Charset.Count() > 1 Then
			IsNumber = False;
		Else
			NewRow.Kind = "Name";
			NewRow.ErrorText = NStr("ru = 'Имя не может начинаться с точки'; en = 'Name cannot start with a period'; pl = 'Nazwa nie może zaczynać się od kropki';es_ES = 'Nombre no puede empezarse con el punto';es_CO = 'Nombre no puede empezarse con el punto';tr = 'İsim nokta ile başlayamaz';it = 'Il nome non può partire con un carattere periodo';de = 'Der Name kann nicht mit einem Punkt beginnen'");
			Return;
		EndIf;
	Else
		IsNumber = NumbersChars.Get(Charset[0]) <> Undefined;
	EndIf;
	
	If IsNumber Then
		NewRow.Kind = "Number";
		CharNumber = 1;
		For Each Char In Charset Do
			If NumbersChars.Get(Char) = Undefined Then
				NewRow.ErrorPosition = CharNumber - 1;
				NewRow.ErrorText   = NStr("ru = 'Число может состоять только из цифр'; en = 'Number can contain only digits'; pl = 'Numer może składać się tylko z cyfr';es_ES = 'Número puede estar compuesto solo de cifras';es_CO = 'Número puede estar compuesto solo de cifras';tr = 'Sayı sadece rakamlardan oluşabilir';it = 'Il numero può contenere solo cifre';de = 'Die Nummer kann nur aus Zahlen bestehen'");
				Return;
			EndIf;
			CharNumber = CharNumber + 1;
		EndDo;
		NumberChars = Left(CharactersString, CharNumber - 1);
		If StrLen(NumberChars) > 16 Then
			NewRow.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Слишком большое число ""%1""'; en = 'Number ""%1"" is too big'; pl = 'Zbyt duża liczba ""%1""';es_ES = 'Número demasiado grande ""%1""';es_CO = 'Número demasiado grande ""%1""';tr = 'Çok büyük sayı ""%1""';it = 'Numero troppo grande ""%1""';de = 'Zu hohe Anzahl ""%1""'"), NumberChars);
			Return;
		EndIf;
		NewRow.Clarification = Number(NumberChars);
	Else
		NewRow.Kind = "Name";
		NameParts = StrSplit(CharactersString, ".");
		NamePartPosition = 1;
		For Each NamePart In NameParts Do
			If NamePart = "" AND NamePartPosition > 1 Then
				NewRow.ErrorPosition = NamePartPosition - 1;
				NewRow.ErrorText   = NStr("ru = 'После точки не указано имя'; en = 'No name after period'; pl = 'Po kropce nie podano nazwy';es_ES = 'Después del punto no está indicado el nombre';es_CO = 'Después del punto no está indicado el nombre';tr = 'Noktadan isim belirtilmemiştir';it = 'Nessun nome dopo il periodo';de = 'Kein Name nach dem Punkt'");
				Return;
			ElsIf NumbersChars.Get(Left(NamePart, 1)) <> Undefined Then
				NewRow.ErrorPosition = NamePartPosition - 1;
				NewRow.ErrorText   = NStr("ru = 'После точки в имени не может следовать число'; en = 'Number cannot be used after period in a name'; pl = 'Po kropce w nazwie nie może podążać liczba';es_ES = 'Después del punto en el nombre no puede seguir el número';es_CO = 'Después del punto en el nombre no puede seguir el número';tr = 'Addaki noktadan sonra sayı bulunamaz';it = 'Il numero non può essere utilizzato dopo il punto in un nome';de = 'Nach einem Punkt im Namen kann die Nummer nicht folgen'");
				Return;
			EndIf;
			NamePartPosition = NamePartPosition + StrLen(NamePart) + 1;
		EndDo;
	EndIf;
	
EndProcedure

// For the CharsetsTable function.
Procedure AddOperationToCharsetsTable(Table,
			Charset, CharsetPosition, LanguageSyntax)
	
	CharactersString = StrConcat(Charset);
	OperationProperties = LanguageSyntax.LanguageOperations.Get(CharactersString);
	
	NewRow = Table.Add();
	NewRow.Chars   = CharactersString;
	NewRow.Position   = CharsetPosition;
	NewRow.Kind       = "Operation";
	NewRow.Type       = OperationProperties.Type;
	NewRow.Priority = OperationProperties.Priority;
	NewRow.IsReserve = OperationProperties.IsReserve;
	
	If OperationProperties = Undefined Then
		NewRow.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Недопустимая операция ""%1""'; en = 'Invalid operation ""%1""'; pl = 'Nieprawidłowa operacja ""%1""';es_ES = 'Operación no admitida ""%1""';es_CO = 'Operación no admitida ""%1""';tr = 'Geçersiz işlem ""%1""';it = 'Operazione non permessa ""%1""';de = 'Ungültige Operation ""%1""'"), CharactersString);
		
	ElsIf OperationProperties.IsReserve Then
		NewRow.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Операция ""%1"" не поддерживается'; en = 'Operation ""%1"" is not supported'; pl = 'Operacja ""%1"" nie jest obsługiwana';es_ES = 'Operación ""%1"" no se admite';es_CO = 'Operación ""%1"" no se admite';tr = '""%1"" operasyonu desteklenmiyor';it = 'Operazione ""%1"" non supportata';de = 'Operation ""%1"" wird nicht unterstützt'"), CharactersString);
	EndIf;
	
EndProcedure

// For the ParsedRestriction function and for many other functions indirectly.
Function LanguageSyntax() Export
	
	LanguageSyntax = New Structure;
	LanguageSyntax.Insert("LanguageChars",  LanguageChars());
	LanguageSyntax.Insert("NumbersChars",   NumbersChars());
	LanguageSyntax.Insert("LanguageOperations", LanguageOperations());
	LanguageSyntax.Insert("LanguageWords",    LanguageWords());
	LanguageSyntax.Insert("TablesTypes",    TablesTypes());
	
	Return New FixedStructure(LanguageSyntax);
	
EndFunction

// For the LanguageSyntax function.
Function LanguageChars()
	
	LanguageChars = New Map;
	
	For CharCode = CharCode("A") To CharCode("Z") Do
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	For CharCode = CharCode("a") To CharCode("z") Do
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	For CharCode = CharCode("A") To CharCode("Z") Do
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	For CharCode = CharCode("a") To CharCode("z") Do
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	
	LanguageChars.Insert("_", "WordChar");
	LanguageChars.Insert(".", "WordChar");
	
	For CharCode = CharCode("0") To CharCode("9") Do
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	
	LanguageChars.Insert(" ",         "Indent");
	LanguageChars.Insert(Chars.Tab, "Indent");
	LanguageChars.Insert(Chars.LF,  "Indent");
	
	LanguageChars.Insert("""", "LineLimiter");
	
	LanguageChars.Insert("(", "Separator");
	LanguageChars.Insert(")", "Separator");
	LanguageChars.Insert(",", "Separator");
	LanguageChars.Insert(";", "Separator");
	LanguageChars.Insert("=", "OperationChar");
	LanguageChars.Insert("<", "OperationChar");
	LanguageChars.Insert(">", "OperationChar");
	
	// Not supported.
	LanguageChars.Insert("+", "OperationChar");
	LanguageChars.Insert("-", "OperationChar");
	LanguageChars.Insert("*", "OperationChar");
	LanguageChars.Insert("/", "OperationChar");
	
	Return New FixedMap(LanguageChars);
	
EndFunction

// For the LanguageSyntax function.
Function NumbersChars()
	
	NumbersChars = New Map;
	
	For CharCode = CharCode("0") To CharCode("9") Do
		NumbersChars.Insert(Char(CharCode), True);
	EndDo;
	
	Return New FixedMap(NumbersChars);
	
EndFunction

// For the LanguageSyntax function.
Function LanguageWords()
	
	Words = New Map;
	
	AddLanguageWord(Words, "AttachAdditionalTables",     "AttachAdditionalTables",      "Begin",       False);
	AddLanguageWord(Words, "ThisList",                            "ThisList",                    "StartList", False);
	AddLanguageWord(Words, "AllowReadUpdate",              "AllowReadUpdate",             "Begin",       False);
	AddLanguageWord(Words, "AllowRead",                       "AllowRead",                   "Begin",       False);
	AddLanguageWord(Words, "AllowUpdateIfReadingAllowed", "AllowUpdateIfReadingAllowed", "Begin",       False);
	AddLanguageWord(Words, "Where",                                   "Where",                       "StartWhere");
	
	AddLanguageWord(Words, "Left",      "Left", "Joining");
	AddLanguageWord(Words, "Join", "Join", "Joining");
	AddLanguageWord(Words, "On",         "On",   "Joining");
	
	AddLanguageWord(Words, "AND",      "AND",    "Connector", , 2);
	AddLanguageWord(Words, "Or",    "Or",     "Connector", , 1);
	AddLanguageWord(Words, "IN",      "IN",     "Connector", , 5);
	AddLanguageWord(Words, "As",    "As",     "Connector");
	AddLanguageWord(Words, "Except",  "Except", "Connector");
	AddLanguageWord(Words, "Only", "Only",   "Connector");
	AddLanguageWord(Words, "Is",   "Is",     "Connector", , 7);
	AddLanguageWord(Words, "Not",     "Not",    "Operator",    , 3);
	
	AddLanguageWord(Words, "Case",  "Case", "SelectionWord");
	AddLanguageWord(Words, "When",  "When", "SelectionWord");
	AddLanguageWord(Words, "Then",  "Then", "SelectionWord");
	AddLanguageWord(Words, "Else",  "Else", "SelectionWord");
	AddLanguageWord(Words, "End",  "End",  "SelectionWord");
	
	AddLanguageWord(Words, "IsNull",                      "IsNull",               "Function", False);
	AddLanguageWord(Words, "Cast",                      "Cast",                 "Function", False);
	AddLanguageWord(Words, "Value",                      "Value",                "Function", False);
	AddLanguageWord(Words, "ValueType",                   "ValueType",            "Function", False);
	AddLanguageWord(Words, "Type",                           "Type",                 "Function", False);
	AddLanguageWord(Words, "ValueAllowed",             "ValueAllowed",         "Function", False);
	AddLanguageWord(Words, "ObjectReadingAllowed",        "ObjectReadingAllowed", "Function", False);
	AddLanguageWord(Words, "ObjectUpdateAllowed",     "ObjectUpdateAllowed",  "Function", False);
	AddLanguageWord(Words, "ListReadingAllowed",         "ListReadingAllowed",   "Function", False);
	AddLanguageWord(Words, "ListUpdateAllowed",      "ListUpdateAllowed",    "Function", False);
	AddLanguageWord(Words, "ForAllRows",                  "ForAllRows",           "Function", False);
	AddLanguageWord(Words, "ForAtLeastOneRow",               "ForAtLeastOneRow",     "Function", False);
	AddLanguageWord(Words, "IsAuthorizedUser", "IsAuthorizedUser",     "Function", False);
	
	AddLanguageWord(Words, "EmptyRef", "EmptyRef",  "ComparisonValue");
	AddLanguageWord(Words, "Disabled",    "Disabled",  "ComparisonValue");
	AddLanguageWord(Words, "Undefined", "Undefined", "ComparisonValue");
	AddLanguageWord(Words, "Null",         "Null",      "ComparisonValue");
	AddLanguageWord(Words, "False",         "False",     "ClarificationValue");
	AddLanguageWord(Words, "True",       "True",      "ClarificationValue");
	
	AddLanguageWord(Words, "String",       "String",    "TypeName");
	AddLanguageWord(Words, "Number",        "Number",    "TypeName");
	AddLanguageWord(Words, "Date",         "Date",      "TypeName");
	AddLanguageWord(Words, "Boolean",       "Boolean",   "TypeName");
	
	// Not supported, reserved words.
	AddLanguageWord(Words, "Select",             "Select",          "Undefined",   , , True);
	AddLanguageWord(Words, "Top",              "Top",             "Undefined",   , , True);
	AddLanguageWord(Words, "Distinct",           "Distinct",        "Undefined",   , , True);
	AddLanguageWord(Words, "From",                  "From",            "Undefined",   , , True);
	AddLanguageWord(Words, "Inner",          "Inner",           "Joining", , , True);
	AddLanguageWord(Words, "Full",              "Full",            "Joining", , , True);
	AddLanguageWord(Words, "Group",       "Group",           "Undefined",   , , True);
	AddLanguageWord(Words, "Having",             "Having",          "Undefined",   , , True);
	AddLanguageWord(Words, "Order",         "Order",           "Undefined",   , , True);
	AddLanguageWord(Words, "Totals",               "Totals",          "Undefined",   , , True);
	AddLanguageWord(Words, "Year",                 "Year",            "Function",   False, , True);
	AddLanguageWord(Words, "Quarter",             "Quarter",         "Function",   False, , True);
	AddLanguageWord(Words, "Month",               "Month",           "Function",   False, , True);
	AddLanguageWord(Words, "DayOfYear",            "DayOfYear",       "Function",   False, , True);
	AddLanguageWord(Words, "Day",                "Day",             "Function",   False, , True);
	AddLanguageWord(Words, "Week",              "Week",            "Function",   False, , True);
	AddLanguageWord(Words, "Weekday",          "Weekday",         "Function",   False, , True);
	AddLanguageWord(Words, "Hour",                 "Hour",            "Function",   False, , True);
	AddLanguageWord(Words, "Minute",              "Minute",          "Function",   False, , True);
	AddLanguageWord(Words, "Second",             "Second",          "Function",   False, , True);
	AddLanguageWord(Words, "BeginOfPeriod",       "BeginOfPeriod",   "Function",   False, , True);
	AddLanguageWord(Words, "EndOfPeriod",        "EndOfPeriod",     "Function",   False, , True);
	AddLanguageWord(Words, "DateAdd",       "DateAdd",         "Function",   False, , True);
	AddLanguageWord(Words, "DateDiff",         "DateDiff",        "Function",   False, , True);
	AddLanguageWord(Words, "Sum",               "Sum",             "Function",   False, , True);
	AddLanguageWord(Words, "Min",             "Min",             "Function",   False, , True);
	AddLanguageWord(Words, "Max",            "Max",             "Function",   False, , True);
	AddLanguageWord(Words, "Avg",             "Avg",             "Function",   False, , True);
	AddLanguageWord(Words, "Count",          "Count",           "Function",   False, , True);
	AddLanguageWord(Words, "Presentation",       "Presentation",    "Function",   False, , True);
	AddLanguageWord(Words, "RefPresentation", "RefPresentation", "Function",   False, , True);
	
	Return New FixedMap(Words);
	
EndFunction

// For the LanguageSyntax function.
Function LanguageOperations()
	
	LanguageOperations = New Map;
	
	AddLanguageWord(LanguageOperations, "=",  "=",  "Connector", , 4);
	AddLanguageWord(LanguageOperations, "<>", "<>", "Connector", , 4);
	
	// Not supported, reserved operations.
	AddLanguageWord(LanguageOperations, "<",  "<",  "Connector", , 4, True);
	AddLanguageWord(LanguageOperations, "<=", "<=", "Connector", , 4, True);
	AddLanguageWord(LanguageOperations, ">",  ">",  "Connector", , 4, True);
	AddLanguageWord(LanguageOperations, ">=", ">=", "Connector", , 4, True);
	AddLanguageWord(LanguageOperations, "+",  "+",  "Connector", , 1, True);
	AddLanguageWord(LanguageOperations, "-",  "-",  "Connector", , 1, True);
	AddLanguageWord(LanguageOperations, "*",  "*",  "Connector", , 6, True);
	AddLanguageWord(LanguageOperations, "/",  "/",  "Connector", , 6, True);
	
	Return New FixedMap(LanguageOperations);
	
EndFunction

// For the LanguageWords and LanguageOperations functions.
Procedure AddLanguageWord(Words, LanguageRussian, LanguageEnglish, WordType,
			Uppercase = True, Priority = 0, IsReserve = False)
	
	WordProperties = New Structure;
	WordProperties.Insert("ID",  LanguageRussian);
	WordProperties.Insert("LanguageRussian",    LanguageRussian);
	WordProperties.Insert("LanguageEnglish", LanguageEnglish);
	WordProperties.Insert("Type",            WordType);
	WordProperties.Insert("Uppercase", Uppercase);
	WordProperties.Insert("Priority",      Priority);
	WordProperties.Insert("IsReserve",      IsReserve);
	
	WordProperties = New FixedStructure(WordProperties);
	
	Words.Insert(Upper(LanguageRussian),    WordProperties);
	Words.Insert(Upper(LanguageEnglish), WordProperties);
	
EndProcedure

// For the LanguageSyntax function.
Function TablesTypes()
	
	TablesTypes = New Structure;
	TablesTypes.Insert("ByNames",     New Map);
	TablesTypes.Insert("ByCollections", New Map);
	
	// Setting table type names.
	AddTablesType(TablesTypes, "ExchangePlan",             "ExchangePlan",               "ExchangePlans");
	AddTablesType(TablesTypes, "FilterCriterion",         "FilterCriterion",            "FilterCriteria");
	AddTablesType(TablesTypes, "Constants",              "Constants",                  "");
	AddTablesType(TablesTypes, "Constant",              "Constant",                   "Constants");
	AddTablesType(TablesTypes, "Catalog",             "Catalog",                    "Catalogs");
	AddTablesType(TablesTypes, "Sequence",     "Sequence",                   "Sequences");
	AddTablesType(TablesTypes, "Document",               "Document",                   "Documents");
	AddTablesType(TablesTypes, "DocumentJournal",       "DocumentJournal",            "DocumentJournals");
	AddTablesType(TablesTypes, "Enum",           "Enum",                       "Enums");
	AddTablesType(TablesTypes, "ChartOfCharacteristicTypes", "ChartOfCharacteristicTypes", "ChartsOfCharacteristicTypes");
	AddTablesType(TablesTypes, "ChartOfAccounts",             "ChartOfAccounts",            "ChartsOfAccounts");
	AddTablesType(TablesTypes, "ChartOfCalculationTypes",       "ChartOfCalculationTypes",    "ChartsOfCalculationTypes");
	AddTablesType(TablesTypes, "InformationRegister",        "InformationRegister",        "InformationRegisters");
	AddTablesType(TablesTypes, "AccumulationRegister",      "AccumulationRegister",       "AccumulationRegisters");
	AddTablesType(TablesTypes, "AccountingRegister",     "AccountingRegister",         "AccountingRegisters");
	AddTablesType(TablesTypes, "CalculationRegister",         "CalculationRegister",        "CalculationRegisters");
	AddTablesType(TablesTypes, "BusinessProcess",          "BusinessProcess",            "BusinessProcesses");
	AddTablesType(TablesTypes, "Task",                 "Task",                       "Tasks");
	
	// Setting main properties of the main table types.
	TablesTypesNames = "ExchangePlan,Catalog,Document,ChartOfCharacteristicTypes,ChartOfAccounts,ChartOfCalculationTypes,BusinessProcess,Task";
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "IsReferenceType", True);
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "HasLimit", True);
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "CommonAttributes",  "Allowed");
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "Use",   "Allowed");
	
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Attributes",            "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "StandardAttributes", "Allowed");
	
	AddTablesTypeTabularSectionsCollection(TablesTypes, TablesTypesNames, "TabularSections", "Allowed");
	
	AddTablesTypeField(TablesTypes, TablesTypesNames, "DataVersion",  "DataVersion",  "Denied");
	AddTablesTypeField(TablesTypes, TablesTypesNames, "Presentation", "Presentation", "Denied");
	
	AddTablesTypeExtension(TablesTypes, TablesTypesNames, "Changes", "Changes", "Denied");
	
	// Setting main register properties.
	TablesTypesNames = "InformationRegister,CalculationRegister";
	SetTablesTypeProperty(TablesTypes,     TablesTypesNames, "CommonAttributes",       "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Resources",              "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Attributes",            "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "StandardAttributes", "Allowed");
	
	TablesTypesNames = "AccumulationRegister,AccountingRegister";
	SetTablesTypeProperty(TablesTypes,     TablesTypesNames, "CommonAttributes",       "Illegal");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Resources",              "Illegal");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Attributes",            "Illegal");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "StandardAttributes", "Illegal");
	
	TablesTypesNames = "InformationRegister,AccumulationRegister,AccountingRegister,CalculationRegister";
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "HasLimit", True);
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Dimensions", "Allowed");
	
	AddTablesTypeExtension(TablesTypes, TablesTypesNames, "Changes", "Changes", "Denied");
	
	// Setting some of the earlier mentioned properties for other table types.
	SetTablesTypeProperty(TablesTypes,     "Sequence", "HasLimit", True);
	AddTablesTypeFieldsCollection(TablesTypes, "Sequence", "Dimensions", "Allowed");
	
	SetTablesTypeProperty(TablesTypes,     "DocumentJournal", "CommonAttributes",       "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, "DocumentJournal", "StandardAttributes", "Allowed");
	
	SetTablesTypeProperty(TablesTypes,     "Enum", "IsReferenceType", True);
	AddTablesTypeFieldsCollection(TablesTypes, "Enum", "StandardAttributes", "Allowed");
	
	TablesTypesNames = "Constant,InformationRegister";
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "Use", "Allowed");
	SetTablesTypeProperty(TablesTypes, "FilterCriterion", "Use", "Illegal");
	
	AddTablesTypeExtension(TablesTypes, "Constant",       "Changes",     "Changes",    "Denied");
	AddTablesTypeExtension(TablesTypes, "InformationRegister", "SliceFirst",    "SliceFirst", "Illegal");
	AddTablesTypeExtension(TablesTypes, "InformationRegister", "SliceLast", "SliceLast",  "Illegal");
	AddTablesTypeExtension(TablesTypes, "BusinessProcess",   "Points",         "Points",     "Denied");
	
	// Setting special properties.
	SetTablesTypeProperty(TablesTypes, "ChartOfAccounts", "ExtDimensionAccountingFlags", "Allowed");
	
	AddTablesTypeFieldsCollection(TablesTypes, "DocumentJournal", "Columns",              "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, "ChartOfAccounts",       "AccountingFlags",      "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, "Task",           "AddressingAttributes", "Allowed");
	
	AddTablesTypeTabularSectionsCollection(TablesTypes, "ChartOfAccounts",       "StandardTabularSections", "Allowed");
	AddTablesTypeTabularSectionsCollection(TablesTypes, "ChartOfCalculationTypes", "StandardTabularSections", "Allowed");
	
	TablesTypesNames = "Catalog,Enum,ChartOfCharacteristicTypes,ChartOfAccounts,ChartOfCalculationTypes";
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "HasPredefined", True);
	
	// Clarifying standard fields of table types.
	TablesTypesNames = "Document,InformationRegister,AccumulationRegister,AccountingRegister";
	AddTablesTypeField(TablesTypes, TablesTypesNames, "PointInTime", "PointInTime", "Illegal");
	
	TablesTypesNames = "Catalog,ChartOfCharacteristicTypes,ChartOfAccounts,ChartOfCalculationTypes";
	AddTablesTypeField(TablesTypes, TablesTypesNames, "PredefinedDataName", "PredefinedDataName", "Denied");
	
	AddTablesTypeField(TablesTypes, "Constant",          "Value",          "Value",               "Allowed");
	AddTablesTypeField(TablesTypes, "Sequence", "Recorder",       "Recorder",            "Allowed");
	AddTablesTypeField(TablesTypes, "Sequence", "Period",            "Period",              "Allowed");
	AddTablesTypeField(TablesTypes, "DocumentJournal",   "Type",               "Type",                "Illegal");
	AddTablesTypeField(TablesTypes, "Enum",       "Order",           "Order",               "Denied");
	
	Return TablesTypes;
	
EndFunction

// For the TablesTypes function.
Procedure AddTablesType(TablesTypes, LanguageRussian, LanguageEnglish, CollectionName)
	
	// The "Use" property for tables.
	// "Allowed"   - can be used without restrictions.
	// "NotAllowed" - cannot be used in 1C:Enterprise platform access restriction.
	// "Prohibited"   - it is prohibited to connect as an additional table in the 1C:Subsystems Library access restriction.
	
	TablesTypeProperties = New Structure;
	TablesTypeProperties.Insert("CollectionName",             CollectionName);
	TablesTypeProperties.Insert("LanguageRussian",              LanguageRussian);
	TablesTypeProperties.Insert("LanguageEnglish",           LanguageEnglish);
	TablesTypeProperties.Insert("IsReferenceType",          False);
	TablesTypeProperties.Insert("HasLimit",          False);
	TablesTypeProperties.Insert("HasPredefined",     False);
	TablesTypeProperties.Insert("FieldCollections",           New Map);
	TablesTypeProperties.Insert("TabularPartCollections", New Map);
	TablesTypeProperties.Insert("CommonAttributes",           "Missing");
	TablesTypeProperties.Insert("ExtDimensionAccountingFlags",    "Missing");
	TablesTypeProperties.Insert("FieldsClarification",           New Map);
	TablesTypeProperties.Insert("TablesClarification",          New Map);
	TablesTypeProperties.Insert("Use",            "Denied");
	
	TablesTypes.ByNames.Insert(Upper(LanguageRussian),    TablesTypeProperties);
	TablesTypes.ByNames.Insert(Upper(LanguageEnglish), TablesTypeProperties);
	
	If ValueIsFilled(CollectionName) Then
		TablesTypes.ByCollections.Insert(CollectionName, TablesTypeProperties);
	EndIf;
	
EndProcedure

// For the TablesTypes function.
Procedure SetTablesTypeProperty(TablesTypes, TablesTypesNames, Property, Value)
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		TablesTypeProperties[Property] = Value;
	EndDo;
	
EndProcedure

// For the TablesTypes function.
Procedure AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, CollectionName, Usage)
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		TablesTypeProperties.FieldCollections.Insert(CollectionName, Usage);
	EndDo;
	
EndProcedure

// For the TablesTypes function.
Procedure AddTablesTypeTabularSectionsCollection(TablesTypes, TablesTypesNames, CollectionName, Usage)
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		TablesTypeProperties.TabularPartCollections.Insert(CollectionName, Usage);
	EndDo;
	
EndProcedure

// For the TablesTypes function.
Procedure AddTablesTypeField(TablesTypes, TablesTypesNames, LanguageRussian, LanguageEnglish, Usage)
	
	// Use:
	// "Allowed"   - can be used without restrictions.
	// "NotAllowed" - cannot be used in 1C:Enterprise platform access restriction.
	// "Prohibited"   - it is prohibited to use in the 1C:Subsystems Library access restriction.
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		FieldClarification = New Structure;
		FieldClarification.Insert("LanguageRussian",    LanguageRussian);
		FieldClarification.Insert("LanguageEnglish", LanguageEnglish);
		FieldClarification.Insert("Use",  Usage);
		
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		
		TablesTypeProperties.FieldsClarification.Insert(Upper(LanguageRussian),    FieldClarification);
		TablesTypeProperties.FieldsClarification.Insert(Upper(LanguageEnglish), FieldClarification);
	EndDo;
	
EndProcedure

// For the TablesTypes function.
Procedure AddTablesTypeExtension(TablesTypes, TablesTypesNames, LanguageRussian, LanguageEnglish, Usage)
	
	// Use:
	// "Allowed"   - can be used without restrictions.
	// "NotAllowed" - cannot be used in 1C:Enterprise platform access restriction.
	// "Prohibited"   - it is prohibited to use in the 1C:Subsystems Library access restriction.
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		TablesClarification = New Structure;
		TablesClarification.Insert("LanguageRussian",    LanguageRussian);
		TablesClarification.Insert("LanguageEnglish", LanguageEnglish);
		TablesClarification.Insert("Use",  Usage);
		
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		
		TablesTypeProperties.TablesClarification.Insert(Upper(LanguageRussian),    TablesClarification);
		TablesTypeProperties.TablesClarification.Insert(Upper(LanguageEnglish), TablesClarification);
	EndDo;
	
EndProcedure

#EndRegion

#Region Parsing

// For the ParsedRestriction function.
Function RestrictionParts(InternalData)
	
	RestrictionParts = New Structure;
	RestrictionParts.Insert("AdditionalTables",    New Array);
	RestrictionParts.Insert("MainTableAlias", "");
	RestrictionParts.Insert("ReadRestriction",        New Structure);
	RestrictionParts.Insert("UpdateRestriction",     New Structure);
	
	CharsetsTable = InternalData.CharsetsTable;
	
	If CharsetsTable.Count() = 0 Then
		Return RestrictionParts;
	EndIf;
	
	CharsetsTable.Columns.Add("Rows", New TypeDescription("Array"));
	CharsetsTable.Columns.Add("EndString");
	
	// Separating a restriction into main parts.
	Rows = CharsetsTable.FindRows(New Structure("Chars, Kind", ";", "Separator"));
	
	SeparatorRowsIndexes = New Array;
	For Each Row In Rows Do
		SeparatorRowsIndexes.Add(CharsetsTable.IndexOf(Row));
	EndDo;
	SeparatorRowsIndexes.Add(CharsetsTable.Count() - 1);
	
	PartsProperties = New Array;
	RowIndex = 0;
	For Each SeparatorRowIndex In SeparatorRowsIndexes Do
		PartRows = New Array;
		While RowIndex < SeparatorRowIndex Do
			PartRow = CharsetsTable[RowIndex];
			If PartRow.Kind <> "IllegalCharacter" Then
				PartRows.Add(PartRow);
			EndIf;
			RowIndex = RowIndex + 1;
		EndDo;
		SeparatorRow = CharsetsTable[SeparatorRowIndex];
		If PartRows.Count() = 0 Then
			PartRows.Add(SeparatorRow);
		EndIf;
		PartProperties = New Structure;
		PartProperties.Insert("Rows", PartRows);
		PartProperties.Insert("SeparatorRow", SeparatorRow);
		PartsProperties.Add(PartProperties);
		If PartRows[0].Kind = "Keyword"
		   AND PartRows[0].Type = "Begin" Then
			
			PartProperties.Insert("Name",           PartRows[0].Clarification);
			PartProperties.Insert("Presentation", PartRows[0].Chars);
			
			ParseRestrictionPart(PartProperties, InternalData);
		Else
			PartProperties.Insert("Name",           "");
			PartProperties.Insert("Presentation", "");
		EndIf;
		RowIndex = SeparatorRowIndex + 1;
	EndDo;
	
	AddDefaultAliases(InternalData);
	
	// Part 1 analysis.
	Part1Properties = PartsProperties[0];
	
	If Part1Properties.Name = "" Then
		SetPartBeginningError(Part1Properties, InsertKeywordsIntoString(InternalData,
			NStr("ru = 'В начале первой части текста ограничения не найдено ни одно из ключевых слов
			           |""%1"", ""%2"", ""%3""'; 
			           |en = 'None of ""%1"", ""%2"", ""%3"" keywords
			           |is found in the first part of the restriction text'; 
			           |pl = 'Na początku pierwszej części tekstu ograniczenia, nie znaleziono ani jednego ze słów kluczowych
			           |""%1"", ""%2"", ""%3""';
			           |es_ES = 'Al inicio de la primera parte de texto de la restricción no se ha encontrado ninguna de las palabras claves
			           |""%1"", ""%2"", ""%3""';
			           |es_CO = 'Al inicio de la primera parte de texto de la restricción no se ha encontrado ninguna de las palabras claves
			           |""%1"", ""%2"", ""%3""';
			           |tr = 'Kısıtlama metnin ilk bölümünde anahtar kelimelerin hiç biri bulunamadı 
			           |""%1"", ""%2"", ""%3""';
			           |it = 'Nessuna delle parole chiave ""%1"", %2, %3 
			           |è stata trovata nella prima parte del testo di restrizione';
			           |de = 'Am Anfang des ersten Teils des Einschränkungstextes wurden keine Schlüsselwörter
			           |""%1"", ""%2"", ""%3"" gefunden'"),
			"AllowReadUpdate,AllowRead,AttachAdditionalTables"));
		Return RestrictionParts;
		
	ElsIf Part1Properties.Name = "AllowUpdateIfReadingAllowed" Then
		SetPartBeginningError(Part1Properties,
			NStr("ru = 'В начале первой части текста ограничения найдено недопустимое ключевое слово'; en = 'Invalid keyword is found at the beginning of the first part of the restriction text'; pl = 'Na początku pierwszej części tekstu ograniczenia znaleziono nieprawidłowe słowo kluczowe';es_ES = 'Al inicio de la primera parte de texto de la restricción se ha encontrado una palabra clave no admitida';es_CO = 'Al inicio de la primera parte de texto de la restricción se ha encontrado una palabra clave no admitida';tr = 'Kısıtlama metnin ilk kısmının başında izin verilmeyen anahtar kelime bulundu';it = 'Parola chiave non valida trovata all''inizio della prima parte del testo di restrizione';de = 'Am Anfang des ersten Teils des Einschränkungstextes wurde ein ungültiges Schlüsselwort gefunden'"));
		Return RestrictionParts;
		
	ElsIf PartsProperties.Count() = 1
	        AND (    Part1Properties.Name = "AttachAdditionalTables"
	           Or Part1Properties.Name = "AllowRead" ) Then
		
		SetPartBeginningError(CharsetsTable,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Текст ограничения не может быть только из одной части
				           |с ключевым словом ""%1""'; 
				           |en = 'Restriction text cannot have just one part
				           |with keyword ""%1""'; 
				           |pl = 'Tekst ograniczenia nie może składać się tylko z jednej części
				           |ze słowem kluczowym ""%1""';
				           |es_ES = 'Texto con restricciones no puede contener solo una parte
				           |con una palabra clave ""%1""';
				           |es_CO = 'Texto con restricciones no puede contener solo una parte
				           |con una palabra clave ""%1""';
				           |tr = 'Kısıtlama metni, "
" anahtar kelime ile tek bölümden %1 oluşmaz';
				           |it = 'Il testo di restrizione non può avere solo una parte
				           |con la parola chiave ""%1""';
				           |de = 'Der Text der Einschränkung darf nicht nur ein Teil
				           |des Schlüsselwortes ""%1"" sein'"), Part1Properties.Presentation));
		Return RestrictionParts;
	EndIf;
	
	SetRestrictionPart(RestrictionParts, Part1Properties);
	
	If PartsProperties.Count() < 2 Then
		Return RestrictionParts;
	EndIf;
	
	// Part 2 analysis.
	Part2Properties = PartsProperties[1];
	
	If Part1Properties.Name = "AllowReadUpdate" Then
		SetPartBeginningError(Part1Properties.SeparatorRow,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Второй части текста ограничения не должно быть, когда
				           |в первой части указано ключевое слово ""%1""'; 
				           |en = 'There must not be the second part of the restriction text when
				           |the ""%1"" keyword is specified in the first part'; 
				           |pl = 'Drugiej części tekstu ograniczenia nie powinno być, gdy
				           |w pierwszej części podane słowo kluczowe ""%1""';
				           |es_ES = 'No debe haber segunda parte de restricción cuando
				           |en la primera parte está indicada la palabra clave ""%1""';
				           |es_CO = 'No debe haber segunda parte de restricción cuando
				           |en la primera parte está indicada la palabra clave ""%1""';
				           |tr = '""%1"" anahtar kelimesi ilk bölümde belirtildiğinde
				           |kısıtlama metninin ikinci kısmı olmamalıdır';
				           |it = 'Non deve esserci la seconda parte del testo di restrizione quando
				           |la parola chiave ""%1"" è indicata nella prima parte';
				           |de = 'Der zweite Teil des Textes der Einschränkung sollte nicht sein, wenn
				           |der erste Teil das Schlüsselwort ""%1"" enthält'"), Part1Properties.Presentation));
		Return RestrictionParts;
	EndIf;
	
	If Part2Properties.Name = "" Then
		If Part1Properties.Name = "AllowRead" Then
			SetPartBeginningError(Part2Properties, InsertKeywordsIntoString(InternalData,
				NStr("ru = 'В начале второй части текста ограничения не найдено
				           |ключевое слово ""%1""'; 
				           |en = 'The ""%1"" keyword is not found
				           |at the beginning of the second part of the restriction text'; 
				           |pl = 'Na początku drugiej części tekstu ograniczenia nie znaleziono
				           |słowo kluczowe ""%1""';
				           |es_ES = 'Al inicio de la segunda parte de texto de la restricción se ha encontrado
				           | una palabra clave ""%1""';
				           |es_CO = 'Al inicio de la segunda parte de texto de la restricción se ha encontrado
				           | una palabra clave ""%1""';
				           |tr = 'Kısıtlama metninin ikinci bölümünün başında
				           |""%1"" anahtar kelimesi bulunmadı';
				           |it = 'La parola chiave ""%1"" non è stata trovata
				           |all''inizio della seconda parte del testo di restrizione';
				           |de = 'Zu Beginn des zweiten Teils des Einschränkungstextes wurde
				           |das Schlüsselwort ""%1"" nicht gefunden'"),
				"AllowUpdateIfReadingAllowed"));
		Else // Part1Properties.Name = "AttachAdditionalTables".
			SetPartBeginningError(Part2Properties, InsertKeywordsIntoString(InternalData,
				NStr("ru = 'В начале второй части текста ограничения не найдено ни одно из ключевых слов
				           |""%1"", ""%2""'; 
				           |en = 'None of ""%1"", ""%2"" keywords
				           |is found at the beginning of the second part of the restriction text'; 
				           |pl = 'Na początku drugiej części tekstu ograniczenia, nie znaleziono ani jednego ze słów kluczowych
				           |""%1"", ""%2""';
				           |es_ES = 'Al inicio de la segunda parte de texto de la restricción no se ha encontrado ninguna de las palabras claves
				           |""%1"", ""%2""';
				           |es_CO = 'Al inicio de la segunda parte de texto de la restricción no se ha encontrado ninguna de las palabras claves
				           |""%1"", ""%2""';
				           |tr = 'Kısıtlama metnin ikinci bölümünde anahtar kelimelerin hiç biri bulunamadı 
				           |""%1"", ""%2""';
				           |it = 'Nessuna delle parole chiave ""%1"", ""%2""
				           |è stata trovata all''inizio della seconda parte del testo di restrizione';
				           |de = 'Am Anfang des zweiten Teils des Einschränkungstextes wurden keine Schlüsselwörter
				           |""%1"", ""%2"" gefunden'"),
				"AllowReadUpdate,AllowRead"));
		EndIf;
		Return RestrictionParts;
		
	ElsIf Part1Properties.Name = "AllowRead"
	        AND Part2Properties.Name <> "AllowUpdateIfReadingAllowed"
	      Or Part1Properties.Name = "AttachAdditionalTables"
	        AND Part2Properties.Name <> "AllowReadUpdate"
	        AND Part2Properties.Name <> "AllowRead" Then
		
		SetPartBeginningError(Part2Properties,
			NStr("ru = 'В начале второй части текста ограничения найдено недопустимое ключевое слово'; en = 'Invalid keyword is found at the beginning of the second part of the restriction text'; pl = 'Na początku drugiej części tekstu ograniczenia znaleziono nieprawidłowe słowo kluczowe';es_ES = 'Al inicio de la segunda parte de texto de la restricción se ha encontrado una palabra clave no admitida';es_CO = 'Al inicio de la segunda parte de texto de la restricción se ha encontrado una palabra clave no admitida';tr = 'Kısıtlama metnin ikinci kısmının başında izin verilmeyen anahtar kelime bulundu';it = 'Parola chiave non valida trovata all''inizio della seconda parte del testo di restrizione';de = 'Am Anfang des zweiten Teils des Einschränkungstextes wurde ein ungültiges Schlüsselwort gefunden'"));
		Return RestrictionParts;
		
	ElsIf PartsProperties.Count() = 2
	        AND Part2Properties.Name = "AllowRead" Then
		
		SetPartBeginningError(CharsetsTable,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Текст ограничения не может быть только из двух частей, когда
				           |во второй части указано ключевое слово ""%1""'; 
				           |en = 'Restriction text cannot consist only of two parts when
				           |the ""%1"" keyword is specified in the second part'; 
				           |pl = 'Tekst ograniczenia nie może być tylko z dwóch części, gdy
				           |w drugiej części wskazano słowo kluczowe ""%1""';
				           |es_ES = 'Texto de restricción no puede tener solo dos partes cuando
				           |en la segunda parte está indicada una palabra clave ""%1""';
				           |es_CO = 'Texto de restricción no puede tener solo dos partes cuando
				           |en la segunda parte está indicada una palabra clave ""%1""';
				           |tr = '""%1"" anahtar kelimesi ikinci kısımda belirtildiğinde
				           |kısıtlama metni sadece iki kısımdan oluşamaz';
				           |it = 'Il testo di restrizione non può essere composto solo da due parti
				           |se la parola chiave ""%1"" viene indicata nella seconda parte';
				           |de = 'Der Text der Einschränkung darf nicht nur aus zwei Teilen bestehen, wenn
				           |der zweite Teil das Schlüsselwort ""%1"" enthält'"), Part2Properties.Presentation));
		Return RestrictionParts;
	EndIf;
	
	SetRestrictionPart(RestrictionParts, Part2Properties);
	
	If PartsProperties.Count() < 3 Then
		Return RestrictionParts;
	EndIf;
	
	// Part 3 analysis.
	Part3Properties = PartsProperties[2];
	
	If Part2Properties.Name = "AllowReadUpdate" Then
		SetPartBeginningError(Part2Properties.SeparatorRow,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Третьей части текста ограничения не должно быть, когда
				           |во второй части указано ключевое слово ""%1""'; 
				           |en = 'There should not be the third part of the restriction text when
				           |the ""%1"" keyword is specified in the second part'; 
				           |pl = 'Trzeciej części tekstu ograniczenia nie powinno być, gdy
				           |w drugiej części wskazano słowo kluczowe ""%1""';
				           |es_ES = 'No debe haber tercera parte de restricción cuando
				           |en la segunda parte está indicada la palabra clave ""%1""';
				           |es_CO = 'No debe haber tercera parte de restricción cuando
				           |en la segunda parte está indicada la palabra clave ""%1""';
				           |tr = 'Kısıtlama metninin üçüncü kısmı, %1ikinci bölümde "
" bir anahtar kelime belirtildiğinde olmamalıdır';
				           |it = 'Non dovrebbe esserci alcuna terza parte del testo di restrizione 
				           |se la parola chiave ""%1"" viene indicata nella seconda parte';
				           |de = 'Der dritte Teil des Textes der Einschränkung sollte nicht sein, wenn
				           |der zweite Teil das Schlüsselwort ""%1"" enthält'"), Part2Properties.Presentation));
		Return RestrictionParts;
	EndIf;
	
	If Part3Properties.Name = "" Then
		SetPartBeginningError(Part3Properties, InsertKeywordsIntoString(InternalData,
			NStr("ru = 'В начале третьей части текста ограничения не найдено
			           |ключевое слово ""%1""'; 
			           |en = 'The ""%1"" keyword is not found
			           |at the beginning of the third part of the restriction text'; 
			           |pl = 'Na początku trzeciej części tekstu ograniczenia nie znaleziono
			           |słowo kluczowe ""%1""';
			           |es_ES = 'Al inicio de la tercera parte de texto de la restricción se ha encontrado
			           | una palabra clave ""%1""';
			           |es_CO = 'Al inicio de la tercera parte de texto de la restricción se ha encontrado
			           | una palabra clave ""%1""';
			           |tr = 'Kısıtlama metninin üçüncü bölümünün başında
			           |""%1"" anahtar kelimesi bulunmadı';
			           |it = 'La parola chiave ""%1"" non è stata trovata
			           |all''inizio della terza parte del testo di restrizione';
			           |de = 'Am Anfang des dritten Teils des Einschränkungstextes wird
			           |das Schlüsselwort ""%1"" nicht gefunden'"),
			"AllowUpdateIfReadingAllowed"));
		Return RestrictionParts;
		
	ElsIf Part2Properties.Name = "AllowRead"
	        AND Part3Properties.Name <> "AllowUpdateIfReadingAllowed" Then
		
		SetPartBeginningError(Part3Properties,
			NStr("ru = 'В начале третьей части текста ограничения найдено недопустимое ключевое слово'; en = 'Invalid keyword is found at the beginning of the third part of the restriction text'; pl = 'Na początku trzeciej części tekstu ograniczenia znaleziono nieprawidłowe słowo kluczowe';es_ES = 'Al inicio de la primera parte de texto de la restricción se ha encontrado una palabra clave no admitida';es_CO = 'Al inicio de la primera parte de texto de la restricción se ha encontrado una palabra clave no admitida';tr = 'Kısıtlama metnin üçüncü kısmının başında izin verilmeyen anahtar kelime bulundu';it = 'Parola chiave non valida trovata all''inizio della terza parte del testo di restrizione';de = 'Am Anfang des dritten Teils des Textes der Einschränkung wurde ein ungültiges Schlüsselwort gefunden'"));
		Return RestrictionParts;
	EndIf;
	
	SetRestrictionPart(RestrictionParts, Part3Properties);
	
	Return RestrictionParts;
	
EndFunction

// For the RestrictionParts function.
Procedure SetRestrictionPart(RestrictionParts, PartProperties)
	
	If PartProperties.Name = "AllowReadUpdate"
	 Or PartProperties.Name = "AllowRead" Then
		
		PropertyName = "ReadRestriction";
		
	ElsIf PartProperties.Name = "AllowUpdateIfReadingAllowed" Then
		
		PropertyName = "UpdateRestriction";
		
	Else // AttachAdditionalTables.
		
		PropertyName = "AdditionalTables";
		RestrictionParts.MainTableAlias = PartProperties.MainTableAlias;
	EndIf;
	
	RestrictionParts[PropertyName] = PartProperties.Content;
	
EndProcedure

// For the RestrictionParts function and the ParseAdditionalTables and ParseRestrictionCondition procedures.
Procedure SetPartBeginningError(PartProperties, ErrorText)
	
	If TypeOf(PartProperties) = Type("ValueTable") Then
		RowWithError = PartProperties[PartProperties.Count() - 1];
		
	ElsIf TypeOf(PartProperties) = Type("ValueTableRow") Then
		RowWithError = PartProperties;
	Else
		RowWithError = PartProperties.Rows[0];
	EndIf;
	
	RowWithError.ErrorText = ErrorText;
	
	// Description of the first keyword options of parts is required.
	RowWithError.ErrorPosition = -1;
	
EndProcedure

// For the ParseConnection procedure.
Procedure SetErrorInsidePart(Rows, RowIndex, ErrorText)
	
	If RowIndex < Rows.Count() Then
		RowWithError = Rows[RowIndex];
	Else
		RowWithError = Rows[RowIndex - 1];
		// An error in the end of the word.
		RowWithError.ErrorPosition = StrLen(RowWithError.Chars);
	EndIf;
	
	RowWithError.ErrorText = ErrorText;
	
EndProcedure

// For the ExpressionsInParenthesesInAttachments and ExpressionsWhenThenSelectionInAttachments function.
Procedure SetErrorInRow(Row, ErrorText, InWordEnd = False, WordNumber = 1)
	
	If ValueIsFilled(Row.ErrorText) Then
		Return;
	EndIf;
	
	If InWordEnd Then
		Row.ErrorPosition = StrLen(Row.Chars);
		
	ElsIf WordNumber > 1 Then
		NameContent = StrSplit(Row.Chars, ".");
		If NameContent.Count() > 1 Then
			Row.ErrorPosition = StrLen(NameContent[0]) + 1;
		EndIf;
	EndIf;
	
	Row.ErrorText = ErrorText;
	
EndProcedure

// For the RestrictionParts function.
Procedure ParseRestrictionPart(PartProperties, InternalData)
	
	FirstWord = PartProperties.Rows[0];
	
	If PartProperties.Name = "AttachAdditionalTables" Then
		PartProperties.Insert("Content", New Array);
		PartProperties.Insert("MainTableAlias", "");
		ParseAdditionalTables(PartProperties, InternalData);
	Else
		PartProperties.Insert("Content", New Structure);
		ParseRestrictionCondition(PartProperties, InternalData);
	EndIf;
	
EndProcedure

// For the ParseRestrictionPart procedure.
Procedure ParseAdditionalTables(PartProperties, InternalData)
	
	PartRows = PartProperties.Rows;
	
	If PartRows.Count() < 2
	 Or PartRows[1].Kind <> "Keyword"
	 Or PartRows[1].Clarification <> "ThisList" Then
		SetPartBeginningError(
			?(PartRows.Count() < 3, PartProperties.SeparatorRow, PartRows[1]),
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'После ключевого слова ""%1"" не найдено
				           |ключевое слово ""%2""'; 
				           |en = 'Keyword ""%2"" is not found
				           |after keyword ""%1""'; 
				           |pl = 'Po słowie kluczowym ""%1"" nie znaleziono
				           |słowo kluczowe ""%2""';
				           |es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado
				           |una palabra clave ""%2""';
				           |es_CO = 'Después de la palabra clave ""%1"" no se ha encontrado
				           |una palabra clave ""%2""';
				           |tr = '""%1"" anahtar kelimesinden sonra "
" anahtar kelimesi %2 bulunamadı';
				           |it = 'Keyword ""%2"" non è stata trovata
				           |dopo la keyword ""%1""';
				           |de = 'Nach dem Schlüsselwort ""%1"" wurde
				           |das Schlüsselwort ""%2"" nicht gefunden'"),
				PartProperties.Presentation,
				KeywordRegardingLanguage("ThisList", InternalData)));
		Return;
	EndIf;
	
	ChangeKeywordTypeListToName(PartRows, PartRows[1]);
	
	If PartRows.Count() < 3
	 Or PartRows[2].Kind <> "Keyword"
	 Or PartRows[2].Clarification <> "As" Then
		SetPartBeginningError(
			?(PartRows.Count() < 3, PartProperties.SeparatorRow, PartRows[2]),
				InsertKeywordsIntoString(InternalData,
					NStr("ru = 'После ключевого слова ""%1"" не найдено ключевое слово ""%2""'; en = 'Keyword ""%2"" is not found after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie znaleziono słowo kluczowe ""%2""';es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado una palabra clave ""%2""';es_CO = 'Después de la palabra clave ""%1"" no se ha encontrado una palabra clave ""%2""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelimesi bulunamadı';it = 'La parola chiave ""%2"" non è stata trovata dopo la parola chiave ""%1""';de = 'Nach dem Schlüsselwort ""%1"" wurde das Schlüsselwort ""%2"" nicht gefunden'"),
					"List,As"));
		Return;
	EndIf;
	
	If PartRows.Count() < 4
	 Or PartRows[3].Kind <> "Name" Then
		SetPartBeginningError(
			?(PartRows.Count() < 4, PartProperties.SeparatorRow, PartRows[3]),
				InsertKeywordsIntoString(InternalData,
					NStr("ru = 'После ключевого слова ""%1"" не найден псевдоним'; en = 'Alias is not found after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie znaleziono alias';es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado alias';es_CO = 'Después de la palabra clave ""%1"" no se ha encontrado alias';tr = '""%1"" anahtar kelimesinden sonra takma ad bulunamadı';it = 'Pseudonimo non trovato dopo la parola chiave ""%1""';de = 'Kein Alias nach dem Schlüsselwort ""%1"" gefunden'"),
					"As"));
		Return;
	EndIf;
	
	SetAlias(PartRows[3], PartProperties.MainTableAlias, InternalData);
	
	// Dividing description into groups of left connections.
	Connections = New Array;
	CurrentConnection = New Array;
	
	For Index = 4 To PartRows.Count()-1 Do
		PartRow = PartRows[Index];
		
		If PartRow.Kind = "Keyword"
		   AND PartRow.Clarification = "Left" Then
			
			If CurrentConnection.Count() > 0 Then
				Connections.Add(CurrentConnection);
			EndIf;
			CurrentConnection = New Array;
			CurrentConnection.Add(PartRow);
			
			If Index + 1 < PartRows.Count()
			   AND PartRows[Index + 1].Kind = "Keyword"
			   AND PartRows[Index + 1].Clarification = "Join" Then
				
				Index = Index + 1;
				CurrentConnection.Add(PartRows[Index]);
			EndIf;
			
			Continue;
		EndIf;
		CurrentConnection.Add(PartRow);
	EndDo;
	
	If CurrentConnection.Count() > 0
	 Or Connections.Count() = 0 Then
		
		Connections.Add(CurrentConnection);
	EndIf;
	
	For Each Connection In Connections Do
		// The condition is parsed universally (maximum), after that errors for the prohibited possibilities 
		// are identified.
		ParseConnection(Connection, PartProperties, InternalData);
	EndDo;
	
	// Continue parsing after filling in the aliases of all additional tables.
	For Each ConnectionDetails In PartProperties.Content Do
		// Only simple conditions are allowed:
		// Field1 = Field2 [And Field3 = Field4] [And Field5 = Constant].
		ParseConnectionConditionFieldsAndMarkProhibitions(ConnectionDetails, InternalData);
	EndDo;
	
EndProcedure

// For the ParseAdditionalTables procedure.
Procedure ParseConnection(Connection, PartProperties, InternalData)
	
	ConnectionDetails = New Structure;
	ConnectionDetails.Insert("Table", "");
	ConnectionDetails.Insert("Alias", "");
	ConnectionDetails.Insert("ConnectionCondition", Undefined);
	
	If Connection[0].Kind <> "Keyword"
	 Or Connection[0].Clarification <> "Left" Then
		SetErrorInsidePart(Connection, 0, InsertKeywordsIntoString(InternalData,
			NStr("ru = 'Не найдено ключевое слово ""%1""'; en = 'Keyword ""%1"" is not found'; pl = 'Nie znaleziono słowo kluczowe ""%1""';es_ES = 'No se ha encontrado la palabra clave ""%1""';es_CO = 'No se ha encontrado la palabra clave ""%1""';tr = '""%1"" anahtar kelimesi bulunamadı';it = 'La keyword ""%1"" non è stata trovata';de = 'Es wurde kein Schlüsselwort ""%1"" gefunden'"), "Left"));
		
		If Connection[0].Kind <> "Keyword"
		 Or Connection[0].Clarification <> "Inner"
		   AND Connection[0].Clarification <> "Full" Then
			
			Return;
		EndIf;
	EndIf;
	
	If Connection.Count() < 2
	 Or Connection[1].Kind <> "Keyword"
	 Or Connection[1].Clarification <> "Join" Then
		SetErrorInsidePart(Connection, 1,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'После ключевого слова ""%1"" не найдено ключевое слово ""%2""'; en = 'Keyword ""%2"" is not found after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie znaleziono słowo kluczowe ""%2""';es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado una palabra clave ""%2""';es_CO = 'Después de la palabra clave ""%1"" no se ha encontrado una palabra clave ""%2""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelimesi bulunamadı';it = 'La parola chiave ""%2"" non è stata trovata dopo la parola chiave ""%1""';de = 'Nach dem Schlüsselwort ""%1"" wurde das Schlüsselwort ""%2"" nicht gefunden'"),
				Connection[0].Chars,
				KeywordRegardingLanguage("Join", InternalData)));
		Return;
	EndIf;
	
	If Connection.Count() < 3
	 Or Connection[2].Kind <> "Name" Then
		SetErrorInsidePart(Connection, 2,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'После ключевого слова ""%1"" не найдено имя таблицы'; en = 'Table name is not found after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie znaleziono nazwy tabeli';es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado nombre de tabla';es_CO = 'Después de la palabra clave ""%1"" no se ha encontrado nombre de tabla';tr = '""%1"" anahtar kelimesinden sonra tablo adı bulunamadı';it = 'Nome tabella non trovato dopo la parola chiave ""%1""';de = 'Kein Tabellenname nach dem Schlüsselwort ""%1"" gefunden'"),
				Connection[1].Chars));
		Return;
	EndIf;
	
	SetTableName(Connection[2], ConnectionDetails, InternalData);
	
	If Connection.Count() < 4
	 Or Connection[3].Kind <> "Keyword"
	 Or Connection[3].Clarification <> "As" Then
		SetErrorInsidePart(Connection, 3, InsertKeywordsIntoString(InternalData,
			NStr("ru = 'После имени таблицы не найдено ключевое слово ""%1""'; en = 'Keyword ""%1"" is not found after the table name'; pl = 'Po nazwie tabeli nie znaleziono słowo kluczowe ""%1""';es_ES = 'Después del nombre de tabla no se ha encontrado palabra clave ""%1""';es_CO = 'Después del nombre de tabla no se ha encontrado palabra clave ""%1""';tr = 'Tablo adından sonra ""%1"" anahtar kelimesi bulunamadı';it = 'Dopo il nome della tabella non c''è la parola chiave ""%1""';de = 'Es wurde kein Schlüsselwort ""%1"" nach dem Tabellennamen gefunden'"), "As"));
		Return;
	EndIf;
	
	If Connection.Count() < 5
	 Or Connection[4].Kind <> "Name" Then
		SetErrorInsidePart(Connection, 4, InsertKeywordsIntoString(InternalData,
			NStr("ru = 'После ключевого слова ""%1"" не найден псевдоним таблицы'; en = 'Table alias is not found after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie znaleziono aliasu tabeli';es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado alias de la tabla';es_CO = 'Después de la palabra clave ""%1"" no se ha encontrado alias de la tabla';tr = '""%1"" anahtar kelimesinden sonra tablonun takma adı bulunamadı';it = 'Pseudonimo tabella non trovato dopo la parola chiave ""%1""';de = 'Kein Tabellenalias nach dem Schlüsselwort ""%1"" gefunden'"), "As"));
		Return;
	EndIf;
	
	SetAlias(Connection[4], ConnectionDetails, InternalData);
	
	If Connection.Count() < 6
	 Or Connection[5].Kind <> "Keyword"
	 Or Connection[5].Clarification <> "On" Then
		SetErrorInsidePart(Connection, 5, InsertKeywordsIntoString(InternalData,
			NStr("ru = 'После псевдонима таблицы не найдено ключевое слово ""%1""'; en = 'Keyword ""%1"" is not found after the table alias'; pl = 'Po aliasie tabeli nie znaleziono słowo kluczowe ""%1""';es_ES = 'Después de alias de tabla no se ha encontrado palabra clave ""%1""';es_CO = 'Después de alias de tabla no se ha encontrado palabra clave ""%1""';tr = 'Tablonun takma adından sonra ""%1"" anahtar kelimesi bulunamadı';it = 'Dopo lo pseudonimo della tabella non c''è la parola chiave ""%1""';de = 'Es wurde kein Schlüsselwort ""%1"" nach dem Tabellenalias gefunden'"), "On"));
		Return;
	EndIf;
	
	Condition = New Array(New FixedArray(Connection));
	For Index = 0 To 5 Do
		Condition.Delete(0);
	EndDo;
	
	ParseCondition(Condition, ConnectionDetails.ConnectionCondition, InternalData);
	
	PartProperties.Content.Add(ConnectionDetails);
	
EndProcedure

// For the ParseAdditionalTables procedure.
Procedure ParseConnectionConditionFieldsAndMarkProhibitions(ConnectionDetails, InternalData)
	
	// Marking incorrect operation arguments and prohibited features.
	CommonNodes = New Map(AccessManagementInternalCached.NodesToCheckAvailability(
		"Field,Value,Constant,AND,=", False));
	
	CommonNodes.Insert("Field", New Structure("Cast, Attachment, IsNull", False, False, False));
	
	AvailableNodes = New Structure;
	AvailableNodes.Insert("Common",          CommonNodes);
	AvailableNodes.Insert("NodesWhen",      CommonNodes);
	AvailableNodes.Insert("NodesThenElse", CommonNodes);
	
	FixedContext = New FixedStructure(InternalData);
	Context = New Structure(FixedContext);
	Context.Insert("IsConnectionCondition",  True);
	Context.Insert("IsConditionWhen",       False);
	Context.Insert("IsValueThenElse", False);
	Context.Insert("RootNode",          ConnectionDetails.ConnectionCondition);
	Context.Insert("Parents",              New Array);
	
	MarkIncorrectArgumentsAndProhibitedNodes(ConnectionDetails.ConnectionCondition,
		AvailableNodes, Context, New Structure("Node", ""));
	
	DeleteSourceProperty(ConnectionDetails.ConnectionCondition);
	
EndProcedure

// For the ParseConnectionCondition and ParseRestrictionCondition procedures.
Function NodesToCheckAvailability(List, IsExceptionsList) Export
	
	AllNodes = New Map;
	AllNodes.Insert("Field", New Structure("Cast, Attachment, IsNull", True, True, True));
	AllNodes.Insert("Value",    True);
	AllNodes.Insert("Constant",   True);
	AllNodes.Insert("AND",           True);
	AllNodes.Insert("Or",         True);
	AllNodes.Insert("Not",          True);
	AllNodes.Insert("=",           True);
	AllNodes.Insert("<>",          True);
	AllNodes.Insert("IN",           True);
	AllNodes.Insert("IsNull",    True);
	AllNodes.Insert("Type",         True);
	AllNodes.Insert("ValueType", True);
	AllNodes.Insert("Case",       True);
	AllNodes.Insert("ValueAllowed",             True);
	AllNodes.Insert("IsAuthorizedUser", True);
	AllNodes.Insert("ObjectReadingAllowed",        True);
	AllNodes.Insert("ObjectUpdateAllowed",     True);
	AllNodes.Insert("ListReadingAllowed",         True);
	AllNodes.Insert("ListUpdateAllowed",      True);
	AllNodes.Insert("ForAllRows",                  True);
	AllNodes.Insert("ForAtLeastOneRow",               True);
	
	NodesArray = StrSplit(List, ",", False);
	Nodes = New Map;
	
	For Each Node In AllNodes Do
		If IsExceptionsList Then
			If NodesArray.Find(Node.Key) = Undefined Then
				Nodes.Insert(Node.Key, Node.Value);
			EndIf;
		Else
			If NodesArray.Find(Node.Key) <> Undefined Then
				Nodes.Insert(Node.Key, Node.Value);
			EndIf;
		EndIf;
	EndDo;
	
	Return New FixedMap(Nodes);
	
EndFunction

// For the ParseConnectionCondition and ParseRestrictionCondition procedures.
Procedure MarkIncorrectArgumentsAndProhibitedNodes(Condition, AvailableNodes, Context, Parent)
	
	If Not ValueIsFilled(Condition) Then
		Return;
	EndIf;
	Context.Parents.Insert(0, Parent);
	
	If Context.IsConditionWhen Then
		CurrentAvailableNodes = AvailableNodes.NodesWhen;
		
	ElsIf Context.IsValueThenElse Then
		CurrentAvailableNodes = AvailableNodes.NodesThenElse;
	Else
		CurrentAvailableNodes = AvailableNodes.Common;
	EndIf;
	
	NodeAvailability = CurrentAvailableNodes.Get(Condition.Node);
	
	If NodeAvailability = Undefined Then
		SetNodeProhibitedError(Condition.Source, Context);
	EndIf;
	
	If Condition.Node = "Field" Then
		
		If Not Context.IsConnectionCondition Then
			If Parent = Undefined Then
				Parent = New Structure("Node", "");
			EndIf;
			AccessKeyField = New Structure;
			AccessKeyField.Insert("Field",     Condition);
			AccessKeyField.Insert("Parents", New FixedArray(Context.Parents));
			AccessKeyField.Insert("Read",   Context.Read);
			Context.AccessKeyFields.Add(AccessKeyField);
		EndIf;
		
		SelectFieldAlias(Condition, Context);
		
		If Not NodeAvailability.Cast
		   AND Condition.Cast <> Undefined Then
			
			SetNodeProhibitedError(Condition.Source, Context);
			
		ElsIf Not NodeAvailability.Attachment
		        AND Condition.Attachment <> Undefined Then
		
			SetNodeProhibitedError(Condition.Attachment.Source, Context);
			
		ElsIf Not NodeAvailability.IsNull
		        AND Condition.IsNull <> Undefined Then
		
			SetNodeProhibitedError(Condition.IsNullSource, Context);
		EndIf;
		
	ElsIf Upper( Condition.Node ) = Upper( "AND" ) // PATCHED:
	      Or Condition.Node = "Or" Then
		
		For Each Argument In Condition.Arguments Do
			MarkIncorrectArgumentsAndProhibitedNodes(Argument, AvailableNodes, Context, Condition);
		EndDo;
		
	ElsIf Condition.Node = "Not"
	      Or Condition.Node = "IsNull"
	      Or Condition.Node = "ForAllRows"
	      Or Condition.Node = "ForAtLeastOneRow" Then
		
		// Checking the parameter correctness.
		If Condition.Node = "IsNull"
		   AND (    Condition.Argument = Undefined
		      Or Condition.Argument.Node <> "Field" ) Then
			
			SetErrorInRow(Condition.Source,
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Операция ""%1"" допустима только после поля'; en = 'Operation ""%1"" is allowed only after the field'; pl = 'Operacja ""%1"" jest dopuszczalna tylko po polu';es_ES = 'Operación ""%1"" no se admite después de este campo';es_CO = 'Operación ""%1"" no se admite después de este campo';tr = '""%1"" işlemi yalnızca alandan sonra mümkündür';it = 'Operazione ""%1"" permessa solo dopo il campo';de = 'Die Operation ""%1"" ist nur nach dem Feld zulässig'"),
					Condition.Source.Chars));
		EndIf;
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.Argument, AvailableNodes, Context, Condition);
		
	ElsIf Condition.Node = "="
	      Or Condition.Node = "<>" Then
		
		NodesCombinations = New Map;
		NodesCombinations.Insert("Value",  ",Field,");
		NodesCombinations.Insert("Constant", ",Field,Constant,");
		
		If Context.IsConnectionCondition Then
			NodesCombinations.Insert("Field",        ",Field,Value,Constant,");
		Else
			NodesCombinations.Insert("Field",        ",Value,Constant,");
			NodesCombinations.Insert("Type",         ",ValueType,");
			NodesCombinations.Insert("ValueType", ",Type,");
		EndIf;
		
		FirstArgumentCombinations = NodesCombinations.Get(Condition.FirstArgument.Node);
		SecondArgumentCombinations = NodesCombinations.Get(Condition.SecondArgument.Node);
		
		ErrorInFirstArgument  = FirstArgumentCombinations = Undefined;
		ErrorInSecondArgument = SecondArgumentCombinations = Undefined
			Or FirstArgumentCombinations <> Undefined
			  AND StrFind(FirstArgumentCombinations, "," + Condition.SecondArgument.Node + ",") = 0;
		
		If ErrorInFirstArgument Or ErrorInSecondArgument Then
			If Context.IsConnectionCondition Then
				ErrorText =
					NStr("ru = 'Операция ""%1"" допустима только для поля с полем, значением или константой'; en = 'Operation ""%1"" is allowed only after a field with a field, a value, or a constant'; pl = 'Operacja ""%1"" jest dopuszczalna tylko dla pola z polem wartość lub wartość stała';es_ES = 'Operación ""%1"" se admite solo para el campo con el campo, valor o constante';es_CO = 'Operación ""%1"" se admite solo para el campo con el campo, valor o constante';tr = '""%1"" İşlemi yalnızca alan, değer veya sabit alan için geçerlidir';it = 'Operazione ""%1"" permessa solo dopo un campo con un campo, valore o costante';de = 'Die Operation ""%1"" ist nur für ein Feld mit einem Feld, einem Wert oder einer Konstanten zulässig'");
			Else
				ErrorText =
					NStr("ru = 'Операция ""%1"" допустима только для поля со значением или константой,
					           |а также для типа значения с типом'; 
					           |en = 'Operation ""%1"" is allowed only after a field with a value or a constant,
					           |as well as a value type with a type'; 
					           |pl = 'Operacja ""%1"" jest dopuszczalna tylko dla pola z wartością lub wartością stałą,
					           |a także do typu wartości z typem';
					           |es_ES = 'Operación ""%1"" se admite solo para el campo con el valor o constante
					           |y también para el tipo de valor con el tipo';
					           |es_CO = 'Operación ""%1"" se admite solo para el campo con el valor o constante
					           |y también para el tipo de valor con el tipo';
					           |tr = '""%1"" işlemi yalnızca bir değer veya sabit alan için ve
					           | bir türe sahip bir değer türü için geçerlidir';
					           |it = 'Operazione ""%1"" permessa solo dopo un campo con un valore o una costante,
					           |così come un tipo di valore con tipo';
					           |de = 'Die Operation ""%1"" ist nur für ein Feld mit einem Wert oder einer Konstanten
					           |sowie für eine Wertart mit einem Typ'");
			EndIf;
			If ErrorInFirstArgument Then
				SetErrorInRow(Condition.FirstArgument.Source,
					StringFunctionsClientServer.SubstituteParametersToString(
						ErrorText, Condition.Source.Chars),
					True);
			EndIf;
			If ErrorInSecondArgument Then
				SetErrorInRow(Condition.SecondArgument.Source,
					StringFunctionsClientServer.SubstituteParametersToString(
						ErrorText, Condition.Source.Chars));
			EndIf;
		EndIf;
		
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.FirstArgument, AvailableNodes, Context, Condition);
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.SecondArgument, AvailableNodes, Context, Condition);
		
	ElsIf Upper( Condition.Node ) = Upper( "IN" ) Then // PATCHED
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.SearchFor, AvailableNodes, Context, Condition);
		For Each Value In Condition.Values Do
			MarkIncorrectArgumentsAndProhibitedNodes(Value, AvailableNodes, Context, Condition);
		EndDo;
		
	ElsIf Condition.Node = "ValueType"
	      Or Condition.Node = "Type" Then
		
		If Parent = Undefined
		 Or Parent.Node <> "="
		   AND Parent.Node <> "<>" Then
		
			SetErrorInRow(Condition.Source,
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Функция ""%1"" допустима только в операциях ""="" и ""<>""'; en = 'Function ""%1"" is available only in operations ""="" and ""<>""'; pl = 'Funkcja ""%1"" jest dopuszczalna tylko w operacjach ""="" i ""<>""';es_ES = 'Función ""%1"" se admite solo en las operaciones ""="" y ""<>""';es_CO = 'Función ""%1"" se admite solo en las operaciones ""="" y ""<>""';tr = '""%1"" işlevi yalnızca ""="" ve ""<>"" işlemlerde geçerlidir';it = 'La funzione ""%1"" è disponibile solo nelle operazioni ""="" e ""<>""';de = 'Die Funktion ""%1"" ist nur in den Operationen ""="" und ""<>"" erlaubt'"),
					Condition.Source.Chars));
		EndIf;
		
		If Condition.Node = "ValueType" Then
			MarkIncorrectArgumentsAndProhibitedNodes(Condition.Argument, AvailableNodes, Context, Condition);
		EndIf;
		
	ElsIf Condition.Node = "Case" Then
		If Condition.Case <> Undefined Then
			MarkIncorrectArgumentsAndProhibitedNodes(Condition.Case, AvailableNodes, Context, Condition);
		EndIf;
		FixedContext = New FixedStructure(Context);
		ContextWhen = New Structure(FixedContext);
		ContextWhen.IsConditionWhen = True;
		ContextThenElse = New Structure(FixedContext);
		ContextThenElse.IsValueThenElse = True;
		
		For Each When In Condition.When Do
			MarkIncorrectArgumentsAndProhibitedNodes(When.Condition,  AvailableNodes, ContextWhen,      Condition);
			MarkIncorrectArgumentsAndProhibitedNodes(When.Value, AvailableNodes, ContextThenElse, Condition);
		EndDo;
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.Else, AvailableNodes, ContextThenElse, Condition);
		
	ElsIf Condition.Node = "ValueAllowed"
	      Or Condition.Node = "IsAuthorizedUser"
	      Or Condition.Node = "ObjectReadingAllowed"
	      Or Condition.Node = "ObjectUpdateAllowed"
	      Or Condition.Node = "ListReadingAllowed"
	      Or Condition.Node = "ListUpdateAllowed" Then
		
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.Field, AvailableNodes, Context, Condition);
		MarkTypesRepetitionsAmongThoseToCheckAndClarify(Condition, Context);
		
		// Adding types that need to be checked for fields.
		Field = Condition.Field;
		Clarifications = New Map;
		For Each ComparisonClarification In Condition.ComparisonClarifications Do
			If TypeOf(ComparisonClarification.Key) <> Type("ValueTableRow") Then
				Clarifications.Insert(ComparisonClarification.Key, ComparisonClarification.Value);
				Continue;
			EndIf;
			Clarifications.Insert(ComparisonClarification.Key.Chars, ComparisonClarification.Value);
			AddRequiredTableField(Context, Field.Table, Field.Name, Field.NameSource,
				ComparisonClarification.Key.Chars, ComparisonClarification.Key);
		EndDo;
		
		// Deleting type sources.
		Condition.ComparisonClarifications = Clarifications;
		
		Types = New Array;
		For Each Type In Condition.Types Do
			Types.Add(Type.Chars);
		EndDo;
		Condition.Types = Types;
	EndIf;
	
	Context.Parents.Delete(0);
	
EndProcedure

// For the MarkIncorrectArgumentsAndProhibitedNodes procedure.
Procedure SelectFieldAlias(FieldNode, Context)
	
	If FieldNode.Attachment <> Undefined Then
		Attachment = FieldNode.Attachment;
		SelectFieldAlias(Attachment, Context);
		If ValueIsFilled(Attachment.Cast) Then
			FieldNode.Table = Attachment.Cast;
		EndIf;
		
	ElsIf Not ValueIsFilled(FieldNode.Name) Then
		Return;
	Else
		NameContent = StrSplit(FieldNode.Name, ".");
		If NameContent.Count() > 1 Then
			Table = Context.Aliases.Get(Upper(NameContent[0]));
			If Table <> Undefined Then
				FieldNode.Alias = NameContent[0];
				NameContent.Delete(0);
				FieldNode.Name = StrConcat(NameContent, ".");
				If ValueIsFilled(Table) Then
					FieldNode.Table = Table;
				EndIf;
			EndIf;
		EndIf;
		If Context.IsConnectionCondition
		   AND Not ValueIsFilled(FieldNode.Alias) Then
			
			SetErrorInRow(FieldNode.NameSource,
				NStr("ru = 'В условии соединения перед именем поля требуется псевдоним'; en = 'Alias is required before a field name in the join condition'; pl = 'W założeniu połączenia przed nazwą pola wymagany jest alias';es_ES = 'En la condición de conexión antes del nombre del campo se requiere un alias';es_CO = 'En la condición de conexión antes del nombre del campo se requiere un alias';tr = 'Bağlantı koşulunda alanın adından önce takma ad gerekir';it = 'Pseudonimo richiesto prima di un nome di campo nella condizione di join';de = 'Im Falle einer Verbindung ist ein Alias vor dem Feldnamen erforderlich'"));
		EndIf;
	EndIf;
	
	If ValueIsFilled(FieldNode.Cast) Then
		AddRequiredTableAsReferenceType(Context, FieldNode.Cast, FieldNode.CastSource);
	EndIf;
	
	AddRequiredTableField(Context, FieldNode.Table, FieldNode.Name, FieldNode.NameSource,
		FieldNode.Cast, FieldNode.CastSource, FieldNode);
	
EndProcedure

// For the ParseConnectionCondition and ParseRestrictionCondition procedures.
Procedure DeleteSourceProperty(Condition)
	
	If TypeOf(Condition) = Type("ValueTableRow") Then
		ErrorText = NStr("ru = 'Не все источники наборов символов удалены'; en = 'Not all sources of character sets are deleted'; pl = 'Nie wszystkie źródła zestawów znaków zostały usunięte';es_ES = 'No todas las fuentes de conjuntos de símbolos se han eliminado';es_CO = 'No todas las fuentes de conjuntos de símbolos se han eliminado';tr = 'Tüm karakter kümesi kaynakları kaldırılmadı';it = 'Non tutte le fonti dei set di caratteri sono eliminate';de = 'Nicht alle Zeichen-Set-Quellen wurden gelöscht'");
		Raise ErrorText;
		
	ElsIf TypeOf(Condition) <> Type("Structure") Then
		Return;
	EndIf;
	
	If Condition.Property("Source") Then
		Condition.Delete("Source");
	EndIf;
	
	If Condition.Property("NameSource") Then
		Condition.Delete("NameSource");
	EndIf;
	
	If Condition.Property("CastSource") Then
		Condition.Delete("CastSource");
	EndIf;
	
	If Condition.Property("IsNullSource") Then
		Condition.Delete("IsNullSource");
	EndIf;
	
	For Each KeyAndValue In Condition Do
		Value = KeyAndValue.Value;
		
		If TypeOf(Value) = Type("Array") Then
			For Each Item In Value Do
				DeleteSourceProperty(Item);
			EndDo;
			
		ElsIf TypeOf(Value) = Type("Map") Then
			For Each KeyAndValue In Value Do
				DeleteSourceProperty(KeyAndValue.Key);
				DeleteSourceProperty(KeyAndValue.Value);
			EndDo;
		Else
			DeleteSourceProperty(Value);
		EndIf;
	EndDo;
	
EndProcedure

// For the MarkIncorrectArgumentsAndProhibitedNodes procedure.
Procedure SetNodeProhibitedError(Row, Context)
	
	If Row.Type = "Function" Then
		If Context.IsConnectionCondition Then
			ErrorTemplate = NStr("ru = 'Функция ""%1"" запрещена в условии соединения'; en = 'The ""%1"" function is prohibited in the join condition'; pl = 'Funkcja ""%1"" zakazana w założeniu połączenia';es_ES = 'Función ""%1"" se ha prohibido en condición de conexión';es_CO = 'Función ""%1"" se ha prohibido en condición de conexión';tr = '""%1"" işlevi bağlantı koşulunda yasaklanmıştır';it = 'La funzione ""%1"" non è concessa nella condizione join';de = 'Die Funktion ""%1"" ist im Verbindungszustand nicht erlaubt'");
			
		ElsIf Context.IsConditionWhen Then
			ErrorTemplate = InsertKeywordsIntoString(Context,
				NStr("ru = 'Функция ""%3"" запрещена в условии ограничения в операции ""%1"" в предложении ""%2""'; en = 'The ""%3"" function is prohibited in the restriction condition in the ""%1"" operation in the ""%2"" sentence'; pl = 'Funkcja ""%3"" jest zabroniona w ograniczeniu warunku w ""%1"" operacji w ""%2"" zdaniu';es_ES = 'Función ""%3"" se ha prohibido en condición de restricción en la operación ""%1"" en la frase ""%2""';es_CO = 'Función ""%3"" se ha prohibido en condición de restricción en la operación ""%1"" en la frase ""%2""';tr = '""%3"" teklifte ""%1"" işlevi ""%2"" işlemindeki kısıtlama koşulunda yasaklandı';it = 'La funzione ""%3"" è vietata nella condizione di restrizione nell''operazione ""%1"" nella frase ""%2""';de = 'Die Funktion ""%3"" ist unter der Bedingung von Einschränkungen in der Operation ""%1"" im Satz ""%2"" verboten'"),
				"Case,When", Row.Chars);
			
		ElsIf Context.IsValueThenElse Then
			ErrorTemplate = InsertKeywordsIntoString(Context,
				NStr("ru = 'Функция ""%4"" запрещена в условии ограничения в операции ""%1"" в предложениях ""%2"" и ""%3""'; en = 'The ""%4"" function is prohibited in the restriction condition in the ""%1"" operation in the ""%2"" and ""%3"" sentences'; pl = 'Funkcja ""%4"" jest zabroniona w warunku ograniczenia w operacji ""%1"" w ""%2"" zdaniu ""%3""';es_ES = 'Función ""%4"" se ha prohibido en condición de restricción en la operación ""%1"" en las frases ""%2"" y ""%3""';es_CO = 'Función ""%4"" se ha prohibido en condición de restricción en la operación ""%1"" en las frases ""%2"" y ""%3""';tr = '""%3"" ve ""%4"" teklifte ""%1"" işlevi ""%2"" işlemindeki kısıtlama koşulunda yasaklandı';it = 'La funzione ""%4"" è vietata nella condizione di restrizione nell''operazione ""%1"" nelle frasi ""%2"" e ""%3""';de = 'Die Funktion ""%4"" ist im Falle einer Einschränkung der Operation ""%1"" in den Angeboten ""%2"" und ""%3"" verboten'"),
				"Case,Then,Else");
		Else
			ErrorTemplate = NStr("ru = 'Функция ""%1"" запрещена в условии ограничения'; en = 'The ""%1"" function is prohibited in the restriction condition'; pl = 'Funkcja ""%1"" zakazana w warunku ograniczenia';es_ES = 'Función ""%1"" se ha prohibido en condición de restricción';es_CO = 'Función ""%1"" se ha prohibido en condición de restricción';tr = '""%1"" işlevi bağlantı koşulunda yasaklanmıştır';it = 'La funzione ""%1"" è vietata nella condizione di restrizione';de = 'Die Funktion ""%1"" ist in der Einschränkungsbedingung nicht zulässig'");
		EndIf;
	Else
		If Context.IsConnectionCondition Then
			ErrorTemplate = NStr("ru = 'Операция ""%1"" запрещена в условии соединения'; en = 'The ""%1"" operation is prohibited in the joint condition'; pl = 'Operacja ""%1"" zakazana w warunku ograniczenia';es_ES = 'Operación ""%1"" se ha prohibido en condición de conexión';es_CO = 'Operación ""%1"" se ha prohibido en condición de conexión';tr = '""%1"" işlemi bağlantı koşulunda yasaklanmıştır';it = 'L''operazione ""%1"" non è concessa nella condizione di join';de = 'Die Operation ""%1"" ist in der Verbindungsbedingung nicht zulässig'");
			
		ElsIf Context.IsConditionWhen Then
			ErrorTemplate = InsertKeywordsIntoString(Context,
				NStr("ru = 'Операция ""%3"" запрещена в условии ограничения в операции ""%1"" в предложении ""%2""'; en = 'The ""%3"" operation is prohibited in the restriction condition in the ""%1"" operation in the ""%2"" sentence'; pl = 'Operacja ""%3"" zakazana w warunku ograniczenia w operacji ""%1"" w ofercie ""%2""';es_ES = 'Operación ""%3"" se ha prohibido en condición de restricción en la operación ""%1"" en la frase ""%2""';es_CO = 'Operación ""%3"" se ha prohibido en condición de restricción en la operación ""%1"" en la frase ""%2""';tr = '""%3"" teklifte ""%1"" işlemi ""%2"" işlemindeki kısıtlama koşulunda yasaklandı';it = 'L''operazione ""%3"" è vietata nella condizione di restrizione nell''operazione ""%1"" nella frase ""%2""';de = 'Operation ""%3"" ist im Sinne der Einschränkungen in der Operation ""%1"" im Satz ""%2"" verboten'"),
				"Case,When", Row.Chars);
			
		ElsIf Context.IsValueThenElse Then
			ErrorTemplate = InsertKeywordsIntoString(Context,
				NStr("ru = 'Операция ""%4"" запрещена в условии ограничения в операции ""%1"" в предложениях ""%2"" и ""%3""'; en = 'The ""%4"" operation is prohibited in the restriction condition in the ""%1"" operation in the ""%2"" and ""%3"" sentences'; pl = 'Operacja ""%4"" zakazana w warunku ograniczenia w operacji ""%1"" w zdaniach ""%2"" i ""%3""';es_ES = 'Función ""%4"" se ha prohibido en condición de restricción en la operación ""%1"" en las frases ""%2"" y ""%3""';es_CO = 'Función ""%4"" se ha prohibido en condición de restricción en la operación ""%1"" en las frases ""%2"" y ""%3""';tr = '""%3"" ve ""%4"" teklifte ""%1"" işlemi ""%2"" işlemindeki kısıtlama koşulunda yasaklandı';it = 'L''operazione ""%4"" è vietata nella condizione di restrizione nell''operazione ""%1"" nelle frasi ""%2"" e ""%3""';de = 'Operation ""%4"" ist im Sinne der Einschränkungen in der Operation ""%1"" in den Sätzen ""%2"" und ""%3"" verboten'"),
				"Case,Then,Else");
		Else
			ErrorTemplate = NStr("ru = 'Операция ""%1"" запрещена в условии ограничения'; en = 'The ""%1"" operation is prohibited in the restriction condition'; pl = 'Operacja ""%1"" zakazana w warunku ograniczenia';es_ES = 'Operación ""%1"" se ha prohibido en condición de restricción';es_CO = 'Operación ""%1"" se ha prohibido en condición de restricción';tr = '""%1"" işlemi kısıtlama koşulunda yasaklanmıştır';it = 'L''operazione ""%1"" è vietata nella condizione di restrizione';de = 'Die Operation ""%1"" ist unter der Einschränkung verboten'");
		EndIf;
	EndIf;
	
	SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
		ErrorTemplate, Row.Chars));
	
EndProcedure

// For the MarkIncorrectArgumentsAndProhibitedNodes procedure.
Procedure MarkTypesRepetitionsAmongThoseToCheckAndClarify(Node, Context)
	
	TypesInList = New Map;
	
	For Each TypeInList In Node.Types Do
		If TypesInList.Get(Upper(TypeInList.Chars)) = Undefined Then
			TypesInList.Insert(Upper(TypeInList.Chars), True);
		Else
			SetErrorInRow(TypeInList, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Тип ""%1"" уже указан'; en = 'The ""%1"" type is already specified'; pl = 'Typ ""%1"" jest już określony';es_ES = 'Tipo ""%1"" se ha indicado ya';es_CO = 'Tipo ""%1"" se ha indicado ya';tr = 'Tür ""%1"" daha önce belirtilmişti';it = 'Il tipo ""%1"" è già indicato';de = 'Typ ""%1"" ist bereits aufgeführt'"), TypeInList.Chars));
		EndIf;
	EndDo;
	
	TypesToClarify = New Map;
	
	For Each ComparisonClarification In Node.ComparisonClarifications Do
		If TypeOf(ComparisonClarification.Key) <> Type("ValueTableRow") Then
			Continue;
		EndIf;
		TypeSource = ComparisonClarification.Key;
		
		If Not Node.CheckTypesExceptListed
		   AND TypesInList.Get(Upper(TypeSource.Chars)) <> Undefined Then
			
			SetErrorInRow(TypeSource, InsertKeywordsIntoString(Context,
				NStr("ru = 'Тип ""%2"" уже указан среди типов ключевого слова ""%1""'; en = 'The ""%2"" type is already specified among the ""%1"" keyword types'; pl = 'Typ ""%2"" jest już określony wśród typów słów kluczowych ""%1""';es_ES = 'Tipo ""%2"" se ha indicado ya en los tipos de la palabra clave ""%1""';es_CO = 'Tipo ""%2"" se ha indicado ya en los tipos de la palabra clave ""%1""';tr = 'Tür ""%2"" anahtar kelimesi ""%1"" türleri arasında zaten belirtilmiştir';it = 'Il tipo ""%2"" è già indicato tra i tipi di parola chiave ""%1""';de = 'Type ""%2"" ist bereits unter den Schlüsselwort-Typen ""%1"" aufgeführt'"),
				"Only",
				TypeSource.Chars));
			
		ElsIf Node.CheckTypesExceptListed
		        AND TypesInList.Get(Upper(TypeSource.Chars)) = Undefined Then
			
			SetErrorInRow(TypeSource, InsertKeywordsIntoString(Context,
				NStr("ru = 'Тип ""%2"" не указан среди типов ключевого слова ""%1""'; en = 'The ""%2"" type is not specified among the ""%1"" keyword types'; pl = 'Typ ""%2"" nie jest określony wśród typów słów kluczowych ""%1""';es_ES = 'Tipo ""%2"" no se ha indicado en los tipos de la palabra clave ""%1""';es_CO = 'Tipo ""%2"" no se ha indicado en los tipos de la palabra clave ""%1""';tr = 'Tür ""%2"" anahtar kelimesi ""%1"" türleri arasında belirtilmemiştir';it = 'Il tipo ""%2"" non indicato tra i tipi di parola chiave ""%1""';de = 'Typ ""%2"" ist nicht unter den Schlüsselwort-Typen ""%1"" aufgeführt'"),
				"Except",
				TypeSource.Chars));
			
		ElsIf TypesToClarify.Get(Upper(TypeSource.Chars)) <> Undefined Then
			SetErrorInRow(TypeSource, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Уточнение типа ""%1"" уже указано'; en = 'The ""%1"" type clarification is already specified'; pl = 'Doprecyzowanie typu ""%1"" jest już określone';es_ES = 'Especificación del tipo ""%1"" se ha indicado ya';es_CO = 'Especificación del tipo ""%1"" se ha indicado ya';tr = 'Tür ""%1"" netleştirilmesi zaten belirtilmiştir';it = 'La precisazione del tipo ""%1"" è già indicata';de = 'Die Typ-Verfeinerung ""%1"" wurde bereits festgelegt'"), TypeSource.Chars));
		Else
			TypesToClarify.Insert(Upper(TypeSource.Chars), True);
		EndIf;
	EndDo;
	
EndProcedure

// For the ParseRestrictionPart procedure.
Procedure ParseRestrictionCondition(PartProperties, InternalData)
	
	PartRows = PartProperties.Rows;
	ChangeKeywordTypeListToName(PartRows);
	
	If PartRows.Count() < 2
	 Or PartRows[1].Kind <> "Keyword"
	 Or PartRows[1].Clarification <> "Where" Then
		SetPartBeginningError(
			?(PartRows.Count() < 2, PartProperties.SeparatorRow, PartRows[1]),
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'После ключевого слова ""%1"" не найдено
					           |ключевое слово ""%2""'; 
					           |en = 'Keyword ""%2"" is not found
					           |after keyword ""%1""'; 
					           |pl = 'Po słowie kluczowym ""%1"" nie znaleziono
					           |słowo kluczowe ""%2""';
					           |es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado
					           |una palabra clave ""%2""';
					           |es_CO = 'Después de la palabra clave ""%1"" no se ha encontrado
					           |una palabra clave ""%2""';
					           |tr = '""%1"" anahtar kelimesinden sonra "
" anahtar kelimesi %2 bulunamadı';
					           |it = 'Keyword ""%2"" non è stata trovata
					           |dopo la keyword ""%1""';
					           |de = 'Nach dem Schlüsselwort ""%1"" wurde
					           |das Schlüsselwort ""%2"" nicht gefunden'"),
					PartProperties.Presentation,
					KeywordRegardingLanguage("Where", InternalData)));
		Return;
	EndIf;
	
	Condition = New Array(New FixedArray(PartRows));
	For Index = 0 To 1 Do
		Condition.Delete(0);
	EndDo;
	
	ParseCondition(Condition, PartProperties.Content, InternalData);
	
	// Marking incorrect parameters of operations and unsupported functionality.
	CommonNodes = AccessManagementInternalCached.NodesToCheckAvailability("", True);
	
	NodesWhen = AccessManagementInternalCached.NodesToCheckAvailability(
		"Field,Value,Constant,AND,Or,Not,=,<>,IN,IsNull,Type,ValueType", False);
	
	NodesThenElse = AccessManagementInternalCached.NodesToCheckAvailability(
		"Case,ForAllRows,ForAtLeastOneRow", True);
	
	AvailableNodes = New Structure;
	AvailableNodes.Insert("Common",          CommonNodes);
	AvailableNodes.Insert("NodesWhen",      NodesWhen);
	AvailableNodes.Insert("NodesThenElse", NodesThenElse);
	
	FixedContext = New FixedStructure(InternalData);
	Context = New Structure(FixedContext);
	Context.Insert("IsConnectionCondition",  False);
	Context.Insert("IsConditionWhen",       False);
	Context.Insert("IsValueThenElse", False);
	Context.Insert("RootNode",          PartProperties.Content);
	Context.Insert("Parents",              New Array);
	Context.Insert("Read",                StrStartsWith(PartProperties.Name, "AllowRead"));
	
	AddDefaultAliases(Context);
	
	MarkIncorrectArgumentsAndProhibitedNodes(PartProperties.Content,
		AvailableNodes, Context, New Structure("Node", ""));
	
	DeleteSourceProperty(PartProperties.Content);
	
EndProcedure

// For the RestrictionParts and ParseRestrictionCondition procedures.
Procedure AddDefaultAliases(Context);
	
	If Context.Aliases.Count() > 0 Then
		Return;
	EndIf;
	
	Context.Aliases.Insert(Upper("ThisList"), "");
	Context.Aliases.Insert(Upper("ThisList"), "");
	
EndProcedure

// For the ParseConnectionCondition and ParseRestrictionCondition procedures.
Procedure ParseCondition(Condition, Composition, InternalData)
	
	ExpressionsInParenthesesInAttachments = ExpressionsInParenthesesInAttachments(Condition);
	
	FunctionsWithExpressionsInParentheses = FunctionsWithExpressionsInParentheses(
		ExpressionsInParenthesesInAttachments, InternalData);
	
	ExpressionsSelectionWhenThenInAttachments = ExpressionsSelectionWhenThenInAttachments(
		FunctionsWithExpressionsInParentheses, InternalData);
	
	Condition = ExpressionsSelectionWhenThenInAttachments;
	
	ParseExpression(Condition, Composition, InternalData, False);
	
	UnionNestedLogicalOperations(Composition);
	
EndProcedure

// For the ParseCondition procedure.
Procedure UnionNestedLogicalOperations(Composition)
	
	If Composition = Undefined Then
		Return;
	EndIf;
	
	If Upper( Composition.Node ) = Upper( "AND" ) // PATCHED:
	 Or Composition.Node = "Or" Then
		
		Index = Composition.Arguments.Count() - 1;
		While Index >= 0 Do
			
			Argument = Composition.Arguments[Index];
			UnionNestedLogicalOperations(Argument);
			
			If Argument.Node = Composition.Node Then
				Composition.Arguments.Delete(Index);
				NestedIndex = Argument.Arguments.Count() - 1;
				While NestedIndex >= 0 Do
					Composition.Arguments.Insert(Index, Argument.Arguments[NestedIndex]);
					NestedIndex = NestedIndex - 1;
				EndDo;
			EndIf;
			Index = Index - 1;
		EndDo;
	EndIf;
	
EndProcedure


// For the ParseCondition, ParseFunction, and ParseChoice procedures.
Procedure ParseExpression(Condition, Composition, CurrentContext, NestedExpression = True)
	
	FixedContext = New FixedStructure(CurrentContext);
	Context = New Structure(FixedContext);
	Context.Insert("Attachments", New Array);
	Context.Insert("Details");
	Context.Insert("String");
	
	For Each Row In Condition Do
		Context.String = Row;
		
		If Row.Kind = "Name"
		 Or Row.Kind = "Number"
		 Or Row.Kind = "ArbitraryLine"
		 Or Row.Kind = "Keyword" 
		   AND (    Row.Clarification = "True"
		      Or Row.Clarification = "False"
		      Or Row.Clarification = "Undefined" ) Then
			
			NewDetails = FieldNodeOrConstantNodeDetails(Row);
			AddArgumentFunctionChoiceOperator(Context, NewDetails);
			
		ElsIf Row.Kind = "Keyword" Then
			
			If Row.Type = "Function"
			 Or Upper( Row.Clarification ) = Upper( "IN" ) Then // PATCHED:
				
				If Row.Type = "Function" Then
					ParseFunction(Context);
				Else
					ParseConnectorIn(Context);
				EndIf;
				
			ElsIf Row.Type = "Connector" Then
				ParseConnector(Context);
			
			ElsIf Row.Type = "Operator" Then
				ParseOperator(Context);
				
			ElsIf Row.Type = "SelectionWord" Then
				ParseChoice(Context);
			Else
				ParseErrorKeyword(Context);
			EndIf;
			
		ElsIf Row.Kind = "Operation" Then
			ParseConnector(Context, True);
			
		ElsIf Row.Kind = "Separator" Then
			If Row.Chars = "(" Then
				NewDetails = Undefined;
				ParseExpression(Row.Rows, NewDetails, Context);
				AddArgumentFunctionChoiceOperator(Context, NewDetails);
				If NewDetails <> Undefined Then
					NewDetails.Source.Priority = 99;
				EndIf;
			Else
				Context.Details = Undefined;
				SetErrorInRow(Row,
					NStr("ru = 'Запятая может использоваться только для разделения параметров функций'; en = 'Comma can be used only to separate function parameters'; pl = 'Przecinek może być używany tylko do oddzielania parametrów funkcji';es_ES = 'La coma puede ser usada solo para separar los parámetros de la función';es_CO = 'La coma puede ser usada solo para separar los parámetros de la función';tr = 'Virgül sadece işlev parametreleri ayırmak için kullanılabilir';it = 'La virgola può essere utilizzata solo per separare due parametri di funzione';de = 'Das Komma kann nur zur Trennung von Funktionsparametern verwendet werden'"));
			EndIf;
		Else
			Context.Details = Undefined;
			SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Обработка ключевого слова ""%1"" не определена'; en = 'The ""%1"" keyword data processor is not determined'; pl = 'Przetwarzanie słów kluczowych ""%1"" niezdefiniowane';es_ES = 'El procesamiento de la palabra clave ""%1"" no se ha determinado';es_CO = 'El procesamiento de la palabra clave ""%1"" no se ha determinado';tr = '""%1"" anahtar kelimesinin işlemesi belirlenmedi';it = 'La parola chiave ""%1"" dell''elaboratore dati non è determinata';de = 'Die Bearbeitung des Schlüsselwortes ""%1"" ist nicht definiert'"), Row.Chars));
		EndIf;
		
		If Context.Details = Undefined Then
			// An error that stops further parsing (preventing from false starts) occurred.
			Break;
		EndIf;
	EndDo;
	
	If Context.Details = Undefined Then
		If NestedExpression Then
			Composition = New Structure("Source, Node, Value", Row, "Constant", False);
		Else
			Composition = Undefined;
		EndIf;
		
	ElsIf Context.Attachments.Count() = 0 Then
		Composition = Context.Details;
	Else
		Composition = Context.Attachments[Context.Attachments.Count() - 1];
	EndIf;
	
EndProcedure

// For the ParseExpression, ParseFirstCheckingFunctionParameter,
// ParseValueTypeFunctionParameters, ParseChoice procedures and the 
// FieldNodeDetailsFromIsNullFunction function.
//
Function FieldNodeOrConstantNodeDetails(Row)
	
	// <Field name>, <Number>, <Arbitrary string>, True, False, Undefined.
	
	If Row.Kind = "Name" Then
		NewDetails = FieldNodeDetails(Row);
		NewDetails.Name         = Row.Chars;
		NewDetails.NameSource = Row;
	Else
		NodeProperties = "Source, Node, Value";
		NewDetails = New Structure(NodeProperties, Row, "Constant");
		
		If Row.Kind = "Keyword" Then
			If Row.Clarification = "True" Then
				NewDetails.Value = True;
				
			ElsIf Row.Clarification = "False" Then
				NewDetails.Value = False;
				
			Else // String.Kind = "Undefined".
				NewDetails.Value = Undefined;
			EndIf;
		Else // "Number" or "ArbitraryString".
			NewDetails.Value = Row.Clarification;
		EndIf;
	EndIf;
	
	Return NewDetails;
	
EndFunction

// For the FieldNodeOrConstantNodeDetails, FieldNodeDetailsFromExpressFunction, and FieldNodeDetailsFromIsNullFunction functions.
Function FieldNodeDetails(Row)
	
	NodeProperties = "Source, Node, Name, Table, Alias, Cast, Attachment, IsNull";
	NewDetails = New Structure(NodeProperties, Row, "Field");
	
	NewDetails.Insert("NameSource",      Undefined);
	NewDetails.Insert("CastSource", Undefined);
	NewDetails.Insert("IsNullSource", Undefined);
	
	Return NewDetails;
	
EndFunction

// For the ParseExpression procedure.
Procedure ParseConnector(Context, IsOperation = False)
	
	// And, Or, As, Except, Only, Is, and any operation =, <>, ...
	// The In keyword is parsed separately in the ParseOperationIn procedure.
	
	Row = Context.String;
	
	NewDetails = New Structure("Source, Node", Row,
		?(Row.Kind = "Operation", Row.Chars, Row.Clarification));
	
	If Upper( Row.Clarification ) = Upper( "AND" ) // PATCHED:
	 Or Row.Clarification = "Or" Then
		
		NewDetails.Insert("Arguments", New Array);
		NewDetails.Arguments.Add(Undefined);
		AddConnector(Context, NewDetails, NewDetails.Arguments[0]);
	
	ElsIf Row.Clarification = "Is" Then
		NewDetails.Node = "IsNull";
		NewDetails.Insert("Argument", Undefined);
		AddConnector(Context, NewDetails, NewDetails.Argument);
		// Checking the parameter accuracy in the MarkIncorrectArgumentsAndProhibitedNodes procedure.
		// 
		
	ElsIf Row.Kind = "Operation" Then
		NewDetails.Insert("FirstArgument", Undefined);
		NewDetails.Insert("SecondArgument", Undefined);
		AddConnector(Context, NewDetails, NewDetails.FirstArgument);
		// Checking the argument accuracy in the MarkIncorrectArgumentsAndProhibitedNodes procedure.
		// 
		
	ElsIf Row.Clarification = "As"
	      Or Row.Clarification = "Except"
	      Or Row.Clarification = "Only" Then
		
		Context.Details = Undefined;
		SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Ключевое слово ""%1"" может использоваться только в параметрах функций'; en = 'The ""%1"" keyword can be used only in function parameters'; pl = 'Słowo kluczowe ""%1"" może być używane tylko w parametrach funkcji';es_ES = 'La palabra clave ""%1"" puede ser usada solo en los parámetros de las funciones';es_CO = 'La palabra clave ""%1"" puede ser usada solo en los parámetros de las funciones';tr = '""%1"" anahtar kelimesi sadece işlevlerin parametrelerinde kullanılabilir';it = 'La parola chiave ""%1"" può essere usata solo nei parametri delle funzioni';de = 'Das Schlüsselwort ""%1"" kann nur in Funktionsparametern verwendet werden'"), Row.Chars));
	Else
		Context.Details = Undefined;
		SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Обработка ключевого слова ""%1"" не определена'; en = 'The ""%1"" keyword data processor is not determined'; pl = 'Przetwarzanie słów kluczowych ""%1"" niezdefiniowane';es_ES = 'El procesamiento de la palabra clave ""%1"" no se ha determinado';es_CO = 'El procesamiento de la palabra clave ""%1"" no se ha determinado';tr = '""%1"" anahtar kelimesinin işlemesi belirlenmedi';it = 'La parola chiave ""%1"" dell''elaboratore dati non è determinata';de = 'Die Bearbeitung des Schlüsselwortes ""%1"" ist nicht definiert'"), Row.Chars));
	EndIf;
	
EndProcedure

// For the ParseExpression procedure.
Procedure ParseConnectorIn(Context)
	
	Row = Context.String;
	
	NewDetails = New Structure("Source, Node", Row, Row.Clarification);
	NewDetails.Insert("SearchFor",  Undefined);
	NewDetails.Insert("Values", New Array);
	
	ParametersContent = CommaSeparatedParameters(Row);
	// The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	
	For Each ParameterDetails In ParametersContent Do
		For Each Substring In ParameterDetails.Rows Do
			
			ParseConnectorValueIn(Context, Substring, NewDetails);
			
			If ParameterDetails.Rows[0] <> Substring Then
				SetErrorInRow(Substring, NStr("ru = 'Перед параметром не указана запятая'; en = 'Comma is not specified before the parameter'; pl = 'Brak przecinka określonego przed parametrem';es_ES = 'Antes del parámetro no se ha indicado una coma';es_CO = 'Antes del parámetro no se ha indicado una coma';tr = 'Parametreden önce virgül belirtilmedi';it = 'La virgola non è specificata prima del parametro';de = 'Es wird kein Komma vor dem Parameter angegeben'"));
			EndIf;
			
		EndDo;
	EndDo;
	
	AddConnector(Context, NewDetails, NewDetails.SearchFor);
	
	If NewDetails.SearchFor.Node <> "Field" Then
		SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Операцию ""%1"" можно указывать только после имени поля'; en = 'The ""%1"" operation can be specified only after a field name'; pl = 'Operacja ""%1"" może być określona tylko po nazwie pola';es_ES = 'Operación ""%1"" se puede indicarla solo después del campo del nombre';es_CO = 'Operación ""%1"" se puede indicarla solo después del campo del nombre';tr = '""%1"" İşlemi yalnızca alan adından sonra belirtilebilir';it = 'L''operazione ""%1"" può essere indicata solo dopo un nome di campo';de = 'Operation ""%1"" kann nur nach dem Feldnamen angegeben werden'"), Row.Chars));
	EndIf;
	
EndProcedure

// For the ParseConnectorIn procedure.
Procedure ParseConnectorValueIn(Context, Substring, NewDetails)
	
	Row = Context.String;
	
	If Substring.Kind = "Number"
	 Or Substring.Kind = "ArbitraryLine" Then
		
		ConstantDetails = New Structure("Source, Node", Substring, "Constant");
		ConstantDetails.Insert("Value", Substring.Clarification);
		NewDetails.Values.Add(ConstantDetails);
		
	ElsIf Substring.Kind = "Keyword" Then
		
		If Substring.Clarification = "Value" Then
			NewContext = NewContext(Context, Substring, Undefined);
			ParseFunction(NewContext);
			If NewContext.Details <> Undefined Then
				NewDetails.Values.Add(NewContext.Details);
			EndIf;
		Else
			SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'В списке значений операции ""%1"" ключевое слово ""%2"" недопустимо'; en = 'The ""%2"" keyword is invalid in the ""%1"" operation value list'; pl = 'Na liście wartości operacji ""%1"" słowo kluczowe ""%2"" jest nieprawidłowe';es_ES = 'En la lista de valores de la operación ""%1"" la palabra clave ""%2"" no se admite';es_CO = 'En la lista de valores de la operación ""%1"" la palabra clave ""%2"" no se admite';tr = '""%1"" işlem değerleri listesinde ""%2"" anahtar kelimesine izin verilmez';it = 'La parola chiave ""%2"" non è valida nell''elenco dei valori dell''operazione ""%1""';de = 'In der Werteliste der Operation ""%1"" ist das Schlüsselwort ""%2"" nicht erlaubt'"),
				Row.Chars, Substring.Chars));
		EndIf;
		
	ElsIf Substring.Kind = "Name" Then
		SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В списке значений операции ""%1"" имя поля недопустимо'; en = 'Field name is invalid in the ""%1"" operation value list'; pl = 'Nazwa pola jest nieprawidłowa na liście wartości operacji ""%1""';es_ES = 'En la lista de valores de la operación ""%1"" el nombre del campo no se admite';es_CO = 'En la lista de valores de la operación ""%1"" el nombre del campo no se admite';tr = '""%1"" işlem değerleri listesinde alan adı kullanılmaz';it = 'Nome campo non valido nell''elenco valori operazione ""%1""';de = 'In der Werteliste der Operation ""%1"" ist der Feldname ungültig'"), Row.Chars));
		
	ElsIf Substring.Chars = "(" Then
		SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В списке значений операции ""%1"" скобки допустимы только для параметров функции'; en = 'Parentheses are valid only for function parameters in the ""%1"" operation value list'; pl = 'Na liście wartości operacji ""%1"" nawiasy są prawidłowe tylko dla parametrów funkcji';es_ES = 'En la lista de valores de la operación ""%1"" las paréntesis se admiten solo para los parámetros de la función';es_CO = 'En la lista de valores de la operación ""%1"" las paréntesis se admiten solo para los parámetros de la función';tr = 'Parantez ""%1"" işlem değerleri listesinde yalnızca işlev parametreleri için geçerlidir';it = 'Le parentesi sono valido solo per i parametri di funzione nell''elenco valori operazione ""%1""';de = 'In der Werteliste der Operation ""%1"" sind Klammern nur für Funktionsparameter gültig'"), Row.Chars));
	Else
		SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В списке значений операции ""%1"" можно указывать только значения'; en = 'Only values can be specified in the ""%1"" operation value list'; pl = 'Można określić tylko wartości na liście wartości operacji ""%1""';es_ES = 'En la lista de valores de la operación ""%1"" se puede indicar solo valores';es_CO = 'En la lista de valores de la operación ""%1"" se puede indicar solo valores';tr = '""%1"" İşlem değerleri listesinde yalnızca değerleri belirtebilirsiniz';it = 'Solo valori possono essere indicati nell''elenco di valori di operazione ""%1""';de = 'In der Werteliste der Operation ""%1"" können Sie nur Werte angeben'"), Row.Chars));
	EndIf;
	
EndProcedure

// For the ParseConnectorValueIn procedure.
Function NewContext(Context, Row = null, Details = null)
	
	FixedContext = New FixedStructure(Context);
	NewContext = New Structure(FixedContext);
	
	If Row <> null Then
		NewContext.String = Row;
	EndIf;
	
	If Details <> null Then
		NewContext.Details = Details;
	EndIf;
	
	Return NewContext;
	
EndFunction

// For the ParseConnector, ParseConnectorIn, and InsertConnectorConsideringPriority procedures.
Procedure AddConnector(Context, NewDetails, FirstArgument);
	
	// A connector to add: And, Or, In, Is, and any operation (=, <>, ...).
	
	Details = Context.Details;
	
	If Details = Undefined Then
		Context.Details = NewDetails;
		
	ElsIf Upper( Details.Node ) = Upper( "AND" ) // PATCHED:
	      Or Details.Node = "Or" Then
		
		If Details.Arguments.Count() = 1 Then
			Details.Arguments.Add(Undefined);
			ProcessMissingArgumentAfterConnector(Context, Details.Arguments[1]);
		EndIf;
		InsertConnectorConsideringPriority(Context,
			Details.Arguments[1], NewDetails, FirstArgument);
		
	ElsIf Details.Node = "Not" Then
		If Not ValueIsFilled(Details.Argument) Then
			ProcessMissingArgumentAfterConnector(Context, Details.Argument);
		EndIf;
		InsertConnectorConsideringPriority(Context,
			Details.Argument, NewDetails, FirstArgument);
		
	ElsIf Details.Source.Kind = "Operation" Then
		If Not ValueIsFilled(Details.SecondArgument) Then
			ProcessMissingArgumentAfterConnector(Context, Details.SecondArgument, False);
		EndIf;
		InsertConnectorConsideringPriority(Context,
			Details.SecondArgument, NewDetails, FirstArgument);
		
	ElsIf StrFind(",Field,Value,Constant,IN,IsNull,Case,", "," + Details.Node + ",") > 0
	      Or Details.Source.Type = "Function" Then
		// The second argument of the In operation is already parsed in the ParseOperationIn procedure.
		// The second Null argument of the Has operation is already parsed in the FunctionsWithExpressionsInParentheses function.
		// The remaining nodes do not have the second argument.
		InsertConnectorConsideringPriority(Context, Undefined, NewDetails, FirstArgument);
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не определена обработка узла ""%1""'; en = '""%1"" node data processor is not determined'; pl = 'Nie zdefiniowane przetwarzanie węzła ""%1""';es_ES = 'El procesamiento del nodo no se ha realizado ""%1""';es_CO = 'El procesamiento del nodo no se ha realizado ""%1""';tr = '""%1"" ünitenin işlemesi belirlenmemiştir';it = '""%1"" nodo elaboratore dati non è determinato';de = 'Die Bearbeitung des Knotens ""%1"" ist nicht definiert'"), Details.Node);
		Raise ErrorText;
	EndIf;
	
EndProcedure

// For the AddConnector procedure.
Procedure ProcessMissingArgumentAfterConnector(Context, SecondArgument, LogicalOperation = True)
	
	SetErrorInRow(Context.Details.Source,
		?(LogicalOperation,
			NStr("ru = 'Не указан аргумент после логической операции'; en = 'Argument after logical operation is not specified'; pl = 'Argument nie jest określony po operacji logicznej';es_ES = 'No se ha indicado el argumento después de la operación lógica';es_CO = 'No se ha indicado el argumento después de la operación lógica';tr = 'Mantıksal işlemden sonra bağımsız değişken belirtilmedi';it = 'Argomento dopo l''operazione logica non indicato';de = 'Nach der logischen Operation ist kein Argument angegeben'"),
			NStr("ru = 'Не указан аргумент после операции'; en = 'Argument after operation is not specified'; pl = 'Argument nie określono po operacji';es_ES = 'No se ha indicado argumento después de la operación';es_CO = 'No se ha indicado argumento después de la operación';tr = 'İşlemden sonra bağımsız değişken belirtilmedi';it = 'Argomento dopo l''operazione non indicato';de = 'Kein Argument angegeben nach der Operation'")),
		True);
	
	SecondArgument = New Structure("Source, Node, Value", Context.String, "Constant", True);
	
EndProcedure

// For the AddConnector and ProcessMissingLogicalOperation procedures.
Procedure InsertConnectorConsideringPriority(Context,
			DetailsLastArgument, NewDetails, NewDetailsFirstArgument)
	
	Attachments = Context.Attachments;
	
	If DetailsLastArgument <> Undefined
	   AND Context.String.Priority >= Context.Details.Source.Priority Then
		
		// Replacing the current node argument with the connector (case "A Or B And ...").
		NewDetailsFirstArgument = DetailsLastArgument;
		DetailsLastArgument = NewDetails;
		
		Attachments.Insert(0, Context.Details);
		Context.Details = NewDetails;
		Return;
	EndIf;
	
	If Attachments.Count() = 0 Then
		// Nesting the current node as the first connector argument (case "A And B Or ...").
		NewDetailsFirstArgument = Context.Details;
		Context.Details = NewDetails;
		Return;
	EndIf;
	
	// Nesting the previous node as the first connector argument (case "A And Not B Or ...").
	Context.Details = Attachments[0];
	Attachments.Delete(0);
	
	AddConnector(Context, NewDetails, NewDetailsFirstArgument);
	
EndProcedure

// For the ParseExpression procedure.
Procedure ParseOperator(Context)
	
	// The Not operator.
	
	NewDetails = New Structure("Source, Node, Argument",
		Context.String, Context.String.Clarification);
	
	AddArgumentFunctionChoiceOperator(Context, NewDetails);
	
	Context.Attachments.Insert(0, Context.Details);
	Context.Details = NewDetails;
	
EndProcedure

// For the ParseExpression and ParseConnectorValueIn procedures.
Procedure ParseFunction(Context)
	
	Row = Context.String;
	
	NewDetails = New Structure("Source, Node", Row, Row.Clarification);
	
	If Row.Clarification = "ValueAllowed"
	 Or Row.Clarification = "ObjectReadingAllowed"
	 Or Row.Clarification = "ObjectUpdateAllowed"
	 Or Row.Clarification = "ListReadingAllowed"
	 Or Row.Clarification = "ListUpdateAllowed"
	 Or Row.Clarification = "IsAuthorizedUser" Then
		
		ParseCheckingFunctionParameters(Context, NewDetails);
		
	ElsIf Row.Clarification = "ForAllRows"
	      Or Row.Clarification = "ForAtLeastOneRow" Then
		
		ExpressionDetails = Undefined;
		ParseExpression(Row.Rows, ExpressionDetails, Context);
		NewDetails.Insert("Argument", ExpressionDetails);
	
	ElsIf Row.Clarification = "Value" Then
		ParseValueFunctionOrTypeFunctionParameters(Row, NewDetails, True, Context);
		
	ElsIf Row.Clarification = "Type" Then
		ParseValueFunctionOrTypeFunctionParameters(Row, NewDetails, False, Context);
		
	ElsIf Row.Clarification = "ValueType" Then
		ParseValueTypeFunctionParameters(Context, NewDetails);
		
	ElsIf Row.Clarification = "IsNull" Then
		NewDetails = FieldNodeDetailsFromIsNullFunction(Context.String, Context);
		
	ElsIf Row.Clarification = "Cast" Then
		NewDetails =  FieldNodeDetailsFromExpressFunction(Context.String, Context);
		
	ElsIf Not Row.IsReserve Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не определена обработка функции ""%1""'; en = '""%1"" function data processor is not determined'; pl = 'Brak specyficznych funkcji przetwarzania ""%1""';es_ES = 'No se ha determinado el procesamiento de la función ""%1""';es_CO = 'No se ha determinado el procesamiento de la función ""%1""';tr = '""%1"" işlevin işlemesi belirlenmemiştir';it = 'L''elaboratore dati di funzione ""%1"" non è determinato';de = 'Die Bearbeitung der Funktion ""%1"" ist nicht definiert'"), Row.Clarification);
		Raise ErrorText;
	EndIf;
	
	AddArgumentFunctionChoiceOperator(Context, NewDetails);
	
EndProcedure

// For the ParseFunction procedure.
Procedure ParseCheckingFunctionParameters(Context, NewDetails)
	
	Row = Context.String;
	
	NewDetails.Insert("Field",                        Undefined);
	NewDetails.Insert("Types",                        New Array);
	NewDetails.Insert("CheckTypesExceptListed", False);
	NewDetails.Insert("ComparisonClarifications",          New Map);
	
	ParametersContent = CommaSeparatedParameters(Row);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	ParseFirstCheckingFunctionParameter(Context, ParametersContent[0], NewDetails);
	
	For Index = 1 To ParametersContent.Count() - 1 Do
		ParseAdditionalCheckingFunctionParameter(Context,
			ParametersContent[Index], NewDetails);
	EndDo;
	
EndProcedure

// For the ParseCheckingFunctionParameters procedure.
Procedure ParseFirstCheckingFunctionParameter(Context, FirstParameter, NewDetails)
	
	If FirstParameter.Rows[0].Kind = "Name" Then
		NewDetails.Field = FieldNodeOrConstantNodeDetails(FirstParameter.Rows[0]);
		
	ElsIf FirstParameter.Rows[0].Kind = "Keyword"
	        AND FirstParameter.Rows[0].Clarification = "Cast" Then
		
		NewDetails.Field = FieldNodeDetailsFromExpressFunction(FirstParameter.Rows[0], Context);
		
	ElsIf FirstParameter.Rows[0].Kind = "Keyword"
	        AND FirstParameter.Rows[0].Clarification = "IsNull" Then
		
		NewDetails.Field = FieldNodeDetailsFromIsNullFunction(FirstParameter.Rows[0], Context);
	Else
		SetErrorInRow(FirstParameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'Первым параметром может быть имя поля, функция ""%1"" или функция ""%2""'; en = 'First parameter can be a field name, function ""%1"", or function ""%2""'; pl = 'Pierwszym parametrem może być nazwa pola, funkcja ""%1"" lub funkcja ""%2""';es_ES = 'Como el primer parámetro puede ser nombre de campo, la función ""%1"" o la función ""%2""';es_CO = 'Como el primer parámetro puede ser nombre de campo, la función ""%1"" o la función ""%2""';tr = 'İlk parametre alan adı, ""%1"" işlevi veya ""%2"" işlevi olabilir';it = 'Il primo parametro può essere un nome campo, funzione ""%1"", or funzione ""%2""';de = 'Der erste Parameter kann Feldname, Funktion ""%1"" oder Funktion ""%2"" sein'"),
				"Cast,IsNull"));
		Return;
	EndIf;
	
	If FirstParameter.Rows.Count() < 2 Then
		Return;
	EndIf;
	
	If FirstParameter.Rows[0].Kind = "Keyword"
	   AND FirstParameter.Rows[0].Clarification = "Cast"
	   AND NewDetails.Field.Attachment = Undefined Then
		
		SetErrorInRow(FirstParameter.Rows[0].EndString,
			InsertKeywordsIntoString(Context,
				NStr("ru = 'После вложенной функции ""%3"" должно быть указано имя поля через точку,
				           |если в параметре функции ""%4"" используется ключевое слово ""%1"" или ""%2""'; 
				           |en = 'Period-separated field name must be specified after the ""%3"" nested function
				           |if keyword ""%1"" or ""%2"" is used in the ""%4"" function parameter'; 
				           |pl = 'Po włożonej funkcji ""%3"" powinny być wskazane nazwa pola przez punkt,
				           |jeśli w parametrze funkcji ""%4"" używane jest słowo kluczowe ""%1"" lub ""%2""';
				           |es_ES = 'Después de la función adjunta ""%3"" debe estar indicado un nombre de campo con puntos,
				           |si en el parámetro de la función ""%4"" se usa la palabra clave ""%1"" o ""%2""';
				           |es_CO = 'Después de la función adjunta ""%3"" debe estar indicado un nombre de campo con puntos,
				           |si en el parámetro de la función ""%4"" se usa la palabra clave ""%1"" o ""%2""';
				           |tr = 'İç içe geçmiş ""%3""işlevinden sonra, 
				           |""%4"" işlev parametresinde ""%1"" veya ""%2"" anahtar kelime kullanıyorsa, alan adı nokta ile belirtilmelidir';
				           |it = 'Il nome del campo separato da un punto deve essere indicato dopo la funzione nidificata ""%3""
				           |se la parola chiave ""%1"" o ""%2"" è utilizzata nel parametro di funzione ""%4""';
				           |de = 'Nach der verschachtelten Funktion ""%3"" muss der Feldname über einen Punkt angegeben werden,
				           |wenn das Schlüsselwort ""%1"" oder ""%2"" im Funktionsparameter ""%4"" verwendet wird'"),
				"Only,Except",
				FirstParameter.Rows[0].Chars,
				Context.String.Chars),
			True);
	EndIf;
	
	If FirstParameter.Rows[1].Kind <> "Keyword"
	 Or (  FirstParameter.Rows[1].Clarification <> "Only"
	      AND FirstParameter.Rows[1].Clarification <> "Except" ) Then
		
		SetErrorInRow(FirstParameter.Rows[1],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'После описания поля может быть указано, либо ключевое слово ""%1"", либо ""%2""'; en = 'Keyword ""%1"" or ""%2"" can be specified after field description'; pl = 'Po opisie pola może być wskazane, albo słowo kluczowe ""%1"", albo ""%2""';es_ES = 'Después de la descripción del campo puede estar indicada una palabra clave ""%1"" o ""%2""';es_CO = 'Después de la descripción del campo puede estar indicada una palabra clave ""%1"" o ""%2""';tr = 'Alan açıklamasından sonra ya ""%1"", ya da ""%2"" anahtar kelimesi belirtilebilir';it = 'La parola chiave ""%1"" o ""%2"" può essere indicata dopo la descrizione del campo';de = 'Nachdem die Beschreibung des Feldes kann entweder das Schlüsselwort ""%1"" oder ""%2"" angegeben werden'"),
				"Only,Except"));
		Return;
	EndIf;
	
	If FirstParameter.Rows[1].Clarification = "Except" Then
		NewDetails.CheckTypesExceptListed = True;
	EndIf;
	
	If FirstParameter.Rows.Count() < 3 Then
		SetErrorInRow(FirstParameter.Rows[1],  StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'После ключевого слова ""%1"" не указан тип (имя таблицы)'; en = 'Type (table name) is not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie jest określony typ (nazwa tabeli)';es_ES = 'Después de la palabra clave ""%1"" no se ha indicado tipo (nombre de tabla)';es_CO = 'Después de la palabra clave ""%1"" no se ha indicado tipo (nombre de tabla)';tr = '""%1"" anahtar kelimesinden sonra tür (tablo adı) belirtilmedi';it = 'Il tipo (nome tabella) non è specificato dopo la keyword ""%1""';de = 'Nach dem Schlüsselwort ""%1"" wird kein Typ (Tabellenname) angegeben'"), FirstParameter.Rows[1].Chars));
		Return;
	EndIf;
	
	If FirstParameter.Rows[2].Kind <> "Name"
	   AND FirstParameter.Rows[2].Chars <> "(" Then
	
		SetErrorInRow(FirstParameter.Rows[2],  StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'После ключевого слова ""%1"" должен быть указан, либо тип (имя таблицы), либо список типов в скобках'; en = 'Either a type (a table name) or a type list in parentheses must be specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" musi być podany rodzaj (nazwa tabeli), albo lista typów w nawiasach';es_ES = 'Después de la palabra clave ""%1"" debe estar indicado tipo (nombre de tabla) o lista de tipos en paréntesis';es_CO = 'Después de la palabra clave ""%1"" debe estar indicado tipo (nombre de tabla) o lista de tipos en paréntesis';tr = '""%1"" anahtar kelimeden sonra tür (tablo adı) veya parantez içinde türler listesi belirtilmelidir';it = 'Dopo la parola chiave ""%1"" deve essere specificato in parentesi un tipo (un nome di tabella) o un elenco di tipi';de = 'Nach dem Schlüsselwort ""%1"" sollte entweder der Typ (Tabellenname) oder die Liste der Typen in Klammern angegeben werden'"),
			FirstParameter.Rows[1].Chars));
		Return;
	EndIf;
	
	If FirstParameter.Rows.Count() > 3 Then
		SetErrorInRow(FirstParameter.Rows[3], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Перед параметром функции ""%1"" не указана запятая'; en = 'Comma is not specified before the ""%1"" function parameter'; pl = 'Przed parametrem funkcji ""%1"" nie podano przecinek';es_ES = 'Antes del parámetro de la función ""%1"" no se ha indicado una coma';es_CO = 'Antes del parámetro de la función ""%1"" no se ha indicado una coma';tr = '""%1"" işlevin parametresinden önce virgül belirtilmemiştir';it = 'La virgola non è specificata prima del parametro funzionale ""%1""';de = 'Vor dem Funktionsparameter ""%1"" wird kein Komma angegeben'"), Context.String.Chars));
	EndIf;
	
	If FirstParameter.Rows[2].Kind = "Name" Then
		NewDetails.Types.Add(FirstParameter.Rows[2]);
		AddRequiredTableAsReferenceType(Context, FirstParameter.Rows[2].Chars, FirstParameter.Rows[2]);
		Return;
	EndIf;
	
	ParametersContent = CommaSeparatedParameters(FirstParameter.Rows[2]);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	For Each Parameter In ParametersContent Do
		
		If Parameter.Rows[0].Kind = "Name"
		   AND Parameter.Rows.Count() < 2 Then
			
			NewDetails.Types.Add(Parameter.Rows[0]);
		Else
			SetErrorInRow(Parameter.Rows[?(Parameter.Rows.Count() < 2, 0, 1)],
				NStr("ru = 'В списке типов могут быть указаны только имена таблицы через запятую'; en = 'Only table names separated by commas can be specified in the type list'; pl = 'W liście typów mogą być podane tylko nazwy tabeli oddzielone przecinkami';es_ES = 'En la lista de tipos pueden estar indicados solo nombres de tabla con comas';es_CO = 'En la lista de tipos pueden estar indicados solo nombres de tabla con comas';tr = 'Türler listesinde yalnızca virgül ile tablo adları belirtilebilir';it = 'Solo i nomi di tabella separati da un punto possono essere indicati nell''elenco tipi';de = 'In der Liste der Typen können nur die durch Komma getrennten Tabellennamen angegeben werden'"));
		EndIf;
	EndDo;
	
EndProcedure

// For the ParseCheckingFunctionParameters procedure.
Procedure ParseAdditionalCheckingFunctionParameter(Context, Parameter, NewDetails)
	
	If Parameter.Rows[0].Kind = "Name"
	 Or Parameter.Rows[0].Kind = "Keyword"
	   AND (    Parameter.Rows[0].Type = "ComparisonValue"
	      Or Parameter.Rows[0].Type = "TypeName" ) Then
		
		If Parameter.Rows[0].Kind = "Name" Then
			ComparisonValue = Parameter.Rows[0];
			AddRequiredTableAsReferenceType(Context, Parameter.Rows[0].Chars, Parameter.Rows[0]);
		Else
			ComparisonValue = Parameter.Rows[0].Clarification;
		EndIf;
	Else
		SetErrorInRow(Parameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'Дополнительным параметром может быть тип (имя таблицы),
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"" и ""%7""'; 
				           |en = 'Additional parameter can be a type (a table name),
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"", and ""%7""'; 
				           |pl = 'Opcją dodatkową może być rodzaj (nazwa tabeli),
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"" i ""%7""';
				           |es_ES = 'Como el parámetro adicional puede ser tipo (nombre de tabla),
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"" y ""%7""';
				           |es_CO = 'Como el parámetro adicional puede ser tipo (nombre de tabla),
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"" y ""%7""';
				           |tr = 'Tür (tablo adı) ek parametre olabilir, 
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"" ve ""%7""';
				           |it = 'Il parametro aggiuntivo può essere un tipo (un nome di tabella),
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"", e ""%7""';
				           |de = 'Ein zusätzlicher Parameter kann vom Typ (Tabellenname),
				           |""%1"",""%2"", ""%3"", ""%4"", ""%5"", ""%6"" und ""%7"" sein'"),
				"EmptyRef,Undefined,Null,Number,String,Date,Boolean"));
		Return;
	EndIf;
	
	If Parameter.Rows.Count() < 2 Then
		If Parameter.Rows[0].Kind = "Name" Then 
			Template = NStr("ru = 'После типа (имени таблицы) ""%2"" должно быть указано ключевое слово ""%1""'; en = 'The ""%1"" keyword must be specified after type (table name) ""%2""'; pl = 'Po rodzaju (nazwy tabeli) ""%2"" powinno być słowo kluczowe ""%1""';es_ES = 'Después del tipo (nombre de tabla) ""%2"" debe estar indicada la palabra clave ""%1""';es_CO = 'Después del tipo (nombre de tabla) ""%2"" debe estar indicada la palabra clave ""%1""';tr = 'Türden (tablo adından) sonra ""%2"" ""%1"" anahtar kelime belirtilmelidir';it = 'La parola chiave ""%1"" deve essere indicata dopo il tipo (nome tabella) ""%2""';de = 'Nach dem Typ (Tabellenname) ""%2"" muss das Schlüsselwort ""%1"" angegeben werden'");
		Else
			Template = NStr("ru = 'После ключевого слова ""%2"" должно быть указано ключевое слово ""%1""'; en = 'The ""%1"" keyword must be specified after keyword ""%2""'; pl = 'Po słowie kluczowym ""%2"" powinno być słowo kluczowe ""%1""';es_ES = 'Después de la palabra clave ""%2"" debe estar indicada la palabra clave ""%1""';es_CO = 'Después de la palabra clave ""%2"" debe estar indicada la palabra clave ""%1""';tr = '""%2"" anahtar kelimeden sonra ""%1"" anahtar kelimesi belirtilmelidir';it = 'La parola chiave ""%1"" deve essere indicata dopo la parola chiave ""%2""';de = 'Dem Schlüsselwort ""%2"" sollte das Schlüsselwort ""%1"" folgen'");
		EndIf;
		SetErrorInRow(Parameter.Rows[0], InsertKeywordsIntoString(Context,
				Template, "As", Parameter.Rows[0].Chars),
			True);
		Return;
	EndIf;
	
	If Parameter.Rows[1].Kind <> "Keyword"
	 Or Parameter.Rows[1].Clarification <> "As" Then
		
		If Parameter.Rows[0].Kind = "Name" Then
			Template = NStr("ru = 'После типа (имени таблицы) ""%2"" должно быть указано ключевое слово ""%1""'; en = 'The ""%1"" keyword must be specified after type (table name) ""%2""'; pl = 'Po rodzaju (nazwy tabeli) ""%2"" powinno być słowo kluczowe ""%1""';es_ES = 'Después del tipo (nombre de tabla) ""%2"" debe estar indicada la palabra clave ""%1""';es_CO = 'Después del tipo (nombre de tabla) ""%2"" debe estar indicada la palabra clave ""%1""';tr = 'Türden (tablo adından) sonra ""%2"" ""%1"" anahtar kelime belirtilmelidir';it = 'La parola chiave ""%1"" deve essere indicata dopo il tipo (nome tabella) ""%2""';de = 'Nach dem Typ (Tabellenname) ""%2"" muss das Schlüsselwort ""%1"" angegeben werden'");
		Else
			Template = NStr("ru = 'После ключевого слова ""%2"" должно быть указано ключевое слово ""%1""'; en = 'The ""%1"" keyword must be specified after keyword ""%2""'; pl = 'Po słowie kluczowym ""%2"" powinno być słowo kluczowe ""%1""';es_ES = 'Después de la palabra clave ""%2"" debe estar indicada la palabra clave ""%1""';es_CO = 'Después de la palabra clave ""%2"" debe estar indicada la palabra clave ""%1""';tr = '""%2"" anahtar kelimeden sonra ""%1"" anahtar kelimesi belirtilmelidir';it = 'La parola chiave ""%1"" deve essere indicata dopo la parola chiave ""%2""';de = 'Dem Schlüsselwort ""%2"" sollte das Schlüsselwort ""%1"" folgen'");
		EndIf;
		SetErrorInRow(Parameter.Rows[1], InsertKeywordsIntoString(Context,
			Template, "As", Parameter.Rows[0].Chars));
		Return;
	EndIf;
	
	If Parameter.Rows.Count() < 3 Then
		SetErrorInRow(Parameter.Rows[1], InsertKeywordsIntoString(Context,
				NStr("ru = 'После ключевого слова ""%4"" не указано значение уточнения ""%1"", ""%2"" или ""%3""'; en = 'Clarification value ""%1"", ""%2"", or ""%3"" is not specified after the ""%4"" keyword'; pl = 'Po słowie kluczowym ""%4"" nie określono wartości objaśnienia ""%1"", ""%2"" lub ""%3""';es_ES = 'Después de la palabra clave ""%4"" no está indicado el valor de la especificación ""%1"", ""%2"" o ""%3""';es_CO = 'Después de la palabra clave ""%4"" no está indicado el valor de la especificación ""%1"", ""%2"" o ""%3""';tr = '""%4"" anahtar kelimeden sonra ""%1"", ""%2"" veya ""%3"" netleştirme değeri belirtilmemiştir';it = 'Valore di precisazione ""%1"", ""%2"", o""%3"" non indicato dopo la parola chiave ""%4""';de = 'Nach dem Schlüsselwort ""%4"" gibt nicht den Wert der Klarstellung ""%1"", ""%2"" oder ""%3"" an'"),
				"False,True,Empty",
				Parameter.Rows[1].Chars),
			True);
		Return;
	EndIf;
	
	If Parameter.Rows[2].Kind <> "Keyword"
	 Or Parameter.Rows[2].Type <> "ClarificationValue" Then
		
		SetErrorInRow(Parameter.Rows[2], InsertKeywordsIntoString(Context,
			NStr("ru = 'После ключевого слова ""%4"" должно быть указано значение уточнения ""%1"", ""%2"" или ""%3""'; en = 'Clarification value ""%1"", ""%2"", or ""%3"" must be specified after the ""%4"" keyword'; pl = 'Po słowie kluczowym ""%4"" musi być określona wartość objaśnienia ""%1"", ""%2"" lub ""%3""';es_ES = 'Después de la palabra clave ""%4"" debe estar indicado el valor de especificación ""%1"", ""%2"" o ""%3""';es_CO = 'Después de la palabra clave ""%4"" debe estar indicado el valor de especificación ""%1"", ""%2"" o ""%3""';tr = '""%4"" anahtar kelimeden sonra ""%1"", ""%2"" veya ""%3"" netleştirme değeri belirtilmelidir';it = 'Il valore di precisazione ""%1"", ""%2"", o ""%3"" deve essere indicato dopo la parola chiave ""%4""';de = 'Auf das Schlüsselwort ""%4"" sollte der Wert der Klarstellung ""%1"", ""%2"" oder ""%3"" folgen'"),
			"False,True,Empty",
			Parameter.Rows[1].Chars));
	Else
		NewDetails.ComparisonClarifications.Insert(ComparisonValue, Parameter.Rows[2].Clarification);
	EndIf;
	
	If Parameter.Rows.Count() > 3 Then
		SetErrorInRow(Parameter.Rows[3],
			NStr("ru = 'Перед параметром не указана запятая или лишний параметр'; en = 'Comma or extra parameter is not specified before the parameter'; pl = 'Przed opcją nie podano przecinek lub dodatkowy parametr';es_ES = 'Antes del parámetro no está indicada coma o parámetro de sobra';es_CO = 'Antes del parámetro no está indicada coma o parámetro de sobra';tr = 'Parametreden önce virgül veya fazla parametre belirtilmemiştir';it = 'Non è indicato un punto o un parametro extra prima del parametro';de = 'Es wird kein Komma oder zusätzlicher Parameter vor dem Parameter angegeben'"));
	EndIf;
	
EndProcedure

// For the ParseFunction procedure.
Procedure ParseValueFunctionOrTypeFunctionParameters(Row, NewDetails, IsValueFunction, Context)
	
	NewDetails.Insert("Name", Undefined);
	
	ParametersContent = CommaSeparatedParameters(Row);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	Parameter = ParametersContent[0];
	If Parameter.Rows[0].Kind = "Name" Then
		NewDetails.Name = Parameter.Rows[0].Chars;
		
		If IsValueFunction Then
			AddRequiredPredefinedItem(Context, NewDetails.Name, Parameter.Rows[0]);
		Else
			AddRequiredTableAsReferenceType(Context, NewDetails.Name, Parameter.Rows[0]);
		EndIf;
		
	ElsIf IsValueFunction Then
		SetErrorInRow(Parameter.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В функции ""%1"" можно указать только имя предопределенного значения'; en = 'In the ""%1"" function, only a predefined value name can be specified'; pl = 'W funkcji ""%1"" można wpisać tylko nazwę zadanej wartości';es_ES = 'En la función ""%1"" se puede indicar solo un nombre del valor predeterminado';es_CO = 'En la función ""%1"" se puede indicar solo un nombre del valor predeterminado';tr = '""%1"" işlevinde yalnızca önceden tanımlanmış değerin adı belirtilebilir';it = 'Nella funzione ""%1"" solo un nome valore predefinito può essere indicato';de = 'In der Funktion ""%1"" kann nur der Name des vordefinierten Wertes angegeben werden'"), Row.Chars));
	
	ElsIf Parameter.Rows[0].Kind = "Keyword"
	        AND Parameter.Rows[0].Type = "TypeName" Then
		
		NewDetails.Name = Parameter.Rows[0].Clarification;
	Else
		SetErrorInRow(Parameter.Rows[0], InsertKeywordsIntoString(Context,
			NStr("ru = 'В функции ""%5"" можно указать имя таблицы или ""%1"", ""%2"", ""%3"" и ""%4""'; en = 'In the ""%5"" function, a table name or ""%1"", ""%2"", ""%3"" and ""%4"" can be specified'; pl = 'W funkcji ""%5"" można określić nazwę tabeli lub ""%1"", ""%2"", ""%3"" i ""%4""';es_ES = 'En la función ""%5"" se puede indicar el nombre de tabla o ""%1"", ""%2"", ""%3"", y ""%4""';es_CO = 'En la función ""%5"" se puede indicar el nombre de tabla o ""%1"", ""%2"", ""%3"", y ""%4""';tr = '""%5"" işlevinde tablo adı veya ""%1"", ""%2"", ""%3"" ve ""%4"" belirtilebilir';it = 'Nella funzione ""%5"" può essere indicato un nome di tabella o ""%1"", ""%2"", ""%3"" e""%4""';de = 'In der Funktion ""%5"" können Sie einen Tabellennamen angeben oder ""%1"", ""%2"", ""%3"" und ""%4""'"),
			"Number,String,Date,Boolean",
			Row.Chars));
	EndIf;
	
	If Parameter.Rows.Count() > 1 Then
		SetErrorInRow(Parameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только один параметр'; en = 'The ""%1"" function can have only one parameter'; pl = 'Funkcja ""%1"" może być tylko jeden parametr';es_ES = 'La función ""%1"" puede tener solo un parámetro';es_CO = 'La función ""%1"" puede tener solo un parámetro';tr = '""%1"" işlevi yalnızca bir parametreye sahip olabilir';it = 'La funzione ""%1"" può avere solo un parametro';de = 'Die Funktion ""%1"" kann nur einen Parameter haben'"), Row.Chars));
	EndIf;
	
	If ParametersContent.Count() > 1 Then
		SetErrorInRow(ParametersContent[1].Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только один параметр'; en = 'The ""%1"" function can have only one parameter'; pl = 'Funkcja ""%1"" może być tylko jeden parametr';es_ES = 'La función ""%1"" puede tener solo un parámetro';es_CO = 'La función ""%1"" puede tener solo un parámetro';tr = '""%1"" işlevi yalnızca bir parametreye sahip olabilir';it = 'La funzione ""%1"" può avere solo un parametro';de = 'Die Funktion ""%1"" kann nur einen Parameter haben'"), Row.Chars));
	EndIf;
	
EndProcedure

// For the ParseFunction procedure.
Procedure ParseValueTypeFunctionParameters(Context, NewDetails)
	
	Row = Context.String;
	NewDetails.Insert("Argument", Undefined);
	
	ParametersContent = CommaSeparatedParameters(Row);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	Parameter = ParametersContent[0];
	
	If Parameter.Rows[0].Kind = "Name" Then
		NewDetails.Argument = FieldNodeOrConstantNodeDetails(Parameter.Rows[0]);
		
	ElsIf Parameter.Rows[0].Kind = "Keyword"
	        AND Parameter.Rows[0].Clarification = "Cast" Then
		
		NewDetails.Argument = FieldNodeDetailsFromExpressFunction(Parameter.Rows[0], Context);
		
	ElsIf Parameter.Rows[0].Kind = "Keyword"
	        AND Parameter.Rows[0].Clarification = "IsNull" Then
		
		NewDetails.Argument = FieldNodeDetailsFromIsNullFunction(Parameter.Rows[0], Context);
	Else
		SetErrorInRow(Parameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'Параметром может быть имя поля, функция ""%1"" или функция ""%2""'; en = 'Parameter can be a field name, function ""%1"", or function ""%2""'; pl = 'Parametrem może być nazwa pola, funkcja ""%1"" lub funkcja ""%2""';es_ES = 'Como el parámetro puede ser nombre de campo, la función ""%1"" o la función ""%2""';es_CO = 'Como el parámetro puede ser nombre de campo, la función ""%1"" o la función ""%2""';tr = 'Parametre alan adı, ""%1"" işlevi veya ""%2"" işlevi olabilir';it = 'Il parametro può essere un nome di campo, funzione ""%1"" o funzione ""%2""';de = 'Parameter können Feldname, Funktion ""%1"" oder Funktion ""%2"" sein'"),
				"Cast,IsNull"));
		Return;
	EndIf;
	
	If Parameter.Rows[0].Kind = "Keyword"
	   AND Parameter.Rows[0].Clarification = "Cast"
	   AND NewDetails.Argument.Attachment = Undefined Then
		
		SetErrorInRow(Parameter.Rows[0].EndString,
			InsertKeywordsIntoString(Context,
				NStr("ru = 'После вложенной функции ""%1"" должно быть указано имя поля через точку'; en = 'Period-separated field name must be specified after the ""%1"" nested function'; pl = 'Po włożonej funkcji ""%1"" powinna być wskazana nazwa pola przez kropkę';es_ES = 'Después de la función adjunta ""%1"" debe estar indicado un nombre de campo con puntos';es_CO = 'Después de la función adjunta ""%1"" debe estar indicado un nombre de campo con puntos';tr = 'İç içe geçmiş ""%1"" işlevinden sonra, alan adı nokta ile belirtilmelidir';it = 'Il nome campo separato dal punto deve essere indicato dopo la funzione nidificata ""%1""';de = 'Nach der verschachtelten Funktion ""%1"" muss der Feldname über einen Punkt angegeben werden'"),
				Parameter.Rows[0].Chars),
			True);
	EndIf;
	
	If Parameter.Rows.Count() < 2 Then
		Return;
	EndIf;
	
	If Parameter.Rows.Count() > 1 Then
		SetErrorInRow(Parameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только один параметр'; en = 'The ""%1"" function can have only one parameter'; pl = 'Funkcja ""%1"" może być tylko jeden parametr';es_ES = 'La función ""%1"" puede tener solo un parámetro';es_CO = 'La función ""%1"" puede tener solo un parámetro';tr = '""%1"" işlevi yalnızca bir parametreye sahip olabilir';it = 'La funzione ""%1"" può avere solo un parametro';de = 'Die Funktion ""%1"" kann nur einen Parameter haben'"), Row.Chars));
	EndIf;
	
	If ParametersContent.Count() > 1 Then
		SetErrorInRow(ParametersContent[1].Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только один параметр'; en = 'The ""%1"" function can have only one parameter'; pl = 'Funkcja ""%1"" może być tylko jeden parametr';es_ES = 'La función ""%1"" puede tener solo un parámetro';es_CO = 'La función ""%1"" puede tener solo un parámetro';tr = '""%1"" işlevi yalnızca bir parametreye sahip olabilir';it = 'La funzione ""%1"" può avere solo un parametro';de = 'Die Funktion ""%1"" kann nur einen Parameter haben'"), Row.Chars));
	EndIf;
	
EndProcedure

// For the ParseFunction, ParseFirstCheckingFunctionParameter, and ParseValueTypeFunctionParameters procedures.
Function FieldNodeDetailsFromExpressFunction(Row, Context)
	
	NewDetails = FieldNodeDetails(Row);
	
	If Row.Rows.Count() > 0 Then
		LastRow = Row.Rows[Row.Rows.Count() - 1];
		If LastRow.Type = "AdditionToExpress" Then
			Row.Rows.Delete(Row.Rows.Count() - 1);
			NewDetails.Name         = Mid(LastRow.Chars, 2);
			NewDetails.NameSource = LastRow;
			NewDetails.Attachment    = FieldNodeDetailsFromExpressFunction(Row, Context);
			Return NewDetails;
		EndIf;
	EndIf;
	
	ParametersContent = CommaSeparatedParameters(Row);
	
	If ParametersContent.Count() = 0 Then
		// The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
		Return NewDetails;
	EndIf;
	
	FirstParameter = ParametersContent[0];
	
	If FirstParameter.Rows[0].Kind = "Name" Then
		NewDetails.Name         = FirstParameter.Rows[0].Chars;
		NewDetails.NameSource = FirstParameter.Rows[0];
		
	ElsIf FirstParameter.Rows[0].Kind = "Keyword"
	        AND FirstParameter.Rows[0].Clarification = "Cast" Then
		
		NewDetails.Attachment = FieldNodeDetailsFromExpressFunction(FirstParameter.Rows[0], Context);
		If NewDetails.Attachment.Attachment = Undefined Then
			SetErrorInRow(FirstParameter.Rows[0].EndString,
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'После вложенной функции ""%1"" должно быть указано имя поля через точку'; en = 'Period-separated field name must be specified after the ""%1"" nested function'; pl = 'Po włożonej funkcji ""%1"" powinna być wskazana nazwa pola przez kropkę';es_ES = 'Después de la función adjunta ""%1"" debe estar indicado un nombre de campo con puntos';es_CO = 'Después de la función adjunta ""%1"" debe estar indicado un nombre de campo con puntos';tr = 'İç içe geçmiş ""%1"" işlevinden sonra, alan adı nokta ile belirtilmelidir';it = 'Il nome campo separato dal punto deve essere indicato dopo la funzione nidificata ""%1""';de = 'Nach der verschachtelten Funktion ""%1"" muss der Feldname über einen Punkt angegeben werden'"),
					FirstParameter.Rows[0].Chars),
				True);
		Else
			NewDetails = NewDetails.Attachment;
		EndIf;
		
	ElsIf FirstParameter.Rows[0].Kind = "Keyword"
	        AND FirstParameter.Rows[0].Clarification = "IsNull" Then
		
		NewDetails = FieldNodeDetailsFromIsNullFunction(FirstParameter.Rows[0], Context);
	Else
		SetErrorInRow(FirstParameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'Первым параметром может быть имя поля, функция ""%1"" или функция ""%2""'; en = 'First parameter can be a field name, function ""%1"", or function ""%2""'; pl = 'Pierwszym parametrem może być nazwa pola, funkcja ""%1"" lub funkcja ""%2""';es_ES = 'Como el primer parámetro puede ser nombre de campo, la función ""%1"" o la función ""%2""';es_CO = 'Como el primer parámetro puede ser nombre de campo, la función ""%1"" o la función ""%2""';tr = 'İlk parametre alan adı, ""%1"" işlevi veya ""%2"" işlevi olabilir';it = 'Il primo parametro può essere un nome campo, funzione ""%1"", or funzione ""%2""';de = 'Der erste Parameter kann Feldname, Funktion ""%1"" oder Funktion ""%2"" sein'"),
				"Cast,IsNull"));
		Return NewDetails;
	EndIf;
	
	If FirstParameter.Rows.Count() < 2 Then
		SetErrorInRow(FirstParameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'После описания поля должно быть указано ключевое слово ""%1""'; en = 'The ""%1"" keyword must be specified after field description'; pl = 'Po opisie pola powinno być podane słowo kluczowe ""%1""';es_ES = 'Después de la descripción del campo debe estar indicada una palabra clave ""%1""';es_CO = 'Después de la descripción del campo debe estar indicada una palabra clave ""%1""';tr = 'Alan açıklamasından sonra ""%1"" anahtar kelimesi belirtilmelidir';it = 'La parola chiave ""%1"" deve essere indicata dopo la descrizione del campo';de = 'Nach der Beschreibung des Feldes muss das Schlüsselwort ""%1"" angegeben werden'"), "As"), True);
		Return NewDetails;
	EndIf;
	
	If FirstParameter.Rows[1].Kind <> "Keyword"
	 Or FirstParameter.Rows[1].Clarification <> "As" Then
		
		SetErrorInRow(FirstParameter.Rows[1],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'После описания поля должно быть указано ключевое слово ""%1""'; en = 'The ""%1"" keyword must be specified after field description'; pl = 'Po opisie pola powinno być podane słowo kluczowe ""%1""';es_ES = 'Después de la descripción del campo debe estar indicada una palabra clave ""%1""';es_CO = 'Después de la descripción del campo debe estar indicada una palabra clave ""%1""';tr = 'Alan açıklamasından sonra ""%1"" anahtar kelimesi belirtilmelidir';it = 'La parola chiave ""%1"" deve essere indicata dopo la descrizione del campo';de = 'Nach der Beschreibung des Feldes muss das Schlüsselwort ""%1"" angegeben werden'"), "As"));
		Return NewDetails;
	EndIf;
	
	If FirstParameter.Rows.Count() < 3 Then
		SetErrorInRow(FirstParameter.Rows[1],  StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'После ключевого слова ""%1"" не указан тип (имя таблицы)'; en = 'Type (table name) is not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie jest określony typ (nazwa tabeli)';es_ES = 'Después de la palabra clave ""%1"" no se ha indicado tipo (nombre de tabla)';es_CO = 'Después de la palabra clave ""%1"" no se ha indicado tipo (nombre de tabla)';tr = '""%1"" anahtar kelimesinden sonra tür (tablo adı) belirtilmedi';it = 'Il tipo (nome tabella) non è specificato dopo la keyword ""%1""';de = 'Nach dem Schlüsselwort ""%1"" wird kein Typ (Tabellenname) angegeben'"), FirstParameter.Rows[1].Chars));
		Return NewDetails;
	EndIf;
	
	If FirstParameter.Rows[2].Kind <> "Name" Then
		SetErrorInRow(FirstParameter.Rows[2],  StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'После ключевого слова ""%1"" должен быть указан тип (имя таблицы)'; en = 'Type (table name) must be specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" musi być określony rodzaj (nazwa tabeli)';es_ES = 'Después de la palabra clave ""%1"" debe estar indicado el tipo (nombre de tabla)';es_CO = 'Después de la palabra clave ""%1"" debe estar indicado el tipo (nombre de tabla)';tr = '""%1"" anahtar kelimesinden sonra tür (tablo adı) belirtilmelidir';it = 'Il tipo (nome tabella) deve essere indicato dopo la parola chiave ""%1""';de = 'Nach dem Schlüsselwort ""%1"" muss der Typ (Tabellenname) angegeben werden'"),
			FirstParameter.Rows[1].Chars));
	Else
		NewDetails.Cast = FirstParameter.Rows[2].Chars;
		NewDetails.CastSource = FirstParameter.Rows[2];
	EndIf;
	
	If FirstParameter.Rows.Count() > 3 Then
		SetErrorInRow(FirstParameter.Rows[3], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только один параметр'; en = 'The ""%1"" function can have only one parameter'; pl = 'Funkcja ""%1"" może być tylko jeden parametr';es_ES = 'La función ""%1"" puede tener solo un parámetro';es_CO = 'La función ""%1"" puede tener solo un parámetro';tr = '""%1"" işlevi yalnızca bir parametreye sahip olabilir';it = 'La funzione ""%1"" può avere solo un parametro';de = 'Die Funktion ""%1"" kann nur einen Parameter haben'"), Row.Chars));
	EndIf;
	
	If ParametersContent.Count() > 1 Then
		SetErrorInRow(FirstParameter.EndString, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только один параметр'; en = 'The ""%1"" function can have only one parameter'; pl = 'Funkcja ""%1"" może być tylko jeden parametr';es_ES = 'La función ""%1"" puede tener solo un parámetro';es_CO = 'La función ""%1"" puede tener solo un parámetro';tr = '""%1"" işlevi yalnızca bir parametreye sahip olabilir';it = 'La funzione ""%1"" può avere solo un parametro';de = 'Die Funktion ""%1"" kann nur einen Parameter haben'"), Row.Chars));
	EndIf;
	
	Return NewDetails;
	
EndFunction

// For the ParseExpression, ParseFirstCheckingFunctionParameter,
// ParseValueTypeFunctionParameters procedures and the FieldNodeDetailsFromExpressFunction function.
// 
//
Function FieldNodeDetailsFromIsNullFunction(Row, Context)
	
	NewDetails = FieldNodeDetails(Row);
	NewDetails.IsNullSource = Row;
	
	ParametersContent = CommaSeparatedParameters(Row);
	
	If ParametersContent.Count() = 0 Then
		// The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
		Return NewDetails;
	EndIf;
	
	FirstParameter = ParametersContent[0];
	
	If FirstParameter.Rows[0].Kind = "Name" Then
		NewDetails.Name         = FirstParameter.Rows[0].Chars;
		NewDetails.NameSource = FirstParameter.Rows[0];
	Else
		SetErrorInRow(FirstParameter.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Первым параметром функции ""%1"" может быть только имя поля'; en = 'First parameter of the ""%1"" function can be only a field name'; pl = 'Pierwszym parametrem funkcji ""%1"" może być tylko nazwa pola';es_ES = 'Como el primer parámetro de la función ""%1"" puede ser solo nombre de campo';es_CO = 'Como el primer parámetro de la función ""%1"" puede ser solo nombre de campo';tr = '""%1"" işlevin ilk parametresi yalnızca alan adı olabilir';it = 'Il primo parametro della funzione ""%1"" può essere solo un nome di campo';de = 'Der erste Parameter der Funktion ""%1"" kann nur der Feldname sein'"), Row.Chars));
	EndIf;
	
	If FirstParameter.Rows.Count() > 1 Then
		SetErrorInRow(FirstParameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Перед параметром функции ""%1"" не указана запятая'; en = 'Comma is not specified before the ""%1"" function parameter'; pl = 'Przed parametrem funkcji ""%1"" nie podano przecinek';es_ES = 'Antes del parámetro de la función ""%1"" no se ha indicado una coma';es_CO = 'Antes del parámetro de la función ""%1"" no se ha indicado una coma';tr = '""%1"" işlevin parametresinden önce virgül belirtilmemiştir';it = 'La virgola non è specificata prima del parametro funzionale ""%1""';de = 'Vor dem Funktionsparameter ""%1"" wird kein Komma angegeben'"), Row.Chars));
		Return NewDetails;
	EndIf;
	
	If ParametersContent.Count() < 2 Then
		SetErrorInRow(FirstParameter.EndString, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" должно быть два параметра'; en = 'The ""%1"" function must have two parameters'; pl = 'Funkcja ""%1"" powinna mieć dwa parametry';es_ES = 'La función ""%1"" debe tener dos parámetros';es_CO = 'La función ""%1"" debe tener dos parámetros';tr = '""%1"" işlevin iki parametresi olmalıdır';it = 'La funzione ""%1"" deve avere due parametri';de = 'Die Funktion ""%1"" muss zwei Parameter haben'"), Row.Chars));
		Return NewDetails;
	EndIf;
	
	SecondParameter = ParametersContent[1];
	
	If SecondParameter.Rows[0].Kind = "Number"
	 Or SecondParameter.Rows[0].Kind = "ArbitraryLine"
	 Or SecondParameter.Rows[0].Kind = "Keyword"
	   AND (    SecondParameter.Rows[0].Clarification = "True"
	      Or SecondParameter.Rows[0].Clarification = "False"
	      Or SecondParameter.Rows[0].Clarification = "Undefined"
	      Or SecondParameter.Rows[0].Clarification = "Value" ) Then
		
		If SecondParameter.Rows[0].Clarification = "Value" Then
			NewDetails.IsNull = New Structure("Source, Node",
				SecondParameter.Rows[0], SecondParameter.Rows[0].Clarification);
			
			ParseValueFunctionOrTypeFunctionParameters(SecondParameter.Rows[0], NewDetails.IsNull, True, Context);
		Else
			NewDetails.IsNull = FieldNodeOrConstantNodeDetails(SecondParameter.Rows[0]);
		EndIf;
	Else
		SetErrorInRow(SecondParameter.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" второй параметр может быть, либо предопределенным значением, либо константой'; en = 'The second parameter of the ""%1"" function can be either a predefined value or a constant'; pl = 'Funkcja ""%1"" drugi parametr może być, albo z predefiniowanych wartości, albo wartością stałą';es_ES = 'El segundo parámetro de la función ""%1"" puede ser valor predeterminado o constante';es_CO = 'El segundo parámetro de la función ""%1"" puede ser valor predeterminado o constante';tr = '""%1"" işlevinde, ikinci parametre önceden tanımlanmış bir değer veya sabit olabilir';it = 'Il secondo parametro della funzione ""%1"" può essere un valore prestabilito, oppure una costante';de = 'Der zweite Parameter der Funktion ""%1"" kann entweder ein vordefinierter Wert oder eine Konstante sein'"),
			Row.Chars));
	EndIf;
	
	If SecondParameter.Rows.Count() > 1 Then
		SetErrorInRow(SecondParameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только два параметра'; en = 'The ""%1"" function can have only two parameters'; pl = 'Funkcja ""%1"" może mieć tylko dwa parametry';es_ES = 'La función ""%1"" puede tener solo dos parámetros';es_CO = 'La función ""%1"" puede tener solo dos parámetros';tr = '""%1"" işlevi yalnızca iki parametreye sahip olabilir';it = 'La funzione ""%1"" può avere solo due parametri';de = 'Die Funktion ""%1"" kann nur zwei Parameter haben'"), Row.Chars));
	EndIf;
	
	If ParametersContent.Count() > 2 Then
		SetErrorInRow(ParametersContent[2].Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" должно быть только два параметра'; en = 'The ""%1"" function must have only two parameters'; pl = 'Funkcja ""%1"" powinna mieć tylko dwa parametry';es_ES = 'La función ""%1"" debe tener solo dos parámetros';es_CO = 'La función ""%1"" debe tener solo dos parámetros';tr = '""%1"" işlevin iki parametresi olmalıdır';it = 'La funzione ""%1"" deve avere solo due parametri';de = 'Die Funktion ""%1"" sollte nur zwei Parameter haben'"), Row.Chars));
	EndIf;
	
	Return NewDetails;
	
EndFunction

// For the ParseConnectorIn, ParseCheckingFunctionParameters,
// ParseValueFunctionOrTypeFunctionParameters, and ParseValueTypeFunctionParameters procedures and 
// the FieldNodeDetailsFromExpressFunction and FieldNodeDetailsFromIsNullFunction functions.
//
Function CommaSeparatedParameters(Row)
	
	ParametersContent = New Array;
	
	If Row.Rows.Count() = 0 Then
		Return ParametersContent;
	EndIf;
	
	ParameterDetails = New Structure("Rows, EndString", New Array);
	PreviousSubstringIsArgumentPart = False;
	
	For Each Substring In Row.Rows Do
		
		If Substring.Chars = "," Then
			If Not PreviousSubstringIsArgumentPart Then
				If Row.Rows[0] = Substring Then
					SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Перед запятой не указан параметр'; en = 'Parameter is not specified before comma'; pl = 'Przed przecinkiem nie podano parametru';es_ES = 'Antes de la coma no está indicado parámetro';es_CO = 'Antes de la coma no está indicado parámetro';tr = 'Virgülden önce parametre belirtilmedi';it = 'Il parametro non è indicato prima della virgola';de = 'Es wird kein Parameter vor dem Punkt angegeben'"), Substring.Chars));
					ParameterDetails.Rows.Add(AdditionalString(Substring, ""));
				Else
					SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Пропущен параметр или лишняя запятая'; en = 'Parameter or extra comma was skipped'; pl = 'Pominięty parametr lub zbędny przecinek';es_ES = 'Parámetro saltado o coma de sobra';es_CO = 'Parámetro saltado o coma de sobra';tr = 'Eksik parametre veya fazla virgül';it = 'Parametro o virgola extra saltati';de = 'Parameter oder zusätzliches Komma fehlt'"), Substring.Chars));
				EndIf;
			EndIf;
			If ParameterDetails.Rows.Count() > 0 Then
				ParametersContent.Add(ParameterDetails);
				ParameterDetails.EndString = Substring;
			EndIf;
			ParameterDetails = New Structure("Rows, EndString", New Array);
			PreviousSubstringIsArgumentPart = False;
			Continue;
		EndIf;
		
		PreviousSubstringIsArgumentPart = True;
		
		ParameterDetails.Rows.Add(Substring);
	EndDo;
	
	If ParameterDetails.Rows.Count() > 0 Then
		ParametersContent.Add(ParameterDetails);
		ParameterDetails.EndString = Row.EndString;
	Else
		SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Лишняя запятая или после запятой не указан параметр'; en = 'Extra comma or parameter is not specified after comma'; pl = 'Zbędny przecinek lub po przecinku nie podano parametru';es_ES = 'Coma de sobra o después de la coma no está indicado el parámetro';es_CO = 'Coma de sobra o después de la coma no está indicado el parámetro';tr = 'Fazla virgül veya virgülden sonra belirtilmemiş parametre';it = 'Virgola extra o parametro non indicati dopo la virgola';de = 'Überschüssiges Komma oder nach dem Punkt wird der Parameter nicht angegeben'"), Substring.Chars), True);
	EndIf;
	
	Return ParametersContent;
	
EndFunction

// For the ParseExpression procedure.
Procedure ParseChoice(Context)
	
	Row = Context.String;
	
	NodeProperties = "Source, Node, Case, When, Else";
	NewDetails = New Structure(NodeProperties, Row, "Case");
	NewDetails.When = New Array;
	
	SkipWhenAnalysis = False;
	
	Choice = Row.Rows[0];
	If Choice.Rows.Count() > 0 Then
		If Choice.Rows[0].Kind = "Name" Then
			NewDetails.Case = FieldNodeOrConstantNodeDetails(Choice.Rows[0]);
		Else
			SkipWhenAnalysis = True;
			SetErrorInRow(Choice.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Когда аргумент ключевого слова ""%1"" указан, то это может быть только имя поля'; en = 'When the ""%1"" keyword argument is specified, it can only be a field name'; pl = 'Gdy argument słowa kluczowego ""%1"" jest określony, to może to być tylko nazwa pola';es_ES = 'Cuando el argumento de la palabra clave ""%1"" está indicado, esto puede ser solo el nombre de campo';es_CO = 'Cuando el argumento de la palabra clave ""%1"" está indicado, esto puede ser solo el nombre de campo';tr = 'Anahtar kelime argümanı ""%1"" belirtildiğinde, yalnızca alan adı olabilir';it = 'Quando l''argomento di parola chiave ""%1"" è indicato, può essere soltanto un nome di campo';de = 'Wenn das Argument des Schlüsselwortes ""%1"" angegeben wird, kann es nur der Feldname sein'"),
				Row.Chars));
		EndIf;
	EndIf;
	
	Index = 1;
	While Row.Rows[Index].Clarification = "When" Do
		WhenThenDetails = New Structure("Condition, Value");
		NewDetails.When.Add(WhenThenDetails);
		
		When = Row.Rows[Index];
		
		If Not SkipWhenAnalysis Then
			If NewDetails.Case = Undefined Then
				ParseExpression(When.Rows, WhenThenDetails.Condition, Context);
				
			ElsIf When.Rows.Count() = 0 Then
				If ValueIsFilled(When.Chars) Then
					SetErrorInRow(When.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Так как после ключевого слова ""%1"" указано поле, то после ключевого слова ""%2""
						           |должно быть указано, либо предопределенное значение, либо константа'; 
						           |en = 'As the field is specified after the ""%1"" keyword, 
						           |either a predefined value or a constant must be specified after the ""%2"" keyword'; 
						           |pl = 'Ponieważ po słowie kluczowym ""%1"" zaznaczono pole, to po słowie kluczowym ""%2""
						           |powinny być wskazane, albo zdefiniowanego wartość lub wartość stała';
						           |es_ES = 'Como después de la palabra clave ""%1"" está indicado un campo, después de la palabra clave ""%2""
						           |debe estar indicado un valor predeterminado o constante';
						           |es_CO = 'Como después de la palabra clave ""%1"" está indicado un campo, después de la palabra clave ""%2""
						           |debe estar indicado un valor predeterminado o constante';
						           |tr = '""%1""Anahtar kelimesinden sonra alan belirtildiğinden, ""%2""anahtar kelimesinden sonra önceden
						           | tanımlanmış bir değer veya sabit belirtilmelidir';
						           |it = 'Poiché il campo è indicato dopo la parola chiave ""%1"",
						           |né un valore predefinito né una costante possono essere indicati dopo la parola chiave ""%2""';
						           |de = 'Da das Feld nach dem Schlüsselwort ""%1"" angegeben wird, sollte entweder ein vordefinierter Wert oder eine Konstante nach dem Schlüsselwort ""%2""
						           |angegeben werden'"),
						Row.Chars,
						When.Chars));
				EndIf;
				
			ElsIf When.Rows[0].Kind = "Number"
			      Or When.Rows[0].Kind = "ArbitraryLine"
			      Or When.Rows[0].Kind = "Keyword"
			        AND (    When.Rows[0].Clarification = "True"
			           Or When.Rows[0].Clarification = "False"
			           Or When.Rows[0].Clarification = "Undefined"
			           Or When.Rows[0].Clarification = "Value" ) Then
				
				If When.Rows[0].Clarification = "Value" Then
					WhenThenDetails.Condition = New Structure("Source, Node",
						When.Rows[0], When.Rows[0].Clarification);
					
					ParseValueFunctionOrTypeFunctionParameters(When.Rows[0], WhenThenDetails.Condition, True, Context);
				Else
					WhenThenDetails.Condition = FieldNodeOrConstantNodeDetails(When.Rows[0]);
				EndIf;
			ElsIf ValueIsFilled(When.Chars) Then
				SetErrorInRow(When.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Так как после ключевого слова ""%1"" указано поле, то после ключевого слова ""%2""
					           |должно быть указано, либо предопределенное значение, либо константа'; 
					           |en = 'As the field is specified after the ""%1"" keyword, 
					           |either a predefined value or a constant must be specified after the ""%2"" keyword'; 
					           |pl = 'Ponieważ po słowie kluczowym ""%1"" zaznaczono pole, to po słowie kluczowym ""%2""
					           |powinny być wskazane, albo zdefiniowanego wartość lub wartość stała';
					           |es_ES = 'Como después de la palabra clave ""%1"" está indicado un campo, después de la palabra clave ""%2""
					           |debe estar indicado un valor predeterminado o constante';
					           |es_CO = 'Como después de la palabra clave ""%1"" está indicado un campo, después de la palabra clave ""%2""
					           |debe estar indicado un valor predeterminado o constante';
					           |tr = '""%1""Anahtar kelimesinden sonra alan belirtildiğinden, ""%2""anahtar kelimesinden sonra önceden
					           | tanımlanmış bir değer veya sabit belirtilmelidir';
					           |it = 'Poiché il campo è indicato dopo la parola chiave ""%1"",
					           |né un valore predefinito né una costante possono essere indicati dopo la parola chiave ""%2""';
					           |de = 'Da das Feld nach dem Schlüsselwort ""%1"" angegeben wird, sollte entweder ein vordefinierter Wert oder eine Konstante nach dem Schlüsselwort ""%2""
					           |angegeben werden'"),
					Row.Chars,
					When.Chars));
			EndIf;
		EndIf;
		
		ThenContent = Row.Rows[Index + 1];
		If ThenContent.Rows.Count() > 0 Then
			ParseExpression(ThenContent.Rows, WhenThenDetails.Value, Context);
			
		ElsIf ValueIsFilled(ThenContent.Chars) Then
			SetErrorInRow(When.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'После ключевого слова ""%1"" должно быть указано логическое выражение'; en = 'Logical expression must be specified after the ""%1"" keyword'; pl = 'Po słowie kluczowym ""%1"" powinno być wskazane wyrażenie logiczne';es_ES = 'Después de la palabra clave ""%1"" debe estar indicada una expresión lógica';es_CO = 'Después de la palabra clave ""%1"" debe estar indicada una expresión lógica';tr = '""%1"" Anahtar kelimesinden sonra mantıksal ifade belirtilmelidir';it = 'L''espressione logica deve essere indicata dopo la parola chiave ""%1""';de = 'Auf das Schlüsselwort ""%1"" sollte ein logischer Ausdruck folgen'"), ThenContent.Chars));
		EndIf;
		
		Index = Index + 2;
	EndDo;
	
	ParseExpression(Row.Rows[Index].Rows, NewDetails.Else, Context);
	
	AddArgumentFunctionChoiceOperator(Context, NewDetails);
	
EndProcedure

// For the ParseExpression procedure.
Procedure ParseErrorKeyword(Context)
	
	Row = Context.String;
	Context.Details = Undefined;
	
	If Row.Type = "Undefined" Then
		// The error is already set for the reserved words.
		Return;
	EndIf;
	
	If Row.Type = "ComparisonValue" Then
		If Row.Clarification = "Disabled" Then
			// "Disabled".
			SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Значение ""%1"" может использоваться только как уточняемое значение
				           |в параметрах функции ""%2""'; 
				           |en = 'The ""%1"" value can be used only as a specifying value
				           |in the ""%2"" function parameters'; 
				           |pl = 'Wartość ""%1"" może być stosowana tylko jako doprecyzowana wartość
				           |w parametrach funkcji ""%2""';
				           |es_ES = 'El valor ""%1"" puede ser usado solo como un valor detallado
				           |en los parámetros de la función ""%2""';
				           |es_CO = 'El valor ""%1"" puede ser usado solo como un valor detallado
				           |en los parámetros de la función ""%2""';
				           |tr = '""%1"" Değeri yalnızca işlev parametrelerinde ""%2""
				           |belirtilen değer olarak kullanılabilir';
				           |it = 'Il valore ""%1"" può essere utilizzato solo per specificare il valore
				           |nei parametri di funzione ""%2""';
				           |de = 'Der Wert ""%1"" kann nur als spezifizierter Wert
				           |in den Parametern der Funktion ""%2"" verwendet werden'"),
				Row.Chars,
				KeywordRegardingLanguage("ValueAllowed", Context)));
		Else
			// "BlankRef" or "Null".
			SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Значение ""%1"" может использоваться только как уточняемое значение
				           |в параметрах функций проверки разрешений'; 
				           |en = 'The ""%1"" value can be used only as a specifying value
				           |in the permission check function parameters'; 
				           |pl = 'Wartość ""%1"" może być stosowana tylko jako doprecyzowana wartość
				           |w parametrach funkcji sprawdzania uprawnień';
				           |es_ES = 'El valor ""%1"" puede ser usado solo como un valor detallado
				           |en los parámetros de las funciones de prueba de permisos';
				           |es_CO = 'El valor ""%1"" puede ser usado solo como un valor detallado
				           |en los parámetros de las funciones de prueba de permisos';
				           |tr = '""%1"" Değeri yalnızca işlev parametrelerinde
				           |netleştirilen değer olarak kullanılabilir';
				           |it = 'Il valore ""%1"" può essere utilizzato solo per specificare il valore
				           |nei parametri di funzione di verifica del permesso';
				           |de = 'Der Wert ""%1"" kann nur als spezifizierter Wert
				           |in den Parametern der Berechtigungsprüfungsfunktionen verwendet werden'"),
				Row.Chars));
		EndIf;
		
	ElsIf Row.Type = "TypeName" Then
		// "Number", "String", "Date", "Boolean".
		SetErrorInRow(Row, InsertKeywordsIntoString(Context,
			NStr("ru = 'Имя типа ""%1"" может использоваться только, как параметр функции ""%2"" или
			           |как уточняемое значение в параметрах функций проверки разрешений'; 
			           |en = 'Name of the ""%1"" type can be used only as a parameter of the ""%2"" function or
			           |as a specifying value in parameters of permission check functions'; 
			           |pl = 'Nazwa typu ""%1"" może być używana tylko, jako ustawienie funkcji ""%2"" lub 
			           |jako doprecyzowana wartość w parametrach funkcji sprawdzania uprawnień';
			           |es_ES = 'El nombre del tipo ""%1"" puede ser usado solo como el parámetro de la función ""%2"" o
			           |como un valor detallado en los parámetros de las funciones de prueba de permisos';
			           |es_CO = 'El nombre del tipo ""%1"" puede ser usado solo como el parámetro de la función ""%2"" o
			           |como un valor detallado en los parámetros de las funciones de prueba de permisos';
			           |tr = '""%1""Türü adı yalnızca ""%2"" işlev parametresi olarak veya 
			           |izin doğrulama işlev parametrelerinde netleştirilen değer olarak kullanılabilir';
			           |it = 'Il nome del tipo ""%1"" può essere utilizzato solo come parametro della funzione ""%2"" o
			           |valore di specifica nei parametri di funzioni di controllo del permesso';
			           |de = 'Der Name des Typs ""%1"" kann nur als Funktionsparameter ""%2"" oder
			           |als spezifizierter Wert in den Parametern der Berechtigungsprüfungsfunktionen verwendet werden'"),
			Row.Chars,
			"Type"));
	Else
		SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Обработка ключевого слова ""%1"" не определена'; en = 'The ""%1"" keyword data processor is not determined'; pl = 'Przetwarzanie słów kluczowych ""%1"" niezdefiniowane';es_ES = 'El procesamiento de la palabra clave ""%1"" no se ha determinado';es_CO = 'El procesamiento de la palabra clave ""%1"" no se ha determinado';tr = '""%1"" anahtar kelimesinin işlemesi belirlenmedi';it = 'La parola chiave ""%1"" dell''elaboratore dati non è determinata';de = 'Die Bearbeitung des Schlüsselwortes ""%1"" ist nicht definiert'"), Row.Chars));
	EndIf;
	
EndProcedure

// For the ParseExpression, ParseOperator, ParseFunction, and ParseChoice procedures.
Procedure AddArgumentFunctionChoiceOperator(Context, DetailsToAdd)
	
	// Current node: Any.
	// Details to add: Field, Value, Constant, Not, Choice, any function.
	
	Details = Context.Details;
	
	If Details = Undefined Then
		Context.Details = DetailsToAdd;
		
	ElsIf Upper( Details.Node ) = Upper( "AND" ) // PATCHED
	      Or Details.Node = "Or" Then
		
		If Details.Arguments.Count() = 1 Then
			Details.Arguments.Add(DetailsToAdd);
		Else
			ProcessMissingLogicalOperation(Context, Details.Arguments[1], DetailsToAdd);
		EndIf;
		
	ElsIf Details.Node = "Not" Then
		
		If Not ValueIsFilled(Details.Argument) Then
			Details.Argument = DetailsToAdd;
		Else
			ProcessMissingLogicalOperation(Context, Details.Argument, DetailsToAdd);
		EndIf;
		
	ElsIf Details.Source.Kind = "Operation" Then
		
		If Not ValueIsFilled(Details.SecondArgument) Then
			Details.SecondArgument = DetailsToAdd;
			// Checking the argument accuracy in the MarkIncorrectArgumentsAndProhibitedNodes procedure.
			// 
		Else
			ProcessMissingLogicalOperation(Context, Details.SecondArgument, DetailsToAdd);
		EndIf;
		
	ElsIf StrFind(",Field,Value,Constant,IN,IsNull,Case,", "," + Details.Node + ",") > 0
	      Or Details.Source.Type = "Function" Then
		// The second argument of the In operation is already parsed in the ParseOperationIn procedure.
		// The second Null argument of the Has operation is already parsed in the FunctionsWithExpressionsInParentheses function.
		// The remaining nodes do not have the second argument.
		ProcessMissingLogicalOperation(Context, Undefined, DetailsToAdd);
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не определена обработка узла ""%1""'; en = '""%1"" node data processor is not determined'; pl = 'Nie zdefiniowane przetwarzanie węzła ""%1""';es_ES = 'El procesamiento del nodo no se ha realizado ""%1""';es_CO = 'El procesamiento del nodo no se ha realizado ""%1""';tr = '""%1"" ünitenin işlemesi belirlenmemiştir';it = '""%1"" nodo elaboratore dati non è determinato';de = 'Die Bearbeitung des Knotens ""%1"" ist nicht definiert'"), Details.Node);
		Raise ErrorText;
	EndIf;
	
EndProcedure

// For the AddArgumentFunctionChoiceOperator procedure
Procedure ProcessMissingLogicalOperation(Context, DetailsLastArgument, DetailsToAdd)
	
	SetErrorInRow(Context.String, NStr("ru = 'Не указана логическая операция'; en = 'Logical operation is not specified'; pl = 'Nie określono logiczna operacja';es_ES = 'Operación lógica no indicada';es_CO = 'Operación lógica no indicada';tr = 'Mantıksal işlem belirtilmedi';it = 'Operazione logica non indicata';de = 'Keine logische Verknüpfung angegeben'"));
	
	// Recovery.
	AdditionalString = AdditionalString(Context.String, Upper( "AND" ), Context);
	
	NewDetails = New Structure("Source, Node, Arguments", AdditionalString, Upper( "AND" ), New Array);
	NewDetails.Arguments.Add();
	
	CurrentRow = Context.String;
	Context.String = AdditionalString;
	
	InsertConnectorConsideringPriority(Context,
		DetailsLastArgument, NewDetails, NewDetails.Arguments[0]);
	
	Context.String = CurrentRow;
	
	NewDetails.Arguments.Add(DetailsToAdd);
	
EndProcedure

// For the ParseCondition procedure.
Function ExpressionsInParenthesesInAttachments(Rows)
	
	Result = New Array;
	
	CurrentAttachment = New Structure("Rows", Result);
	Attachments = New Array;
	Attachments.Add(CurrentAttachment);
	
	For Each Row In Rows Do
		If Row.Chars = "(" Then
			AddAttachment(Row, Attachments, CurrentAttachment);
			
		ElsIf Row.Chars = ")" Then
			If Attachments.Count() = 1 Then
				SetErrorInRow(Row,
					NStr("ru = 'Указана закрывающаяся скобка до открывающейся скобки'; en = 'Closing parenthesis is specified before opening parenthesis'; pl = 'Podano otwierający nawias do otwierającego nawiasu';es_ES = 'Se ha indicado una paréntesis de cierre antes de una paréntesis de apertura';es_CO = 'Se ha indicado una paréntesis de cierre antes de una paréntesis de apertura';tr = 'Açılış parantezinden önce kapanış parantezi belirtildi';it = 'Chiusura parentesi indicato prima dell''apertura parentesi';de = 'Die schließende Klammer wird bis zur öffnenden Klammer angezeigt'"));
			Else
				DeleteLastAttachment(Attachments, CurrentAttachment, Row);
			EndIf;
		Else
			CurrentAttachment.Rows.Add(Row);
		EndIf;
	EndDo;
	
	While Attachments.Count() > 1 Do
		LastAttachmentIndex = Attachments.Count() - 1;
		Attachment = Attachments[LastAttachmentIndex];
		Attachment.EndString = Row;
		Attachments.Delete(LastAttachmentIndex);
		SetErrorInRow(Attachment,
			NStr("ru = 'Указана открывающаяся скобка без закрывающейся скобки'; en = 'Opening parenthesis is specified without closing parenthesis'; pl = 'Podano otwierający nawias bez zamykającego nawiasu';es_ES = 'Se ha indicado una paréntesis de cierre sin una paréntesis de apertura';es_CO = 'Se ha indicado una paréntesis de cierre sin una paréntesis de apertura';tr = 'Kapanış parantezi olmadan açılış parantez belirtildi';it = 'Apertura parentesi indicata senza chiusura parentesi';de = 'Die öffnende Klammer wird angezeigt, ohne die schließende Klammer'"), True);
	EndDo;
	
	Return Result;
	
EndFunction

// For the ParseCondition procedure.
Function ExpressionsSelectionWhenThenInAttachments(Rows, Context)
	
	Result = New Array;
	
	CurrentAttachment = New Structure("Rows, Clarification", Result, "");
	Attachments = New Array;
	Attachments.Add(CurrentAttachment);
	
	For Each Row In Rows Do
		
		If Row.Kind <> "Keyword"
		 Or Row.Type <> "SelectionWord" Then
			
			If CurrentAttachment.Clarification = "Case" Then
				CurrentAttachment.Rows[0].Rows.Add(Row);
			Else
				CurrentAttachment.Rows.Add(Row);
				If Row.Chars = "(" Then
					Row.Rows = ExpressionsSelectionWhenThenInAttachments(Row.Rows, Context);
				EndIf;
			EndIf;
		ElsIf Row.Clarification = "Case" Then
			If Attachments.Count() = 1 Then
				// Standard processing after the condition.
			Else
				If CurrentAttachment.Clarification = "Case" Then
					SetErrorInRow(CurrentAttachment, InsertKeywordsIntoString(Context,
						NStr("ru = 'После ключевого слова ""%1"" не указано ключевое слова ""%2""'; en = 'Keyword ""%2"" is not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie określono słowo kluczowe ""%2""';es_ES = 'Después de la palabra clave ""%1"" no se ha indicado una palabra clave ""%2""';es_CO = 'Después de la palabra clave ""%1"" no se ha indicado una palabra clave ""%2""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelimesi belirtilmedi';it = 'La parola chiave ""%2"" non è specificata dopo la parola chiave ""%1""';de = 'Das Schlüsselwort ""%2"" wird nach dem Schlüsselwort ""%1"" nicht aufgeführt'"), "Case,When"), True);
					RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "When", Context);
				EndIf;
			EndIf;
			AddAttachment(Row, Attachments, CurrentAttachment);
			CurrentAttachment.Rows.Add(AdditionalString(CurrentAttachment, "Case", Context));
			
		ElsIf Row.Clarification = "When" Then
			
			If Attachments.Count() = 1 Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевого слова ""%2""'; en = 'Keyword ""%1"" is specified before keyword ""%2""'; pl = 'Słowo kluczowe ""%1"" podano do słowa kluczowego ""%2""';es_ES = 'La palabra clave ""%1"" se ha indicado antes de la palabra clave ""%2""';es_CO = 'La palabra clave ""%1"" se ha indicado antes de la palabra clave ""%2""';tr = 'Anahtar kelime ""%1"" anahtar kelimeden ""%2"" önce belirtildi';it = 'La parola chiave ""%1"" è indicata prima della parola chiave ""%2""';de = 'Das Schlüsselwort ""%1"" wird vor dem Schlüsselwort ""%2"" angegeben'"), "When,Case"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Case", Context);
				
			ElsIf CurrentAttachment.Clarification = "Case" Then
				// Standard processing after the condition.
				
			ElsIf CurrentAttachment.Clarification = "When" Then
				SetErrorInRow(CurrentAttachment, InsertKeywordsIntoString(Context,
					NStr("ru = 'После ключевого слова ""%1"" не указано ключевое слова ""%2""'; en = 'Keyword ""%2"" is not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie określono słowo kluczowe ""%2""';es_ES = 'Después de la palabra clave ""%1"" no se ha indicado una palabra clave ""%2""';es_CO = 'Después de la palabra clave ""%1"" no se ha indicado una palabra clave ""%2""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelimesi belirtilmedi';it = 'La parola chiave ""%2"" non è specificata dopo la parola chiave ""%1""';de = 'Das Schlüsselwort ""%2"" wird nach dem Schlüsselwort ""%1"" nicht aufgeführt'"), "When,Then"), True);
				RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "Then", Context);
				
			ElsIf CurrentAttachment.Clarification = "Then" Then
				DeleteLastAttachment(Attachments, CurrentAttachment);
				
			Else // CurrentAttachment.Clarification = "Else"
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" должно быть до ключевого слова ""%2""'; en = 'Keyword ""%1"" must be specified before keyword ""%2""'; pl = 'Słowo kluczowe ""%1"" musi być do słowa kluczowego ""%2""';es_ES = 'La palabra clave ""%1"" debe estar indicada antes de la palabra clave ""%2""';es_CO = 'La palabra clave ""%1"" debe estar indicada antes de la palabra clave ""%2""';tr = 'Anahtar kelime ""%1"" anahtar kelimeden ""%2"" önce olmalıdır';it = 'La parola chiave ""%1"" deve essere indicata prima della parola chiave ""%2""';de = 'Das Schlüsselwort ""%1"" sollte vor dem Schlüsselwort ""%2"" stehen'"), "When,Else"));
				DeleteLastAttachment(Attachments, CurrentAttachment);
			EndIf;
			AddAttachment(Row, Attachments, CurrentAttachment);
			
		ElsIf Row.Clarification = "Then" Then
			
			If Attachments.Count() = 1 Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"" и ""%3""'; en = 'Keyword ""%1"" is specified before keywords ""%2"" and ""%3""'; pl = 'Słowo kluczowe ""%1"" podano do słów kluczowych ""%2"" i ""%3""';es_ES = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"" y ""%3""';es_CO = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"" y ""%3""';tr = 'Anahtar kelime ""%1"" anahtar kelimelerden ""%2"" ve ""%3"" önce belirtildi';it = 'La parola chiave ""%1"" è indicata prima delle parole chiave ""%2"" e ""%3""';de = 'Das Schlüsselwort ""%1"" wird vor den Schlüsselwörtern ""%2"" und ""%3"" angezeigt'"), "Then,Case,When"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Case,When", Context);
			
			ElsIf CurrentAttachment.Clarification = "Case" Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевого слова ""%2""'; en = 'Keyword ""%1"" is specified before keyword ""%2""'; pl = 'Słowo kluczowe ""%1"" podano do słowa kluczowego ""%2""';es_ES = 'La palabra clave ""%1"" se ha indicado antes de la palabra clave ""%2""';es_CO = 'La palabra clave ""%1"" se ha indicado antes de la palabra clave ""%2""';tr = 'Anahtar kelime ""%1"" anahtar kelimeden ""%2"" önce belirtildi';it = 'La parola chiave ""%1"" è indicata prima della parola chiave ""%2""';de = 'Das Schlüsselwort ""%1"" wird vor dem Schlüsselwort ""%2"" angegeben'"), "Then,When"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "When", Context);
				
			ElsIf CurrentAttachment.Clarification = "When" Then
				// Standard processing after the condition.
				
			ElsIf CurrentAttachment.Clarification = "Then" Then
				SetErrorInRow(CurrentAttachment, InsertKeywordsIntoString(Context,
					NStr("ru = 'После ключевого слова ""%1"" не указано ключевое слова ""%2""'; en = 'Keyword ""%2"" is not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie określono słowo kluczowe ""%2""';es_ES = 'Después de la palabra clave ""%1"" no se ha indicado una palabra clave ""%2""';es_CO = 'Después de la palabra clave ""%1"" no se ha indicado una palabra clave ""%2""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelimesi belirtilmedi';it = 'La parola chiave ""%2"" non è specificata dopo la parola chiave ""%1""';de = 'Das Schlüsselwort ""%2"" wird nach dem Schlüsselwort ""%1"" nicht aufgeführt'"), "Then,When"), True);
				RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "When", Context);
				
			Else // CurrentAttachment.Clarification = "Else"
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" должно быть до ключевого слова ""%2""'; en = 'Keyword ""%1"" must be specified before keyword ""%2""'; pl = 'Słowo kluczowe ""%1"" musi być do słowa kluczowego ""%2""';es_ES = 'La palabra clave ""%1"" debe estar indicada antes de la palabra clave ""%2""';es_CO = 'La palabra clave ""%1"" debe estar indicada antes de la palabra clave ""%2""';tr = 'Anahtar kelime ""%1"" anahtar kelimeden ""%2"" önce olmalıdır';it = 'La parola chiave ""%1"" deve essere indicata prima della parola chiave ""%2""';de = 'Das Schlüsselwort ""%1"" sollte vor dem Schlüsselwort ""%2"" stehen'"), "Then,Else"));
				DeleteLastAttachment(Attachments, CurrentAttachment);
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "When", Context);
			EndIf;
			DeleteLastAttachment(Attachments, CurrentAttachment);
			AddAttachment(Row, Attachments, CurrentAttachment);
			
		ElsIf Row.Clarification = "Else" Then
			
			If Attachments.Count() = 1 Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"", ""%3"" и ""%4""'; en = 'Keyword ""%1"" is specified before keywords ""%2"", ""%3"", and ""%4""'; pl = 'Słowo kluczowe ""%1"" podano do słów kluczowych ""%2"", ""%3"" i ""%4""';es_ES = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"", ""%3"" y ""%4""';es_CO = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"", ""%3"" y ""%4""';tr = 'Anahtar kelime ""%1"" anahtar kelimelerden ""%2"", ""%3"" ve ""%4"" önce belirtildi';it = 'La parola chiave ""%1"" è indicata prima delle parole chiave ""%2"", ""%3"", e ""%4""';de = 'Das Schlüsselwort ""%1"" wird vor den Schlüsselwörtern ""%2"", ""%3"" und ""%4"" angezeigt'"), "Else,Case,When,Then"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Case,When,Then", Context);
			
			ElsIf CurrentAttachment.Clarification = "Case" Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"" и ""%3""'; en = 'Keyword ""%1"" is specified before keywords ""%2"" and ""%3""'; pl = 'Słowo kluczowe ""%1"" podano do słów kluczowych ""%2"" i ""%3""';es_ES = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"" y ""%3""';es_CO = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"" y ""%3""';tr = 'Anahtar kelime ""%1"" anahtar kelimelerden ""%2"" ve ""%3"" önce belirtildi';it = 'La parola chiave ""%1"" è indicata prima delle parole chiave ""%2"" e ""%3""';de = 'Das Schlüsselwort ""%1"" wird vor den Schlüsselwörtern ""%2"" und ""%3"" angezeigt'"), "Else,When,Then"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "When,Then", Context);
				
			ElsIf CurrentAttachment.Clarification = "When" Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевого слова ""%2""'; en = 'Keyword ""%1"" is specified before keyword ""%2""'; pl = 'Słowo kluczowe ""%1"" podano do słowa kluczowego ""%2""';es_ES = 'La palabra clave ""%1"" se ha indicado antes de la palabra clave ""%2""';es_CO = 'La palabra clave ""%1"" se ha indicado antes de la palabra clave ""%2""';tr = 'Anahtar kelime ""%1"" anahtar kelimeden ""%2"" önce belirtildi';it = 'La parola chiave ""%1"" è indicata prima della parola chiave ""%2""';de = 'Das Schlüsselwort ""%1"" wird vor dem Schlüsselwort ""%2"" angegeben'"), "Else,Then"));
				DeleteLastAttachment(Attachments, CurrentAttachment);
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Then", Context);
				
			ElsIf CurrentAttachment.Clarification = "Then" Then
				// Standard processing after the condition.
				
			Else // CurrentAttachment.Clarification = "Else"
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано повторно'; en = 'Keyword ""%1"" is specified again'; pl = 'Słowo kluczowe ""%1"" podano ponownie';es_ES = 'La palabra clave ""%1"" se ha indicado otra vez';es_CO = 'La palabra clave ""%1"" se ha indicado otra vez';tr = 'Anahtar kelime ""%1"" tekrar belirtildi';it = 'La keyword ""%1"" è stato specificato ancora';de = 'Das Schlüsselwort ""%1"" wird wiederholt'"), "Else"));
			EndIf;
			DeleteLastAttachment(Attachments, CurrentAttachment);
			AddAttachment(Row, Attachments, CurrentAttachment);
			
		Else // String.Clarification = "End"
			
			If Attachments.Count() = 1 Then
				SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"", ""%3"", ""%4"" и ""%5""'; en = 'Keyword ""%1"" is specified before keywords ""%2"", ""%3"", ""%4"", and ""%5""'; pl = 'Słowo kluczowe ""%1"" podano do słów kluczowych,""%2"", ""%3"", ""%4"" i ""%5""';es_ES = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"", ""%3"", ""%4"" y ""%5""';es_CO = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"", ""%3"", ""%4"" y ""%5""';tr = '""%1"" anahtar kelimesi ""%2"", ""%3"", ""%4"" ve ""%5"" anahtar kelimelerinden önce belirtildi';it = 'La parola chiave ""%1"" è indicata prima delle parole chiave ""%2"", ""%3"", ""%4"" e ""%5""';de = 'Das Schlüsselwort ""%1"" wird vor den Schlüsselwörtern ""%2"", ""%3"", ""%4"" und ""%5"" angezeigt'"), "End,Case,When,Then,Else"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Case,When,Then,Else", Context);
				
			ElsIf CurrentAttachment.Clarification = "Case" Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"", ""%3"" и ""%4""'; en = 'Keyword ""%1"" is specified before keywords ""%2"", ""%3"", and ""%4""'; pl = 'Słowo kluczowe ""%1"" podano do słów kluczowych ""%2"", ""%3"" i ""%4""';es_ES = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"", ""%3"" y ""%4""';es_CO = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"", ""%3"" y ""%4""';tr = 'Anahtar kelime ""%1"" anahtar kelimelerden ""%2"", ""%3"" ve ""%4"" önce belirtildi';it = 'La parola chiave ""%1"" è indicata prima delle parole chiave ""%2"", ""%3"", e ""%4""';de = 'Das Schlüsselwort ""%1"" wird vor den Schlüsselwörtern ""%2"", ""%3"" und ""%4"" angezeigt'"), "End,When,Then,Else"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "When,Then,Else", Context);
				
			ElsIf CurrentAttachment.Clarification = "When" Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"" и ""%3""'; en = 'Keyword ""%1"" is specified before keywords ""%2"" and ""%3""'; pl = 'Słowo kluczowe ""%1"" podano do słów kluczowych ""%2"" i ""%3""';es_ES = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"" y ""%3""';es_CO = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"" y ""%3""';tr = 'Anahtar kelime ""%1"" anahtar kelimelerden ""%2"" ve ""%3"" önce belirtildi';it = 'La parola chiave ""%1"" è indicata prima delle parole chiave ""%2"" e ""%3""';de = 'Das Schlüsselwort ""%1"" wird vor den Schlüsselwörtern ""%2"" und ""%3"" angezeigt'"), "End,Then,Else"));
				DeleteLastAttachment(Attachments, CurrentAttachment);
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Then,Else", Context);
				
			ElsIf CurrentAttachment.Clarification = "Then" Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевого слова ""%2""'; en = 'Keyword ""%1"" is specified before keyword ""%2""'; pl = 'Słowo kluczowe ""%1"" podano do słowa kluczowego ""%2""';es_ES = 'La palabra clave ""%1"" se ha indicado antes de la palabra clave ""%2""';es_CO = 'La palabra clave ""%1"" se ha indicado antes de la palabra clave ""%2""';tr = 'Anahtar kelime ""%1"" anahtar kelimeden ""%2"" önce belirtildi';it = 'La parola chiave ""%1"" è indicata prima della parola chiave ""%2""';de = 'Das Schlüsselwort ""%1"" wird vor dem Schlüsselwort ""%2"" angegeben'"), "End,Else"));
				DeleteLastAttachment(Attachments, CurrentAttachment);
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Else", Context);
				
			Else // CurrentAttachment.Clarification = "Else".
				// Standard processing after the condition.
			EndIf;
			DeleteLastAttachment(Attachments, CurrentAttachment);
			DeleteLastAttachment(Attachments, CurrentAttachment);
		EndIf;
	EndDo;
	
	While Attachments.Count() > 1 Do
		CurrentAttachment = Attachments[Attachments.Count() - 1];
		
		If CurrentAttachment.Clarification = "Case" Then
			ErrorText = InsertKeywordsIntoString(Context,
				NStr("ru = 'После ключевого слова ""%1"" не указаны ключевые слова ""%2"", ""%3"", ""%4"" и ""%5""'; en = 'Keywords ""%2"", ""%3"", ""%4"", and ""%5"" are not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie podano słowa kluczowe ""%2"", ""%3"", ""%4"" i ""%5""';es_ES = 'Antes de la palabra clave ""%1"" no se han indicado las palabras clave ""%2"", ""%3"", ""%4"" y ""%5""';es_CO = 'Antes de la palabra clave ""%1"" no se han indicado las palabras clave ""%2"", ""%3"", ""%4"" y ""%5""';tr = '""%1"" anahtar kelimesinden sonra ""%2"", ""%3"", ""%4"" ve ""%5"" anahtar kelimeleri belirtilmedi';it = 'Le parole chiave ""%2"", ""%3"", ""%4"", e""%5"" non sono indicate dopo la parola chiave ""%1""';de = 'Die Schlüsselwörter ""%2"", ""%3"", ""%4"" und ""%5"" sind nicht nach dem Schlüsselwort ""%1"" aufgeführt'"), "Case,When,Then,Else,End");
			RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "When,Then,Else", Context);
			
		ElsIf CurrentAttachment.Clarification = "When" Then
			ErrorText = InsertKeywordsIntoString(Context,
				NStr("ru = 'После ключевого слова ""%1"" не указаны ключевые слова ""%2"", ""%3"", ""%4""'; en = 'Keywords ""%2"", ""%3"", and ""%4"" are not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie są określone słowa kluczowe ""%2"", ""%3"", ""%4""';es_ES = 'Después de la palabra clave ""%1"" no se han indicado las palabras clave ""%2"", ""%3"", ""%4""';es_CO = 'Después de la palabra clave ""%1"" no se han indicado las palabras clave ""%2"", ""%3"", ""%4""';tr = 'Anahtar kelimeden ""%1"" sonra anahtar kelimeler ""%2"", ""%3"" ve ""%4"" belirtilmedi';it = 'Le parole chiave ""%2"", ""%3"", e""%4"" non sono indicate dopo la parola chiave ""%1""';de = 'Die Schlüsselwörter ""%2"", ""%3"", ""%4"" werden nach dem Schlüsselwort ""%1"" nicht aufgeführt'"), "When,Then,Else,End");
			DeleteLastAttachment(Attachments, CurrentAttachment);
			RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "Then,Else", Context);
			
		ElsIf CurrentAttachment.Clarification = "Then" Then
			ErrorText = InsertKeywordsIntoString(Context,
				NStr("ru = 'После ключевого слова ""%1"" не указаны ключевые слова ""%2"" и ""%3""'; en = 'Keywords ""%2"" and ""%3"" are not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie podano słowa kluczowe ""%2"" i ""%3""';es_ES = 'Después de la palabra clave ""%1"" no se han indicado las palabras clave ""%2"" y ""%3""';es_CO = 'Después de la palabra clave ""%1"" no se han indicado las palabras clave ""%2"" y ""%3""';tr = 'Anahtar kelimeden ""%1"" sonra anahtar kelimeler ""%2"" ve ""%3"" belirtilmedi';it = 'Le parole chiave ""%2"" e""%3"" non sono indicate dopo la parola chiave ""%1""';de = 'Die Schlüsselwörter ""%2"" und ""%3"" werden nach dem Schlüsselwort ""%1"" nicht aufgeführt'"), "Then,Else,End");
			DeleteLastAttachment(Attachments, CurrentAttachment);
			RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "Else", Context);
			
		Else // CurrentAttachment.Clarification = "Else"
			ErrorText = InsertKeywordsIntoString(Context,
				NStr("ru = 'После ключевого слова ""%1"" не указано ключевое слова ""%2""'; en = 'Keyword ""%2"" is not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie określono słowo kluczowe ""%2""';es_ES = 'Después de la palabra clave ""%1"" no se ha indicado una palabra clave ""%2""';es_CO = 'Después de la palabra clave ""%1"" no se ha indicado una palabra clave ""%2""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelimesi belirtilmedi';it = 'La parola chiave ""%2"" non è specificata dopo la parola chiave ""%1""';de = 'Das Schlüsselwort ""%2"" wird nach dem Schlüsselwort ""%1"" nicht aufgeführt'"), "Else,End");
		EndIf;
		SetErrorInRow(CurrentAttachment, ErrorText, True);
		DeleteLastAttachment(Attachments, CurrentAttachment);
		DeleteLastAttachment(Attachments, CurrentAttachment);
	EndDo;
	
	Return Result;
	
EndFunction

// For the ParseCondition procedure.
Function FunctionsWithExpressionsInParentheses(Rows, InternalData)
	
	Result = New Array;
	StringsCount = Rows.Count();
	
	Row = Undefined;
	Index = 0;
	While Index < StringsCount Do
		PreviousString = Row;
		Row = Rows[Index];
		
		If Row.Chars = "(" Then
			Row.Rows = FunctionsWithExpressionsInParentheses(Row.Rows, InternalData);
			
		ElsIf Row.Kind = "Keyword"
		        AND (    Row.Type = "Function"
		           Or Upper( Row.Clarification ) = Upper( "IN" ) ) Then // PATCHED:
			
			If Index + 1 < Rows.Count()
			   AND Rows[Index + 1].Chars = "(" Then
				
				Index = Index + 1;
				Row.Rows = FunctionsWithExpressionsInParentheses(Rows[Index].Rows, InternalData);
				Row.EndString = Rows[Index].EndString;
				
				If Row.Rows.Count() = 0 Then
					If Row.Type = "Function" Then
						SetErrorInRow(Rows[Index], StringFunctionsClientServer.SubstituteParametersToString(
							NStr("ru = 'У функции ""%1"" не указано ни одного параметра'; en = 'No parameter is specified for the ""%1"" function'; pl = 'Funkcja ""%1"" nie podano żadnego parametru';es_ES = 'Para la función ""%1"" no se ha indicado ningún parámetro';es_CO = 'Para la función ""%1"" no se ha indicado ningún parámetro';tr = '""%1"" işlevin hiç bir parametresi belirtilmedi';it = 'Nessun parametro indicato per la funzione ""%1""';de = 'Für die Funktion ""%1"" ist kein Parameter angegeben'"), Row.Chars), True);
					Else
						SetErrorInRow(Rows[Index], StringFunctionsClientServer.SubstituteParametersToString(
							NStr("ru = 'В списке значений операции ""%1"" не указано ни одного значения'; en = 'No value is specified in the value list of the ""%1"" operation'; pl = 'W liście wartości operacji ""%1"" nie określono żadnej wartości';es_ES = 'En la lista de valores de la operación ""%1"" no se ha indicado ningún valor';es_CO = 'En la lista de valores de la operación ""%1"" no se ha indicado ningún valor';tr = '""%1"" İşlem değerleri listesinde herhangi bir değer belirtilmedi';it = 'Nessun valore indicato nell''elenco valori dell''operazione ""%1""';de = 'In der Werteliste der Operation ""%1"" ist kein Wert angegeben'"), Row.Chars), True);
					EndIf;
				EndIf;
			Else
				Row.Rows = New Array;
				If Row.Type = "Function" Then
					SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'После функции ""%1"" не указаны параметры в скобках'; en = 'Parameters in parentheses are not specified after the ""%1"" function'; pl = 'Po funkcji ""%1"" nie podano parametry w nawiasach';es_ES = 'Después de la función ""%1"" no se han indicado parámetros en paréntesis';es_CO = 'Después de la función ""%1"" no se han indicado parámetros en paréntesis';tr = '""%1"" İşlevinden sonra parantez içindeki parametreler belirtilmedi';it = 'I parametri in parentesi non sono indicati dopo la funzione ""%1""';de = 'Parameter in Klammern werden nach der Funktion ""%1"" nicht angegeben'"), Row.Chars), True);
				Else
					SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'После ключевого слова ""%1"" не указаны значения в скобках'; en = 'Values in parentheses are not specified after the ""%1"" keyword'; pl = 'Po słowie kluczowym ""%1"" nie podano wartości w nawiasach';es_ES = 'Después de la palabra clave ""%1"" no se han indicado valores en paréntesis';es_CO = 'Después de la palabra clave ""%1"" no se han indicado valores en paréntesis';tr = '""%1"" anahtar kelimesinden sonra parantez içindeki değerler belirtilmedi';it = 'I valori in parentesi non sono indicati dopo la parola chiave ""%1""';de = 'Nach dem Schlüsselwort ""%1"" werden die Werte in Klammern nicht angegeben'"), Row.Chars), True);
				EndIf;
			EndIf;
			
		ElsIf Row.Kind = "Keyword"
		        AND Row.Clarification = "Is"  Then
			
			If Index + 1 < Rows.Count()
			   AND Rows[Index + 1].Kind = "Keyword"
			   AND Rows[Index + 1].Clarification = "Null" Then
				
				Index = Index + 1;
				Row.Rows.Add(Rows[Index]);
			Else
				Row.Rows = New Array;
				SetErrorInRow(Row, InsertKeywordsIntoString(InternalData,
						NStr("ru = 'После ключевого слова ""%2"" не указано ключевое слово ""%1""'; en = 'Keyword ""%1"" is not specified after keyword ""%2""'; pl = 'Po słowie kluczowym ""%2"" nie określono słowo kluczowe ""%1""';es_ES = 'Después de la palabra clave ""%2"" no se ha indicado una palabra clave ""%1""';es_CO = 'Después de la palabra clave ""%2"" no se ha indicado una palabra clave ""%1""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelime belirtilmedi';it = 'La keyword ""%1"" non è specificata dopo la keyword ""%2""';de = 'Nach dem Schlüsselwort ""%2"" wird das Schlüsselwort ""%1"" nicht angegeben'"),
						"Null",
						Row.Chars),
					True);
			EndIf;
			
		ElsIf Row.Kind = "Name"
		        AND StrStartsWith(Row.Chars, ".")
		        AND PreviousString <> Undefined Then
			
			If PreviousString <> Undefined
			   AND PreviousString.Kind = "Keyword"
			   AND PreviousString.Clarification = "Cast" Then
				
				Row.Type = "AdditionToExpress";
				PreviousString.Rows.Add(Row);
				Index = Index + 1;
				Continue;
			Else
				SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Имя поля не может начинаться с символа "".""'; en = 'Field name cannot start with a period (""."")'; pl = 'Nazwa pola nie może zaczynać się od znaku (""."")';es_ES = 'El nombre del campo no puede empezarse con el símbolo "".""';es_CO = 'El nombre del campo no puede empezarse con el símbolo "".""';tr = 'Alan adı nokta (""."") ile başlayamaz';it = 'Il nome del campo non èuò cominciare con un carattere periodo (""."")';de = 'Der Feldname darf nicht mit dem Symbol ""."" beginnen'"), Row.Chars));
			EndIf;
		EndIf;
		
		Result.Add(Row);
		Index = Index + 1;
	EndDo;
	
	Return Result;
	
EndFunction

// For the ExpressionsInParenthesesInAttachments and ExpressionsWhenThenSelectionInAttachments functions.
Procedure AddAttachment(Row, Attachments, CurrentAttachment)
	
	CurrentAttachment.Rows.Add(Row);
	CurrentAttachment = Row;
	Attachments.Add(CurrentAttachment);
	
EndProcedure

// For the ExpressionsInParenthesesInAttachments and ExpressionsWhenThenSelectionInAttachments functions.
Procedure DeleteLastAttachment(Attachments, CurrentAttachment, EndString = Undefined)
	
	If EndString = Undefined Then
		If CurrentAttachment.Rows.Count() = 0 Then
			EndString = CurrentAttachment;
		Else
			EndString = CurrentAttachment.Rows[CurrentAttachment.Rows.Count() - 1];
			If EndString.EndString <> Undefined Then
				EndString = EndString.EndString;
			EndIf;
		EndIf;
	EndIf;
	
	CurrentAttachment.EndString = EndString;
	
	LastAttachmentIndex = Attachments.Count() - 1;
	Attachments.Delete(LastAttachmentIndex);
	CurrentAttachment = Attachments[LastAttachmentIndex - 1];
	
EndProcedure

// For the ExpressionsWhenThenSelectionInAttachments function.
Procedure RestoreChoiceStructure(Row, Attachments, CurrentAttachment, MissingWordsList, Context)
	
	MissingWords = StrSplit(MissingWordsList, ",", False);
	
	For Each MissingWord In MissingWords Do
		NewRow = AdditionalString(Row, MissingWord, Context);
		CurrentAttachment.Rows.Add(NewRow);
		
		If MissingWord = "Case" Then
			CurrentAttachment = NewRow;
			Attachments.Add(CurrentAttachment);
		EndIf;
	EndDo;
	
	If MissingWord <> "Case" Then
		CurrentAttachment = NewRow;
		Attachments.Add(CurrentAttachment);
	EndIf;
	
EndProcedure

// For the ProcessMissingLogicalOperation, ExpressionsWhenThenSelectionInAttachments,
// RestoreChoiceStructure procedures, and the CommaSeparatedParameters function.
//
Function AdditionalString(Row, Clarification = "", Context = Undefined)
	
	Fields = "Chars, Kind, Type, Priority, Clarification, InitialString, Rows, EndString, ErrorPosition, ErrorText";
	
	NewRow = New Structure(Fields);
	NewRow.Clarification      = Clarification;
	NewRow.Rows         = New Array;
	NewRow.InitialString = Row;
	
	WordProperties = ?(Context = Undefined,
		Undefined, Context.LanguageSyntax.LanguageWords.Get(Upper(Clarification)));
	
	If WordProperties <> Undefined Then
		NewRow.Kind       = "Keyword";
		NewRow.Type       = WordProperties.Type;
		NewRow.Priority = WordProperties.Priority;
	EndIf;
	
	Return NewRow;
	
EndFunction

// For the ParseAdditionalTables and ParseRestrictionCondition procedures.
Procedure ChangeKeywordTypeListToName(PartRows, RowToExclude = Undefined)
	
	For Each Row In PartRows Do
		If Row = RowToExclude
		 Or Row.Kind <> "Keyword"
		 Or Row.Clarification <> "ThisList" Then
			Continue;
		EndIf;
		Row.Kind = "Name";
		Row.Clarification = "";
	EndDo;
	
EndProcedure

// For the ParseAdditionalTables and ParseCondition procedures.
Procedure SetAlias(PartRow, ConnectionDetails, InternalData)
	
	If ValueIsFilled(PartRow.ErrorText) Then
		Return;
	EndIf;
	
	PointPosition = StrFind(PartRow.Chars, ".");
	If PointPosition > 0 Then
		PartRow.ErrorPosition = PointPosition - 1;
		PartRow.ErrorText =
			NStr("ru = 'Псевдоним не может содержать символа "".""'; en = 'Alias cannot contain a period (""."")'; pl = 'Alias nie może zawierać okresu (""."")';es_ES = 'El alias no puede contener el símbolo "".""';es_CO = 'El alias no puede contener el símbolo "".""';tr = 'Takma ad ""."" karakterini içeremez';it = 'L''alias non può contenere il carattere speciale ""(."")';de = 'Der Alias darf nicht das Symbol ""."" enthalten'");
			
	ElsIf TypeOf(ConnectionDetails) = Type("String") Then
		ConnectionDetails = PartRow.Chars;
		InternalData.Aliases.Insert(Upper(PartRow.Chars), "");
	Else
		ConnectionDetails.Alias = PartRow.Chars;
		If InternalData.Aliases.Get(Upper(PartRow.Chars)) = Undefined Then
			If ValueIsFilled(ConnectionDetails.Table) Then
				InternalData.Aliases.Insert(Upper(PartRow.Chars), ConnectionDetails.Table);
			EndIf;
		Else
			PartRow.ErrorText = NStr("ru = 'Псевдоним повторяется'; en = 'Alias is repeated'; pl = 'Alias powtarza się';es_ES = 'Alias se repite';es_CO = 'Alias se repite';tr = 'Takma ad tekrarlandı';it = 'Alias è ripetuto';de = 'Das Pseudonym wiederholt sich'");
		EndIf;
	EndIf;
	
EndProcedure

// For the ParseConnection procedure.
Procedure SetTableName(PartRow, ConnectionDetails, InternalData)
	
	If ValueIsFilled(PartRow.ErrorText) Then
		Return;
	EndIf;
	
	If StrStartsWith(PartRow.Chars, ".") Then
		PartRow.ErrorText =
			NStr("ru = 'Имя таблицы не может начинаться с символа "".""'; en = 'Table name cannot start with a period "".""'; pl = 'Nazwa tabeli nie może zaczynać się od znaku "".""';es_ES = 'El nombre de la tabla no puede empezarse con el símbolo "".""';es_CO = 'El nombre de la tabla no puede empezarse con el símbolo "".""';tr = 'Tablo adı ""."" karakteriyle başlayamaz';it = 'Il nome tabella non può cominciare con un carattere periodo "".""';de = 'Der Tabellenname darf nicht mit dem Symbol ""."" beginnen'");
		Return;
	EndIf;
	
	If StrOccurrenceCount(PartRow.Chars, ".") > 2 Then
		
		PointPosition = StrFind(PartRow.Chars, ".");
		PointPosition = PointPosition + StrFind(Mid(PartRow.Chars, PointPosition + 1), ".");
		
		PointPosition = PointPosition + StrFind(Mid(PartRow.Chars, PointPosition + 1), ".");
		PartRow.ErrorText =
			NStr("ru = 'Полное имя таблицы не может содержать более двух символов "".""'; en = 'Full table name cannot contain more than two periods (""."")'; pl = 'Pełna nazwa tabeli nie może zawierać więcej niż dwóch znaków "".""';es_ES = 'El nombre completo de la tabla no puede contener más de dos símbolos "".""';es_CO = 'El nombre completo de la tabla no puede contener más de dos símbolos "".""';tr = 'Tablonun tam adı ikiden fazla ""."" karakter içeremez';it = 'Il nome della tabella completo non può contenere più di due caratteri (""."")';de = 'Der vollständige Name der Tabelle darf nicht mehr als zwei Symbole ""."" enthalten'");
		
		PartRow.ErrorPosition = PointPosition - 1;
		Return;
	EndIf;
	
	ConnectionDetails.Table = PartRow.Chars;
	
	AddRequiredTableAsDataSource(InternalData, ConnectionDetails.Table, PartRow);
	
EndProcedure

// For the SetTableName procedure.
Procedure AddRequiredTableAsDataSource(Context, Table, Source)
	
	If ValueIsFilled(Source.ErrorText) Then
		Return;
	EndIf;
	
	NameProperties = TableNameProperties(Context, Table);
	
	If NameProperties.NamePartsCount < 2
	 Or NameProperties.NamePartsCount > 3 Then
		SetErrorInRow(Source,
			NStr("ru = 'В имени присоединяемой таблицы должна быть одна или две точки'; en = 'Attached table name must contain one or two periods'; pl = 'W imieniu dodawanej tabeli musi być jedna lub dwie kropki';es_ES = 'En el nombre de la tabla adjunta debe haber uno o dos puntos';es_CO = 'En el nombre de la tabla adjunta debe haber uno o dos puntos';tr = 'Ekli tablo adında bir veya iki nokta olmalıdır';it = 'Il nome tabella allegata deve contenere uno o due punti';de = 'Der Name der zu verbindenden Tabelle muss einen oder zwei Punkte enthalten'"));
		Return;
	EndIf;
	
	If NameProperties.TablesTypeProperties = Undefined Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Некорректное начало ""%1"" имени таблицы ""%2""'; en = 'Incorrect beginning ""%1"" of the ""%2"" table name'; pl = 'Nieprawidłowy początek ""%1"" nazwy tabeli ""%2""';es_ES = 'Inicio incorrecto ""%1"" del nombre de la tabla ""%2""';es_CO = 'Inicio incorrecto ""%1"" del nombre de la tabla ""%2""';tr = '""%1"" tablo adının ""%2"" başlangıcı yanlış';it = 'Inizio non corretto ""%1""del nome tabella ""%2""';de = 'Falscher Anfang von ""%1"" Tabellenname ""%2""'"), NameProperties.TypeName, Table));
		Return;
	EndIf;
	
	If NameProperties.NamePartsCount = 3 Then
		ClarificationProperties = NameProperties.TablesTypeProperties.TablesClarification.Get(
			Upper(NameProperties.Extension));
		
		If ClarificationProperties <> Undefined
		   AND ClarificationProperties.Use <> "Allowed" Then
			
			If ClarificationProperties.Use = "Illegal" Then
				SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Недопустимо использовать таблицы ""%1"" группы таблиц ""%2""'; en = 'Cannot use tables ""%1"" of the ""%2"" table group'; pl = 'Niedopuszczalne jest stosowanie tabeli ""%1"" grupy tabel ""%2""';es_ES = 'No se admite usar las tablas ""%1"" del grupo de tablas ""%2""';es_CO = 'No se admite usar las tablas ""%1"" del grupo de tablas ""%2""';tr = '""%1"" tablo grubunun ""%2"" tabloları kullanılamaz';it = 'Impossibile utilizzare le tabelle ""%1"" del gruppo tabelle ""%2""';de = 'Verwenden Sie keine Tabellen ""%1"" der Tabellengruppen ""%2""'"),
					NameProperties.Extension, NameProperties.TypeName));
			Else
				SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Запрещено присоединять таблицы ""%1"" группы таблиц ""%2""'; en = 'Cannot attach tables ""%1"" of the ""%2"" table group'; pl = 'Zabronione jest dołączanie tabeli ""%1"" grupy tabel ""%2""';es_ES = 'No se admite adjuntar las tablas ""%1"" del grupo de tablas ""%2""';es_CO = 'No se admite adjuntar las tablas ""%1"" del grupo de tablas ""%2""';tr = '""%1"" tablo grubunun ""%2"" tabloları eklenemez';it = 'Impossibile allegare tabelle ""%1"" del gruppo tabelle ""%2""';de = 'Es ist verboten, Tabellen ""%1"" der Tischgruppe ""%2"" anzuhängen'"),
					NameProperties.Extension, NameProperties.TypeName));
			EndIf;
			Return;
		EndIf;
	EndIf;
	
	Properties = RequiredTableProperties(Context, NameProperties);
	Properties.Sources.Add(Source);
	
EndProcedure

// For the SelectFieldAlias, ParseFirstCheckingFunctionParameter,
// ParseAdditionalCheckingFunctionParameter, and ParseValueFunctionOrTypeFunctionParameters procedures.
//
Procedure AddRequiredTableAsReferenceType(Context, Table, Source)
	
	If ValueIsFilled(Source.ErrorText) Then
		Return;
	EndIf;
	
	NameProperties = TableNameProperties(Context, Table);
	
	If NameProperties.NamePartsCount <> 2 Then
		SetErrorInRow(Source,
			NStr("ru = 'В имени таблицы, указанной в качестве типа, должна быть одна точка'; en = 'Table name specified as a type must contain a period'; pl = 'W nazwie tabeli, podanej jako typ, musi być jedna kropka';es_ES = 'En el nombre de la tabla indicada como el tipo debe haber un punto';es_CO = 'En el nombre de la tabla indicada como el tipo debe haber un punto';tr = 'Bir tür olarak belirtilen tablo adında tek bir nokta olmalıdır';it = 'Il nome tabella indicato come tipo deve contenere un punto';de = 'Der als Typ angegebene Tabellenname muss einen Punkt haben'"));
		Return;
	EndIf;
	
	If NameProperties.TablesTypeProperties = Undefined Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Некорректное начало ""%1"" имени таблицы ""%2""'; en = 'Incorrect beginning ""%1"" of the ""%2"" table name'; pl = 'Nieprawidłowy początek ""%1"" nazwy tabeli ""%2""';es_ES = 'Inicio incorrecto ""%1"" del nombre de la tabla ""%2""';es_CO = 'Inicio incorrecto ""%1"" del nombre de la tabla ""%2""';tr = '""%1"" tablo adının ""%2"" başlangıcı yanlış';it = 'Inizio non corretto ""%1""del nome tabella ""%2""';de = 'Falscher Anfang von ""%1"" Tabellenname ""%2""'"), NameProperties.TypeName, Table));
		Return;
	EndIf;
	
	If Not NameProperties.TablesTypeProperties.IsReferenceType Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Группа таблиц ""%1"" не входит в состав ссылочных типов'; en = '""%1"" table group is not included in reference types'; pl = 'Grupa tabel ""%1"" nie wchodzi w skład typów odwołań';es_ES = 'Grupo de tablas ""%1"" no forma parte de los tipos de enlace';es_CO = 'Grupo de tablas ""%1"" no forma parte de los tipos de enlace';tr = '""%1"" tablo grubu referans türlerin kapsamına girmez';it = '""%1"" gruppo tabella non è incluso nelle tipologie di riferimento';de = 'Die Tabellengruppe ""%1"" ist nicht Bestandteil von Referenztypen'"), NameProperties.TypeName, Table));
		Return;
	EndIf;
	
	Properties = RequiredTableProperties(Context, NameProperties);
	Properties.Sources.Add(Source);
	
EndProcedure

// For the ParseValueFunctionOrTypeFunctionParameters procedure.
Procedure AddRequiredPredefinedItem(Context, FullPredefinedItemName, Source)
	
	If ValueIsFilled(Source.ErrorText) Then
		Return;
	EndIf;
	
	NameProperties = TableNameProperties(Context, FullPredefinedItemName);
	
	If NameProperties.NamePartsCount <> 3 Then
		SetErrorInRow(Source,
			NStr("ru = 'В имени предопределенного значения должно быть две точки'; en = 'Predefined value name must contain two periods'; pl = 'W imieniu zadanej wartości powinny być dwie kropki';es_ES = 'En el nombre del valor predeterminado debe haber dos puntos';es_CO = 'En el nombre del valor predeterminado debe haber dos puntos';tr = 'Önceden belirlenmiş değerin adından iki nokta olmalıdır';it = 'Il nome valore predefinito deve contenere due punti';de = 'Der Name eines vordefinierten Werts muss zwei Punkte enthalten'"));
		Return;
	EndIf;
	
	If NameProperties.TablesTypeProperties = Undefined Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Некорректное начало ""%1"" имени таблицы ""%2""'; en = 'Incorrect beginning ""%1"" of the ""%2"" table name'; pl = 'Nieprawidłowy początek ""%1"" nazwy tabeli ""%2""';es_ES = 'Inicio incorrecto ""%1"" del nombre de la tabla ""%2""';es_CO = 'Inicio incorrecto ""%1"" del nombre de la tabla ""%2""';tr = '""%1"" tablo adının ""%2"" başlangıcı yanlış';it = 'Inizio non corretto ""%1""del nome tabella ""%2""';de = 'Falscher Anfang von ""%1"" Tabellenname ""%2""'"),
			NameProperties.TypeName,
			NameProperties.TypeName + "." + NameProperties.NameWithoutType));
		Return;
	EndIf;
	
	If Not NameProperties.TablesTypeProperties.IsReferenceType Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Группа таблиц ""%1"" не входит в состав ссылочных типов'; en = '""%1"" table group is not included in reference types'; pl = 'Grupa tabel ""%1"" nie wchodzi w skład typów odwołań';es_ES = 'Grupo de tablas ""%1"" no forma parte de los tipos de enlace';es_CO = 'Grupo de tablas ""%1"" no forma parte de los tipos de enlace';tr = '""%1"" tablo grubu referans türlerin kapsamına girmez';it = '""%1"" gruppo tabella non è incluso nelle tipologie di riferimento';de = 'Die Tabellengruppe ""%1"" ist nicht Bestandteil von Referenztypen'"), NameProperties.TypeName));
		Return;
	EndIf;
	
	WordProperties = Context.LanguageSyntax.LanguageWords.Get(Upper(NameProperties.Extension));
	
	If Not NameProperties.TablesTypeProperties.HasPredefined
	   AND Not NameProperties.TypeName = "Enum"
	   AND (    WordProperties = Undefined
	      Or WordProperties.ID <> "EmptyRef") Then
		
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В группе таблиц ""%1"" нет предопределенных элементов'; en = 'There are no predefined items in the ""%1"" table group'; pl = 'W grupie tabel ""%1"" nie ma gotowych elementów';es_ES = 'En el grupo de tablas ""%1"" no hay elementos predeterminados';es_CO = 'En el grupo de tablas ""%1"" no hay elementos predeterminados';tr = '""%1"" tablo grubunda önceden tanımlanmış unsurlar yok';it = 'Non ci sono elementi predefiniti nel gruppo tabella ""%1""';de = 'Die Tabellengruppe ""%1"" enthält keine vordefinierten Elemente'"), NameProperties.TypeName));
		Return;
	EndIf;
	
	Properties = RequiredTableProperties(Context, NameProperties, True);
	
	PredefinedOptionProperties = Properties.Predefined.Get(Upper(NameProperties.Extension));
	If PredefinedOptionProperties = Undefined Then
		PredefinedOptionProperties = New Structure;
		PredefinedOptionProperties.Insert("NameExists", False);
		PredefinedOptionProperties.Insert("Sources", New Array);
		Properties.Predefined.Insert(Upper(NameProperties.Extension), PredefinedOptionProperties);
	EndIf;
	PredefinedOptionProperties.Sources.Add(Source);
	
EndProcedure

// For the MarkIncorrectArgumentsAndProhibitedNodes, SelectFieldAlias,
// and AddUsersAndExternalUsersAccessKindsTypesToCheckAbsence procedures.
//
Procedure AddRequiredTableField(Context, Table, FieldName, Source,
			FieldType = "", FieldTypeSource = Undefined, FieldNode = Undefined)
	
	If ValueIsFilled(Source.ErrorText) Then
		Return;
	EndIf;
	
	NameProperties = TableNameProperties(Context, Table);
	If NameProperties.TablesTypeProperties = Undefined Then
		
		If NameProperties.IsMainTable
		   AND Not Context.Property("ErrorSetToFirstFieldInMainTable") Then
			
			Context.Insert("ErrorSetToFirstFieldInMainTable");
			SetErrorInFieldNameString(Context, Source,
				NStr("ru = 'Поле не найдено, так как не найдена таблица ""%1""'; en = 'Field is not found as the ""%1"" table is not found'; pl = 'Nie znaleziono pola, ponieważ nie znaleziono tabeli ""%1""';es_ES = 'Campo no encontrado, porque la tabla no se ha encontrado ""%1""';es_CO = 'Campo no encontrado, porque la tabla no se ha encontrado ""%1""';tr = '""%1"" tablo bulunmadığından dolayı alan bulunamadı';it = 'Il campo non è stato trovato dato che la tabella""%1"" non è stata trovata';de = 'Das Feld wurde nicht gefunden, weil die Tabelle ""%1"" nicht gefunden wurde'"), 0, ,
				Context.MainTable);
		EndIf;
		
		Return;
	EndIf;
	
	Properties = RequiredTableProperties(Context, NameProperties);
	
	FieldProperties = Properties.Fields.Get(Upper(FieldName));
	If FieldProperties = Undefined Then
		FieldProperties = New Structure;
		FieldProperties.Insert("FieldWithError", 0);
		FieldProperties.Insert("ErrorKind",    "");
		FieldProperties.Insert("Collection",    "");
		FieldProperties.Insert("ContainsTypes", New Map);
		FieldProperties.Insert("Sources",    New Map);
		FieldProperties.Insert("FieldNodes",     New Array);
		Properties.Fields.Insert(Upper(FieldName), FieldProperties);
		
		If Properties.Property("FirstField")
		   AND Properties.FirstField = Undefined
		   AND Source <> Undefined Then
			
			FieldProperties.Insert("FirstSource", New Structure("Key,Value", Source, Table));
			Properties.FirstField = FieldProperties;
		EndIf;
	EndIf;
	FieldProperties.Sources.Insert(Source, Table);
	If FieldNode <> Undefined Then
		FieldProperties.FieldNodes.Add(FieldNode);
	EndIf;
	
	If Not ValueIsFilled(FieldType) Then
		Return;
	EndIf;
	
	If TypeOf(FieldTypeSource) = Type("ValueTableRow")
	   AND ValueIsFilled(FieldTypeSource.ErrorText) Then
		Return;
	EndIf;
	
	TypeProperties = FieldProperties.ContainsTypes.Get(Upper(FieldType));
	If TypeProperties = Undefined Then
		NameContent = StrSplit(FieldType, ".");
		TablesTypeProperties = Context.LanguageSyntax.TablesTypes.ByNames.Get(Upper(NameContent[0]));
		If TablesTypeProperties = Undefined Then
			TypeName = FieldType;
			TypeCollectionName = "";
			TypeCollectionObjectName = "";
		Else
			TypeName = TablesTypeProperties.LanguageRussian + "Ref." + NameContent[1];
			TypeCollectionName = TablesTypeProperties.CollectionName;
			TypeCollectionObjectName = NameContent[1];
		EndIf;
		TypeProperties = New Structure;
		TypeProperties.Insert("ContainsType", False);
		TypeProperties.Insert("TypeName", TypeName);
		TypeProperties.Insert("TypeCollectionName", TypeCollectionName);
		TypeProperties.Insert("TypeCollectionObjectName", TypeCollectionObjectName);
		TypeProperties.Insert("Sources", New Map);
		FieldProperties.ContainsTypes.Insert(Upper(FieldType), TypeProperties);
	EndIf;
	TypeProperties.Sources.Insert(FieldTypeSource, Source);
	
EndProcedure

// For the AddRequiredTableAsDataSource, AddRequiredTableAsReferenceType,
// AddRequiredPredefinedItem, and AddRequiredTableField procedures.
//
Function TableNameProperties(Context, FullName)
	
	If ValueIsFilled(FullName) Then
		Table = FullName;
	Else
		Table = Context.MainTable;
	EndIf;
	
	NameContent = StrSplit(Table, ".", False);
	
	Properties = New Structure;
	Properties.Insert("NamePartsCount", NameContent.Count());
	Properties.Insert("TypeName",    NameContent[0]);
	Properties.Insert("NameWithoutType", ?(NameContent.Count() > 1, NameContent[1], Undefined));
	Properties.Insert("Extension", ?(NameContent.Count() = 3, NameContent[2], Undefined));
	Properties.Insert("IsMainTable", Upper(Table) = Upper(Context.MainTable));
	Properties.Insert("TablesTypeProperties",
		Context.LanguageSyntax.TablesTypes.ByNames.Get(Upper(NameContent[0])));
	
	Return Properties;
	
EndFunction

// For the AddRequiredTableAsDataSource, AddRequiredTableAsReferenceType,
// AddRequiredPredefinedItem, and AddRequiredTableField procedures.
//
Function RequiredTableProperties(Context, NameProperties, WithoutExtension = False)
	
	CollectionName = NameProperties.TablesTypeProperties.CollectionName;
	
	CollectionProperties = Context.TablesFields.Get(CollectionName);
	If CollectionProperties = Undefined Then
		CollectionProperties = New Map;
		Context.TablesFields.Insert(CollectionName, CollectionProperties);
	EndIf;
	
	Properties = CollectionProperties.Get(Upper(NameProperties.NameWithoutType));
	If Properties = Undefined Then
		Properties = New Structure;
		Properties.Insert("TableExists", False);
		Properties.Insert("Sources",         New Array);
		Properties.Insert("Fields",              New Map);
		Properties.Insert("Predefined",  New Map);
		Properties.Insert("Extensions",        New Map);
		If NameProperties.IsMainTable AND NameProperties.Extension = Undefined Then
			Properties.Insert("FirstField");
		EndIf;
		CollectionProperties.Insert(Upper(NameProperties.NameWithoutType), Properties);
	EndIf;
	
	If NameProperties.Extension = Undefined Or WithoutExtension Then
		Return Properties;
	EndIf;
	
	ExtensionProperties = Properties.Extensions.Get(Upper(NameProperties.Extension));
	If ExtensionProperties = Undefined Then
		ExtensionProperties = New Structure;
		ExtensionProperties.Insert("TableExists", False);
		ExtensionProperties.Insert("Sources",         New Array);
		ExtensionProperties.Insert("Fields",              New Map);
		If NameProperties.IsMainTable Then
			ExtensionProperties.Insert("FirstField");
		EndIf;
		Properties.Extensions.Insert(Upper(NameProperties.Extension), ExtensionProperties);
	EndIf;
	
	Return ExtensionProperties;
	
EndFunction

// For the RestrictionParts, ParseAdditionalTables, ParseConnection,
// ParseRestrictionCondition, and ExpressionsWhenThenSelectionInAttachments procedures and functions.
Function InsertKeywordsIntoString(Context, Row, WordsList, ParameterOne = "", ParameterTwo = "", ParameterThree = "")
	
	Words = StrSplit(WordsList, ",", False);
	WordsToInsert = New Map;
	
	For Each Word In Words Do
		WordsToInsert.Insert(Words.Find(Word),
			KeywordRegardingLanguage(TrimAll(Word), Context));
	EndDo;
	
	Index = WordsToInsert.Count();
	WordsToInsert.Insert(Index,     ParameterOne);
	WordsToInsert.Insert(Index + 1, ParameterTwo);
	WordsToInsert.Insert(Index + 2, ParameterThree);
	
	Return StringFunctionsClientServer.SubstituteParametersToString(Row,
		WordsToInsert[0], WordsToInsert[1], WordsToInsert[2],
		WordsToInsert[3], WordsToInsert[4], WordsToInsert[5],
		WordsToInsert[6], WordsToInsert[7], WordsToInsert[8]);
	
EndFunction

// For the ParseAdditionalTables, ParseConnection, and ParseRestrictionCondition procedures.
Function KeywordRegardingLanguage(WordID, Context)
	
	WordProperties = Context.LanguageSyntax.LanguageWords.Get(Upper(WordID));
	
	If ScriptVariantRussian() Then
		Word = WordProperties.LanguageRussian;
	Else
		Word = WordProperties.LanguageEnglish;
	EndIf;
	
	If WordProperties.Uppercase Then
		Word = Upper(Word);
	EndIf;
	
	Return Word;
	
EndFunction

// For the AllowedTemplatesDetails and KeywordRegardingLanguage functions.
Function ScriptVariantRussian()
	
	Return Metadata.ScriptVariant = Metadata.ObjectProperties.ScriptVariant.Russian;
	
EndFunction

#EndRegion

#Region TablesNamesAndTablesFieldsAnalysis

// Checking tables, table fields, and field types found when parsing the restriction text.
// The same procedure is implemented in ASDS.
//
// Parameters:
//  ParsedRestriction - Structure - returned by the ParsedRestriction function.
//
Procedure CheckFieldTablesAndFieldsTypes(ParsedRestriction)
	
	Context = New Structure;
	Context.Insert("TablesTypes", AccessManagementInternalCached.LanguageSyntax().TablesTypes);
	
	For Each TablesType In ParsedRestriction.TablesFields Do
		TablesCollection = Metadata[TablesType.Key];
		
		For Each TableFields In TablesType.Value Do
			
			TableMetadata = TablesCollection.Find(TableFields.Key);
			If TableMetadata = Undefined Then
				Continue;
			EndIf;
			TableFields.Value.TableExists = True;
			
			Context.Insert("TableMetadata",  TableMetadata);
			Context.Insert("TablesTypeProperties", Context.TablesTypes.ByCollections.Get(TablesType.Key));
			
			For Each TableField In TableFields.Value.Fields Do
				FieldDetails = New Structure;
				FieldDetails.Insert("NameContent", StrSplit(TableField.Key, "."));
				FieldDetails.Insert("Properties",    TableField.Value);
				FieldDetails.Insert("FieldType",     New TypeDescription);
				CheckTableField(FieldDetails, Context);
				If FieldDetails.Properties.FieldWithError = 0 Then
					CheckFieldTypes(FieldDetails, Context);
				EndIf;
			EndDo;
			
			CheckTableExtensions(TableFields, Context);
			CheckPredefinedTableValues(TableFields, Context);
		EndDo;
	EndDo;
	
EndProcedure

// For the CheckFieldTablesAndFieldsTypes and CheckNextPointSeparatedField procedures.
Procedure CheckTableField(FieldDetails, Context, Index = 0, InitialCall = True)
	
	NameContent  = FieldDetails.NameContent;
	FieldProperties = FieldDetails.Properties;
	
	FieldClarification = Context.TablesTypeProperties.FieldsClarification.Get(Upper(NameContent[Index]));
	
	If FieldClarification <> Undefined
	   AND FieldClarification.Use <> "Allowed" Then
		
		FieldProperties.FieldWithError = Index + 1;
		FieldProperties.ErrorKind = FieldClarification;
		Return;
	EndIf;
	
	Properties = FieldOrTabularSectionProperties(NameContent[Index], Context, Index = 0);
	If Properties = Undefined Then
		FieldProperties.FieldWithError = Index + 1;
		FieldProperties.ErrorKind = "NotFound";
		Return;
	EndIf;
	If Index = 0 Then
		FieldProperties.Collection = Properties.Collection;
	EndIf;
	
	If Properties.IsTabularSection Then
		If Index > 0 Then
			FieldProperties.FieldWithError = Index + 1;
			FieldProperties.ErrorKind = "TabularSectionAfterDot";
			Return;
		EndIf;
		If Index + 1 = NameContent.Count() Then
			FieldProperties.FieldWithError = Index + 1;
			FieldProperties.ErrorKind = "TabularSectionNoField";
			Return;
		EndIf;
		Index = Index + 1;
		Properties = TabularSectionFieldProperties(NameContent[Index],
			Properties.Metadata, Properties.Collection, Context.TableMetadata);
		If Properties = Undefined Then
			FieldProperties.FieldWithError = Index + 1;
			FieldProperties.ErrorKind = "NotFound";
			Return;
		EndIf;
	EndIf;
	
	CheckNextPointSeparatedField(FieldDetails, Index, Properties, Context);
	
	If InitialCall Then
		FillFieldTypesAsStringAdditional(FieldDetails);
	EndIf;
	
EndProcedure

// For the CheckTableField and CheckTableExtensions procedures.
Procedure CheckNextPointSeparatedField(FieldDetails, Index, CurrentFieldProperties, Context)
	
	AddFieldTypesAdditional(FieldDetails, Index, CurrentFieldProperties, Context);
	
	Index = Index + 1;
	If Index = FieldDetails.NameContent.Count() Then
		FieldDetails.FieldType = New TypeDescription(FieldDetails.FieldType, CurrentFieldProperties.Type.Types());
		Return;
	EndIf;
	
	FieldProperties = FieldDetails.Properties;
	FieldFound = False;
	
	If FieldDetails.Property("NextFieldTables") Then
		// See the AddFieldTypesAdditional procedure.
		If FieldDetails.NextFieldTables.Count() < Index + 1 Then
			NextFieldTables = New Array;
			FieldDetails.NextFieldTables.Add(NextFieldTables);
		Else
			NextFieldTables = FieldDetails.NextFieldTables[Index];
		EndIf;
	EndIf;
	
	For Each Type In CurrentFieldProperties.Type.Types() Do
		If Not Common.IsReference(Type) Then
			Continue;
		EndIf;
		FieldProperties.FieldWithError = 0;
		FieldProperties.ErrorKind = "";
		
		// Saving the current context.
		CurrentTableMetadata  = Context.TableMetadata;
		CurrentTablesTypeProperties = Context.TablesTypeProperties;
		
		Context.TableMetadata = Metadata.FindByType(Type);
		FullName = Context.TableMetadata.FullName();
		FullNameContent = StrSplit(FullName, ".", False);
		Context.TablesTypeProperties = Context.TablesTypes.ByNames.Get(Upper(FullNameContent[0]));
		
		CurrentIndex = Index;
		CheckTableField(FieldDetails, Context, CurrentIndex, False);
		
		// Restoring the current context.
		Context.TableMetadata  = CurrentTableMetadata;
		Context.TablesTypeProperties = CurrentTablesTypeProperties;
		
		If FieldProperties.FieldWithError = 0 Then
			FieldFound = True;
			If NextFieldTables <> Undefined Then
				// See the AddFieldTypesAdditional procedure.
				NextFieldTables.Add(FullName);
			EndIf;
		ElsIf FieldProperties.ErrorKind <> "NotFound" Then
			Return;
		EndIf;
	EndDo;
	
	If FieldFound Then
		FieldProperties.FieldWithError = 0;
		FieldProperties.ErrorKind = "";
	EndIf;
	
EndProcedure

// For the CheckTableField procedure.
Function FieldOrTabularSectionProperties(FieldOrTabularSectionName, Context, IsFirstField)
	
	Result = New Structure;
	Result.Insert("IsTabularSection", False);
	Result.Insert("Collection");
	Result.Insert("Metadata");
	Result.Insert("Type");
	
	TableMetadata  = Context.TableMetadata;
	TablesTypeProperties = Context.TablesTypeProperties;
	
	For Each TabularSectionsCollection In TablesTypeProperties.TabularPartCollections Do
		If TabularSectionsCollection.Key = "StandardTabularSections" Then
			For Each StandardTabularSection In TableMetadata.StandardTabularSections Do
				If Upper(FieldOrTabularSectionName) = Upper(StandardTabularSection.Name) Then
					Result.Metadata = StandardTabularSection;
					Break;
				EndIf;
			EndDo;
		Else
			Result.Metadata = TableMetadata[TabularSectionsCollection.Key].Find(FieldOrTabularSectionName);
		EndIf;
		If Result.Metadata <> Undefined Then
			Result.IsTabularSection = True;
			Result.Collection = TabularSectionsCollection.Key;
			Return Result;
		EndIf;
	EndDo;
	
	For Each FieldsCollection In TablesTypeProperties.FieldCollections Do
		If FieldsCollection.Key = "StandardAttributes" Then
			Number = 0;
			For Each StandardAttribute In TableMetadata.StandardAttributes Do
				Number = Number + 1;
				If Upper(FieldOrTabularSectionName) = Upper(StandardAttribute.Name) Then
					Result.Metadata = StandardAttribute;
					Break;
				EndIf;
			EndDo;
		Else
			Result.Metadata = TableMetadata[FieldsCollection.Key].Find(FieldOrTabularSectionName);
		EndIf;
		If Result.Metadata <> Undefined Then
			Result.Collection = FieldsCollection.Key;
			If Result.Collection = "Columns" Then
				Result.Type = New TypeDescription;
				For Each RefMetadata In Result.Metadata.References Do
					Result.Type = New TypeDescription(Result.Type, RefMetadata.Type.Types());
				EndDo;
			Else
				Result.Type = Result.Metadata.Type;
			EndIf;
			Return Result;
		EndIf;
	EndDo;
	
	If TablesTypeProperties.CommonAttributes <> "Missing" Then
		Result.Metadata = Metadata.CommonAttributes.Find(FieldOrTabularSectionName);
		If Result.Metadata <> Undefined Then
			Result.Collection = "CommonAttributes";
			Result.Type = Result.Metadata.Type;
			Return Result;
		EndIf;
	EndIf;
	
	If TablesTypeProperties.CollectionName = "Constants" Then
		
		If Upper(FieldOrTabularSectionName) = Upper("Value")
		 Or Upper(FieldOrTabularSectionName) = Upper("Value") Then
			
			Result.Collection = "SpecialFields";
			Result.Type = TableMetadata.Type;
			Result.Insert("DefaultOrder", "001"); // See the AddMainFieldOrder procedure.
			Return Result;
		EndIf;
		
	ElsIf TablesTypeProperties.CollectionName = "Sequences" Then
		
		If Upper(FieldOrTabularSectionName) = Upper("Period")
		 Or Upper(FieldOrTabularSectionName) = Upper("Period") Then
		
			Result.Collection = "SpecialFields";
			Result.Type = New TypeDescription("Date");
			Result.Insert("DefaultOrder", "001"); // See the AddMainFieldOrder procedure.
			Return Result;
		EndIf;
		
		If Upper(FieldOrTabularSectionName) = Upper("Recorder")
		 Or Upper(FieldOrTabularSectionName) = Upper("Recorder") Then
			
			Result.Collection = "SpecialFields";
			Result.Type = New TypeDescription;
			For Each DocumentMetadata In TableMetadata.Documents Do
				Result.Type = New TypeDescription(Result.Type, "DocumentRef." + DocumentMetadata.Name);
			EndDo;
			Result.Insert("DefaultOrder", "002"); // See the AddMainFieldOrder procedure.
			Return Result;
		EndIf;
	EndIf;
	
	Return Undefined;
	
EndFunction

// For the CheckTableExtensions and CheckTableField procedures.
Function TabularSectionFieldProperties(TabularSectionFieldName, TabularSectionMetadata, CollectionName, TableMetadata)
	
	Result = New Structure;
	Result.Insert("Type");
	Result.Insert("TabularSectionName", TabularSectionMetadata.Name);
	
	If Upper(TabularSectionFieldName) = Upper("Ref")
	 Or Upper(TabularSectionFieldName) = Upper("Ref") Then
		
		For Each StandardAttribute In TableMetadata.StandardAttributes Do
			If Upper(TabularSectionFieldName) = Upper(StandardAttribute.Name) Then
				Result.Type = StandardAttribute.Type;
				Return Result;
			EndIf;
		EndDo;
	EndIf;
	
	For Each StandardAttribute In TabularSectionMetadata.StandardAttributes Do
		If Upper(TabularSectionFieldName) = Upper(StandardAttribute.Name) Then
			Result.Type = StandardAttribute.Type;
			Return Result;
		EndIf;
	EndDo;
	
	If CollectionName = "TabularSections" Then
		FieldMetadata = TabularSectionMetadata.Attributes.Find(TabularSectionFieldName);
		If FieldMetadata <> Undefined Then
			Result.Type = FieldMetadata.Type;
			Result.Insert("TabularSectionMetadata", TabularSectionMetadata);
			Return Result;
		EndIf;
	EndIf;
	
	Return Undefined;
	
EndFunction

// For the CheckTableExtensions and CheckTableField procedures.
Function RecalculationFieldProperties(RecalculationFieldName, RecalculationMetadata, TableMetadata)
	
	Result = New Structure;
	Result.Insert("Type");
	Result.Insert("Collection");
	Result.Insert("Metadata");
	
	If Upper(RecalculationFieldName) = Upper("RecalculationObject")
	 Or Upper(RecalculationFieldName) = Upper("RecalculationObject") Then
		
		FieldName = "Recorder";
		
	ElsIf Upper(RecalculationFieldName) = Upper("CalculationType")
	      Or Upper(RecalculationFieldName) = Upper("CalculationType") Then
	
		FieldName = "CalculationType";
	EndIf;
	
	If ValueIsFilled(FieldName) Then
		For Each StandardAttribute In TableMetadata.StandardAttributes Do
			If Upper(FieldName) = Upper(StandardAttribute.Name) Then
				Result.Collection = "StandardAttributes";
				Result.Metadata = StandardAttribute;
				Result.Type = StandardAttribute.Type;
				Return Result;
			EndIf;
		EndDo;
		Return Undefined;
	EndIf;
	
	FieldMetadata = RecalculationMetadata.Dimensions.Find(RecalculationFieldName);
	If FieldMetadata <> Undefined Then
		Result.Type = FieldMetadata.RegisterDimension.Type;
		Result.Collection = "SpecialFields";
		Number = 200 + TableMetadata.Dimensions.IndexOf(FieldMetadata) + 1;
		Result.Insert("DefaultOrder", Number); // See the AddMainFieldOrder procedure.
		Return Result;
	EndIf;
	
	Return Undefined;
	
EndFunction

// For the CheckTableField procedure.
Procedure AddFieldTypesAdditional(FieldDetails, Index, CurrentFieldProperties, Context)
	
	// Additionally collecting types to use in service procedures.
	
	// Expanding properties of the Field node to use in service procedures.
	If Index = 0 Then
		If FieldDetails.NameContent.Count() > 1 Then
			FieldDetails.Insert("NextFieldTables", New Array);
		EndIf;
		If Not Context.TablesTypeProperties.IsReferenceType Then
			AddMainFieldOrder(CurrentFieldProperties, Context);
		EndIf;
	EndIf;
	
	For Each FieldNode In FieldDetails.Properties.FieldNodes Do
		If CurrentFieldProperties.Property("DefaultOrder")
		   AND Not FieldNode.Property("DefaultOrder") Then
			FieldNode.Insert("DefaultOrder", CurrentFieldProperties.DefaultOrder);
		EndIf;
		If FieldDetails.Property("NextFieldTables")
		   AND Not FieldNode.Property("NextFieldTables") Then
			FieldNode.Insert("NextFieldTables", FieldDetails.NextFieldTables);
		EndIf;
		If Not FieldNode.Property("FieldTypes") Then
			FieldNode.Insert("FieldTypes", New Array);
			SetFieldContainsNull(FieldNode, CurrentFieldProperties, Context);
		EndIf;
		If CurrentFieldProperties.Property("TabularSectionName")
		   AND Upper(CurrentFieldProperties.TabularSectionName) = Upper(FieldDetails.NameContent[0]) Then
			
			FieldNode.FieldTypes.Add(CurrentFieldProperties.TabularSectionName);
		EndIf;
		If Index > FieldNode.FieldTypes.Count() - 1 Then
			FieldNode.FieldTypes.Add(CurrentFieldProperties.Type);
		EndIf;
		FieldNode.FieldTypes[Index] = New TypeDescription(FieldNode.FieldTypes[Index],
			CurrentFieldProperties.Type.Types());
	EndDo;
	
	// Adding field types as a string to check changes in service procedures.
	FullFieldName = Context.TablesTypeProperties.LanguageRussian + "." + Upper(Context.TableMetadata.Name);
	
	If CurrentFieldProperties.Property("TabularSectionName") Then
		FullFieldName = FullFieldName + "." + Upper(CurrentFieldProperties.TabularSectionName);
	EndIf;
	
	FullFieldName = FullFieldName + "." + FieldDetails.NameContent[Index];
	
	If Not FieldDetails.Property("AllFields") Then
		FieldDetails.Insert("AllFields",       New Map);
		FieldDetails.Insert("AllFieldsTypes", New ValueList);
	EndIf;
	If FieldDetails.AllFields.Get(FullFieldName) <> Undefined Then
		Return;
	EndIf;
	FieldDetails.AllFields.Insert(FullFieldName, True);
	
	TypesString = DataStringForHashing(CurrentFieldProperties.Type);
	FieldDetails.AllFieldsTypes.Add(TypesString, FullFieldName);
	
EndProcedure

// For the CheckTableField procedure.
Procedure FillFieldTypesAsStringAdditional(FieldDetails)
	
	If FieldDetails.AllFieldsTypes.Count() > 1 Then
		FieldDetails.AllFieldsTypes.SortByPresentation();
	EndIf;
	TypesString = StrConcat(FieldDetails.AllFieldsTypes.UnloadValues(), Chars.LF);
	FieldNodes = FieldDetails.Properties.FieldNodes;
	
	For Each FieldNode In FieldNodes Do
		FieldNode.Insert("TypesString", TypesString);
	EndDo;
	
	FieldDetails.Delete("AllFields");
	FieldDetails.Delete("AllFieldsTypes");
	
EndProcedure

// For the AddFieldTypesAdditional procedure.
Procedure AddMainFieldOrder(CurrentFieldProperties, Context)
	
	If CurrentFieldProperties.Collection = "SpecialFields" Then
		Return; // It is set in the FieldOrTabularSectionProperties function.
	EndIf;
	
	TableMetadata = Context.TableMetadata;
	FieldMetadata    = CurrentFieldProperties.Metadata;
	
	If CurrentFieldProperties.Collection = "StandardAttributes" Then
		Index = 0;
		For Each StandardAttribute In TableMetadata.StandardAttributes Do
			If StandardAttribute = FieldMetadata Then
				Break;
			EndIf;
			Index = Index + 1;
		EndDo;
		Number = 100 + Index + 1;
		
	ElsIf CurrentFieldProperties.Collection = "Dimensions" Then
		Number = 200 + TableMetadata.Dimensions.IndexOf(FieldMetadata) + 1;
		
	ElsIf CurrentFieldProperties.Collection = "Resources" Then
		Number = 300 + TableMetadata.Resources.IndexOf(FieldMetadata) + 1;
		
	ElsIf CurrentFieldProperties.Collection = "Attributes" Then
		Number = 400 + TableMetadata.Attributes.IndexOf(FieldMetadata) + 1;
		
	ElsIf CurrentFieldProperties.Collection = "CommonAttributes" Then
		Number = 500 + Context.TablesTypeProperties.CommonAttributes.IndexOf(FieldMetadata) + 1;
	EndIf;
	
	CurrentFieldProperties.Insert("DefaultOrder", String(Number));
	
EndProcedure

// For the AddFieldTypesAdditional procedure.
Procedure SetFieldContainsNull(FieldNode, CurrentFieldProperties, Context)
	
	If Context.TablesTypeProperties.CollectionName <> "Catalogs"
	   AND Context.TablesTypeProperties.CollectionName <> "ChartsOfCharacteristicTypes"
	 Or Not Context.TableMetadata.Hierarchical Then
		
		Return;
	EndIf;
	
	If Context.TablesTypeProperties.CollectionName = "Catalogs"
	   AND Context.TableMetadata.HierarchyType
	       <> Metadata.ObjectProperties.HierarchyType.HierarchyFoldersAndItems Then
		
		Return;
	EndIf;
	
	If CurrentFieldProperties.Property("TabularSectionName") Then
		If CurrentFieldProperties.Property("TabularSectionMetadata")
		   AND CurrentFieldProperties.TabularSectionMetadata.Use
		      <> Metadata.ObjectProperties.AttributeUse.ForFolderAndItem Then
			
			FieldNode.Insert("FieldContainsNull");
		EndIf;
		
		Return;
	EndIf;
	
	If CurrentFieldProperties.Collection = "Attributes"
	   AND CurrentFieldProperties.Metadata.Use
	      <> Metadata.ObjectProperties.AttributeUse.ForFolderAndItem Then
		
		FieldNode.Insert("FieldContainsNull");
	EndIf;
	
EndProcedure

// For the CheckFieldTablesAndFieldsTypes procedure.
Procedure CheckTableExtensions(TableFields, Context)
	
	TablesTypeProperties = Context.TablesTypeProperties;
	
	If TablesTypeProperties.TabularPartCollections.Count() = 0
	   AND TablesTypeProperties.CollectionName <> "CalculationRegisters" Then
		Return;
	EndIf;
	
	TableMetadata = Context.TableMetadata;
	
	For Each TableExtension In TableFields.Value.Extensions Do
		
		If TablesTypeProperties.CollectionName = "CalculationRegisters" Then
			ExtensionMetadata = TableMetadata.Recalculations.Find(TableExtension.Key);
		Else
			For Each TabularSectionsCollection In TablesTypeProperties.TabularPartCollections Do
				If TabularSectionsCollection.Key = "StandardTabularSections" Then
					For Each StandardTabularSection In TableMetadata.StandardTabularSections Do
						If Upper(TableExtension.Key) = Upper(StandardTabularSection.Name) Then
							ExtensionMetadata = StandardTabularSection;
							Break;
						EndIf;
					EndDo;
				Else
					ExtensionMetadata = TableMetadata[TabularSectionsCollection.Key].Find(TableExtension.Key);
				EndIf;
				If ExtensionMetadata <> Undefined Then
					Break;
				EndIf;
			EndDo;
		EndIf;
		If ExtensionMetadata = Undefined Then
			Continue;
		EndIf;
		TableExtension.Value.TableExists = True;
		
		For Each TableField In TableExtension.Value.Fields Do
			FieldDetails = New Structure;
			FieldDetails.Insert("NameContent", StrSplit(TableField.Key, "."));
			FieldDetails.Insert("Properties",    TableField.Value);
			FieldDetails.Insert("FieldType",     New TypeDescription);
			
			Index = 0;
			If TablesTypeProperties.CollectionName = "CalculationRegisters" Then
				FieldProperties = RecalculationFieldProperties(FieldDetails.NameContent[Index],
					ExtensionMetadata, TableMetadata);
			Else
				FieldProperties = TabularSectionFieldProperties(FieldDetails.NameContent[Index],
					ExtensionMetadata, TabularSectionsCollection.Key, TableMetadata);
			EndIf;
			
			If FieldProperties = Undefined Then
				FieldDetails.Properties.FieldWithError = Index + 1;
				FieldDetails.Properties.ErrorKind = "NotFound";
				Continue;
			EndIf;
			CheckNextPointSeparatedField(FieldDetails, Index, FieldProperties, Context);
			FillFieldTypesAsStringAdditional(FieldDetails);
			If FieldDetails.Properties.FieldWithError = 0 Then
				CheckFieldTypes(FieldDetails, Context);
			EndIf;
		EndDo;
		
	EndDo;
	
EndProcedure

// For the CheckFieldTablesAndFieldsTypes and CheckTableExtensions procedures.
Procedure CheckFieldTypes(FieldDetails, Context)
	
	FieldTypesDetails = FieldDetails.FieldType;
	
	For Each TypeDetails In FieldDetails.Properties.ContainsTypes Do
		TypeProperties = TypeDetails.Value;
		If ValueIsFilled(TypeProperties.TypeCollectionName)
		   AND Metadata[TypeProperties.TypeCollectionName].Find(TypeProperties.TypeCollectionObjectName) = Undefined Then
			Continue;
		EndIf;
		Type = Type(TypeDetails.Value.TypeName);
		TypeProperties.ContainsType = FieldTypesDetails.ContainsType(Type);
	EndDo;
	
EndProcedure

// For the CheckFieldTablesAndFieldsTypes procedure.
Procedure CheckPredefinedTableValues(TableFields, Context)
	
	TablesTypeProperties = Context.TablesTypeProperties;
	
	If TableFields.Value.Predefined.Count() = 0 Then
		Return;
	EndIf;
	
	If TablesTypeProperties.HasPredefined Then
		TableMetadata = Context.TableMetadata;
		
		If TablesTypeProperties.CollectionName = "Enums" Then
			PredefinedItemNames = New Array;
			For Each EnumValue In TableMetadata.EnumValues Do
				PredefinedItemNames.Add(EnumValue.Name);
			EndDo;
		Else
			PredefinedItemNames = New Array(TableMetadata.GetPredefinedNames());
		EndIf;
	Else
		PredefinedItemNames = New Array;
	EndIf;
	
	PredefinedItemNames.Add("EmptyRef");
	PredefinedItemNames.Add("EmptyRef");
	
	For Each Predefined In TableFields.Value.Predefined Do
		For Each PredefinedItemName In PredefinedItemNames Do
			If Upper(PredefinedItemName) = Predefined.Key Then
				Predefined.Value.NameExists = True;
				Break;
			EndIf;
		EndDo;
	EndDo;
	
EndProcedure


// For the RestrictionStructure function.
Procedure MarkIncorrectFieldsTablesAndFieldsTypesNames(TablesFields, Context)
	
	For Each TablesType In TablesFields Do
		For Each TableDetails In TablesType.Value Do
			TableProperties = TableDetails.Value;
			
			If Not TableProperties.TableExists Then
				For Each Source In TableProperties.Sources Do
					SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
							NStr("ru = 'Не найдена таблица ""%1""'; en = 'Table ""%1"" not found'; pl = 'Nie znaleziono tabeli ""%1""';es_ES = 'Tabla ""%1"" no se ha encontrado';es_CO = 'Tabla ""%1"" no se ha encontrado';tr = '""%1"" tablo bulunamadı';it = 'La tabella""%1"" non è stata trovata';de = 'Tabelle ""%1"" nicht gefunden'"), Source.Chars), , 2);
				EndDo;
				If TableProperties.Property("FirstField")
				   AND TableProperties.FirstField.FirstSource <> Undefined Then
					
					SetErrorInFieldNameString(Context, TableProperties.FirstField.FirstSource.Key,
						NStr("ru = 'Поле не найдено, так как не найдена таблица ""%1""'; en = 'Field is not found as the ""%1"" table is not found'; pl = 'Nie znaleziono pola, ponieważ nie znaleziono tabeli ""%1""';es_ES = 'Campo no encontrado, porque la tabla no se ha encontrado ""%1""';es_CO = 'Campo no encontrado, porque la tabla no se ha encontrado ""%1""';tr = '""%1"" tablo bulunmadığından dolayı alan bulunamadı';it = 'Il campo non è stato trovato dato che la tabella""%1"" non è stata trovata';de = 'Das Feld wurde nicht gefunden, weil die Tabelle ""%1"" nicht gefunden wurde'"), 0, ,
						TableProperties.FirstField.FirstSource.Value);
				EndIf;
				For Each PredefinedItemDetails In TableProperties.Predefined Do
					For Each Source In PredefinedItemDetails.Value.Sources Do
						NameContent = StrSplit(Source.Chars, ".");
						
						SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
								NStr("ru = 'Предопределенное значение не найдено, так как не найдена таблица ""%1""'; en = 'Predefined value is not found as the ""%1"" table is not found'; pl = 'Predefiniowanej wartości nie znaleziono, ponieważ nie znaleziono tabeli ""%1""';es_ES = 'Valor predeterminado no encontrado, porque la tabla no se ha encontrado ""%1""';es_CO = 'Valor predeterminado no encontrado, porque la tabla no se ha encontrado ""%1""';tr = '""%1"" tablo bulunmadığından dolayı önceden tanımlanmış değer bulunamadı';it = 'Valore predefinito non trovato, poiché non è stata trovata la tabella ""%1""';de = 'Der vordefinierte Wert wurde nicht gefunden, da die Tabelle ""%1"" nicht gefunden wurde'"),
								NameContent[0] + "." + NameContent[1]), , 2);
					EndDo;
				EndDo;
				Continue;
			EndIf;
			
			For Each PredefinedItemDetails In TableProperties.Predefined Do
				PredefinedOptionProperties = PredefinedItemDetails.Value;
				If PredefinedOptionProperties.NameExists Then
					Continue;
				EndIf;
				For Each Source In PredefinedOptionProperties.Sources Do
					NameContent = StrSplit(Source.Chars, ".");
					Source.ErrorPosition = StrLen(NameContent[0] + "." + NameContent[1]) + 1;
					Source.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Не найдено предопределенное значение ""%1""'; en = 'Predefined value ""%1"" is not found'; pl = 'Nie znaleziono zdefiniowanej wartość ""%1""';es_ES = 'No se ha encontrado un valor predeterminado ""%1""';es_CO = 'No se ha encontrado un valor predeterminado ""%1""';tr = '""%1"" Önceden tanımlanmış değer bulunamadı';it = 'Il valore predefinito ""%1"" non è stato trovato';de = 'Kein vordefinierter Wert ""%1"" gefunden'"), NameContent[2]);
				EndDo;
			EndDo;
			
			For Each FieldDetails In TableProperties.Fields Do
				MarkIncorrectFieldAndFieldTypes(FieldDetails, Context);
			EndDo;
			
			For Each ExtensionDetails In TableProperties.Extensions Do
				ExtensionProperties = ExtensionDetails.Value;
				If Not ExtensionProperties.TableExists Then
					For Each Source In ExtensionProperties.Sources Do
						SetErrorInRow(Source,
							StringFunctionsClientServer.SubstituteParametersToString(
								NStr("ru = 'Не найдена таблица ""%1""'; en = 'Table ""%1"" not found'; pl = 'Nie znaleziono tabeli ""%1""';es_ES = 'Tabla ""%1"" no se ha encontrado';es_CO = 'Tabla ""%1"" no se ha encontrado';tr = '""%1"" tablo bulunamadı';it = 'La tabella""%1"" non è stata trovata';de = 'Tabelle ""%1"" nicht gefunden'"), Source.Chars), , 2);
					EndDo;
					If ExtensionProperties.Property("FirstField")
					   AND ExtensionProperties.FirstField.FirstSource <> Undefined Then
						
						SetErrorInFieldNameString(Context, ExtensionProperties.FirstField.FirstSource.Key,
							NStr("ru = 'Поле не найдено, так как не найдена таблица ""%1""'; en = 'Field is not found as the ""%1"" table is not found'; pl = 'Nie znaleziono pola, ponieważ nie znaleziono tabeli ""%1""';es_ES = 'Campo no encontrado, porque la tabla no se ha encontrado ""%1""';es_CO = 'Campo no encontrado, porque la tabla no se ha encontrado ""%1""';tr = '""%1"" tablo bulunmadığından dolayı alan bulunamadı';it = 'Il campo non è stato trovato dato che la tabella""%1"" non è stata trovata';de = 'Das Feld wurde nicht gefunden, weil die Tabelle ""%1"" nicht gefunden wurde'"), 0, ,
							ExtensionProperties.FirstField.FirstSource.Value);
					EndIf;
					Continue;
				EndIf;
				For Each FieldDetails In ExtensionProperties.Fields Do
					MarkIncorrectFieldAndFieldTypes(FieldDetails, Context);
				EndDo;
			EndDo;
			
		EndDo;
	EndDo;
	
EndProcedure

// For the MarkIncorrectFieldsTablesAndFieldsTypesNames procedure.
Procedure MarkIncorrectFieldAndFieldTypes(FieldDetails, Context)
	
	FieldProperties = FieldDetails.Value;
	If FieldProperties.FieldWithError = 1 Then
		For Each SourceDetails In FieldDetails.Value.Sources Do
			EOF = False;
			If FieldProperties.ErrorKind = "TabularSectionNoField" Then
				EOF = True;
				ErrorTemplate = NStr("ru = 'Не указано поле после табличной части ""%1"" таблицы ""%2""'; en = 'Field is not specified after the ""%1"" tabular section of the ""%2"" table'; pl = 'Nie zaznaczono pola po części tabelarycznej ""%1"" tabeli ""%2""';es_ES = 'No se ha indicado un campo después de la sección tabular ""%1"" de la tabla ""%2""';es_CO = 'No se ha indicado un campo después de la sección tabular ""%1"" de la tabla ""%2""';tr = '""%1"" tablonun sekmeli bölümünden sonraki ""%2"" alan belirtilmedi';it = 'Il campo non è indicato dopo la sezione tabellare ""%1"" della tabella ""%2""';de = 'Nach dem Tabellenteil ""%1"" der Tabelle ""%2"" ist kein Feld angegeben'");
					
			ElsIf FieldProperties.ErrorKind = "Illegal" Then
				ErrorTemplate = NStr("ru = 'Недопустимо использовать поле ""%1"" таблицы ""%2""'; en = 'Cannot use the ""%1"" field of the ""%2"" table'; pl = 'Niedopuszczalne jest stosowanie pola ""%1"" tabeli ""%2""';es_ES = 'No se admite usar el campo ""%1"" de la tabla ""%2""';es_CO = 'No se admite usar el campo ""%1"" de la tabla ""%2""';tr = '""%1"" tablonun ""%2"" alanı kullanılamaz';it = 'Impossibile utilizzare il campo ""%1"" della tabella ""%2""';de = 'Das Feld ""%1"" der Tabelle ""%2"" darf nicht verwendet werden'");
				
			ElsIf FieldProperties.ErrorKind = "Denied" Then
				ErrorTemplate = NStr("ru = 'Запрещено использовать поле ""%1"" таблицы ""%2""'; en = 'It is prohibited to use the ""%1"" field of the ""%2"" table'; pl = 'Nie wolno używać pola ""%1"" tabeli ""%2""';es_ES = 'Está prohibido usar el campo ""%1"" de la tabla ""%2""';es_CO = 'Está prohibido usar el campo ""%1"" de la tabla ""%2""';tr = '""%1"" tablonun ""%2"" alanı kullanılamaz';it = 'Non è consentito utilizzare il campo ""%1"" della tabella ""%2""';de = 'Es ist verboten das Feld ""%1"" der Tabelle ""%2"" zu benutzen'");
			Else
				ErrorTemplate = NStr("ru = 'Не найдено поле ""%1"" таблицы ""%2""'; en = '""%1"" field of the ""%2"" table is not found'; pl = 'Nie znaleziono pola ""%1"" tabeli ""%2""';es_ES = 'No se ha encontrado el campo ""%1"" de la tabla ""%2""';es_CO = 'No se ha encontrado el campo ""%1"" de la tabla ""%2""';tr = '""%1"" tablonun ""%2"" alanı bulunamadı';it = 'Campo ""%1"" della tabella ""%2"" non trovato';de = 'Kein Feld ""%1"" der Tabelle ""%2"" gefunden'");
			EndIf;
			SetErrorInFieldNameString(Context,
				 SourceDetails.Key, ErrorTemplate, 1, True, SourceDetails.Value, EOF);
		EndDo;
		Return;
	EndIf;
	
	If FieldProperties.FieldWithError > 1 Then
		For Each SourceDetails In FieldDetails.Value.Sources Do
			If FieldProperties.ErrorKind = "TabularSectionAfterDot" Then
				ErrorTemplate = NStr("ru = 'Табличная часть ""%1"" не поддерживается ""через точку"" от поля'; en = 'Tabular section ""%1"" is not supported being period-separated from the field'; pl = 'Część tabelaryczna ""%1"" nie jest obsługiwana ""przez punkt"" od pola';es_ES = 'La sección tabular ""%1"" no se admite ""con puntos"" del campo';es_CO = 'La sección tabular ""%1"" no se admite ""con puntos"" del campo';tr = '""%1"" tablo kısmı ""nokta ile"" alandan desteklenmez';it = 'La sezione tabellare ""%1"" non è supportata poiché separata da un punto dal campo';de = 'Der Tabellenteil ""%1"" wird nicht ""durch einen Punkt"" aus dem Feld unterstützt'");
				
			ElsIf FieldProperties.ErrorKind = "Illegal" Then
				ErrorTemplate = NStr("ru = 'Недопустимо использовать поле ""%1""'; en = 'Cannot use the ""%1"" field'; pl = 'Niedopuszczalne jest stosowanie pola ""%1""';es_ES = 'No se admite usar el campo ""%1""';es_CO = 'No se admite usar el campo ""%1""';tr = '""%1"" alan kullanılamaz';it = 'Impossibile utilizzare il campo ""%1""';de = 'Es ist nicht erlaubt das Feld ""%1"" zu benutzen'");
				
			ElsIf FieldProperties.ErrorKind = "Denied" Then
				ErrorTemplate = NStr("ru = 'Запрещено использовать поле ""%1""'; en = 'It is prohibited to use the ""%1"" field'; pl = 'Nie wolno używać pola ""%1""';es_ES = 'Está prohibido usar el campo ""%1""';es_CO = 'Está prohibido usar el campo ""%1""';tr = '""%1"" alan kullanılamaz';it = 'Non è consentito utilizzare il campo ""%1""';de = 'Es ist verboten das Feld ""%1"" zu benutzen'");
			Else
				ErrorTemplate = NStr("ru = 'Не найдено поле ""%1""'; en = 'Field ""%1"" not found'; pl = 'Nie znaleziono pola ""%1""';es_ES = 'No se ha encontrado el campo ""%1""';es_CO = 'No se ha encontrado el campo ""%1""';tr = '""%1"" alan bulunamadı';it = 'Il campo ""%1"" non è stato trovato';de = 'Feld ""%1"" nicht gefunden'");
			EndIf;
			SetErrorInFieldNameString(Context,
				SourceDetails.Key, ErrorTemplate, FieldProperties.FieldWithError, True);
		EndDo;
		Return;
	EndIf;
	
	NameContent = StrSplit(FieldDetails.Key, ".");
	If NameContent.Count() > 1
	   AND (    NameContent[1] = Upper("Ref")
	      Or NameContent[1] = Upper("Ref") )
	   AND FieldProperties.Collection <> "TabularSections"
	   AND FieldProperties.Collection <> "StandardTabularSections" Then
		
			For Each SourceDetails In FieldDetails.Value.Sources Do
				ErrorTemplate = NStr("ru = 'Поле ""%1"" избыточно указывать ""через точку"" от любого поля'; en = 'It is redundant to indicate a %1 field separated by period from another field'; pl = 'Pole ""%1"" ponadto wskazywać ""przez kropkę"" od każdego pola';es_ES = 'Es excedente indicar campo ""%1"" ""con puntos"" de cualquier campo';es_CO = 'Es excedente indicar campo ""%1"" ""con puntos"" de cualquier campo';tr = '""%1"" alan herhangi alandan ""nokta ile"" belirt';it = 'Non è necessario indicare un campo %1 separato da un punto da un altro campo';de = 'Das Feld ""%1"" sollte übermäßig ""durch einen Punkt"" von jedem Feld aus angegeben werden'");
				SetErrorInFieldNameString(Context,
					SourceDetails.Key, ErrorTemplate, 2, True);
		EndDo;
		Return;
	EndIf;
	
	For Each TypeDetails In FieldProperties.ContainsTypes Do
		TypeProperties = TypeDetails.Value;
		For Each SourceDetails In TypeDetails.Value.Sources Do
			If TypeOf(SourceDetails.Key) = Type("ValueTableRow") Then
				If Not TypeProperties.ContainsType Then
					SetErrorInRow(SourceDetails.Key,
						StringFunctionsClientServer.SubstituteParametersToString(
							NStr("ru = 'У поля ""%1"" не найден тип ""%2""'; en = '""%2"" type is not found in the ""%1"" field'; pl = 'Pole ""%1"" nie znaleziono typu ""%2""';es_ES = 'Para el campo ""%1"" no se ha encontrado el tipo ""%2""';es_CO = 'Para el campo ""%1"" no se ha encontrado el tipo ""%2""';tr = '""%1"" alanın ""%2"" türü bulunamadı';it = 'Tipo ""%2"" non trovato nel campo ""%1""';de = 'Im Feld ""%1"" den Typ ""%2"" nicht gefunden'"),
							SourceDetails.Value.Chars,
							SourceDetails.Key.Chars),
						, 2);
				EndIf;
			EndIf;
		EndDo;
	EndDo;
	
EndProcedure

// For the MarkIncorrectFieldsTablesAndFieldsTypesNames procedure.
Procedure SetErrorInFieldNameString(Context, Row, ErrorTemplate, FieldWithError,
			InsertName = False, Table = Null, EOF = False)
	
	If ValueIsFilled(Row.ErrorText) Then
		Return;
	EndIf;
	
	If TypeOf(InsertName) = Type("String") Then
		NameContent = StrSplit(InsertName, ".");
		InsertName = True;
	Else
		NameContent = StrSplit(Row.Chars, ".");
	EndIf;
	
	If NameContent.Count() > 1
	   AND Context.Aliases.Get(Upper(NameContent[0])) <> Undefined Then
		
		Row.ErrorPosition = StrLen(NameContent[0]) + 1;
		NameContent.Delete(0);
	EndIf;
	
	For Number = 1 To FieldWithError - 1 Do
		Row.ErrorPosition = Row.ErrorPosition + StrLen(NameContent[0]) + 1;
		NameContent.Delete(0);
	EndDo;
	If EOF Then
		Row.ErrorPosition = Row.ErrorPosition + StrLen(NameContent[0]);
	EndIf;
	FieldName = NameContent[0];
	
	If InsertName AND Table <> Null Then
		Row.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate,
			FieldName, ?(ValueIsFilled(Table), Table, Context.MainTable));
			
	ElsIf InsertName Then
		Row.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate, FieldName);
		
	ElsIf Table <> Null Then
		Row.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate,
			?(ValueIsFilled(Table), Table, Context.MainTable));
	Else
		Row.ErrorText = ErrorTemplate;
	EndIf;
	
EndProcedure

#EndRegion

#EndRegion

#Region AccessUpdateProgressUpdate

Procedure UpdateProgressInBackground(Context, ResultAddress) Export
	
	ProgressUpdateStartDate = CurrentSessionDate();
	TimeConsumingOperations.ReportProgress(0); // Updating progress.
	
	ListsRows   = Context.StoredData.ListsRows;
	ListsProperties = Context.StoredData.ListsProperties;
	If Not Context.IsRepeatedProgressUpdate Then
		Context.StoredData.LatestUpdateDate = '00010101';
	EndIf;
	
	ActiveParameters = Undefined;
	TablesIDs = ListsWithRestrictionIDs(ActiveParameters);
	
	For Each KeyAndValue In TablesIDs Do
		If Not Context.ShowProcessedLists Then
			Continue;
		EndIf;
		If ListsRows.Get(KeyAndValue.Value) <> Undefined Then
			Continue;
		EndIf;
		AddNewListRow(Context, KeyAndValue.Value, KeyAndValue.Key);
	EndDo;
	
	Query = New Query;
	Query.SetParameter("MaxDate", MaxDate());
	Query.SetParameter("LatestUpdateDate", Context.StoredData.LatestUpdateDate);
	Query.SetParameter("EmptyUniqueID",
		New UUID("00000000-0000-0000-0000-000000000000"));
	
	Context.StoredData.LatestUpdateDate = ProgressUpdateStartDate;
	
	Query.Text =
	"SELECT
	|	AllUpdateLists.List AS List,
	|	MAX(AllUpdateLists.ItemsUpdate) AS ItemsUpdate,
	|	MAX(AllUpdateLists.AccessKeysUpdate) AS AccessKeysUpdate
	|FROM
	|	(SELECT DISTINCT
	|		DataAccessKeysUpdate.List AS List,
	|		TRUE AS ItemsUpdate,
	|		FALSE AS AccessKeysUpdate
	|	FROM
	|		InformationRegister.DataAccessKeysUpdate AS DataAccessKeysUpdate
	|	
	|	UNION ALL
	|	
	|	SELECT DISTINCT
	|		UsersAccessKeysUpdate.List,
	|		FALSE,
	|		TRUE
	|	FROM
	|		InformationRegister.UsersAccessKeysUpdate AS UsersAccessKeysUpdate) AS AllUpdateLists
	|
	|GROUP BY
	|	AllUpdateLists.List
	|
	|ORDER BY
	|	List
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	Lists.List AS List,
	|	DataAccessKeysUpdate.LatestUpdatedItemDate AS LatestUpdatedItemDate,
	|	ISNULL(DataAccessKeysUpdate.LastUpdatedItem, Lists.FullUpdate) AS LastUpdatedItem,
	|	UpdateDataAccessKeysForExternalUsers.LatestUpdatedItemDate AS LatestUpdatedItemForExternalUsersDate,
	|	ISNULL(UpdateDataAccessKeysForExternalUsers.LastUpdatedItem, Lists.FullUpdateForExternalUsers) AS LastUpdatedItemForExtrenalUsers
	|FROM
	|	(SELECT
	|		DataAccessKeysUpdate.List AS List,
	|		MAX(CASE
	|				WHEN DataAccessKeysUpdate.ForExternalUsers
	|					THEN FALSE
	|				ELSE DataAccessKeysUpdate.UniqueKey <> &EmptyUniqueID
	|						OR DataAccessKeysUpdate.LatestUpdatedItemDate = &MaxDate
	|			END) AS FullUpdate,
	|		MAX(CASE
	|				WHEN DataAccessKeysUpdate.ForExternalUsers
	|					THEN DataAccessKeysUpdate.UniqueKey <> &EmptyUniqueID
	|							OR DataAccessKeysUpdate.LatestUpdatedItemDate = &MaxDate
	|				ELSE FALSE
	|			END) AS FullUpdateForExternalUsers
	|	FROM
	|		InformationRegister.DataAccessKeysUpdate AS DataAccessKeysUpdate
	|	WHERE
	|		DataAccessKeysUpdate.RegisterRecordChangeDate >= &LatestUpdateDate
	|	
	|	GROUP BY
	|		DataAccessKeysUpdate.List) AS Lists
	|		LEFT JOIN InformationRegister.DataAccessKeysUpdate AS DataAccessKeysUpdate
	|		ON (NOT Lists.FullUpdate)
	|			AND (DataAccessKeysUpdate.List = Lists.List)
	|			AND (DataAccessKeysUpdate.ForExternalUsers = FALSE)
	|			AND (DataAccessKeysUpdate.UniqueKey = &EmptyUniqueID)
	|		LEFT JOIN InformationRegister.DataAccessKeysUpdate AS UpdateDataAccessKeysForExternalUsers
	|		ON (NOT Lists.FullUpdateForExternalUsers)
	|			AND (DataAccessKeysUpdate.List = Lists.List)
	|			AND (DataAccessKeysUpdate.ForExternalUsers = TRUE)
	|			AND (DataAccessKeysUpdate.UniqueKey = &EmptyUniqueID)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	Lists.List AS List,
	|	ISNULL(UpdateAccessKeysForUsers.LastUpdatedAccessKey, Lists.FullUpdate) AS LastUpdatedAccessKey,
	|	ISNULL(UpdateAccessKeysForExternalUsers.LastUpdatedAccessKey, Lists.FullUpdateForExternalUsers) AS LastUpdatedAccessKeyForExtrenalUsers
	|FROM
	|	(SELECT
	|		UsersAccessKeysUpdate.List AS List,
	|		MAX(CASE
	|				WHEN UsersAccessKeysUpdate.ForExternalUsers
	|					THEN FALSE
	|				ELSE UsersAccessKeysUpdate.UniqueKey <> &EmptyUniqueID
	|			END) AS FullUpdate,
	|		MAX(CASE
	|				WHEN UsersAccessKeysUpdate.ForExternalUsers
	|					THEN UsersAccessKeysUpdate.UniqueKey <> &EmptyUniqueID
	|				ELSE FALSE
	|			END) AS FullUpdateForExternalUsers
	|	FROM
	|		InformationRegister.UsersAccessKeysUpdate AS UsersAccessKeysUpdate
	|	WHERE
	|		UsersAccessKeysUpdate.RegisterRecordChangeDate >= &LatestUpdateDate
	|	
	|	GROUP BY
	|		UsersAccessKeysUpdate.List) AS Lists
	|		LEFT JOIN InformationRegister.UsersAccessKeysUpdate AS UpdateAccessKeysForUsers
	|		ON (NOT Lists.FullUpdate)
	|			AND (UpdateAccessKeysForUsers.List = Lists.List)
	|			AND (UpdateAccessKeysForUsers.ForExternalUsers = FALSE)
	|			AND (UpdateAccessKeysForUsers.UniqueKey = &EmptyUniqueID)
	|		LEFT JOIN InformationRegister.UsersAccessKeysUpdate AS UpdateAccessKeysForExternalUsers
	|		ON (NOT Lists.FullUpdateForExternalUsers)
	|			AND (UpdateAccessKeysForExternalUsers.List = Lists.List)
	|			AND (UpdateAccessKeysForExternalUsers.ForExternalUsers = TRUE)
	|			AND (UpdateAccessKeysForExternalUsers.UniqueKey = &EmptyUniqueID)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	COUNT(*) AS Count
	|FROM
	|	Catalog.AccessKeys AS AccessKeys";
	
	QueryResults = Query.ExecuteBatch();
	
	AllUpdateLists = QueryResults[0].Unload();
	ItemsCountUpdateRows = New Array;
	AccessKeysCountUpdateRows = New Array;
	
	For Each UpdateList In AllUpdateLists Do
		Row = ListsRows.Get(UpdateList.List);
		If Row = Undefined Then
			AddNewListRow(Context, UpdateList.List, "");
		EndIf;
	EndDo;
	
	RowsToDelete = New Array;
	For Each KeyAndValue In ListsRows Do
		Row = KeyAndValue.Value;
		UpdateList = AllUpdateLists.Find(Row.List, "List");
		If UpdateList = Undefined AND Not Context.ShowProcessedLists Then
			RowsToDelete.Add(Row);
			Continue;
		EndIf;
		ListProperties = ListsProperties.Get(Row.List);
		If UpdateList = Undefined Or Not UpdateList.ItemsUpdate Then
			ListProperties.LatestUpdatedItemDate = '00010101';
			ListProperties.LastUpdatedItem = Undefined;
			ListProperties.LatestUpdatedItemForExternalUsersDate = '00010101';
			ListProperties.LastUpdatedItemForExtrenalUsers = Undefined;
			If Context.CalculateByDataAmount Then
				If Row.ProcessedItemsCount <> 100 Then
					ItemsCountUpdateRows.Add(Row);
				EndIf;
			Else
				ResetItemsCount(Row, Context);
			EndIf;
			UpdateValueInRow(Row.ProcessedItemsCount, 100, Row, Context);
		EndIf;
		If UpdateList = Undefined Or Not UpdateList.AccessKeysUpdate Then
			ListProperties.LastUpdatedAccessKey = Undefined;
			ListProperties.LastUpdatedAccessKeyForExtrenalUsers = Undefined;
			If Context.CalculateByDataAmount Then
				If Row.ProcessedAccessKeysCount <> 100 Then
					AccessKeysCountUpdateRows.Add(Row);
				EndIf;
			Else
				ResetAccessKeysCount(Row, Context);
			EndIf;
			UpdateValueInRow(Row.ProcessedAccessKeysCount, 100, Row, Context);
		EndIf;
	EndDo;
	
	ItemsUpdateLists = QueryResults[1].Unload();
	MetadataObjectsByIDs =
		Catalogs.MetadataObjectIDs.MetadataObjectsByIDs(
			ItemsUpdateLists.UnloadColumn("List"), True);
	
	For Each UpdateDetails In ItemsUpdateLists Do
		Row = ListsRows.Get(UpdateDetails.List);
		If Row = Undefined Then
			Continue;
		EndIf;
		MetadataObject = MetadataObjectsByIDs.Get(UpdateDetails.List);
		If TypeOf(MetadataObject) <> Type("MetadataObject") Then
			If RowsToDelete.Find(Row) = Undefined Then
				RowsToDelete.Add(Row);
			EndIf;
			Continue;
		EndIf;
		If Not ValueIsFilled(Row.TableName) Then
			Row.TableName = MetadataObject.FullName();
		EndIf;
		If Not Context.CalculateByDataAmount Then
			UpdateValueInRow(Row.ProcessedItemsCount, 0, Row, Context);
			ResetItemsCount(Row, Context);
		Else
			Properties = ListsProperties.Get(Row.List);
			FillPropertyValues(Properties, UpdateDetails);
			If Context.IsRepeatedProgressUpdate Then
				ItemsCountUpdateRows.Add(Row);
			EndIf;
		EndIf;
	EndDo;
	
	AccessKeysUpdateLists = QueryResults[2].Unload();
	MetadataObjectsByIDs =
		Catalogs.MetadataObjectIDs.MetadataObjectsByIDs(
			AccessKeysUpdateLists.UnloadColumn("List"), True);
	
	For Each UpdateDetails In AccessKeysUpdateLists Do
		MetadataObject = MetadataObjectsByIDs.Get(UpdateDetails.List);
		Row = ListsRows.Get(UpdateDetails.List);
		If Row = Undefined Then
			Continue;
		EndIf;
		If TypeOf(MetadataObject) <> Type("MetadataObject") Then
			If RowsToDelete.Find(Row) = Undefined Then
				RowsToDelete.Add(Row);
			EndIf;
			Continue;
		EndIf;
		If Not ValueIsFilled(Row.TableName) Then
			Row.TableName = MetadataObject.FullName();
		EndIf;
		If Not Context.CalculateByDataAmount Then
			UpdateValueInRow(Row.ProcessedAccessKeysCount, 0, Row, Context);
			ResetAccessKeysCount(Row, Context);
		Else
			Properties = ListsProperties.Get(Row.List);
			FillPropertyValues(Properties, UpdateDetails);
			If Context.IsRepeatedProgressUpdate Then
				AccessKeysCountUpdateRows.Add(Row);
			EndIf;
		EndIf;
	EndDo;
	
	For Each RowToDelete In RowsToDelete Do
		ListsRows.Delete(RowToDelete.List);
		ListsProperties.Delete(RowToDelete.List);
		Index = Context.AddedRows.Find(RowToDelete);
		If Index <> Undefined Then
			Context.AddedRows.Delete(Index);
			Continue;
		EndIf;
		Context.DeletedRows.Insert(RowToDelete.List, True);
	EndDo;
	
	Index = Context.AddedRows.Count() - 1;
	While Index >= 0 Do
		If Not ValueIsFilled(Context.AddedRows[Index].TableName) Then
			Context.AddedRows.Delete(Index);
		EndIf;
		Index = Index - 1;
	EndDo;
	
	If Not Context.IsRepeatedProgressUpdate Then
		For Each RowDetails In ListsRows Do
			ItemsCountUpdateRows.Add(RowDetails.Value);
			AccessKeysCountUpdateRows.Add(RowDetails.Value);
		EndDo;
	EndIf;
	
	KeysCount = QueryResults[3].Unload()[0].Count;
	If Context.IsRepeatedProgressUpdate
	   AND Context.StoredData.KeysCount <> KeysCount Then
		
		For Each RowDetails In ListsRows Do
			If AccessKeysCountUpdateRows.Find(RowDetails.Value) = Undefined Then
				AccessKeysCountUpdateRows.Add(RowDetails.Value);
			EndIf;
		EndDo;
	EndIf;
	Context.StoredData.KeysCount = KeysCount;
	
	If Context.CalculateByDataAmount Then
		CurrentContext = New Structure;
		CurrentContext.Insert("AddedRows",                       Context.AddedRows);
		CurrentContext.Insert("ModifiedRows",                        Context.ModifiedRows);
		CurrentContext.Insert("ListsProperties",                         ListsProperties);
		CurrentContext.Insert("ListsRows",                           ListsRows);
		CurrentContext.Insert("ActiveParameters",                    ActiveParameters);
		CurrentContext.Insert("ItemsCountUpdateRows",     ItemsCountUpdateRows);
		CurrentContext.Insert("AccessKeysCountUpdateRows", AccessKeysCountUpdateRows);
		CurrentContext.Insert("TablesIDs",                    TablesIDs);
		CurrentContext.Insert("StoredData",                          Context.StoredData);
		UpdatedTotal = 100;
		CalculateUpdatedByDataCountTotal(CurrentContext, UpdatedTotal);
	Else
		If Context.StoredData.Property("ItemsByListsCount") Then
			Context.StoredData.Delete("ItemsByListsCount");
			Context.StoredData.Delete("AccessKeysByListsCount");
		EndIf;
		CountTotal = TablesIDs.Count();
		If ListsRows.Count() > CountTotal Then
			CountTotal = ListsRows.Count();
		EndIf;
		UpdatedTotal = (100 + 100) * (CountTotal - ListsRows.Count());
		For Each KeyAndValue In ListsRows Do
			Row = KeyAndValue.Value;
			UpdatedTotal = UpdatedTotal + Row.ProcessedItemsCount + Row.ProcessedAccessKeysCount;
		EndDo;
		UpdatedTotal = UpdatedTotal / 2 / CountTotal;
	EndIf;
	If UpdatedTotal > 100 Then
		UpdatedTotal = 100;
	EndIf;
	Context.UpdatedTotal = Int(UpdatedTotal);
	
	UpdateTime = CurrentSessionDate() - ProgressUpdateStartDate;
	
	If Context.IsRepeatedProgressUpdate
	   AND UpdateTime > Context.ProgressUpdatePeriod Then
		
		Context.ProgressUpdatePeriod = UpdateTime;
	Else
		Context.Delete("ProgressUpdatePeriod");
	EndIf;
	
	If Not Context.IsRepeatedProgressUpdate AND UpdateTime > 60 Then
		Context.ProgressAutoUpdate = False;
	Else
		Context.Delete("ProgressAutoUpdate");
	EndIf;
	
	Filter = New Structure("Metadata", Metadata.ScheduledJobs.AccessUpdateAtRecordLevel);
	Jobs = ScheduledJobsServer.FindJobs(Filter);
	Enabled = False;
	For Each Job In Jobs Do
		If Job.Use Then
			Enabled = True;
			Break;
		EndIf;
	EndDo;
	
	If Not Enabled AND Context.UpdatedTotal < 100 Then
		Context.Insert("ScheduledJobDisabled");
	EndIf;
	
	PutToTempStorage(Context, ResultAddress);
	
EndProcedure

Procedure ResetItemsCount(Row, Context);
	
	UpdateValueInRow(Row.ItemCount, 0, Row, Context);
	UpdateValueInRow(Row.ProcessedItemsCount, 0, Row, Context);
	UpdateValueInRow(Row.ItemsForUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.ItemsForExternalUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.RemainingItemsForUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.RemainingItemsForExternalUsersCount, 0, Row, Context);
	
EndProcedure

Procedure ResetAccessKeysCount(Row, Context);
	
	UpdateValueInRow(Row.AccessKeysCount, 0, Row, Context);
	UpdateValueInRow(Row.ProcessedAccessKeysCount, 0, Row, Context);
	UpdateValueInRow(Row.AccessKeysForUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.AccessKeysForExternalUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.RemainingAccessKeysForUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.RemainingAccessKeysForExternalUsersCount, 0, Row, Context);
	
EndProcedure

Procedure AddNewListRow(Context, List, TableName)
	
	Row = New Structure;
	Row.Insert("List", List);
	Row.Insert("ListPresentation", String(List));
	Row.Insert("TableName", TableName);
	Row.Insert("UpdatePosition", "");
	Row.Insert("ProcessedItemsCount", 0);
	Row.Insert("ProcessedAccessKeysCount", 0);
	Row.Insert("ItemCount", 0);
	Row.Insert("AccessKeysCount", 0);
	Row.Insert("ProcessedItemsCount", 0);
	Row.Insert("ProcessedAccessKeysCount", 0);
	
	Row.Insert("ItemsForUsersCount", 0);
	Row.Insert("ItemsForExternalUsersCount", 0);
	Row.Insert("AccessKeysForUsersCount", 0);
	Row.Insert("AccessKeysForExternalUsersCount", 0);
	Row.Insert("RemainingItemsForUsersCount", 0);
	Row.Insert("RemainingItemsForExternalUsersCount", 0);
	Row.Insert("RemainingAccessKeysForUsersCount", 0);
	Row.Insert("RemainingAccessKeysForExternalUsersCount", 0);
	
	Context.StoredData.ListsRows.Insert(List, Row);
	Context.AddedRows.Add(Row);
	
	Properties = New Structure;
	Properties.Insert("LatestUpdatedItemDate", '00010101');
	Properties.Insert("LastUpdatedItem", Undefined);
	Properties.Insert("LastUpdatedAccessKey", Undefined);
	
	Properties.Insert("LatestUpdatedItemForExternalUsersDate", '00010101');
	Properties.Insert("LastUpdatedItemForExtrenalUsers", Undefined);
	Properties.Insert("LastUpdatedAccessKeyForExtrenalUsers", Undefined);
	
	Context.StoredData.ListsProperties.Insert(List, Properties);
	
EndProcedure

Procedure CalculateUpdatedByDataCountTotal(Context, UpdatedTotal)
	
	TablesTypesByNames = AccessManagementInternalCached.LanguageSyntax().TablesTypes.ByNames;
	Context.Insert("TablesTypesByNames", TablesTypesByNames);
	
	If Not Context.StoredData.Property("ItemsByListsCount") Then
		FilItemsAndAccessKeysCountByLists(Context);
	EndIf;
	
	UpdateItemsAndAccessKeysCount(Context);
	
	ItemsByListsCount     = Context.StoredData.ItemsByListsCount;
	AccessKeysByListsCount = Context.StoredData.AccessKeysByListsCount;
	
	TotalItemsCount = 0;
	For Each KeyAndValue In ItemsByListsCount Do
		TotalItemsCount = TotalItemsCount + KeyAndValue.Value;
	EndDo;
	TotalItemsCount = ?(TotalItemsCount = 0, 100, TotalItemsCount);
	
	TotalAccessKeysCount = 0;
	For Each KeyAndValue In AccessKeysByListsCount Do
		TotalAccessKeysCount = TotalAccessKeysCount + KeyAndValue.Value;
	EndDo;
	TotalAccessKeysCount = ?(TotalAccessKeysCount = 0, 100, TotalAccessKeysCount);
	
	UpdatedItemsTotal = 0;
	UpdatedAccessKeysTotal = 0;
	
	AddTotalItemsCount = 0;
	AddTotalAccessKeysCount = 0;
	
	TablesNamesWithItemsUpdate     = New Map;
	TablesNamesWithAccessKeysUpdate = New Map;
	
	For Each KeyAndValue In Context.ListsRows Do
		Row = KeyAndValue.Value;
		
		ItemsCount = ItemsByListsCount.Get(KeyAndValue.Value.TableName);
		If ItemsCount = Undefined Then
			Addition = ?(ItemsByListsCount.Count() = 0, 10,
				Int(TotalItemsCount / ItemsByListsCount.Count()));
			AddTotalItemsCount = AddTotalItemsCount + Addition;
			Share = Addition * 0.1;
		Else
			Share = ItemsCount / TotalItemsCount;
			TablesNamesWithItemsUpdate.Insert(KeyAndValue.Value.TableName, True);
		EndIf;
		UpdatedItemsTotal = UpdatedItemsTotal + Row.ProcessedItemsCount * Share;
		
		AccessKeysCount = AccessKeysByListsCount.Get(KeyAndValue.Value.TableName);
		If AccessKeysCount = Undefined Then
			Addition = ?(AccessKeysByListsCount.Count() = 0, 10,
				Int(TotalAccessKeysCount / AccessKeysByListsCount.Count()));
			AddTotalAccessKeysCount = AddTotalAccessKeysCount + Addition;
			Share = Addition * 0.1;
		Else
			Share = AccessKeysCount / TotalAccessKeysCount;
			TablesNamesWithAccessKeysUpdate.Insert(KeyAndValue.Value.TableName, True);
		EndIf;
		UpdatedAccessKeysTotal = UpdatedAccessKeysTotal + Row.ProcessedAccessKeysCount * Share;
	EndDo;
	
	UpdatedItemsCount = 0;
	For Each KeyAndValue In ItemsByListsCount Do
		If TablesNamesWithItemsUpdate.Get(KeyAndValue.Key) = Undefined Then
			UpdatedItemsCount = UpdatedItemsCount + KeyAndValue.Value;
		EndIf;
	EndDo;
	UpdatedItemsTotal = UpdatedItemsTotal
		+ (UpdatedItemsCount / TotalItemsCount) * 100;
		
	UpdatedAccessKeysCount = 0;
	For Each KeyAndValue In AccessKeysByListsCount Do
		If TablesNamesWithAccessKeysUpdate.Get(KeyAndValue.Key) = Undefined Then
			UpdatedAccessKeysCount = UpdatedAccessKeysCount + KeyAndValue.Value;
		EndIf;
	EndDo;
	UpdatedAccessKeysTotal = UpdatedAccessKeysTotal
		+ (UpdatedAccessKeysCount / TotalAccessKeysCount) * 100;
	
	UpdatedItemsTotal = UpdatedItemsTotal
		+ UpdatedItemsTotal * AddTotalItemsCount / TotalItemsCount;
	
	UpdatedAccessKeysTotal = UpdatedAccessKeysTotal
		+ UpdatedAccessKeysTotal * AddTotalAccessKeysCount / TotalAccessKeysCount;
	
	UpdatedTotal = (UpdatedItemsTotal + UpdatedAccessKeysTotal) / 2;
	
EndProcedure

Procedure FilItemsAndAccessKeysCountByLists(Context)
	
	ItemsByListsCount     = New Map;
	AccessKeysByListsCount = New Map;
	Context.StoredData.Insert("ItemsByListsCount",     ItemsByListsCount);
	Context.StoredData.Insert("AccessKeysByListsCount", AccessKeysByListsCount);
	
	QueryDetails = New Structure("Query, QueryPackageTexts", New Query, New Array);
	
	Index = 0;
	TablesNames = New Array;
	For Each KeyAndValue In Context.TablesIDs Do
		TablesNames.Add(KeyAndValue.Key);
		Row = New Structure("List, TableName", KeyAndValue.Value, KeyAndValue.Key);
		AddItemsCountQueryText(QueryDetails, Row, Index, Context, Undefined);
		AddQueryTextOfAccessKeysCount(QueryDetails, Row, Index, Undefined);
	EndDo;
	
	QueryResults = ExecuteQueriesPackageByParts(QueryDetails);
	
	Index = 0;
	For Each TableName In TablesNames Do
		Selection = QueryResults[Index].Select();
		Count = ?(Selection.Next(), Selection.Count, 0);
		ItemsByListsCount[TableName] = Count;
		Index = Index + 1;
		
		Selection = QueryResults[Index].Select();
		Count = ?(Selection.Next(), Selection.Count, 0);
		AccessKeysByListsCount[TableName] = Count;
		Index = Index + 1;
	EndDo;
	
EndProcedure

Procedure UpdateItemsAndAccessKeysCount(Context)
	
	QueryDetails = New Structure("Query, QueryPackageTexts", New Query, New Array);
	Index = 0;
	For Each Row In Context.ItemsCountUpdateRows Do
		AddItemsCountQueryText(QueryDetails, Row, Index, Context, False);
		AddItemsCountQueryText(QueryDetails, Row, Index, Context, True);
		AddQueryTextOfRemainingItemsCount(QueryDetails, Row, Index, Context, False);
		AddQueryTextOfRemainingItemsCount(QueryDetails, Row, Index, Context, True);
	EndDo;
	For Each Row In Context.AccessKeysCountUpdateRows Do
		AddQueryTextOfAccessKeysCount(QueryDetails, Row, Index, False);
		AddQueryTextOfAccessKeysCount(QueryDetails, Row, Index, True);
		AddQueryTextOfRemainingAccessKeysCount(QueryDetails, Row, Index, Context, False);
		AddQueryTextOfRemainingAccessKeysCount(QueryDetails, Row, Index, Context, True);
	EndDo;
	
	If QueryDetails.QueryPackageTexts.Count() = 0 Then
		Return;
	EndIf;
	
	QueryResults = ExecuteQueriesPackageByParts(QueryDetails);

	ItemsByListsCount     = Context.StoredData.ItemsByListsCount;
	AccessKeysByListsCount = Context.StoredData.AccessKeysByListsCount;
	ListsRestrictionsVersions         = Context.ActiveParameters.ListsRestrictionsVersions;
	TablesTypesByNames               = Context.TablesTypesByNames;
	
	Index = 0;
	For Each Row In Context.ItemsCountUpdateRows Do
		Selection = QueryResults[Index].Select();
		ItemsForUsersCount = ?(Selection.Next(), Selection.Count, 0);
		Index = Index + 1;
		
		Selection = QueryResults[Index].Select();
		ItemsForExternalUsersCount = ?(Selection.Next(), Selection.Count, 0);
		Index = Index + 1;
		
		ItemsCount = ItemsForUsersCount + ItemsForExternalUsersCount;
		UpdateValueInRow(Row.ItemCount, ItemsCount, Row, Context);
		If ValueIsFilled(Row.TableName) Then
			ItemsByListsCount.Insert(Row.TableName, ItemsCount);
		EndIf;
		
		If Row.ItemCount = 0 Then
			ResetItemsCount(Row, Context);
			UpdateValueInRow(Row.ProcessedItemsCount, 100, Row, Context);
			Index = Index + 2;
		Else
			ProcessedItemsCount = 0;
			ListProperties = Context.ListsProperties.Get(Row.List);
			HasKeysForUsers = False;
			HasKeysForExternalUsers = False;
			Versions = ListsRestrictionsVersions.Get(Row.TableName);
			If ValueIsFilled(Versions) Then
				HasKeysForUsers        = ValueIsFilled(StrGetLine(Versions, 1));
				HasKeysForExternalUsers = ValueIsFilled(StrGetLine(Versions, 2));
			EndIf;
			NameContent = StrSplit(Row.TableName, ".", False);
			TypeProperties = TablesTypesByNames.Get(Upper(NameContent[0]));
			Divisor = ?(TypeProperties.IsReferenceType, 2, 1);
			For UsersKind = 0 To 1 Do
				If UsersKind = 0 Then
					LastUpdatedItem = ListProperties.LastUpdatedItem;
				Else
					LastUpdatedItem = ListProperties.LastUpdatedItemForExtrenalUsers;
				EndIf;
				If LastUpdatedItem = Undefined Or LastUpdatedItem = False Then
					RemainingItemsCount = 0;
				Else
					If UsersKind = 0 Then
						HasKeysForUsers = True;
					Else
						HasKeysForExternalUsers = True;
					EndIf;
					If LastUpdatedItem = True Then
						RemainingItemsCount = ?(UsersKind = 0,
							ItemsForUsersCount, ItemsForExternalUsersCount);
					Else
						Selection = QueryResults[Index].Select();
						RemainingItemsCount = ?(Selection.Next(), Selection.Count, 0);
						If RemainingItemsCount = -1 Then
							RemainingItemsCount = ?(UsersKind = 0,
								ItemsForUsersCount, ItemsForExternalUsersCount);
						EndIf;
					EndIf;
				EndIf;
				If UsersKind = 0 Then
					If Not HasKeysForUsers Then
						Row.RemainingItemsForUsersCount = 0;
						Row.ItemsForUsersCount = 0;
					ElsIf TypeOf(RemainingItemsCount) = Type("Number") Then
						Row.RemainingItemsForUsersCount = RemainingItemsCount;
						Row.ItemsForUsersCount = ItemsForUsersCount;
					EndIf;
					ProcessedItemsCount = ProcessedItemsCount
						+ (Row.ItemsForUsersCount
							- Row.RemainingItemsForUsersCount) / Divisor;
				Else
					If Not HasKeysForExternalUsers Then
						Row.RemainingItemsForExternalUsersCount = 0;
						Row.ItemsForExternalUsersCount = 0;
					ElsIf TypeOf(RemainingItemsCount) = Type("Number") Then
						Row.RemainingItemsForExternalUsersCount = RemainingItemsCount;
						Row.ItemsForExternalUsersCount = ItemsForExternalUsersCount;
					EndIf;
					ProcessedItemsCount = ProcessedItemsCount
						+ (Row.ItemsForExternalUsersCount
							- Row.RemainingItemsForExternalUsersCount) / Divisor;
				EndIf;
				Index = Index + 1;
			EndDo;
			If Not HasKeysForUsers Or Not HasKeysForExternalUsers Then
				ProcessedItemsCount = ProcessedItemsCount * Divisor;
			EndIf;
			UpdateValueInRow(Row.ProcessedItemsCount,
				Int(ProcessedItemsCount), Row, Context);
			If Row.ProcessedItemsCount > Row.ItemCount Then
				UpdateValueInRow(Row.ProcessedItemsCount,
					Row.ItemCount, Row, Context);
			EndIf;
			UpdateValueInRow(Row.ProcessedItemsCount,
				Int(Row.ProcessedItemsCount / Row.ItemCount * 100), Row, Context);
		EndIf;
	EndDo;
	
	For Each Row In Context.AccessKeysCountUpdateRows Do
		Selection = QueryResults[Index].Select();
		AccessKeysForUsersCount = ?(Selection.Next(), Selection.Count, 0);
		Index = Index + 1;
		
		Selection = QueryResults[Index].Select();
		AccessKeysForExternalUsersCount = ?(Selection.Next(), Selection.Count, 0);
		Index = Index + 1;
		
		AccessKeysCount = AccessKeysForUsersCount + AccessKeysForExternalUsersCount;
		UpdateValueInRow(Row.AccessKeysCount, AccessKeysCount, Row, Context);
		If ValueIsFilled(Row.TableName) Then
			AccessKeysByListsCount.Insert(Row.TableName, AccessKeysCount);
		EndIf;
		
		If Row.AccessKeysCount = 0 Then
			ResetAccessKeysCount(Row, Context);
			UpdateValueInRow(Row.ProcessedAccessKeysCount, 100, Row, Context);
			Index = Index + 2;
		Else
			ProcessedAccessKeysCount = 0;
			ListProperties = Context.ListsProperties.Get(Row.List);
			For UsersKind = 0 To 1 Do
				If UsersKind = 0 Then
					LastUpdatedAccessKey = ListProperties.LastUpdatedAccessKey;
				Else
					LastUpdatedAccessKey = ListProperties.LastUpdatedAccessKeyForExtrenalUsers;
				EndIf;
				If LastUpdatedAccessKey = Undefined Or LastUpdatedAccessKey = False Then
					RemainingAccessKeysCount = 0;
				ElsIf LastUpdatedAccessKey = True Then
					RemainingAccessKeysCount = ?(UsersKind = 0,
						AccessKeysForUsersCount, AccessKeysForExternalUsersCount);
				Else
					Selection = QueryResults[Index].Select();
					RemainingAccessKeysCount = ?(Selection.Next(), Selection.Count, 0);
					If RemainingAccessKeysCount = -1 Then
						RemainingAccessKeysCount = ?(UsersKind = 0,
							AccessKeysForUsersCount, AccessKeysForExternalUsersCount);
					EndIf;
				EndIf;
				If UsersKind = 0 Then
					If TypeOf(RemainingAccessKeysCount) = Type("Number") Then
						Row.RemainingAccessKeysForUsersCount = RemainingAccessKeysCount;
						Row.AccessKeysForUsersCount = AccessKeysForUsersCount;
					EndIf;
					ProcessedAccessKeysCount = ProcessedAccessKeysCount
						+ (Row.AccessKeysForUsersCount
							- Row.RemainingAccessKeysForUsersCount);
				Else
					If TypeOf(RemainingAccessKeysCount) = Type("Number") Then
						Row.RemainingAccessKeysForExternalUsersCount = RemainingAccessKeysCount;
						Row.AccessKeysForExternalUsersCount = AccessKeysForExternalUsersCount;
					EndIf;
					ProcessedAccessKeysCount = ProcessedAccessKeysCount
						+ (Row.AccessKeysForExternalUsersCount
							- Row.RemainingAccessKeysForExternalUsersCount);
				EndIf;
				Index = Index + 1;
			EndDo;
			UpdateValueInRow(Row.ProcessedAccessKeysCount,
				Int(ProcessedAccessKeysCount), Row, Context);
			If Row.ProcessedAccessKeysCount > Row.AccessKeysCount Then
				UpdateValueInRow(Row.ProcessedAccessKeysCount,
					Row.AccessKeysCount, Row, Context);
			EndIf;
			UpdateValueInRow(Row.ProcessedAccessKeysCount,
				Int(Row.ProcessedAccessKeysCount / Row.AccessKeysCount * 100), Row, Context);
		EndIf;
	EndDo;
	
EndProcedure

Function ExecuteQueriesPackageByParts(QueryDetails)
	
	QueriesPackageResults = New Array;
	
	QueriesBatchTexts = New Array;
	For Each QueryText In QueryDetails.QueryPackageTexts Do
		If QueriesBatchTexts.Count() = 200 Then
			AddQueryResults(QueriesPackageResults, QueriesBatchTexts, QueryDetails);
			QueriesBatchTexts = New Array;
		EndIf;
		QueriesBatchTexts.Add(QueryText);
	EndDo;
	AddQueryResults(QueriesPackageResults, QueriesBatchTexts, QueryDetails);
	
	Return QueriesPackageResults;
	
EndFunction

Procedure AddQueryResults(QueriesPackageResults, QueriesBatchTexts, QueryDetails)
	
	Query = QueryDetails.Query;
	
	Query.Text = StrConcat(QueriesBatchTexts, Common.QueryBatchSeparator());
	QueryResults = Query.ExecuteBatch();
	Query.Text = "";
	
	For Each QueryResult In QueryResults Do
		QueriesPackageResults.Add(QueryResult);
	EndDo;
	
EndProcedure

Procedure UpdateValueInRow(PreviousValue, NewValue, Row, Context)
	
	If PreviousValue = NewValue Then
		Return;
	EndIf;
	PreviousValue = NewValue;
	
	If Context.AddedRows.Find(Row) = Undefined
	   AND Context.ModifiedRows.Get(Row) = Undefined Then
		
		Context.ModifiedRows.Insert(Row.List, Row);
	EndIf;
	
EndProcedure

Procedure AddItemsCountQueryText(QueryDetails, Row, Index, Context, ForExternalUsers)
	
	If ValueIsFilled(Row.TableName) Then
		NameContent = StrSplit(Row.TableName, ".", False);
		TypeProperties = Context.TablesTypesByNames.Get(Upper(NameContent[0]));
		If TypeProperties.IsReferenceType Then
			QueryText =
			"SELECT
			|	COUNT(*) AS Count
			|FROM
			|	&CurrentTable AS CurrentTable";
			
		ElsIf ForExternalUsers = Undefined Then
			QueryTextForUsers        = RegisterItemsCountQueryText(Context, Row, Index, False);
			QueryTextForExternalUsers = RegisterItemsCountQueryText(Context, Row, Index, True);
			QueryText =
			"SELECT
			|	SUM(CountByUserKinds.Count) AS Count
			|FROM
			|	(" + TextWithIndent(QueryTextForUsers, "	") + "
			|	
			|	UNION ALL
			|	
			|	" + TextWithIndent(QueryTextForExternalUsers, "	") + ") AS CountByUserKinds";
		Else
			QueryText = RegisterItemsCountQueryText(Context, Row, Index, ForExternalUsers);
		EndIf;
		QueryText = StrReplace(QueryText, "&CurrentTable", Row.TableName);
	Else
		QueryText =
		"SELECT
		|	0 AS Count";
	EndIf;
	
	QueryDetails.QueryPackageTexts.Add(QueryText);
	Index = Index + 1;
	
EndProcedure

Function RegisterItemsCountQueryText(Context, Row, Index, ForExternalUsers)
	
	Properties = Context.ActiveParameters.AdditionalContext[?(ForExternalUsers,
		"ForExternalUsers", "ForUsers")].ListRestrictionsProperties.Get(Row.TableName);
	
	If Properties = Undefined
	 Or Properties.BasicFields = Undefined
	 Or Properties.BasicFields.Used.Count() = 0 Then
	
		Return
		"SELECT
		|	0 AS Count";
	EndIf;
	
	SelectionFields = "";
	For Each FieldName In Properties.BasicFields.Used Do
		SelectionFields = SelectionFields + ?(SelectionFields = "", "", ",
		|		") + "CurrentTable." + FieldName;
	EndDo;
	
	If Properties.BasicFields.Used.Count() = 1 Then
		QueryText =
		"SELECT
		|	COUNT(DISTINCT &SelectionFields) AS Count
		|FROM
		|	&CurrentTable AS CurrentTable";
	Else
		QueryText =
		"SELECT
		|	COUNT(*) AS Count
		|FROM
		|	(SELECT DISTINCT
		|		&SelectionFields
		|	FROM
		|		&CurrentTable AS CurrentTable) AS CombinationCount";
		SelectionFields = TextWithIndent(SelectionFields, "	");
	EndIf;
	
	QueryText = StrReplace(QueryText, "&SelectionFields", SelectionFields);
	
	Return QueryText;
	
EndFunction

Procedure AddQueryTextOfRemainingItemsCount(QueryDetails, Row, Index, Context, ForExternalUsers)
	
	ListProperties = Context.ListsProperties.Get(Row.List);
	ListsWithDate = Context.ActiveParameters.ListsWithDate;
	
	NameContent = StrSplit(Row.TableName, ".", False);
	TypeProperties = Context.TablesTypesByNames.Get(Upper(NameContent[0]));
	
	If ListProperties = Undefined Then
		LastUpdatedItem = Undefined;
		
	ElsIf ForExternalUsers Then
		LatestUpdatedItemDate = ListProperties.LatestUpdatedItemForExternalUsersDate;
		LastUpdatedItem        = ListProperties.LastUpdatedItemForExtrenalUsers;
	Else
		LatestUpdatedItemDate = ListProperties.LatestUpdatedItemDate;
		LastUpdatedItem        = ListProperties.LastUpdatedItem;
	EndIf;
	
	If TypeOf(LastUpdatedItem) <> Type("ValueStorage") Then
		QueryText =
		"SELECT
		|	UNDEFINED AS Count";
	Else
		LastUpdatedItem = LastUpdatedItem.Get();
		
		FilterCriterion = "";
		If TypeProperties.IsReferenceType Then
			If ListsWithDate.Get(Row.TableName) <> Undefined Then
				
				If TypeOf(LatestUpdatedItemDate) = Type("Date") Then
					ParameterName = "LastDate" + Format(Index, "NG=");
					FilterCriterion = "CurrentTable.Date <= &" + ParameterName;
					QueryDetails.Query.SetParameter(ParameterName, LatestUpdatedItemDate);
				EndIf;
				
			ElsIf ValueIsFilled(LastUpdatedItem) Then
				MetadataObject = Metadata.FindByType(TypeOf(LastUpdatedItem));
				If MetadataObject <> Undefined
				   AND MetadataObject.FullName() = Row.TableName Then
					
					ParameterName = "LastRef" + Format(Index, "NG=");
					FilterCriterion = "CurrentTable.Ref > &" + ParameterName;
					QueryDetails.Query.SetParameter(ParameterName, LastUpdatedItem);
				EndIf;
			EndIf;
			If ValueIsFilled(FilterCriterion) Then
				QueryText =
				"SELECT
				|	COUNT(*) AS Count
				|FROM
				|	&CurrentTable AS CurrentTable
				|WHERE
				|	&FilterCriterion";
				QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
			Else
				QueryText =
				"SELECT
				|	-1 AS Count";
			EndIf;
			
		ElsIf TypeOf(LastUpdatedItem) = Type("Structure") Then
			QueryText = QueryTextOfRemainingRegisterItemsCount(QueryDetails,
				Row, Index, Context, ForExternalUsers, LastUpdatedItem);
		EndIf;
		QueryText = StrReplace(QueryText, "&CurrentTable", Row.TableName);
	EndIf;
	
	QueryDetails.QueryPackageTexts.Add(QueryText);
	Index = Index + 1;
	
EndProcedure

Function QueryTextOfRemainingRegisterItemsCount(QueryDetails, Row, Index, Context,
			ForExternalUsers, LastUpdatedItem)
	
	Properties = Context.ActiveParameters.AdditionalContext[?(ForExternalUsers,
		"ForExternalUsers", "ForUsers")].ListRestrictionsProperties.Get(Row.TableName);
	
	If Properties = Undefined
	 Or Properties.BasicFields = Undefined
	 Or Properties.BasicFields.Used.Count() = 0
	 Or Properties.BasicFields.Used.Count() <> LastUpdatedItem.Count() Then
	
		Return
		"SELECT
		|	-1 AS Count";
	EndIf;
	
	UpdateParameters = New Structure;
	UpdateParameters.Insert("BasicFields", Properties.BasicFields);
	UpdateParameters.Insert("UsesRestrictionByOwner", False);
	DataKey = DataKey(UpdateParameters, LastUpdatedItem);
	
	SelectionFields = "";
	FilterCriterion = "";
	
	FieldNumber = 1;
	For Each FieldName In Properties.BasicFields.Used Do
		FieldNameInDataKey = "Field" + FieldNumber;
		ParameterName = FieldName + Format(Index, "NG=");
		
		Filter = "";
		For CurrentIndex = 0 To FieldNumber - 2 Do
			CurrentFieldName = Properties.BasicFields.Used[CurrentIndex];
			CurrentParameterName = CurrentFieldName + Format(Index, "NG=");
			Filter = Filter + ?(Filter = "", "", "
			|	AND ") + "CurrentTable." + CurrentFieldName + " = &" + CurrentParameterName;
		EndDo;
		Filter = Filter + ?(Filter = "", "", "
		|	AND ") + "CurrentTable." + FieldName + " > &" + ParameterName;
		
		FilterCriterion = FilterCriterion + ?(FieldNumber = 1, "" + Filter, "
		|		OR " + TextWithIndent(Filter, "		"));
	
		If DataKey.Property(FieldNameInDataKey) Then
			QueryDetails.Query.SetParameter(ParameterName, DataKey[FieldNameInDataKey]);
		Else
			QueryDetails.Query.SetParameter(ParameterName, Undefined);
		EndIf;
		SelectionFields = SelectionFields + ?(SelectionFields = "", "", ",
		|	") + "CurrentTable." + FieldName;
		FieldNumber = FieldNumber + 1;
	EndDo;
	
	If Properties.BasicFields.Used.Count() = 1 Then
		QueryText =
		"SELECT
		|	COUNT(DISTINCT &SelectionFields) AS Count
		|FROM
		|	&CurrentTable AS CurrentTable
		|WHERE
		|	&FilterCriterion";
	Else
		QueryText =
		"SELECT
		|	COUNT(*) AS Count
		|FROM
		|	(SELECT DISTINCT
		|		&SelectionFields
		|	FROM
		|		&CurrentTable AS CurrentTable
		|	WHERE
		|		&FilterCriterion) AS CombinationCount";
		SelectionFields    = TextWithIndent(SelectionFields, "	");
		FilterCriterion = TextWithIndent(FilterCriterion, "	");
	EndIf;
	
	QueryText = StrReplace(QueryText, "&SelectionFields",    SelectionFields);
	QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
	
	Return QueryText;
	
EndFunction

Procedure AddQueryTextOfAccessKeysCount(QueryDetails, Row, Index, ForExternalUsers)
	
	QueryText =
	"SELECT
	|	COUNT(AccessKeys.Ref) AS Count
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|WHERE
	|	AccessKeys.List = &List
	|	AND AccessKeys.ForExternalUsers = FALSE";
	
	ParameterName = "KeysList" + Format(Index, "NG=");
	QueryText = StrReplace(QueryText, "&List", "&" + ParameterName);
	QueryDetails.Query.SetParameter(ParameterName, Row.List);
	
	If ForExternalUsers = Undefined Then
		QueryText = StrReplace(QueryText, "AccessKeys.ForExternalUsers = FALSE", "TRUE");
		
	ElsIf ForExternalUsers Then
		QueryText = StrReplace(QueryText, "FALSE", "TRUE");
	EndIf;
	
	QueryDetails.QueryPackageTexts.Add(QueryText);
	Index = Index + 1;
	
EndProcedure

Procedure AddQueryTextOfRemainingAccessKeysCount(QueryDetails, Row, Index, Context, ForExternalUsers)
	
	ListProperties = Context.ListsProperties.Get(Row.List);
	If ForExternalUsers Then
		LastAccessKey = ListProperties.LastUpdatedAccessKeyForExtrenalUsers;
	Else
		LastAccessKey = ListProperties.LastUpdatedAccessKey;
	EndIf;
	If TypeOf(LastAccessKey) <> Type("ValueStorage") Then
		QueryText =
		"SELECT
		|	UNDEFINED AS Count";
	Else
		LastAccessKey = LastAccessKey.Get();
		FilterCriterion = "";
		If TypeOf(LastAccessKey) = Type("CatalogRef.AccessKeys") Then
			ParameterName = "ProcessedKeysList" + Format(Index, "NG=");
			FilterCriterion = "AccessKeys.List = &" + ParameterName;
			QueryDetails.Query.SetParameter(ParameterName, Row.List);
			
			FilterCriterion = FilterCriterion + "
			|	AND AccessKeys.ForExternalUsers = " + ?(ForExternalUsers, "TRUE", "FALSE");
			
			ParameterName = "LastAccessKey" + Format(Index, "NG=");
			FilterCriterion = FilterCriterion + "
			|	AND AccessKeys.Ref > &" + ParameterName;
			QueryDetails.Query.SetParameter(ParameterName, LastAccessKey);
		EndIf;
		
		If ValueIsFilled(FilterCriterion) Then
			QueryText =
			"SELECT
			|	COUNT(*) AS Count
			|FROM
			|	Catalog.AccessKeys AS AccessKeys
			|WHERE
			|	&FilterCriterion";
			QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
		Else
			QueryText =
			"SELECT
			|	-1 AS Count";
		EndIf;
	EndIf;
	
	QueryDetails.QueryPackageTexts.Add(QueryText);
	Index = Index + 1;
	
EndProcedure

Function ListsWithRestrictionIDs(ActiveParameters)
	
	ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined);
	
	Lists = New Array;
	For Each VersionDetails In ActiveParameters.ListsRestrictionsVersions Do
		Lists.Add(VersionDetails.Key);
	EndDo;
	
	Return Catalogs.MetadataObjectIDs.MetadataObjectIDs(Lists, True);
	
EndFunction

Function CurrentDateAtServer() Export
	
	Return CurrentDate(); // There must be the server CurrentDate, since this particular date is recorded to the event log.
	
EndFunction

#EndRegion

#EndRegion

#EndRegion
